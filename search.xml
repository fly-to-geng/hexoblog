<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>代码记忆法</title>
      <link href="/hexoblog/2019/04/03/%E5%BF%83%E7%90%86%E5%AD%A6/%E8%AE%B0%E5%BF%86%E9%AD%94%E6%B3%95/%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BF%86%E6%B3%95/"/>
      <url>/hexoblog/2019/04/03/%E5%BF%83%E7%90%86%E5%AD%A6/%E8%AE%B0%E5%BF%86%E9%AD%94%E6%B3%95/%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BF%86%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="代码记忆法">代码记忆法</h1><p>使用英语单词对数字编码，强化记忆数字和编码之间的关系，就可以把数字转换成对应的英语单词，而英语单词是有意义的，可以转化成画面，运用画面辅助记忆，可以达到快速记忆的目的。这就是代码记忆法的思路。</p><h2 id="数字编码方法">数字编码方法</h2><p>来自布拉德·乔伊斯（美）的超级记忆力训练</p><h3 id="section">0</h3><div class="figure"><img src="zero.jpg" alt="Z, S"><p class="caption">Z, S</p></div><h3 id="section-1">1</h3><div class="figure"><img src="tie.jpg" alt="T,D,tie,领带"><p class="caption">T,D,tie,领带</p></div><h3 id="section-2">2</h3><div class="figure"><img src="noah.jpg" alt="N, noah, 诺亚方舟"><p class="caption">N, noah, 诺亚方舟</p></div><h3 id="section-3">3</h3><div class="figure"><img src="ma.jpg" alt="M, ma, 妈妈"><p class="caption">M, ma, 妈妈</p></div><h3 id="section-4">4</h3><div class="figure"><img src="rye.jpg" alt="R, rye, 燕麦"><p class="caption">R, rye, 燕麦</p></div><h3 id="section-5">5</h3><div class="figure"><img src="law.jpg" alt="L, law, 法律"><p class="caption">L, law, 法律</p></div><h3 id="section-6">6</h3><p><img src="shoe.jpg" alt="sh, shoe, 鞋子"> ### 7</p><div class="figure"><img src="cow.jpg" alt="K,C, cow, 奶牛"><p class="caption">K,C, cow, 奶牛</p></div><h3 id="section-7">8</h3><div class="figure"><img src="ivy.jpg" alt="V, ivy, 常春藤"><p class="caption">V, ivy, 常春藤</p></div><h3 id="section-8">9</h3><div class="figure"><img src="bee.jpg" alt="B,P, bee, 蜜蜂"><p class="caption">B,P, bee, 蜜蜂</p></div><p>0 到9都有了代表它们的发音字母和具体的实物，接下来为10 到 99 设置对应的代表实物，方法是分解成单个数字，然后组合。</p><p>例如：</p><p>10 由 1 和 0 组成， 所以代表10的单词应该包含T或者D，且包含Z或者S，找一个满足这个条件的单词，我们使用toes这个单词。</p><h3 id="section-9">10</h3><div class="figure"><img src="toes.jpg" alt="toes, 脚趾"><p class="caption">toes, 脚趾</p></div><h3 id="section-10">11 – 50</h3><table><thead><tr class="header"><th>数字</th><th>单词</th><th>含义</th><th>自己想象画面</th></tr></thead><tbody><tr class="odd"><td>11</td><td>tot</td><td>小孩</td><td></td></tr><tr class="even"><td>12</td><td>tin</td><td>罐头</td><td></td></tr><tr class="odd"><td>13</td><td>tomb</td><td>坟墓</td><td></td></tr><tr class="even"><td>14</td><td>tire</td><td>轮胎</td><td></td></tr><tr class="odd"><td>15</td><td>towel</td><td>毛巾</td><td></td></tr><tr class="even"><td>16</td><td>dish</td><td>盘子</td><td></td></tr><tr class="odd"><td>17</td><td>tack</td><td>大头针</td><td></td></tr><tr class="even"><td>18</td><td>dove</td><td>鸽子</td><td></td></tr><tr class="odd"><td>19</td><td>tub</td><td>浴盆</td><td></td></tr><tr class="even"><td>20</td><td>nose</td><td>鼻子</td><td></td></tr><tr class="odd"><td>21</td><td>net</td><td>网</td><td></td></tr><tr class="even"><td>22</td><td>nun</td><td>修女</td><td></td></tr><tr class="odd"><td>23</td><td>name</td><td>名字</td><td></td></tr><tr class="even"><td>24</td><td>nero</td><td>罗马暴君尼禄</td><td></td></tr><tr class="odd"><td>25</td><td>nail</td><td>指甲</td><td></td></tr><tr class="even"><td>26</td><td>notch</td><td>东非大裂谷</td><td></td></tr><tr class="odd"><td>27</td><td>neck</td><td>脖子</td><td></td></tr><tr class="even"><td>28</td><td>knife</td><td>刀子</td><td></td></tr><tr class="odd"><td>29</td><td>knob</td><td>球形把手</td><td></td></tr><tr class="even"><td>30</td><td>mice</td><td>老鼠</td><td></td></tr><tr class="odd"><td>31</td><td>mat</td><td>席子</td><td></td></tr><tr class="even"><td>32</td><td>moon</td><td>月亮</td><td></td></tr><tr class="odd"><td>33</td><td>mummy</td><td>木乃伊</td><td></td></tr><tr class="even"><td>34</td><td>mower</td><td>割草机</td><td></td></tr><tr class="odd"><td>35</td><td>mule</td><td>骡子</td><td></td></tr><tr class="even"><td>36</td><td>match</td><td>火柴</td><td></td></tr><tr class="odd"><td>37</td><td>mug</td><td>大杯子</td><td></td></tr><tr class="even"><td>38</td><td>movie</td><td>电影</td><td></td></tr><tr class="odd"><td>39</td><td>mob</td><td>拖把</td><td></td></tr><tr class="even"><td>40</td><td>rose</td><td>玫瑰</td><td></td></tr><tr class="odd"><td>41</td><td>rod</td><td>杆子</td><td></td></tr><tr class="even"><td>42</td><td>rain</td><td>雨水</td><td></td></tr><tr class="odd"><td>43</td><td>ram</td><td>公羊</td><td></td></tr><tr class="even"><td>44</td><td>rower</td><td>划船的人</td><td></td></tr><tr class="odd"><td>45</td><td>roll</td><td>面包卷</td><td></td></tr><tr class="even"><td>46</td><td>roach</td><td>螳螂</td><td></td></tr><tr class="odd"><td>47</td><td>rock</td><td>岩石</td><td></td></tr><tr class="even"><td>48</td><td>roof</td><td>房顶</td><td></td></tr><tr class="odd"><td>49</td><td>rope</td><td>绳子</td><td></td></tr><tr class="even"><td>50</td><td>lace</td><td>鞋带</td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 心理学 </category>
          
          <category> 记忆魔法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记忆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AutoHotKey非常有用的脚本</title>
      <link href="/hexoblog/2018/12/02/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/AutoHotKey/AutoHotKey%E9%9D%9E%E5%B8%B8%E6%9C%89%E7%94%A8%E7%9A%84%E8%84%9A%E6%9C%AC/"/>
      <url>/hexoblog/2018/12/02/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/AutoHotKey/AutoHotKey%E9%9D%9E%E5%B8%B8%E6%9C%89%E7%94%A8%E7%9A%84%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>键盘和鼠标按键修改工具AutoHotKey可以实现修改任意键盘按键和鼠标按键的功能，可以实现快捷短语的输入。</p><p>我的AutoHotKey脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br></pre></td><td class="code"><pre><span class="line">SetCapsLockState, AlwaysOff</span><br><span class="line">;***********************************************************</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;||                 使用键盘模拟鼠标                      ||</span><br><span class="line">;|+-------------------------+-----------------------------+|</span><br><span class="line">;||      CapsLock+d         |    开启                     ||</span><br><span class="line">;||      CapsLock+f         |    关闭                     ||</span><br><span class="line">;|+-------------------------+-----------------------------+|</span><br><span class="line">;||        d                |    左键                     ||</span><br><span class="line">;||        f                |    右键                     ||</span><br><span class="line">;||      ikjl               |    鼠标移动                 ||</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">#SingleInstance</span><br><span class="line">count = 0</span><br><span class="line">JoyMultiplier = 0.20</span><br><span class="line">JoyThreshold = 3</span><br><span class="line">JoyThresholdUpper := 50 + JoyThresholdr</span><br><span class="line">JoyThresholdLower := 50 - JoyThreshold</span><br><span class="line">YAxisMultiplier = -1</span><br><span class="line">SetTimer, WatchKeyboard, 20</span><br><span class="line">Hotkey, d, ButtonRight</span><br><span class="line">Hotkey, f, ButtonLeft</span><br><span class="line">Hotkey, i,empty</span><br><span class="line">Hotkey, k,empty</span><br><span class="line">Hotkey, j,empty</span><br><span class="line">Hotkey, l,empty</span><br><span class="line">Hotkey, u,empty</span><br><span class="line">Hotkey, m,empty</span><br><span class="line">Return</span><br><span class="line"></span><br><span class="line">CapsLock &amp; d::</span><br><span class="line">    SetTimer, WatchKeyboard,On</span><br><span class="line">    Hotkey, d, on</span><br><span class="line">    Hotkey, f, on</span><br><span class="line">    Hotkey, i, on</span><br><span class="line">    Hotkey, k, on</span><br><span class="line">    Hotkey, j, on</span><br><span class="line">    Hotkey, l, on</span><br><span class="line">Hotkey, u, on</span><br><span class="line">Hotkey, m, on</span><br><span class="line">Return</span><br><span class="line"></span><br><span class="line">CapsLock &amp; f::</span><br><span class="line">    SetTimer, WatchKeyboard, Off</span><br><span class="line">    Hotkey, d, Off</span><br><span class="line">    Hotkey, f, Off</span><br><span class="line">    Hotkey, i, Off</span><br><span class="line">    Hotkey, k, Off</span><br><span class="line">    Hotkey, j, Off</span><br><span class="line">    Hotkey, l, Off</span><br><span class="line">Hotkey, u, off</span><br><span class="line">Hotkey, m, off</span><br><span class="line">Return</span><br><span class="line"></span><br><span class="line">empty:</span><br><span class="line">Return</span><br><span class="line">WatchKeyboard:</span><br><span class="line">MouseNeedsToBeMoved := false  ; Set default.</span><br><span class="line">JoyMultiplier+=0.01</span><br><span class="line">SetFormat, float, 03</span><br><span class="line">i:=GetKeyState(&quot;i&quot;,&quot;p&quot;)</span><br><span class="line">k:=GetKeyState(&quot;k&quot;,&quot;p&quot;)</span><br><span class="line">j:=GetKeyState(&quot;j&quot;,&quot;p&quot;)</span><br><span class="line">l:=GetKeyState(&quot;l&quot;,&quot;p&quot;)</span><br><span class="line">u:=GetKeyState(&quot;u&quot;,&quot;p&quot;)</span><br><span class="line">m:=GetKeyState(&quot;m&quot;,&quot;p&quot;)</span><br><span class="line">if(u)</span><br><span class="line">&#123;</span><br><span class="line">send,&#123;WheelUp&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(m)</span><br><span class="line">&#123;</span><br><span class="line">send,&#123;WheelDown&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(l)</span><br><span class="line">&#123;</span><br><span class="line">    MouseNeedsToBeMoved := true</span><br><span class="line">    DeltaX := 10</span><br><span class="line">&#125;</span><br><span class="line">else if(j)</span><br><span class="line">&#123;</span><br><span class="line">    MouseNeedsToBeMoved := true</span><br><span class="line">BeMoved := true</span><br><span class="line">    DeltaX := -10</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">    DeltaX = 0</span><br><span class="line">if (i)</span><br><span class="line">&#123;</span><br><span class="line">    MouseNeedsToBeMoved := true</span><br><span class="line">    DeltaY := 10</span><br><span class="line">&#125;</span><br><span class="line">else if (k)</span><br><span class="line">&#123;</span><br><span class="line">    MouseNeedsToBeMoved := true</span><br><span class="line">    DeltaY := -10</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">    DeltaY = 0</span><br><span class="line">if MouseNeedsToBeMoved</span><br><span class="line">&#123;</span><br><span class="line">    SetMouseDelay, -1  ; Makes movement smoother.</span><br><span class="line">    MouseMove, DeltaX * JoyMultiplier, DeltaY * JoyMultiplier * YAxisMultiplier, 0, R</span><br><span class="line">&#125;</span><br><span class="line">Else</span><br><span class="line">count++</span><br><span class="line">If(count&gt;20)&#123;</span><br><span class="line">JoyMultiplier = 0.30</span><br><span class="line">count=0</span><br><span class="line">&#125;</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">ButtonLeft:</span><br><span class="line">SetMouseDelay, -1  ; Makes movement smoother.</span><br><span class="line">MouseClick, left,,, 1, 0, D  ; Hold down the left mouse button.</span><br><span class="line">SetTimer, WaitForLeftButtonUp, 10</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">ButtonRight:</span><br><span class="line">SetMouseDelay, -1  ; Makes movement smoother.</span><br><span class="line">MouseClick, right,,, 1, 0, D  ; Hold down the right mouse button.</span><br><span class="line">SetTimer, WaitForRightButtonUp, 10</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WaitForLeftButtonUp:</span><br><span class="line">if GetKeyState(&quot;f&quot;)</span><br><span class="line">    return  ; The button is still, down, so keep waiting.</span><br><span class="line">; Otherwise, the button has been released.</span><br><span class="line">SetTimer, WaitForLeftButtonUp, off</span><br><span class="line">SetMouseDelay, -1  ; Makes movement smoother.</span><br><span class="line">MouseClick, left,,, 1, 0, U  ; Release the mouse button.</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">WaitForRightButtonUp:</span><br><span class="line">if GetKeyState(&quot;d&quot;)</span><br><span class="line">    return  ; The button is still, down, so keep waiting.</span><br><span class="line">; Otherwise, the button has been released.</span><br><span class="line">SetTimer, WaitForRightButtonUp, off</span><br><span class="line">MouseClick, right,,, 1, 0, U  ; Release the mouse button.</span><br><span class="line">return</span><br><span class="line">;************************************************************</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;||                 使用键盘模拟鼠标                      ||</span><br><span class="line">;|+-------------------------+-----------------------------+|</span><br><span class="line">;||      a+f                |    左键                     ||</span><br><span class="line">;||      a+d                |    右键                     ||</span><br><span class="line">;||      a+u                |    向上滚轮                 ||</span><br><span class="line">;||      a+m                |    向下滚轮                 ||</span><br><span class="line">;||      a+i,j,k,l          |    鼠标移动                 ||</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;************************************************************</span><br><span class="line">$a::</span><br><span class="line">Send, a</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">a &amp; i::</span><br><span class="line">SetMouseDelay, -1 </span><br><span class="line">MouseMove, 0, -15, 0, R </span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">a &amp; k::</span><br><span class="line">SetMouseDelay, -1 </span><br><span class="line">MouseMove, 0, 15, 0, R</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">a &amp; j::</span><br><span class="line">SetMouseDelay, -1 </span><br><span class="line">MouseMove, -15, 0, 0, R</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">a &amp; l::</span><br><span class="line">SetMouseDelay, -1</span><br><span class="line">MouseMove 15 ,0,0,R</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">a &amp; u::</span><br><span class="line">Send, &#123;WheelUp&#125;</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">a &amp; m::</span><br><span class="line">Send, &#123;WheelDown&#125;</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">a &amp; f::</span><br><span class="line">SetMouseDelay, -1  </span><br><span class="line">MouseClick, left,,, 1, 0, D  ; Hold down the left mouse button.</span><br><span class="line">SetTimer, WaitForLeftButtonUp, 10</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">a &amp; d::</span><br><span class="line">SetMouseDelay, -1 </span><br><span class="line">MouseClick, right,,, 1, 0, D  ; Hold down the right mouse button.</span><br><span class="line">SetTimer, WaitForRightButtonUp, 10</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">;************************************************************</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;||                CapsLock改成Enter键                    ||</span><br><span class="line">;|+-------------------------+-----------------------------+|</span><br><span class="line">;||      CaspLock                |    Enter               ||</span><br><span class="line">;||      alt + CapsLock          |    CaspLock            ||</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;************************************************************</span><br><span class="line">$CapsLock::Enter </span><br><span class="line"></span><br><span class="line">LAlt &amp; CapsLock::</span><br><span class="line">GetKeyState, CapsLockState, CapsLock, T</span><br><span class="line">if CapsLockState = D</span><br><span class="line">SetCapsLockState, AlwaysOff</span><br><span class="line">else</span><br><span class="line">SetCapsLockState, AlwaysOn</span><br><span class="line">KeyWait, CapsLock </span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">RAlt &amp; CapsLock::</span><br><span class="line">GetKeyState, CapsLockState, CapsLock, T</span><br><span class="line">if CapsLockState = D</span><br><span class="line">SetCapsLockState, AlwaysOff</span><br><span class="line">else</span><br><span class="line">SetCapsLockState, AlwaysOn</span><br><span class="line">KeyWait, CapsLock </span><br><span class="line">return</span><br><span class="line">;************************************************************</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;||                主键盘增加方向键                       ||</span><br><span class="line">;|+-------------------------+-----------------------------+|</span><br><span class="line">;||      CaspLock + i       |    Up                       ||</span><br><span class="line">;||      CaspLock + k       |    Down                     ||</span><br><span class="line">;||      CaspLock + j       |    Left                     ||</span><br><span class="line">;||      CaspLock + l       |    Right                    ||</span><br><span class="line">;||      CaspLock + u       |    Home                     ||</span><br><span class="line">;||      CaspLock + m       |    End                      ||</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;************************************************************</span><br><span class="line"></span><br><span class="line">CapsLock &amp; k::</span><br><span class="line">if GetKeyState(&quot;LShift&quot;, &quot;P&quot;)</span><br><span class="line">Send, +&#123;Down&#125;</span><br><span class="line">else if GetKeyState(&quot;LAlt&quot;, &quot;P&quot;)</span><br><span class="line">Send,^&#123;Down&#125;</span><br><span class="line">else if GetKeyState(&quot;LControl&quot;, &quot;P&quot;)</span><br><span class="line">Send,^+&#123;Down&#125;</span><br><span class="line">else</span><br><span class="line">Send, &#123;Down&#125;</span><br><span class="line">Return</span><br><span class="line"></span><br><span class="line">CapsLock &amp; i::</span><br><span class="line">if GetKeyState(&quot;LShift&quot;, &quot;P&quot;)</span><br><span class="line">Send, +&#123;Up&#125;</span><br><span class="line">else if GetKeyState(&quot;LAlt&quot;, &quot;P&quot;)</span><br><span class="line">Send,^&#123;Up&#125;</span><br><span class="line">else if GetKeyState(&quot;LControl&quot;, &quot;P&quot;)</span><br><span class="line">Send,^+&#123;Up&#125;</span><br><span class="line">else</span><br><span class="line">Send, &#123;Up&#125;</span><br><span class="line">Return</span><br><span class="line"></span><br><span class="line">; move left</span><br><span class="line">CapsLock &amp; j::</span><br><span class="line">if GetKeyState(&quot;LShift&quot;, &quot;P&quot;)</span><br><span class="line">Send, +&#123;Left&#125;</span><br><span class="line">else if GetKeyState(&quot;LAlt&quot;, &quot;P&quot;)</span><br><span class="line">Send,^&#123;left&#125;</span><br><span class="line">else if GetKeyState(&quot;LControl&quot;, &quot;P&quot;)</span><br><span class="line">Send,^+&#123;left&#125;</span><br><span class="line">else</span><br><span class="line">Send, &#123;Left&#125;</span><br><span class="line">Return</span><br><span class="line"></span><br><span class="line">CapsLock &amp; l::</span><br><span class="line">if GetKeyState(&quot;LShift&quot;, &quot;P&quot;)</span><br><span class="line">Send, +&#123;Right&#125;</span><br><span class="line">else if GetKeyState(&quot;LAlt&quot;, &quot;P&quot;)</span><br><span class="line">Send,^&#123;Right&#125;</span><br><span class="line">else if GetKeyState(&quot;LControl&quot;, &quot;P&quot;)</span><br><span class="line">Send,^+&#123;Right&#125;</span><br><span class="line">else</span><br><span class="line">Send, &#123;Right&#125;</span><br><span class="line">Return</span><br><span class="line"></span><br><span class="line">CapsLock &amp; u::</span><br><span class="line">if GetKeyState(&quot;LShift&quot;, &quot;P&quot;)</span><br><span class="line">    Send, +&#123;Home&#125;</span><br><span class="line">else if GetKeyState(&quot;LAlt&quot;, &quot;P&quot;)</span><br><span class="line">Send, ^&#123;Home&#125;</span><br><span class="line">else if GetKeyState(&quot;LControl&quot;, &quot;P&quot;)</span><br><span class="line">Send, ^&#123;Home&#125;</span><br><span class="line">else</span><br><span class="line">Send, &#123;Home&#125;</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">CapsLock &amp; m::</span><br><span class="line">if GetKeyState(&quot;LShift&quot;, &quot;P&quot;)</span><br><span class="line">    Send, +&#123;End&#125;</span><br><span class="line">else if GetKeyState(&quot;LAlt&quot;, &quot;P&quot;)</span><br><span class="line">Send, ^&#123;End&#125;</span><br><span class="line">else if GetKeyState(&quot;LControl&quot;, &quot;P&quot;)</span><br><span class="line">Send, ^&#123;End&#125;</span><br><span class="line">else</span><br><span class="line">Send, &#123;End&#125;</span><br><span class="line">return</span><br><span class="line">;************************************************************</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;||                剪贴板设置成3个                        ||</span><br><span class="line">;|+-------------------------+-----------------------------+|</span><br><span class="line">;||      Ctrl + 1           |    复制到剪贴板1            ||</span><br><span class="line">;||      Ctrl + 2           |    复制到剪贴板2            ||</span><br><span class="line">;||      Ctrl + 3           |    复制到剪贴板3            ||</span><br><span class="line">;||      Alt  + l           |    粘贴剪贴板1的内容        ||</span><br><span class="line">;||      Alt  + 2           |    粘贴剪贴板2的内容        ||</span><br><span class="line">;||      Alt  + 3           |    粘贴剪贴板3的内容        ||</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;************************************************************</span><br><span class="line">^1:: </span><br><span class="line">Send ^c</span><br><span class="line">a = %ClipBoard%</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">^2:: </span><br><span class="line">Send ^c</span><br><span class="line">b = %ClipBoard%</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">^3:: </span><br><span class="line">Send ^c</span><br><span class="line">c = %ClipBoard%</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">!1:: </span><br><span class="line">ClipBoard = %a%</span><br><span class="line">Send ^v</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">!2:: </span><br><span class="line">ClipBoard = %b%</span><br><span class="line">Send ^v</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">!3:: </span><br><span class="line">ClipBoard = %c%</span><br><span class="line">Send ^v</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">;************************************************************</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;||                主键盘区域增加小键盘                   ||</span><br><span class="line">;|+-------------------------+-----------------------------+|</span><br><span class="line">;||      CapsLock + p       |    开关                     ||</span><br><span class="line">;||      m                  |    0                        ||</span><br><span class="line">;||      j, k, l            |    1, 2, 3                  ||</span><br><span class="line">;||      u, i, p            |    4, 5, 6                  ||</span><br><span class="line">;||      7, 8, 9            |    7, 8, 9                  ||</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;************************************************************</span><br><span class="line">#if</span><br><span class="line">CapsLock &amp; p::</span><br><span class="line">ONOFF := !ONOFF</span><br><span class="line">Return</span><br><span class="line">#if ONOFF</span><br><span class="line">&#123;</span><br><span class="line">u::4</span><br><span class="line">i::5</span><br><span class="line">o::6</span><br><span class="line">j::1</span><br><span class="line">k::2</span><br><span class="line">l::3</span><br><span class="line">m::0</span><br><span class="line">n::0</span><br><span class="line">&#125;</span><br><span class="line">#if</span><br><span class="line"></span><br><span class="line">;************************************************************</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;||                   快捷搜索                            ||</span><br><span class="line">;|+-------------------------+-----------------------------+|</span><br><span class="line">;||      CapsLock + e       |    翻译所选词汇             ||</span><br><span class="line">;||      CapsLock + s       |    搜索所选词汇             ||</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;************************************************************</span><br><span class="line"></span><br><span class="line">CapsLock &amp; e::</span><br><span class="line">ffSearchWord = %ClipBoard%</span><br><span class="line">run https://fanyi.baidu.com/#en/zh/%ffSearchWord%</span><br><span class="line">run https://cn.bing.com/dict/search?q=%ffSearchWord%</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">CapsLock &amp; s::</span><br><span class="line">Send ^c</span><br><span class="line">content = %ClipBoard%</span><br><span class="line">run https://www.baidu.com/s?wd=%content%</span><br><span class="line">run https://cn.bing.com/search?q=%content%</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">CapsLock &amp; n::</span><br><span class="line">run http://www.baidu.com</span><br><span class="line">return</span><br><span class="line">;************************************************************</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;||                   重新加载本脚本                      ||</span><br><span class="line">;|+-------------------------+-----------------------------+|</span><br><span class="line">;||      CapsLock + r       |    重载                     ||</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;************************************************************</span><br><span class="line">CapsLock &amp; r::</span><br><span class="line">Send ^s</span><br><span class="line">reload</span><br><span class="line">return</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工具 </category>
          
          <category> AutoHotKey </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AutoHotKey </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 手册</title>
      <link href="/hexoblog/2018/07/29/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/Git/Git%E6%9F%A5%E8%AF%A2%E6%89%8B%E5%86%8C/"/>
      <url>/hexoblog/2018/07/29/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/Git/Git%E6%9F%A5%E8%AF%A2%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="git-的结构">Git 的结构</h2><p>Git 分成三个区域，工作区，暂存区，版本库</p><ul><li><p>工作区：就是和<code>.git</code>文件夹在同一级的工程目录。</p></li><li><p>暂存区：<code>.git</code>中的index中存储暂存区的目录树</p></li><li><p>版本库：<code>.git</code>中的其他地方存储版本库的内容，这个里面包含历史提交和即将要推送到远程版本库的内容。</p></li></ul><p>工作区的文件我们可以从文件管理器直观的看到，暂存区和版本库的文件<code>git</code>只是存储的相应的目录树，具体文件的内容在<code>.git\object</code>对象库中存储，并且使用的是差异化的存储，所以不能之间看到相应的文件，但是可以利用<code>Git</code>提供的工具间接的了解其中的内容。</p><div class="figure"><img src="git_show_01.svg" alt="Git内部结构"><p class="caption">Git内部结构</p></div><h2 id="查看差异">查看差异</h2><ul><li><p><code>git diff</code> ： 比较工作区和暂存区的差异</p></li><li><p><code>git diff --cached</code> ： 比较暂存区和版本库的差异</p></li><li><p><code>git diff HEAD</code> : 比较工作区和版本库的差异</p></li></ul><p>将上面命令中的<code>giff</code>换成<code>difftool</code>, 可以使用自定义的图形工具比较差异文件。</p><h2 id="从工作区到暂存区">1. 从工作区到暂存区</h2><p>如果想把工作区所做的改动(添加文件、修改内容、删除文件)，可以使用<code>git add</code>命令。</p><ul><li><p><code>git add filename</code> : 把工作区文件filename的改动添加到暂存区</p></li><li><p><code>git reset -- filename</code> : 把添加到暂存区的文件filename 撤销，工作区的文件filename不变，其实就是撤销刚才的<code>git add filename</code> 命令。</p></li><li><code>git add .</code> : 把工作区所有改动添加到暂存区</li><li><p><code>git reset</code> : 撤销<code>git add .</code>操作</p></li><li><p><code>git add -i</code> : 用交互的方式选择添加哪些文件到暂存区</p></li></ul><h2 id="从暂存区到工作区">2. 从暂存区到工作区</h2><ul><li><p><code>git checkout filename</code> : 把暂存区的文件filename添加到工作区，工作区的该文件会被覆盖，其实相当于<code>git add filename</code>的逆操作。</p></li><li><p><code>git reset filename</code> : 用暂存区的文件<code>filename</code>覆盖工作区的文件，相当于<code>git add filename</code>的反操作</p></li><li><p><code>git checkout .</code> : 把暂存区的所有文件添加到工作区，相当于<code>git add .</code>的逆操作。</p></li><li><p><code>git reset</code> : 撤销<code>git add .</code>操作，即用暂存区的内容覆盖工作区的内容。</p></li></ul><p><code>git checkout</code>会清除工作区中尚未<code>add</code>到暂存区中的内容，一定不要用错，否则自己做的工作就要白费了。</p><h2 id="从暂存区到版本库">3. 从暂存区到版本库</h2><p>如果想把在暂存区的内容提交到版本库，推送到远程版本库，可以使用<code>git commit</code>命令。</p><ul><li><p><code>git commit</code> : 提交暂存区的内容到版本库，需要写提交说明。</p></li><li><p><code>git commit --allow-empty</code> : 允许提交空的内容</p></li><li><p><code>git commit --amend</code> : 修补提交，不生成新的提交，而是在上一次提交的基础上修改提交内容。</p></li><li><p><code>git reset --soft HEAD^</code> : 撤销最新的提交，相当于<code>git commit</code>的逆操作。 命令解析：<code>--soft</code>选项指定不改变工作区和暂存区, HEAD指向最新的提交，<code>HEAD^</code>指向上一次提交，合起来该命令实现的功能就是撤销最新的提交，而工作区和暂存区的内容不改变。</p></li></ul><h2 id="从版本库到暂存区">4. 从版本库到暂存区</h2><ul><li><code>git reset HEAD^</code> : 工作区不改变，暂存区回退到上一次提交，版本库回退到上一次提交。</li></ul><h2 id="工作区直接到版本库">5. 工作区直接到版本库</h2><h2 id="版本库直接到工作区">6. 版本库直接到工作区</h2><ul><li><code>git reset --hard HEAD^</code> : 工作区、暂存区都会回退到上一次提交，版本库回退到上一次提交</li></ul><h2 id="常用命令解析">常用命令解析</h2><h3 id="git-diff"><code>git diff</code></h3><h3 id="git-log"><code>git log</code></h3><p><code>git log -g -2 HEAD</code> : 查看最近HEAD指向的两次提交</p><h3 id="git-add"><code>git add</code></h3><h3 id="git-checkout"><code>git checkout</code></h3><p>有两种主要的用法，切换分支 和 检出文件</p><p>检出文件：</p><ul><li><code>git checkout -- filename</code> : 从暂存区检出filename到工作区，工作区未提交的内容会丢失</li><li><code>git checkout -- '.'</code> :用暂存区覆盖工作区</li></ul><h3 id="git-reset"><code>git reset</code></h3><p>reset就是重置的意思，该命令的本质是修改HEAD指向的提交ID，可以使用不同的参数指定对暂存区和工作区的影响。</p><ul><li><p><code>git reset</code> : 其对应的完成形式应该是<code>git reset --mixed HEAD</code>, 含义是用HEAD指向的内容覆盖暂存区内容， 它是<code>git add .</code>的逆操作。</p></li><li><p><code>git reset -- filename</code> : 其完整形式是<code>git reset -- filename HEAD</code>, 含义是用HEAD指向的文件filename的内容覆盖暂存区内容，它是<code>git add filename</code>的逆操作。</p></li><li><p><code>git reset --mixed</code> : 工作区内容不变，暂存区和版本库重置；</p></li><li><p><code>git reset --soft</code> : 工作区和暂存区内容都不变，版本库重置；</p></li><li><p><code>git reset --hard</code> : 工作区，暂存区和版本库都改变。</p></li></ul><p>例如，<code>git reset --soft HEAD^</code>, 撤销最近的提交，暂存区和工作区都不变，要想恢复直接<code>git commit</code>; <code>git reset --mixed HEAD^</code>, 撤销最近的提交和暂存区的内容，要想恢复需要<code>git add .</code>, <code>git commit</code>两条命令； <code>git reset --hard HEAD^</code> 工作区，暂存区都会被上一次提交覆盖，工作区保持和上一次提交一致，未提交的内容会丢失。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/hexoblog/2018/07/29/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/hexoblog/2018/07/29/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>正则表达式是使用一个字符串表达一个要匹配的模式。模式的表示通过元字符，正则表达式常用的元字符及含义如下：</p><h2 id="元字符">元字符</h2><table><thead><tr class="header"><th>匹配单个字符</th><th>含义</th></tr></thead><tbody><tr class="odd"><td><code>.</code></td><td>匹配任意一个字符，除了<code>\r</code>和<code>\n</code></td></tr><tr class="even"><td><code>\d</code></td><td>匹配数字0-9，等价于<code>[0-9]</code></td></tr><tr class="odd"><td><code>\D</code></td><td>匹配除了0-9之外的字符,等价于<code>[^0-9]</code></td></tr><tr class="even"><td><code>\w</code></td><td>匹配任何一个字母数字或者下划线，等价于<code>[A-Za-z0-9_]</code></td></tr><tr class="odd"><td><code>\W</code></td><td>匹配任何一个非字母数字下划线，等价于<code>[^A-Za-z0-9_]</code></td></tr><tr class="even"><td><code>\b</code></td><td>匹配单词边界</td></tr><tr class="odd"><td><code>\B</code></td><td>匹配非单词边界</td></tr><tr class="even"><td><code>\s</code></td><td>匹配任意一个空白字符，等价于<code>[\f\n\r\t\v]</code></td></tr><tr class="odd"><td><code>\S</code></td><td>匹配任意一个非空白字符</td></tr><tr class="even"><td><code>^</code></td><td>匹配一行的开头</td></tr><tr class="odd"><td><code>$</code></td><td>匹配一行的结束</td></tr></tbody></table><table><thead><tr class="header"><th>匹配重复次数</th><th>含义</th></tr></thead><tbody><tr class="odd"><td><code>?</code></td><td>匹配0次或者1次，用在一个表达式后面可以表示非贪心的匹配</td></tr><tr class="even"><td><code>+</code></td><td>匹配一次或者多次</td></tr><tr class="odd"><td><code>*</code></td><td>匹配0次或者多次</td></tr><tr class="even"><td><code>{n}</code></td><td>匹配n次</td></tr><tr class="odd"><td><code>{m,}</code></td><td>至少匹配m次</td></tr><tr class="even"><td><code>{m,n}</code></td><td>最少匹配m次，最多匹配n次</td></tr></tbody></table><p>了解了以上的元字符，便可以构造匹配任意字符任意次的一个模式，但是还不能指定多个字符构成的模式的重复次数，下面介绍分组和捕获的相关内容。</p><table style="width:14%;"><colgroup><col width="6%"><col width="6%"></colgroup><thead><tr class="header"><th>逻辑控制</th><th>含义</th></tr></thead><tbody><tr class="odd"><td><code>x|y</code></td><td>逻辑或，匹配x或者匹配y</td></tr><tr class="even"><td><code>{}</code></td><td>里面跟数字，指定前面的模式的重复次数</td></tr><tr class="odd"><td><code>[]</code></td><td>里面放置任意字符，都是或的关系，匹配这个集合里面的任意一个</td></tr><tr class="even"><td><code>(pattern)</code></td><td>指定分组，分组后面紧跟的描述符描述的是这一组模式重复的次数,这个分组会被捕获，可以使用<code>\num</code>来引用捕获的这个分组</td></tr><tr class="odd"><td><code>(?:pattern)</code></td><td>指定这个分组不被捕获</td></tr><tr class="even"><td><code>(?=pattern)</code></td><td>非捕获匹配，正向肯定预先查找，匹配后面符合pattern的前面部分，例如<code>Windows(?=95|98|NT|2000)</code>,在匹配<code>Windows的时候会查找</code>Windows后面的字符，只匹配那些后面紧跟的是<code>95</code>,<code>98</code>,<code>NT</code>,<code>2000</code>的<code>Windows</code>,而不会匹配到<code>Windows3.1</code>中的<code>Windows</code></td></tr><tr class="odd"><td><code>(?!pattern)</code></td><td>非捕获匹配，正向非肯定预先查找</td></tr><tr class="even"><td><code>(?&lt;=pattern)</code></td><td>非捕获匹配，反向肯定预先查找</td></tr><tr class="odd"><td><code>(?&lt;!pattern)</code></td><td>非捕获查找，反向非肯定预先查找</td></tr></tbody></table><h2 id="常用实例解析">常用实例解析</h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工具 </category>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习-第七章-感知机</title>
      <link href="/hexoblog/2017/11/04/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
      <url>/hexoblog/2017/11/04/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习-第六章-kmeans</title>
      <link href="/hexoblog/2017/11/04/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E5%85%AD%E7%AB%A0-kmeans/"/>
      <url>/hexoblog/2017/11/04/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E5%85%AD%E7%AB%A0-kmeans/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习-第五章-最近邻</title>
      <link href="/hexoblog/2017/11/04/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9C%80%E8%BF%91%E9%82%BB/"/>
      <url>/hexoblog/2017/11/04/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9C%80%E8%BF%91%E9%82%BB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习-第四章-支持向量机</title>
      <link href="/hexoblog/2017/11/04/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
      <url>/hexoblog/2017/11/04/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>【支持向量机】【函数间隔】【几何间隔】【KTT】</p><a id="more"></a><h2 id="模型">模型</h2><p>令 <span class="math inline">\(\theta = (w_1,w_2,...,w_n,b)\)</span>, <span class="math inline">\(x = (x_1,x_2,...,x_n,1)\)</span>,则有： <span class="math display">\[\theta^T \cdot x = w_1x_1+x_2x_2+...+w_nx_n+b\]</span></p><p>支持向量机要得到的分类决策函数是：</p><p><span class="math display">\[h_\theta(x) = sign(\theta^T \cdot x)\]</span></p><p>其中，<span class="math inline">\(sign(x)\)</span>的定义是：</p><p><span class="math display">\[sign(x) = \begin{cases}          1, &amp; x&gt;=0 \\          0, &amp; x &lt; 0 \\          \end{cases}\]</span></p><p>当<span class="math inline">\(\theta^T &gt;= 0\)</span> 的时候，分类成正类，当<span class="math inline">\(\theta^T &lt; 0\)</span>的时候，分类成负类。支持向量机就是通过给定的训练数据求解出<span class="math inline">\(\theta\)</span>.</p><h2 id="策略">策略</h2><h3 id="函数间隔">函数间隔</h3><p><span class="math inline">\(\theta^T \cdot x = 0\)</span> 可以确定一个超平面(n维空间中，n-1维的叫做超平面)，<span class="math inline">\(\theta^T \cdot x &gt; 0\)</span> 的时候，我们定义类别的标签是<code>1</code>, <span class="math inline">\(\theta^T \cdot x &lt; 0\)</span> 的时候，我们定义类别的标签是<code>-1</code>. 这样，<span class="math inline">\(\theta^T \cdot x\)</span>的符号和标签<code>y</code>的符号是一致的。 $ y(\theta^T x ) &gt; 0 $ 表示分类正确， $y(\theta^T x)&lt;0 $ 表示分类错误. 而<span class="math inline">\(|\theta^T \cdot x|\)</span>表示的是点<code>x</code>到分类超平面的距离，可以认为距离越远，分类的可信度越高。</p><p>点<span class="math inline">\((x_i,y_i)\)</span>函数间隔的定义为：</p><p><span class="math display">\[\hat \gamma_i = y_i(\theta^T \cdot x_i)\]</span></p><p>训练集合中所有样本的函数间隔定义为所有样本的函数间隔最小的那一个。</p><h3 id="几何间隔">几何间隔</h3><p><span class="math inline">\(\theta^T \cdot x = wx+b\)</span>, 其中<span class="math inline">\(w = (w_1,w_2,...,w_n)\)</span>. 函数间隔有一个问题，就是成比例的改变<span class="math inline">\(w\)</span>和<span class="math inline">\(b\)</span>的值，函数间隔的大小就会成比例的变化。所以函数间隔并不适合用来求极值点。 改进的方法是限制<span class="math inline">\(w\)</span>的取值，是<span class="math inline">\(||w|| = 1\)</span>, 这样函数间隔就变成了几何间隔。</p><p>样本<span class="math inline">\((x_i,y_i)\)</span>到分类超平面<span class="math inline">\(wx+b=0\)</span>的几何间隔是：</p><p><span class="math display">\[\gamma_i = y_i(\frac w {||w||} \cdot x_i + \frac b {||w||})\]</span></p><p>训练集的几何间隔取 训练集合中所有的样本点到分类超平面几何间隔的最小值。</p><p><strong>优化目标</strong></p><p>支持向量机的优化目标就是找到使得 几何间隔最大化的参数取值。这是一个约束优化问题，目标是<span class="math inline">\(max(\gamma)\)</span>, 约束条件是<span class="math inline">\(\gamma_i &gt;= \gamma\)</span>, 含义是在保证某个点的几何间隔都大于等于<span class="math inline">\(\gamma\)</span>的情况下，求最大的<span class="math inline">\(\gamma\)</span>.</p><p>在约束条件两边都乘以一个<span class="math inline">\(||w||\)</span>, 等式的性质不变，现在约束变成 <span class="math inline">\(y_i(w \cdot x_i + b) &gt;= \hat \gamma\)</span>, 因为 <span class="math inline">\(\gamma = \frac {\hat \gamma} \gamma\)</span>, 最优化的目标变为： <span class="math inline">\(\frac {\hat \gamma} {||w||}\)</span>, <span class="math inline">\(\hat \gamma\)</span>的取值是不影响最后的结果的，前面介绍过了，函数间隔会根据<span class="math inline">\(w\)</span>和<span class="math inline">\(b\)</span>的取值等比例的缩放，所以这里我们令<span class="math inline">\(\hat \gamma = 1\)</span>, 最优化问题可以写成下面的形式：</p><p><span class="math display">\[min \quad \frac 1 2 {||w||^2} \\s.t. \quad y_i(w \cdot x_i + b)-1 &gt;= 0, \quad \text{i=1,2,...,n}\]</span></p><blockquote><p>最大化 <span class="math inline">\(\frac 1 {||w||}\)</span> 等价于 最小化<span class="math inline">\(\frac 1 2 {||w||^2}\)</span></p></blockquote><p>支持向量机就是求解上面的最优化问题，来求得参数<span class="math inline">\(\theta\)</span>，然后构造分类超平面为未知的数据分类的。</p><h2 id="方法">方法</h2><h3 id="拉格朗日函数">拉格朗日函数</h3><p>凸优化问题的一般形式</p><p><span class="math display">\[min \quad f(x) \\s.t. \quad c_i(x) &lt;= 0, \quad i = 1,2,...,k \\           h_j(x) = 0, \quad j = 1,2,...,l\]</span></p><p>其中，<span class="math inline">\(f(x)\)</span>和<span class="math inline">\(c_i(x)\)</span> 都是 <span class="math inline">\(R^n\)</span>上的连续可微的凸函数，<span class="math inline">\(h_j(x)\)</span> 是 <span class="math inline">\(R^n\)</span>上的仿射函数。</p><blockquote><p><span class="math inline">\(f(x)\)</span>是仿射函数的含义是满足条件：<span class="math inline">\(f(x) = ax+b\)</span>,其中<span class="math inline">\(a \in R^n\)</span>,<span class="math inline">\(b \in R\)</span>,<span class="math inline">\(x \in R^n\)</span>.</p></blockquote><p>拉格朗日函数是在 约束优化问题中 用来把约束条件添加到目标函数中的一种手段，广义的拉格朗日函数的定义是：</p><p><span class="math display">\[L(x,\alpha,\beta) = f(x) + \sum_{i=1}^k \alpha_i c_i(x) + \sum_{j=1}^l \beta_j h_j(x) \quad \alpha_i &gt;= 0\]</span></p><p>其中，<span class="math inline">\(f(x)\)</span>是原来约束优化问题的目标函数，<span class="math inline">\(c_i(x)\)</span>和<span class="math inline">\(h_j(x)\)</span>是约束条件中的函数.</p><p>定义函数：</p><p><span class="math display">\[P(x) = \mathop{max} \limits_{\alpha,\beta} L(x,\alpha,\beta)\]</span></p><p>其中，<span class="math inline">\(P(x)\)</span>表示在把<span class="math inline">\(x\)</span>看作常数，<span class="math inline">\(\alpha,\beta\)</span>看作变量的情况下，求<span class="math inline">\(L(x,\alpha,\beta)\)</span>的最大值；</p><p>现在来分析函数<span class="math inline">\(P(x)\)</span>, 如果<span class="math inline">\(x\)</span>满足原来最优化问题的约束条件，即<span class="math inline">\(c_i(x) &lt;= 0\)</span>, <span class="math inline">\(h_j(x) = 0\)</span>, 那么 <span class="math inline">\(P(x) = \mathop{max} \limits_{\alpha,\beta} ( f(x) + \sum_{i=1}^k \alpha_i c_i(x))\)</span>, 这个时候的最大值的结果就是<span class="math inline">\(P(x) = f(x)\)</span>, <span class="math inline">\(\alpha_i = 0\)</span>. 除此之外，<span class="math inline">\(\alpha_i\)</span>取任何大于0的值最后的结果都会减小。</p><p>如果<span class="math inline">\(x\)</span>不满足约束条件，即 <span class="math inline">\(c_i(x) &gt; 0\)</span> 或者 <span class="math inline">\(h_j(x) \neq 0\)</span>, 这个时候总能找到满足的 <span class="math inline">\(\alpha\)</span> 或 <span class="math inline">\(\beta\)</span> ,使得 <span class="math inline">\(P(x) = +\infty\)</span> . 例如，如果<span class="math inline">\(c_i(x) &gt; 0\)</span>, 只需要让<span class="math inline">\(\alpha_i\)</span>足够大，就能保证结果足够大，如果<span class="math inline">\(h_j(x) \neq 0\)</span>, 只需要让<span class="math inline">\(\beta_j\)</span>足够大就能保证结果趋近 <span class="math inline">\(+\infty\)</span> .</p><p>综上，<span class="math inline">\(P(x)\)</span>是一个满足下述条件的函数：</p><p><span class="math display">\[P(x) = \begin{cases}        f(x) &amp; \text{x 满足约束条件} \\        +\infty &amp; \text{x 不满足约束条件}       \end{cases}\]</span></p><p>那么， <span class="math inline">\(min P(x)\)</span> 表示求<span class="math inline">\(P(x)\)</span>的最小值，其含义就是求在满足约束条件的情况下，<span class="math inline">\(f(x)\)</span>的最小值。所以原来的约束最优化问题，在引入拉格朗日函数之后，可以变成下面的无约束优化问题，它与原来的问题等价：</p><p><span class="math display">\[\mathop{min} \limits_x   \quad \mathop{max} \limits_{\alpha,\beta} ( f(x) + \sum_{i=1}^k \alpha_i c_i(x) + \sum_{j=1}^l \beta_j h_j(x))  \quad \alpha_i &gt;= 0\]</span></p><h3 id="对偶问题">对偶问题</h3><p>如果原始问题是：</p><p><span class="math display">\[p^*  =  \mathop{min} \limits_x   \quad \mathop{max} \limits_{\alpha,\beta} ( f(x) + \sum_{i=1}^k \alpha_i c_i(x) + \sum_{j=1}^l \beta_j h_j(x))  \quad \alpha_i &gt;= 0\]</span></p><p>则它的对偶问题是：</p><p><span class="math display">\[d^* =   \mathop{max} \limits_{\alpha,\beta}  \quad  \mathop{min} \limits_x   ( f(x) + \sum_{i=1}^k \alpha_i c_i(x) + \sum_{j=1}^l \beta_j h_j(x))  \quad \alpha_i &gt;= 0\]</span></p><p>原问题是先固定的把<span class="math inline">\(x\)</span>看作常数，求解<span class="math inline">\(\alpha,\beta\)</span>, 再把<span class="math inline">\(\alpha,\beta\)</span>看作常数，求解<span class="math inline">\(x\)</span>; 而对偶问题正好反了过来，是先把<span class="math inline">\(\alpha,\beta\)</span>看作常数，求解出<span class="math inline">\(x\)</span>,再把<span class="math inline">\(x\)</span>看作常数，求解出<span class="math inline">\(\alpha,\beta\)</span></p><p>如果<span class="math inline">\(p^*\)</span>表示原始问题的最优解，而<span class="math inline">\(d^*\)</span>表示对偶问题的最优解，则有<span class="math inline">\(d^* &lt;= p^*\)</span>. 原问题的解是大于等于对偶问题的最优解的，如果想通过解对偶问题来解原来的问题，需要满足如下的KKT条件，才能保证原问题和对偶问题的解相同：</p><p><span class="math display">\[\triangledown_x L(x,\alpha,\beta) = 0 \\\triangledown_{\alpha} L(x,\alpha,\beta) = 0 \\\triangledown_{\beta} L(x,\alpha,\beta) = 0 \\\alpha_ic_i(x) = 0,i=1,2,...,k \\c_i(x) &lt;=0, i = 1,2,...,k \\\alpha_i &gt;= 0, i=1,2,...,k \\h_j(x) = 0, j=1,2,...,l\]</span></p><p>其中， <span class="math inline">\(x,\alpha,\beta\)</span>,分别代表原始问题和最优问题的解。如果满足上述的约束条件，则原始问题和对偶问题有相同的解。 前三个条件是对<span class="math inline">\(x,\alpha,\beta\)</span>的偏导数为0， 后三个条件是原来问题的约束条件，只有中间的条件是新的约束条件 <span class="math inline">\(\alpha_i c_i(x) = 0\)</span>, 这意味着如果<span class="math inline">\(\alpha_i &gt; 0\)</span>, 那么<span class="math inline">\(c_i(x) = 0\)</span>，否则约束条件就无法得到满足。</p><h3 id="求解原问题">求解原问题</h3><p>支持向量机的优化目标是：</p><p><span class="math display">\[min \quad \frac 1 2 {||w||^2} \\s.t. \quad y_i(w \cdot x_i + b)-1 &gt;= 0, \quad \text{i=1,2,...,n}\]</span></p><p>把约束条件加入优化函数，改写成拉格朗日函数如下：</p><p><span class="math display">\[L(w,\alpha) = \frac 1 2 {||w||^2} - ( \sum_{k=1}^m \alpha_i (y_i(w \cdot x_i + b)-1) )\]</span></p><p>因为没有等式约束条件，所以这里没有<span class="math inline">\(\beta\)</span>, 还有这里是<span class="math inline">\(-\)</span>号，因为凸优化的标准约束是小于等于的形式，而这里却是大于等于的形式。</p><p>所以原来的优化问题可以转化成求解下面的问题：</p><p><span class="math display">\[\mathop{min} \limits_w \quad \mathop{max} \limits_{\alpha} L(w,\alpha)\]</span></p><p>它的对偶问题是:</p><p><span class="math display">\[\mathop{max} \limits_{\alpha} \quad \mathop{min} \limits_w  L(w,\alpha)\]</span></p><p>首先要求解<span class="math inline">\(\mathop{min} \limits_w L(w,\alpha)\)</span>, 这个时候<span class="math inline">\(w,b\)</span>是变量，<span class="math inline">\(\alpha\)</span>看作常量，求解函数 <span class="math inline">\(\frac 1 2 {||w||^2} - ( \sum_{k=1}^m \alpha_i (y_i(w \cdot x_i + b)-1) )\)</span> 的最小值。</p><blockquote><p>多元函数的极值点必在驻点（偏导数为0的点）和偏导数不存在的点中。</p></blockquote><p>要求极值点，首先对每个变量(<span class="math inline">\(w,b\)</span>)求偏导数，令其等于0：</p><p><span class="math display">\[\triangledown_w L(w,b,\alpha) = w - \sum_{i=1}^m \alpha_i y_i x_i = 0 \\\triangledown_b L(w,b,\alpha) = \sum_{i=1}^m \alpha_i y_i = 0\]</span></p><p>把得到的等式带入原来的式子<span class="math inline">\(L(w,b,\alpha)\)</span>中化简,去掉<span class="math inline">\(w,b\)</span>,得到只有<span class="math inline">\(x,y,\alpha\)</span>的表达式：</p><p><span class="math display">\[\mathop{min} \limits_{w,b}  L(w,b,\alpha)  = - \frac 1 2 \sum_{i=1}^m \sum_{j=1}^m \alpha_i \alpha_j y_i y_j(x_i \cdot  x_j) + \sum_{i=1}^m \alpha_i\]</span></p><p>上式中，<span class="math inline">\(w,b\)</span>已经确定了，得到了一个极小值，下一步是求极大值<span class="math inline">\(\mathop{max} \limits_{\alpha} \quad \mathop{min} \limits_{w,b} L(w,b,\alpha)\)</span>, 具体的式子带入，转化成求如下的约束优化问题：</p><p><span class="math display">\[\mathop{max} \limits_{\alpha}  \quad - \frac 1 2 \sum_{i=1}^m \sum_{j=1}^m \alpha_i \alpha_j y_i y_j(x_i \cdot  x_j) + \sum_{i=1}^m \alpha_i \\s.t. \quad \sum_{i=1}^m \alpha_i y_i = 0 \\    \alpha_i &gt;= 0, \quad i=1,2,...,m\]</span></p><p>把求解最大化问题转化成求解最小化问题：</p><p><span class="math display">\[\mathop{min} \limits_{\alpha}  \quad  \frac 1 2 \sum_{i=1}^m \sum_{j=1}^m \alpha_i \alpha_j y_i y_j(x_i \cdot  x_j) - \sum_{i=1}^m \alpha_i \\s.t. \quad \sum_{i=1}^m \alpha_i y_i = 0 \\    \alpha_i &gt;= 0, \quad i=1,2,...,m\]</span></p><p>设该问题的解是<span class="math inline">\(\alpha^*\)</span>, 则原来问题的解是<span class="math inline">\(w^*,b^*\)</span>, KKT条件成立，可以导出三者之间的关系为：</p><p><span class="math display">\[w^* = \sum_{i=1}^m \alpha^* y_i x_i \\b^* = y_i - \sum_{i=1}^m \alpha^* y_i (x_i \cdot x_j)\]</span></p><h3 id="求解支持向量机参数的一般步骤">求解支持向量机参数的一般步骤</h3><p>输入：训练集<span class="math inline">\((x_i,y_i)\)</span>, 训练集合有样本<code>m</code>个，特征数量<code>n</code>个。</p><p>输出：分类决策函数</p><p><strong>最大间隔法</strong></p><ol style="list-style-type: decimal"><li>构造并求解约束最优化问题：</li></ol><p><span class="math display">\[\mathop{min} \limits_{w,b} \quad \frac 1 2 {||w||^2} \\s.t. \quad  y_i(w \cdot x_i + b) - 1 &gt;= 0, \quad i=1,2,...,m\]</span></p><ol start="2" style="list-style-type: decimal"><li><p>求解该问题得到问题的解<span class="math inline">\(w^*,b^*\)</span></p></li><li><p>构造分类平面 <span class="math inline">\(w^* \cdot x + b^* = 0\)</span></p></li></ol><p><strong>对偶学习算法</strong></p><ol style="list-style-type: decimal"><li>构造并求解约束最优化问题：</li></ol><p><span class="math display">\[\mathop{min} \limits_{\alpha} \quad \frac 1 2 \sum_{i=1}^n \sum_{j=1}^n \alpha_i \alpha_j y_i y_j (x_i \cdot x_j) - \sum_{i=1}^n \\s.t. \quad \sum_{i=1}^m \alpha_i y_i = 0 \\    \alpha_i &gt;= 0, \quad i=1,2,...,m\]</span></p><p>求解上面的最优化问题得到 <span class="math inline">\(\alpha^*\)</span>.</p><ol start="2" style="list-style-type: decimal"><li>计算 <span class="math inline">\(w^*\)</span> 和 <span class="math inline">\(b^*\)</span> :</li></ol><p><span class="math display">\[w^* = \sum_{i=1}^n \alpha^* y_i x_i \\b^* = y_i - \sum_{i=1}^n \alpha^*_i y_i (x_i \cdot x_j)\]</span></p><ol start="3" style="list-style-type: decimal"><li>根据第二步求解的参数构造分类决策函数：</li></ol><p><span class="math display">\[w^* \cdot x + b^* = 0\]</span></p><h3 id="一个具体的例子">一个具体的例子</h3><p>有三个训练样本，每个样本有两个特征，<span class="math inline">\(x_1 = (3,3), x_2 = (4,3), x_3 = (1,1)\)</span>, 求支持向量机的分类超平面。其中<span class="math inline">\(x_1,x_2\)</span>是正样本，<span class="math inline">\(x_3\)</span>是负样本。</p><ol style="list-style-type: decimal"><li>用最大间隔法求解</li></ol><p>根据数据构造约束最优化问题：</p><p><span class="math display">\[\mathop{min} \limits_{w,b} \quad \frac 1 2 (w_1^2+w_2^2) \\s.t. \quad 3w_1 + 3w_2 + b &gt;= 1 \\           4w_1 + 4w_2 + b &gt;= 1 \\           -w_1 - w_2 - b &gt;= 1\]</span></p><p>求解此最优化问题得到结果：<span class="math inline">\(w_1 = w_2 = \frac 1 2, b = -2\)</span>, 最后的分类超平面是:</p><p><span class="math display">\[\frac 1 2 x^{(1)} + \frac 1 2 x^{(2)} - 2 = 0\]</span></p><ol start="2" style="list-style-type: decimal"><li>用对偶学习算法求解：</li></ol><p>根据数据构造约束最优化问题：</p><p><span class="math display">\[\mathop{min} \limits_{\alpha} \quad \frac 1 2 (18\alpha_1^2 + 25\alpha_2^2 + 2\alpha_3^2 + 42 \alpha_1 \alpha_2 - 12 \alpha_1 \alpha_3 - 14 \alpha_2 \alpha_3) - (\alpha_1 + \alpha_2 + \alpha_3)  \\s.t. \quad \alpha_1 + \alpha_2 - \alpha_3 = 0 \\           \alpha_i &gt;= 0, \quad i=1,2,3\]</span></p><p>求解最优化问题得到结果：<span class="math inline">\(\alpha_1 = \frac 1 4, \alpha_2 = 0, \alpha_3 = \frac 1 4\)</span>.</p><p>则可以得到 <span class="math inline">\(w_1^* = = w_2^* = \frac 1 2\)</span>, <span class="math inline">\(b^* = -2\)</span>.</p><p>最后的分类超平面为：</p><p><span class="math display">\[\frac 1 2 x^{(1)} + \frac 1 2 x^{(2)} - 2 = 0\]</span></p><p>比较最大间隔算法和对偶学习算法可以看出，对偶学习算法更容易求解，因为其约束条件变得更少，更容易得到不同变量之间的转换关系。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习-第三章-朴素贝叶斯</title>
      <link href="/hexoblog/2017/11/04/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
      <url>/hexoblog/2017/11/04/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习-第二章-决策树</title>
      <link href="/hexoblog/2017/11/04/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%86%B3%E7%AD%96%E6%A0%91/"/>
      <url>/hexoblog/2017/11/04/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%86%B3%E7%AD%96%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>【决策树】【ID3】【C4.5】</p><a id="more"></a><h2 id="模型">模型</h2><p>一棵树，每次分支都按照某个属性确定分到哪一个分支，直到所有的数据集都被分到正确的类别上。</p><h2 id="策略">策略</h2><p>主要涉及使用什么指标划分</p><p>如何剪枝避免过拟合</p><h2 id="方法">方法</h2><p>ID3</p><p>C4.5</p><p>CART</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习-第一章-逻辑回归</title>
      <link href="/hexoblog/2017/11/04/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
      <url>/hexoblog/2017/11/04/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p>【逻辑回归】</p><a id="more"></a><h2 id="模型">模型</h2><p>令 <span class="math inline">\(\theta = (w_1,w_2,...,w_n,b)\)</span>, <span class="math inline">\(x = (x_1,x_2,...,x_n,1)\)</span>,则有： <span class="math display">\[\theta^T \cdot x = w_1x_1+x_2x_2+...+w_nx_n+b\]</span></p><p>逻辑回归要训练得到的函数模型是：</p><p><span class="math display">\[h_\theta(x) = f(\theta^T \cdot x)\]</span></p><p>其中<code>f</code>是下面的函数：</p><p><span class="math display">\[f(z) = \frac 1 {1+e^{-z}}\]</span></p><p>函数<code>f</code>的图像如下图所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plot[<span class="number">1.0</span> / (<span class="number">1</span> + E^(-x)), &#123;x, <span class="number">-10</span>, <span class="number">10</span>&#125;]</span><br></pre></td></tr></table></figure><div class="figure"><img src="softmax.png" alt="f(z)"><p class="caption">f(z)</p></div><p><span class="math inline">\(h_\theta(x)\)</span> 的结果是<code>(0,1)</code>，含义是类别为正类别的概率; <span class="math inline">\(\theta\)</span>的含义是模型的参数.</p><p>算法的目标是在已知<span class="math inline">\((x_1,x_2,...x_n)\)</span> 和对应的 <span class="math inline">\(y\)</span> 的若干个样本的情况下，求解出<span class="math inline">\((w_1,w_2,...,w_n,b)\)</span>这些参数，使得损失函数最小。</p><blockquote><p>Wolfram Mathematica 是一个专业的科学计算软件，使用它可以非常方便的绘制出函数的图形。<code>Plot[1.0 / (1 + E^(-x)), {x, -10, 10}]</code>就是绘制出上面的函数图形的命令。</p></blockquote><h2 id="策略">策略</h2><p>逻辑回归使用的损失函数是：</p><p><span class="math display">\[cost(h_\theta(x),y) = \begin{cases}                      -log(h_\theta(x)) &amp; \text{if y = 1} \\                      -log(1-h_\theta(x)) &amp;  \text{if y = 0}                      \end{cases}\]</span></p><p>其中，<span class="math inline">\(h_\theta(x)\)</span>就是模型预测的结果，<span class="math inline">\(y\)</span>是实际的标签，取值是<span class="math inline">\(0，1\)</span>.</p><p>当<span class="math inline">\(y=1\)</span>时，<span class="math inline">\(h_\theta(x)\)</span>接近1的时候，损失函数<span class="math inline">\(-log(h_\theta(x))\)</span>接近0，而当<span class="math inline">\(h_\theta(x)\)</span>接近0的时候，损失函数是接近正无穷的。其对应的关系如下图所示：</p><div class="figure"><img src="hox.png"></div><p>当<span class="math inline">\(y = 0\)</span>时，<span class="math inline">\(h_\theta(x)\)</span>接近0的时候，损失函数<span class="math inline">\(-log(1-h_\theta(x))\)</span>接近0，而当<span class="math inline">\(h_\theta(x)\)</span>接近1的时候，损失函数<span class="math inline">\(-log(1-h_\theta(x))\)</span>接近正无穷。其对应的关系如下图所示：</p><div class="figure"><img src="hox2.png"></div><p>分段函数不利于表达，把上面的<code>cost</code>函数写成统一的格式如下：</p><p><span class="math display">\[cost(h_\theta(x),y) = - ( y \times log(h_\theta(x))  +  (1-y) \times log(1-h_\theta(x)) )\]</span></p><p>对于一个有<code>m</code>个样本的训练集，训练集上的损失为：</p><p><span class="math display">\[J(\theta) = - \frac 1 m \sum_{i=1}^{m} (y^{(i)} \times log(h_\theta(x^{(i)})) + (1-y^{(i)}) \times log(1-h_\theta(x^{(i)})))\]</span></p><p>其中，<span class="math inline">\(i\)</span>表示训练集中的第<span class="math inline">\(i\)</span>个样本，<span class="math inline">\(x\)</span>表示特征向量<span class="math inline">\((x_1,x_2,...,x_n,x_{n+1})\)</span>, <span class="math inline">\(y\)</span> 表示实际的标签，取值<span class="math inline">\(0,1\)</span>。</p><h2 id="算法">算法</h2><p>找到一种算法，在已经知道<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>的情况下，求解出能够使得<span class="math inline">\(J(\theta)\)</span>最小的<span class="math inline">\(\theta\)</span>的值，具体的就是<span class="math inline">\((w_1,w_2,...,w_n,b)\)</span>的值。</p><h3 id="梯度下降法">梯度下降法</h3><p><strong>梯度</strong>， 函数对每一个参数求偏导数，偏导数组合成向量，向量的方向就是梯度的方向，函数在梯度的方向上升最快，在梯度的反方向下降最快。</p><p>使用梯度下降法求解参数的步骤：</p><ol style="list-style-type: decimal"><li>初始化参数。</li></ol><p>首先给参数一个初始值<span class="math inline">\(\theta = \theta^0\)</span>, 定义一个步长<span class="math inline">\(\alpha\)</span>,就是每次要在梯度的方向上移动的距离; 定义一个终止条件<span class="math inline">\(\epsilon\)</span>，确定算法在什么条件下终止。（一般是看参数更新前后两者的差值，小于某一个很小的数字，就可以结束算法）</p><ol start="2" style="list-style-type: decimal"><li>计算梯度：</li></ol><p><span class="math display">\[\frac \partial {\partial\theta_j} J(\theta_1,\theta_2,...,\theta_{n+1})) = \frac 1 m   \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})x\]</span></p><p>其中，<span class="math inline">\(j \in (1,n+1)\)</span> 表示第<code>j</code>个参数， <span class="math inline">\(i \in (1,m)\)</span> 表示第<code>m</code>个样本。</p><blockquote><p>这里涉及到函数的求导，先来复习一下函数的链式求导法则： <span class="math display">\[\frac {dx} {dy} = \frac {dx} {dz} \times \frac {dz} {dy}\]</span> 举个例子： sigmoid 函数的导数是： <span class="math display">\[y = f(z) = \frac 1 {1 + e^{-z}}\]</span> 它的导数可以很容易的求出来，还可以把它表示成y的乘积的形式。 <span class="math display">\[\frac {dy} {dz} = \frac {e^{-z}} {1+e^{-z}} = y(1-y)\]</span></p></blockquote><p>现在来求损失函数的对每一个参数<span class="math inline">\(\theta_i\)</span>的导数：</p><p><span class="math display">\[\frac {\partial cos(h_\theta,y)} {\partial \theta} = (h_\theta(x) - y) \cdot x\]</span></p><p>假设一共有<code>m</code>个训练样本,<span class="math inline">\(i \in (1,m)\)</span>, 一共有<code>n+1</code>个参数，<span class="math inline">\(j \in (1,n+1)\)</span>, 则每个参数的导数如下：</p><p><span class="math display">\[\frac {\partial cos(h_\theta(x),y)}  {\theta_j}   =  \frac 1 m   \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)}))  x_j^{(i)}\]</span></p><p>根据上面的公式，初始化<span class="math inline">\(\theta^0\)</span>之后，可以利用整个训练集的数据<span class="math inline">\((x^{(i)},y^{(i)}),i \in (1,m)\)</span>, 计算出一个梯度向量<span class="math inline">\((\Delta \theta_1,\Delta \theta_2,...,\Delta \theta_{n+1})\)</span>.</p><ol start="3" style="list-style-type: decimal"><li>更新参数</li></ol><p><span class="math display">\[\theta^{i+1} = \theta^i + \alpha \Delta \theta^i\]</span></p><p>其中，<span class="math inline">\(\theta^i\)</span>表示第<span class="math inline">\(i\)</span>次迭代的时候的参数取值，<span class="math inline">\(\Delta \theta^i\)</span>表示第二步计算出来的梯度，<span class="math inline">\(\alpha\)</span>表示 <strong>学习率</strong>，是控制梯度下降的每步大小的一个超参数，需要自己设置。</p><ol start="4" style="list-style-type: decimal"><li>比较更新前后的参数的变化</li></ol><p><span class="math display">\[\epsilon = \sum_{i=1}^{n+1} ( \theta^{i+1} - \theta^{i} )\]</span></p><p>如果<span class="math inline">\(\epsilon\)</span>的值小于预先确定的结束条件，算法结束，最后的<span class="math inline">\(\theta\)</span>就是要求解的参数，如果<span class="math inline">\(\epsilon\)</span>大于结束条件，则转到第三步继续迭代，直到满足结束条件为止。</p><blockquote><p>梯度下降的几种策略： 上面的例子中，每一次参数的更新，我们是使用训练集中的所有样本计算的梯度，这样做每次计算出来的梯度比较准确，但是当训练集合非常大的时候，每次的计算开销就很大。 <span class="math display">\[\frac {\partial cos(h_\theta(x),y)}  {\theta_j}   =  \frac 1 m   \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)}))  x_j^{(i)}\]</span> 可以看出，求解的方法是每个样本计算出一个梯度，然后求和取平均值作为最后的梯度。</p><p><strong>随机梯度下降法</strong></p><p>随机梯度下降法就是把上面的式子中的求和符号去掉，每次只使用一个样本计算梯度，计算出来就更新一次参数，然后再在更新之后的参数上，利用下一个样本计算梯度，这样每次更新的速度都很快，但是只是利用一个样本计算出来的梯度可能根本就不是函数上升最快的方向，所以收敛的速度不一定快。</p><p><strong>批量梯度下降法</strong></p><p>这种方法就综合上面两种方法的利弊提出的，每次使用若干个（一般是10个）样本计算梯度，计算完就更新参数，然后在更新的参数的基础上利用另外的10个样本计算下一个梯度方向，直到算法结束。</p></blockquote><h3 id="梯度下降法算法调优">梯度下降法算法调优</h3><p>通过梯度下降法的求解过程，我们知道要设置三个重要的参数，一个是<span class="math inline">\(\theta^0\)</span>, 初始参数的值；一个是<span class="math inline">\(\alpha\)</span>,学习率；一个是算法停止条件，<span class="math inline">\(\epsilon\)</span>.</p><p>如果要优化的函数是凸函数（只有一个极值点），<span class="math inline">\(\theta^0\)</span> 的值不会影响最终的结果，但是会影响算法结束的速度；如果优化的函数有多个极值点，<span class="math inline">\(\theta^0\)</span> 的初始值会影响最后的结果。这个时候，一个解决的办法是随机选择多次初始点，分别计算出极值点，选择极值点最小的那个初始点作为算法的初始点。 理论上如果选择足够多的初始点(并且是随机选择)，一定可以找到真正的极值点。</p><p><span class="math inline">\(\alpha\)</span> 的选择也十分重要，如果过小，算法迭代次数过多，会结束的非常慢；如果过大，很可能会越过极值点，找不到正确的结果。</p><p><span class="math inline">\(\epsilon\)</span> 的选择影响算法的终止条件，如果过大，可能还没有达到极值点就结束了，如果过小，可能导致算法运行时间过长。</p><p>除此之外，使用梯度下降法时候，特征一般要归一化处理，这是因为，如果不同的维度取值范围差异很大的话，算法的迭代效率就很差，归一化的方法是计算数据的均值和方差，然后每个特征减去均值之后除以标准差</p><p>使用随机梯度下降的时候，如果数据集不是线性可分的(存在噪声的情况)，可能会造成梯度来回波动的情况，可以下面的方式优化：</p><blockquote><ul><li>在每次迭代时，调整更新步长<span class="math inline">\(\alpha\)</span>的值。随着迭代的进行，<span class="math inline">\(\alpha\)</span>越来越小，这会缓解系数的高频波动（也就是每次迭代系数改变得太大，跳的跨度太大）。当然了，为了避免<span class="math inline">\(\alpha\)</span>随着迭代不断减小到接近于0（这时候，系数几乎没有调整，那么迭代也没有意义了），我们约束<span class="math inline">\(\alpha\)</span>一定大于一个稍微大点的常数项.</li></ul></blockquote><blockquote><ul><li>每次迭代，改变样本的优化顺序。也就是随机选择样本来更新回归系数。这样做可以减少周期性的波动，因为样本顺序的改变，使得每次迭代不再形成周期性。</li></ul></blockquote><h3 id="牛顿法">牛顿法</h3><h3 id="拟牛顿法">拟牛顿法</h3><h2 id="对模型的理解">对模型的理解</h2><p>理解一个模型的含义有时候会很有帮助，但不是所有的模型都有确切的含义，幸运的是，逻辑回归模型有一些很好的解释便于理解实际含义。</p><p><strong>对数几率</strong></p><p>在逻辑回归模型中，<span class="math inline">\(\theta^T \cdot x\)</span>的值是有含义的。假设一件事发生的概率是<span class="math inline">\(P\)</span>,不发生的概率是<span class="math inline">\(1-P\)</span>,定义一件事发生的<strong>几率</strong> 为发生的概率和不发生的概率的比值：<span class="math inline">\(p / (1-p)\)</span>. 定义一件事发生的对数几率是：<span class="math inline">\(log(p / (1-p))\)</span>.</p><p>逻辑回归的输出<span class="math inline">\(h_\theta(x)\)</span>可以看作分类为1的概率：</p><p><span class="math display">\[P(Y=1|X) = h_\theta(x) = \frac 1 {1 + e^{-\theta^T \cdot x}}\]</span></p><p>记A表示分类结果是1这一时间，则A的对数几率是：</p><p><span class="math display">\[logit(A) = log(\frac {h_\theta(x)} {1-h_\theta(x)}) = \theta^T = w_1 x_1+ x_2 x_2 + ... + w_n x_n + b\]</span></p><p><span class="math inline">\(\theta^T \cdot x\)</span> 的含义其实是事件A发生的对数几率，取对数并不影响函数原来的极值点，可以认为是原来的含义。所以可以认为<span class="math inline">\(\theta^T \cdot x\)</span> 度量了事件A发生的几率。 而原来的<span class="math inline">\(h_\theta(x)\)</span> 表示的事件A发生的概率。</p><p><strong>最大似然</strong></p><p>最大似然的思想是： 选择使得已经发生的事件概率取得最大值的 那些参数。 例如<span class="math inline">\(\theta\)</span>表示箱子的编号，1号箱子里面有1个红球，9个白球，2号箱子里面有1个白球，9个红球；如果任意选择一个箱子，任意取一个球，发现取得的是红球，那么根据最大似然的原理<span class="math inline">\(\theta = 2\)</span>,因为如果是2号箱子，取得红球的概率是0.9， 如果是1号箱子，取得红球的概率是0.1.</p><p>把训练集中的出现的样本作为一次实验，那么出现这种实验结果的概率是：</p><p><span class="math display">\[P(Y=1|X)^{y_i} (1-P(Y=0|X))^{1-y_i}\]</span></p><p>所有的<code>m</code>个样本出现的概率是每一个样本出现的概率的乘积：</p><p><span class="math display">\[L(\theta) = \prod_{i=1}^m (h_\theta(x))^{y_i} (1-h_\theta(x))^{1-y_i}\]</span></p><p>用最大似然的观点，逻辑回归转化成求<span class="math inline">\(L(\theta)\)</span>最大的时候，<span class="math inline">\(\theta\)</span>的值。求解该函数的极大值，就是求解负函数的极小值。对<span class="math inline">\(\theta\)</span>求导之后会发现，最优化函数和上面提到的用损失函数表示的是一样的。所以求解的方法依然是梯度下降法。</p><h2 id="编写算法python">编写算法（Python）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Sat Nov 04 20:47:47 2017</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: FF120</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math <span class="keyword">as</span> mm</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogisticRegression</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    theta : 初始的参数选择(n+1_features),最后一个参数是截距b</span></span><br><span class="line"><span class="string">    alpha : 学习率</span></span><br><span class="line"><span class="string">    epsilon : 终止条件</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,theta,alpha,epsilon)</span>:</span></span><br><span class="line">        self.theta = theta</span><br><span class="line">        self.alpha = alpha</span><br><span class="line">        self.epsilon = epsilon</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(z)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span> / (<span class="number">1</span> + mm.exp(-z))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_theta</span><span class="params">(self,X,y)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        使用所有训练数据完成一次参数的更新过程</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        返回值</span></span><br><span class="line"><span class="string">        epsilon: 本次更新的梯度和上次的差异</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m,n = X.shape</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n+<span class="number">1</span>): <span class="comment"># 第j个参数的偏移</span></span><br><span class="line">            delta_theta = np.zeros((<span class="number">1</span>,n+<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span> i,line_x,line_y <span class="keyword">in</span> enumerate(zip(X,y)):</span><br><span class="line">                line_x = np.array(list(line_x) + [<span class="number">1</span>]) <span class="comment"># 添加x_n+1</span></span><br><span class="line">                theta = np.array(self.theta)</span><br><span class="line">                delta_theta[i] += self.sigmoid(np.dot(theta.T,line_x) - line_y) * (line_x[j])</span><br><span class="line">                </span><br><span class="line">            delta_theta = delta_theta*(<span class="number">1.0</span> / m)</span><br><span class="line">            epsilon = np.sum(np.absolute(self.alpha *delta_theta))</span><br><span class="line">            self.theta = self.theta + self.alpha * delta_theta</span><br><span class="line">            <span class="keyword">return</span> epsilon</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fix</span><span class="params">(self,X,y)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        X : (n_samples,n_featues) 训练集合</span></span><br><span class="line"><span class="string">        y : (n_samples,) 训练集对应的标签</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            epsilon = self.update_theta(X,y)</span><br><span class="line">            <span class="keyword">if</span> epsilon &lt; self.epsilon:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self,X)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        X : (n_samples.n_features) 训练集合</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> X.shape[<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            y = self.sigmoid( np.dot(self.theta.T,X) )</span><br><span class="line">            <span class="keyword">if</span> y &gt;= <span class="number">0.5</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> y &lt; <span class="number">0.5</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习-绪论-基本概念</title>
      <link href="/hexoblog/2017/11/04/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%BB%AA%E8%AE%BA-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/hexoblog/2017/11/04/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%BB%AA%E8%AE%BA-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="统计学习方法的三要素">统计学习方法的三要素</h2><blockquote><p>方法 = 模型 + 策略 + 算法</p></blockquote><p><strong>模型</strong> 是方法依据的数学原理 <strong>策略</strong> 是使用哪种损失函数或者代价函数 <strong>算法</strong> 是如何如何求解问题</p><p>一个模型可以有多种策略(例如使用不同的损失函数度量损失的程度)， 一种策略可以有多种不同的方法(例如可以用梯度下降法，最小二乘法求解)。</p><h2 id="常用的模型">常用的模型</h2><h2 id="常用的损失函数">常用的损失函数</h2><h3 id="损失函数">0-1 损失函数</h3><p><span class="math display">\[L(Y,f(X)) = \begin{cases}              1, &amp; { Y \neq f(X)} \\              0, &amp; { Y = f(X) }              \end{cases}\]</span></p><p><code>Y</code>表示实际的值，<code>f(X)</code>表示通过模型预测出来的值，0-1损失就是当预测正确的时候损失是0，预测错误的时候损失是1.</p><h3 id="绝对值损失函数">绝对值损失函数</h3><p><span class="math display">\[L(Y,f(X) = |Y - f(X)|\]</span></p><h3 id="平方损失函数">平方损失函数</h3><p><span class="math display">\[L(Y,f(X)) = (Y - f(X))^2\]</span></p><h3 id="对数损失函数">对数损失函数</h3><p><span class="math display">\[L(Y,P(Y|X)) = -logP(Y|X)\]</span></p><h2 id="常用的算法">常用的算法</h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL</title>
      <link href="/hexoblog/2017/11/02/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/"/>
      <url>/hexoblog/2017/11/02/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/</url>
      
        <content type="html"><![CDATA[<p>基于MySQL的语法说明数据库查询的一些操作。</p><p>在<code>test</code>数据库中创建一个<code>user</code>表，执行一些查询操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">6Li Xiao102017-11-01</span><br><span class="line">7Li Xiao202017-11-02</span><br><span class="line">8Li Xiao102017-11-03</span><br><span class="line">9Zhao Hi202016-10-11</span><br><span class="line">10Zhao Hi202016-10-12</span><br><span class="line">11Zhao Hi202016-10-13</span><br><span class="line">12Kao Ha102016-03-01</span><br><span class="line">13Kao Ha202016-03-02</span><br><span class="line">14Cao Pi502016-09-11</span><br><span class="line">15Cao Pi102016-09-12</span><br></pre></td></tr></table></figure><a id="more"></a><ol style="list-style-type: decimal"><li>切换数据库</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure><ol start="2" style="list-style-type: decimal"><li>显示数据库中的表</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure><ol start="3" style="list-style-type: decimal"><li>如果已经存在<code>user</code>表，删除它</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><ol start="4" style="list-style-type: decimal"><li>创建表</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    price <span class="built_in">numeric</span>(<span class="number">20</span>,<span class="number">2</span>) <span class="keyword">default</span> <span class="number">0.0</span>,</span><br><span class="line">    update_time <span class="built_in">date</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>创建表的时候基本语法是： 列名 类型 [约束]，</p><p>约束是可选的，可用的约束有：</p><ul><li>unique 唯一值</li><li>not null 不能为空</li><li>default 默认值 添加默认值</li><li>check 满足某一个条件</li><li>primary key 指定为主键</li><li>foreign key 指定外键</li></ul><p>只约束某一列的时候，可以直接写在某个列上，如果涉及多个列，要写在最后。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    price <span class="built_in">numeric</span>(<span class="number">20</span>,<span class="number">2</span>) <span class="keyword">default</span> <span class="number">0.0</span>,</span><br><span class="line">    update_time <span class="built_in">date</span>,</span><br><span class="line">    <span class="keyword">check</span> (<span class="keyword">id</span> &gt; <span class="number">0</span> <span class="keyword">and</span> price &gt; <span class="number">0</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="5" style="list-style-type: decimal"><li>插入值</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">name</span>, price , update_time) <span class="keyword">values</span> (<span class="string">'Li Xiao'</span>,<span class="number">10.0</span>,<span class="string">'2017-11-01'</span>);</span><br></pre></td></tr></table></figure><p>指定自动增长的列和没有设置非空约束的列可以没有对应的值，会自动添加对应的数据。指定非空的列在插入的时候必须有值。</p><ol start="6" style="list-style-type: decimal"><li>更新值</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> update_time = <span class="keyword">curdate</span>() <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'Li Xiao'</span>;</span><br></pre></td></tr></table></figure><ol start="7" style="list-style-type: decimal"><li>删除值</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'Li Xiao'</span>;</span><br></pre></td></tr></table></figure><p>完整的创建数据库和插入需要的数据的语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  price <span class="built_in">numeric</span> <span class="keyword">default</span> <span class="number">0.0</span>,</span><br><span class="line">  <span class="built_in">date</span> <span class="built_in">date</span> </span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">name</span>,price,<span class="built_in">date</span>) <span class="keyword">values</span> (<span class="string">'Li Xiao'</span>,<span class="number">10.2</span>,<span class="keyword">curdate</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">name</span>,price,<span class="built_in">date</span>) <span class="keyword">values</span> (<span class="string">'Li Xiao'</span>,<span class="number">80.0</span>,<span class="keyword">curdate</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">name</span>,price,<span class="built_in">date</span>) <span class="keyword">values</span> (<span class="string">'Li Xiao'</span>,<span class="number">10.0</span>,<span class="keyword">curdate</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">name</span>,price,<span class="built_in">date</span>) <span class="keyword">values</span> (<span class="string">'Zhao Hi'</span>,<span class="number">20.0</span>,<span class="string">'2016-10-10'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">name</span>,price,<span class="built_in">date</span>) <span class="keyword">values</span> (<span class="string">'Zhao Hi'</span>,<span class="number">20.0</span>,<span class="string">'2016-6-10'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">name</span>,price,<span class="built_in">date</span>) <span class="keyword">values</span> (<span class="string">'Zhao Hi'</span>,<span class="number">20.0</span>,<span class="string">'2016-3-6'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">name</span>,price,<span class="built_in">date</span>) <span class="keyword">values</span> (<span class="string">'Kao Ha'</span>,<span class="number">10.0</span>,<span class="string">'2016-3-5'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">name</span>,price,<span class="built_in">date</span>) <span class="keyword">values</span> (<span class="string">'Kao Ha'</span>,<span class="number">20.0</span>,<span class="string">'2016-3-7'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">name</span>,price,<span class="built_in">date</span>) <span class="keyword">values</span> (<span class="string">'Cao Pi'</span>,<span class="number">50.0</span>,<span class="string">'2016-9-10'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">name</span>,price,<span class="built_in">date</span>) <span class="keyword">values</span> (<span class="string">'Cao Pi'</span>,<span class="number">10.0</span>,<span class="string">'2016-2-10'</span>);</span><br></pre></td></tr></table></figure><ol start="8" style="list-style-type: decimal"><li>查询</li></ol><p>每个人的总额</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">sum</span>(price) <span class="keyword">as</span> total <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure><p>每个人的记录数量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">count</span>(*) <span class="keyword">as</span> nums <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure><p>每个人的平均值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">sum</span>(price) / <span class="keyword">count</span>(*) <span class="keyword">as</span> <span class="keyword">avg</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure><p>总的金额</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(price) <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p>每个人每次得到的钱占总共金额的百分比</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, price / (<span class="keyword">select</span> <span class="keyword">sum</span>(price) <span class="keyword">from</span> <span class="keyword">user</span>) <span class="keyword">as</span> <span class="keyword">percent</span> <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p>每个人得到的钱的和占总金额的百分比：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">sum</span>(price) / (<span class="keyword">select</span> <span class="keyword">sum</span>(price) <span class="keyword">from</span> <span class="keyword">user</span>) <span class="keyword">as</span> <span class="keyword">percent</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure><p>输出记录数量大于2且总金额大于90的人的姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">having</span> <span class="keyword">count</span>(*) &gt; <span class="number">2</span> <span class="keyword">and</span> <span class="keyword">sum</span>(price) &gt; <span class="number">90</span>;</span><br></pre></td></tr></table></figure><p>输出2016年每个人得到的金额 占 2016 年总金额的百分比</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">sum</span>(price) / (<span class="keyword">select</span> <span class="keyword">sum</span>(price) <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="built_in">date</span>) = <span class="number">2016</span>) <span class="keyword">as</span> <span class="keyword">percent</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="built_in">date</span>) = <span class="number">2016</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure><p>输出每一年 每个人得到的总金额 占当年总金额的百分比</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 获得每个人在一年总的收入金额</span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">sum</span>(price) <span class="keyword">as</span> price ,<span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="built_in">date</span>) <span class="keyword">as</span> <span class="keyword">year</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>)；</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 获得每一年总的金额</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="built_in">date</span>) <span class="keyword">as</span> <span class="keyword">year</span> , <span class="keyword">sum</span>(price) <span class="keyword">as</span> <span class="keyword">sum</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="built_in">date</span>);</span><br><span class="line">3. 两个表连接</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> a.name, a.price, b.sum, a.year <span class="keyword">from</span> ((<span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">sum</span>(price) <span class="keyword">as</span> price ,<span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="built_in">date</span>) <span class="keyword">as</span> <span class="keyword">year</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>)) <span class="keyword">as</span> a, (<span class="keyword">select</span> <span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="built_in">date</span>) <span class="keyword">as</span> <span class="keyword">year</span> , <span class="keyword">sum</span>(price) <span class="keyword">as</span> <span class="keyword">sum</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="built_in">date</span>)) <span class="keyword">as</span> b <span class="keyword">where</span> a.year = b.year;</span><br><span class="line"></span><br><span class="line">4. 查询连接之后的表得到结果</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, price / <span class="keyword">sum</span> <span class="keyword">as</span> <span class="keyword">percent</span> <span class="keyword">from</span> (<span class="keyword">select</span> a.name, a.price, b.sum, a.year <span class="keyword">from</span> ((<span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">sum</span>(price) <span class="keyword">as</span> price ,<span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="built_in">date</span>) <span class="keyword">as</span> <span class="keyword">year</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>)) <span class="keyword">as</span> a, (<span class="keyword">select</span> <span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="built_in">date</span>) <span class="keyword">as</span> <span class="keyword">year</span> , <span class="keyword">sum</span>(price) <span class="keyword">as</span> <span class="keyword">sum</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="built_in">date</span>)) <span class="keyword">as</span> b <span class="keyword">where</span> a.year = b.year) <span class="keyword">as</span> tmp</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KNN with C++</title>
      <link href="/hexoblog/2017/10/15/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/KNN-with-C/"/>
      <url>/hexoblog/2017/10/15/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/KNN-with-C/</url>
      
        <content type="html"><![CDATA[<p>KNN 算法步骤：</p><ul><li>存储训练集的特征和标签，确定K</li><li>预测一个未知的样本的时候，计算该样本到每一个训练集中的样本的距离，取前K个距离的最小值</li><li>在前K个最小值中选择标签出现次数最大的那个，作为预测结果</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KNN</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> feature_num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; trainSet;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; trainLabel;</span><br><span class="line">    <span class="comment">// 特征向量之间的距离，修改这里使用不同的距离度量</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">distance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;a, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="comment">//  返回两个点的距离</span></span><br><span class="line">        <span class="keyword">if</span>(a.size() != b.size()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.size();i++)&#123;</span><br><span class="line">            sum += (a[i] - b[i]) * (a[i] - b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> dis = <span class="built_in">sqrt</span>(sum);</span><br><span class="line">        <span class="keyword">return</span> dis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    KNN() : k(<span class="number">3</span>) &#123;&#125;</span><br><span class="line">    <span class="comment">// 创建类的时候保存训练集的特征和标签数据</span></span><br><span class="line">    KNN(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; features,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; labels)&#123;</span><br><span class="line">        <span class="keyword">int</span> samples = features.size();</span><br><span class="line">        <span class="keyword">if</span>(samples != labels.size())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;trainSet = features;</span><br><span class="line">        <span class="keyword">this</span>-&gt;trainLabel = labels;</span><br><span class="line">        <span class="keyword">if</span>(!features.empty()) feature_num = features[<span class="number">0</span>].size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预测一个测试样例的标签</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">predict</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; test)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(test.size() != <span class="keyword">this</span>-&gt;feature_num) <span class="keyword">throw</span> <span class="keyword">new</span> exception();</span><br><span class="line">        <span class="comment">// 求test到训练集合中所有点的距离，找出距离最小的K个值</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">double</span>,<span class="keyword">int</span>&gt;,<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">double</span>,<span class="keyword">int</span>&gt;&gt;,lessThan&gt; maxHeap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;trainSet.size();i++)&#123;</span><br><span class="line">            <span class="keyword">double</span> dis = <span class="keyword">this</span>-&gt;distance(trainSet[i],test);</span><br><span class="line">            <span class="keyword">if</span>(maxHeap.size() &lt; <span class="keyword">this</span>-&gt;k)&#123;</span><br><span class="line">                maxHeap.push(make_pair(dis,trainLabel[i]));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(dis &lt; maxHeap.top().first)&#123;</span><br><span class="line">                    maxHeap.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 统计K个点的类别标签，找到出现次数最多的那个标签</span></span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cc; <span class="comment">// 统计每个类别从出现的次数 kye</span></span><br><span class="line">        <span class="keyword">while</span>(!maxHeap.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(cc.count(maxHeap.top().second) == <span class="number">0</span>)&#123;</span><br><span class="line">                cc[maxHeap.top().second] = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cc[maxHeap.top().second]++;</span><br><span class="line">            &#125;</span><br><span class="line">            maxHeap.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxV = INT32_MIN;</span><br><span class="line">        <span class="keyword">int</span> label = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter= cc.begin();iter != cc.end(); iter++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(iter-&gt;second &gt; maxV)&#123;</span><br><span class="line">                maxV = iter-&gt;second;</span><br><span class="line">                label = iter-&gt;first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> label;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 预测一个测试样例的标签</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">predict</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; test, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;predict(test);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Kmeans 算法步骤</p><ul><li>在数据集中随机选择K个点</li><li>计算所有的点到K个中心点的距离，距离哪个中心点近，就标记成哪个中心点所属的列别</li><li>计算每个团的新的中心，</li><li>计算新的中心和上次的中心的差距</li><li>如果差距大，就继续循环，否则退出</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> MINVALUE = <span class="number">0.01</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">feature</span>&#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; v;</span><br><span class="line">    <span class="keyword">int</span> label; <span class="comment">// 属于哪一个聚类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kmeans</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 从[start,end] 产生 count 个随机数</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; random(<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> count)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">distance</span><span class="params">(feature &amp;a, feature &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> cycle = <span class="number">1000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cluster</span><span class="params">(<span class="built_in">vector</span>&lt;feature&gt; dataset)</span></span>&#123;</span><br><span class="line">         <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; random3 = random(<span class="number">0</span>,dataset.size()<span class="number">-1</span>,<span class="number">3</span>);</span><br><span class="line">         <span class="built_in">vector</span>&lt;feature&gt; centers;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;random3.size();i++)&#123;</span><br><span class="line">             dataset[i].label = i;</span><br><span class="line">             centers.push_back(dataset[i]);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">while</span>(cycle--) &#123;</span><br><span class="line">             <span class="comment">// 标记所有点的所属聚簇</span></span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dataset.size(); i++) &#123;</span><br><span class="line">                 <span class="keyword">double</span> minDistance = INT32_MAX;</span><br><span class="line">                 <span class="keyword">int</span> label = <span class="number">-1</span>;</span><br><span class="line">                 <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; random3.size(); j++) &#123;</span><br><span class="line">                     <span class="keyword">double</span> dis = distance(dataset[i], dataset[random3[j]]);</span><br><span class="line">                     <span class="keyword">if</span> (dis &lt; minDistance) &#123;</span><br><span class="line">                         minDistance = dis;</span><br><span class="line">                         label = j;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 dataset[i].label = label;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 更新每个聚簇的中心</span></span><br><span class="line">             <span class="built_in">vector</span>&lt;feature&gt; newCenters(centers);</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dataset[<span class="number">0</span>].v.size(); j++) &#123;</span><br><span class="line">                 <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; sum(k, <span class="number">0.0</span>);</span><br><span class="line">                 <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cc(k, <span class="number">0</span>);</span><br><span class="line">                 <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dataset.size(); i++) &#123;</span><br><span class="line">                     <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; k; p++) &#123;</span><br><span class="line">                         <span class="keyword">if</span> (dataset[i].label == p) &#123;</span><br><span class="line">                             sum[p] += dataset[i].v[j];</span><br><span class="line">                             cc[p]++;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">                     sum[i] = sum[i] / cc[i];</span><br><span class="line">                     newCenters[i].v.push_back(sum[i]);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 计算和上次中心的差距，差距在一定范围内就退出,centers, newcenters 之间的差距</span></span><br><span class="line">             <span class="keyword">double</span> dis = <span class="number">0.0</span>;</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">                 dis += distance(newCenters[i], centers[i]);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (dis &lt; MINVALUE) &#123;</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cluster</span><span class="params">(<span class="built_in">vector</span>&lt;feature&gt; dataset,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cluster(dataset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据基础框架</title>
      <link href="/hexoblog/2017/10/06/%E6%8A%80%E6%9C%AF/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6/"/>
      <url>/hexoblog/2017/10/06/%E6%8A%80%E6%9C%AF/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>大数据系统最初由google公布的一篇论文引起，后来发展出hadoop和一系列工具，后来又有spark，本文介绍在大数据处理领域一些常用工具的基本原理。</p><a id="more"></a><h2 id="hdfs">HDFS</h2><p><code>hadoop distributed file system (HDFS)</code> 是脱胎于<code>google file system</code>的一个分布式文件系统,据说，其性能并没有达到GFS的水平，只是根据谷歌论文的原理的一个开源实现版本。 HDFS的特定有以下几点：</p><ol style="list-style-type: decimal"><li>同时保存多个副本(默认三个)，提供容错机制，副本丢失能够自动恢复。</li><li>运行在不可靠机器上(廉价机器上)</li><li>适合大数据的处理，HDFS默认将文件分成64M大小的block, 将block按照键值对的方式存储在HDFS上。将映射关系保存在内存中。</li></ol><h3 id="hdfs的构成">HDFS的构成</h3><p><code>HDFS</code>是主从结构(<code>master/slave</code>结构)，主要由<code>NameNode</code>和<code>DataNode</code>组成。<code>NameNode</code> 是Master节点，负责整个系统的结构信息和调度控制，<code>DataNode</code>是slave节点，负责存储数据。除此之外，一般还有一个<code>SecondaryNameNode</code>节点，是<code>NameNode</code>节点的备份，负责承担一部分<code>NameNode</code>的工作，定时备份<code>NameNode</code>的数据，当<code>NameNode</code>出现故障的时候，可以从<code>SecondaryNameNode</code>恢复数据。</p><ul><li>NameNode</li><li>DataNode</li></ul><h3 id="写文件操作">写文件操作</h3><div class="figure"><img src="26162921-2de9d28df9b54fe6a97a6fd88f1cb03f.jpg" alt="HDFS写文件示意图"><p class="caption">HDFS写文件示意图</p></div><p>如上图，该图表示一个win7系统的电脑要把一个100M的文件写入一个HDFS文件系统。该HDFS文件系统运行在一个Hadoop集群之上，集群拥有一个NameNode(NN)节点，8个DataNode(DN)节点，有三个机架(rack1,rack2,rack3), 全部在一个机房内。</p><ol style="list-style-type: decimal"><li><p>client把文件分割程64M大小(HDFS文件系统的默认大小)，生成两个文件块，一个64M， 一个36M。</p></li><li><p>client向NameNode发送写文件的请求。</p></li><li><p>NameNode收到请求之后，查询自己数据中记录的整个HDFS文件系统的信息，确定这些数据写入哪些DataNode节点中，并且记录下该信息，返回该信息给请求的主机。</p></li></ol><blockquote><p>假设分配的情况如下：</p></blockquote><blockquote><ul><li>block1: host2,host1,host3</li><li>block2: host7,host8,host4</li></ul></blockquote><blockquote><p>分配DataNode节点的规则为： 如果client为DataNode节点，那么副本1存储在与client相同的节点上，副本2存储在不同机架的节点上，副本三存储在同副本2相同机架上的不同节点； 如果client不是DataNode节点，则副本1随机选择一个节点，副本2选择不同的机架，副本3同副本2的机架的不同节点。</p></blockquote><ol start="4" style="list-style-type: decimal"><li><p>client根据收到的写入信息,把block1写入第一个主机host2, 整个写入过程是流式写入的，数据被分割策划那个64K的小数据包写入，每次写完64K，host2将自己刚刚得到的64K数据写入host1, host1得到64K之后写入host3, 实际上客户端只需要向host2写入一次数据，数据就可以有三个备份。当第一个block写完之后，host2,host1,host3向NameNode, host2向client发送信息说明数据已经写完。</p></li><li><p>client收到信息之后发送第二个block，过程和第一个block一样。</p></li><li><p>第二个block写完之后，数据彻底写完，写文件的过程就结束了。</p></li></ol><p>通过写文件的过程和不同副本的分配策略可以看出，挂掉一个节点设置整个机架都是没有关系的，总能从其他的地方找回这些丢失的数据。</p><h3 id="读文件操作">读文件操作</h3><div class="figure"><img src="26163017-fc613879835c402886b75e0593ca52ed.jpg" alt="HDFS读取文件示意图"><p class="caption">HDFS读取文件示意图</p></div><p>如图，win7客户端要从HDFS文件系统上读取一个100M大小的的文件，该文件在HDFS中有两个数据块组成:block1,block2.</p><ol style="list-style-type: decimal"><li><p>client 向NameNode 发送读取文件的请求。</p></li><li><p>NameNode收到读取文件的请求，查询自己存储的元信息，返回block1和block2的存储位置： <code>block1: host2,host1,host3; block2: host7,host8,host4</code>;</p></li><li><p>客户端收到NameNode的消息，去机器host2读取block1,去机器host7读取block2,读取完成之后合并成一个完整的文件，整个读文件的过程就结束了。如果client位于DataNode内，则优先读取本机架上的数据。</p></li></ol><p>参考文献：<a href="http://www.cnblogs.com/laov/p/3434917.html" target="_blank" rel="noopener">HDFS读写原理</a></p><h2 id="mapreduce">MapReduce</h2><p>MapReduce 是一个计算框架，就是在特定的输入上产生特定的输出。输入和输出都是<code>&lt;key,val&gt;</code>这种键值对的形式。 Mapper就是对每个个体进行操作，不涉及个体之间的相互作用，例如转换格式，分割字符串等，这样Mapper这个阶段做的工作可以在许多机器上并行的执行， Reducer执行一些需要不同条目之间协同才能完成的操作，例如计数，求和，需要遍历所有的条目才能得到结果。Reducer任务会在不同的机器上传递结果，得到最终的结果之后再返回。</p><div class="figure"><img src="x.png" alt="MapReduce运行机制"><p class="caption">MapReduce运行机制</p></div><ol style="list-style-type: decimal"><li><p>在执行Map计算之前，先要根据文件的大小和HDFS的配置情况进行分片(input split), 假设HDFS默认的block大小是64M，而本次任务的输入有3个文件，一个10M，一个70M，一个128M，则10M的文件会被分成一片，70M的文件会被分成两片，128M的文件也会被分成两片。 分片操作仅仅计算出一个分片的长度和每个分片对应的数据的索引位置，并不改变原来的数据。</p></li><li><p>执行程序中定义好的Map操作，Map在各个数据节点上独立的执行，相互之间没有影响。</p></li><li><p>combiner阶段：目的是在本地机器上执行reduce操作，把可以在本地机器上合并的结果先执行了，避免以后需要大量传输数据(机器之间传输数据 的开销往往是分布式系统最大的瓶颈). 例如求最大值，最小值和求和等操作，可以Map之后可以现在各个数据节点求出整个数据节点的最大值，作为一个结果输出，之后的reduce操作会大大减少结果的传输负担。</p></li><li><p>shuffle阶段： 将Mapper阶段的输出作为Reducer阶段的输入数据。</p></li><li><p>Reduce阶段： 执行用户编写的reduce函数，得出结果之后存储在HDFS文件系统之上。</p></li></ol><div class="figure"><img src="1.png" alt="Map-Shuffle-Reduce过程解析"><p class="caption">Map-Shuffle-Reduce过程解析</p></div><p>参考文献:<a href="http://www.cnblogs.com/sharpxiajun/p/3151395.html" target="_blank" rel="noopener">cnblogs</a></p><h2 id="spark">Spark</h2><h3 id="弹性分布式数据集rdd">弹性分布式数据集(RDD)</h3><p>Spark 底层存储数据的时候使用的是Hadoop的HDFS分布是文件系统，所以可以存储任何兼容Hadoop的数据源，例如Hbase. Spark 在逻辑上把数据存储在一个一个的RDD中，一个RDD可以看作一张表格，可以保存任何类型的数据。RDD是不可改变的，任何改变RDD的操作都会返回一个全新的RDD，spark的所有操作，在逻辑上都是针对RDD的操作。 RDD支持两种操作：transformation 和 action . transformation 是对RDD执行一个变换操作，不会立即计算，只是记录了应该在该RDD上执行这样的操作。 action 一般会是一个reduce操作， 会立刻执行，就是之前定义的所有transformation操作和当前定义的action操作。</p><ul><li><p><strong>transformation</strong>: 对RDD执行一个变换，返回一个新的RDD。可用的操作有map,filter,flatMap, groupByKey, reduceByKey 等。</p></li><li><p><strong>action</strong>: 在该RDD对象上执行之前定义的所有操作(包括所有的transformation操作)， 返回计算的结果。 可用的操作有reduce, collect, count, first, countByKey 等。</p></li></ul><h3 id="wordcount-程序">WordCount 程序</h3><p>使用spark运行一个统计单词个数的程序十分简单，这个过程可以帮助我们了解spark是如何工作的。</p><p>读取文本文件并生成RDD，将RDD缓存在内存中，缓存的RDD不需要从头开始计算，如果RDD没有缓存，就算过后的RDD会被立刻丢弃，每次想要得到结果都需要从头开始计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SimpleApp.scala */</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.SparkContext</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.SparkContext._</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.SparkConf</span><br><span class="line"></span><br><span class="line">object SimpleApp &#123;</span><br><span class="line">  <span class="function">def <span class="title">main</span><span class="params">(args: Array[String])</span> </span>&#123;</span><br><span class="line">    val logFile = <span class="string">"YOUR_SPARK_HOME/README.md"</span> <span class="comment">// 应该是你系统上的某些文件</span></span><br><span class="line">    val conf = <span class="keyword">new</span> SparkConf().setAppName(<span class="string">"Simple Application"</span>)</span><br><span class="line">    val sc = <span class="keyword">new</span> SparkContext(conf)</span><br><span class="line">    val logData = sc.textFile(logFile, <span class="number">2</span>).cache()</span><br><span class="line">    val numAs = logData.filter(line =&gt; line.contains(<span class="string">"a"</span>)).count()</span><br><span class="line">    val numBs = logData.filter(line =&gt; line.contains(<span class="string">"b"</span>)).count()</span><br><span class="line">    println(<span class="string">"Lines with a: %s, Lines with b: %s"</span>.format(numAs, numBs))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序仅仅是在 Spark README 中计算行里面包含 ‘a’ 和包含 ‘b’ 的次数.</p><h3 id="spark-框架的主要内容">Spark 框架的主要内容</h3><div class="figure"><img src="spark-stack-new.png" alt="Spark生态系统"><p class="caption">Spark生态系统</p></div><ul><li><p><code>spark streaming</code> : 基于微批量方式的计算和处理，可以用于处理实时的流数据。它使用DStream，简单来说就是一个弹性分布式数据集（RDD）系列，处理实时数据。</p></li><li><p><code>spark SQL</code> : 可以通过JDBC API将Spark数据集暴露出去，而且还可以用传统的BI和可视化工具在Spark数据上执行类似SQL的查询。用户还可以用Spark SQL对不同格式的数据（如JSON，Parquet以及数据库等）执行ETL，将其转化，然后暴露给特定的查询。</p></li><li><p><code>spark mlib</code> : 是一个可扩展的Spark机器学习库，由通用的学习算法和工具组成，包括二元分类、线性回归、聚类、协同过滤、梯度下降以及底层优化原语。</p></li><li><p><code>spark graphx</code> : 是用于图计算和并行图计算的新的（alpha）Spark API。通过引入弹性分布式属性图（Resilient Distributed Property Graph），一种顶点和边都带有属性的有向多重图，扩展了Spark RDD。为了支持图计算，GraphX暴露了一个基础操作符集合（如subgraph，joinVertices和aggregateMessages）和一个经过优化的Pregel API变体。此外，GraphX还包括一个持续增长的用于简化图分析任务的图算法和构建器集合。</p></li><li><p><code>blinkDB</code> : 一个近似查询引擎，用于在海量数据上执行交互式SQL查询。BlinkDB可以通过牺牲数据精度来提升查询响应时间。通过在数据样本上执行查询并展示包含有意义的错误线注解的结果，操作大数据集合。</p></li><li><p><code>sparkR</code> : R语言的spark接口</p></li></ul><h2 id="hbase">HBASE</h2><p>HBase, Hadoop Database, 是Google Bigtable的开源实现，是一个面向列的，可伸缩的分布式存储系统，它的底层文件存储使用的是HDFS。</p><p><strong><code>HBase</code>的存储逻辑</strong></p><p>表由行和列组成，列被分组，若干个列组成一个列簇（row family）,表在定义的时候，就必须声明所有的列簇，但是列簇内包含几个列可以动态增加(这也体现了面向列的存储这一方面). 同一个列簇使用相同的前缀为其命名，例如<code>temperature:air</code> 和 <code>temperature:dew</code> 都是<code>temperature</code>列簇的成员, <code>HBase</code>的每个列簇称作一个<code>store</code>，同一个列簇的数据会存储在同一个目录下，可能会分割成多个文件存储。</p><p>每个行由一个键表示，行键是一个字节数组，行按照行键进行排序。</p><p>行列交叉的位置称作<code>Cell</code>，每个cell都有版本，以时间戳标识，这个标识可以自己定义。也就是说，Hbase中的每个数据都是有版本的，数据按照时间倒序排列，最新的数据排列在最前面。cell中的内容是字节数组，不带格式,HBase存储的数据都是无格式的。唯一的确定一个cell需要下面这些数据：row key(行键), column:label(列簇的前缀的列的名称)， version(版本号)， 行键用来确定是哪一行，column:label确定是哪一列，版本号确定是哪个版本的数据，这样可以唯一的确定一个单元格里的数据。</p><p>HBase自动把表格水平划分程若干region, 每个region都是连续的若干行数据(类似数据库的水平分割).</p><p><strong>HBase的物理存储结构</strong></p><p>一个Table最初只有一个Region,随这行的数量的增加，当超过一个既定的阈值的时候，Region就会等分为2个。 相同的Region保证存储在相同的机器上，不同的Region可以存储在不同的机器上，叫做region server。</p><p>每个Region存储的若干行和这些行的所有列。每个Region的内部存储是这样的：Region 由一个或者多个store组成，每个store存储一个列簇， 每个store包括一个memStore和0个或者多个storefile,storefile是存储的最小单位，以HFile的格式保存在HDFS文件系统上。</p><div class="figure"><img src="QQ截图20171007212611.png" alt="HBase架构示意图"><p class="caption">HBase架构示意图</p></div><p><strong>HBase的运行</strong></p><p>HBase 由一个主节点master和若干个RegionServer组成，主节点的负载较轻，主要负责引导初始安装，分配区域给已经注册的区域服务器，恢复区域服务器的故障等。 区域服务器负责自己存储的若干个区域的读写工作。</p><h2 id="hive">Hive</h2><p>hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供完整的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析</p><p>Hive是建立在 Hadoop 上的数据仓库基础构架。它提供了一系列的工具，可以用来进行数据提取转化加载（ETL），这是一种可以存储、查询和分析存储在 Hadoop 中的大规模数据的机制。Hive 定义了简单的类 SQL 查询语言，称为 HQL，它允许熟悉 SQL 的用户查询数据。同时，这个语言也允许熟悉 MapReduce 开发者的开发自定义的 mapper 和 reducer 来处理内建的 mapper 和 reducer 无法完成的复杂的分析工作</p><p>简单来讲，Hive提供了一种高级的类似SQL的语言，来执行一些以前必须要自己写Map,Reduce程序才能实现的功能，大大简化了数据处理的难度(MapReduce程序很难写)， 但是，Hive的实时性很差，适合离线处理，数据分析和数据挖掘等对实时性要求不高的任务。</p><h2 id="pig">Pig</h2><p>提供类似SQL的语言叫做<code>Pig Latin</code>, 可以把类SQL的语言转化程优化处理过的MapReduce运算。</p><p>Pig是一种大规模数据集的脚本语言，它实际上提供了一整套脚本语言的特性，用来处理海量的数据。</p><h2 id="zookeeper">Zookeeper</h2><p>Zookeeper的目的是提供一些工具集，用来建立安全处理局部故障的分布式应用。 使用Zookeeper, 我们可以更容易的自己实现一个分布式的应用。</p><p>参考文献:<a href="http://www.cnblogs.com/wuxl360/p/5817471.html" target="_blank" rel="noopener">1</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HDFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法专题_常见题目</title>
      <link href="/hexoblog/2017/10/03/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98-%E5%B8%B8%E8%A7%81%E9%A2%98%E7%9B%AE/"/>
      <url>/hexoblog/2017/10/03/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98-%E5%B8%B8%E8%A7%81%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>【栈】【队列】【链表】【二叉树】【堆】【快速排序】【归并排序】【数组】【指针】</p><a id="more"></a><h2 id="栈">栈</h2><h3 id="栈的压入弹出序列"><a href="https://www.nowcoder.com/questionTerminal/d77d11405cc7470d82554cb392585106" target="_blank" rel="noopener">栈的压入弹出序列</a></h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsPopOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pushV,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popV)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列"><a href="http://lintcode.com/zh-cn/problem/132-pattern/#" target="_blank" rel="noopener">132序列</a></h3><p>Given a sequence of n integers a1, a2, …, an, a 132 pattern is a subsequence ai, aj, ak such that i &lt; j &lt; k and ai &lt; ak &lt; aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.</p><p>n will be less than 20,000.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> third = INT32_MIN; <span class="comment">// 中间大的数</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">// 如果找到小于第二大的数字，则小于第二大的数字，第二大的数字和最大的数字三个数字都找到，返回true;</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; third) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 如果当前数字大于栈顶元素，则找到了第二大的数字(栈顶元素)，最大的数字变成了当前数字</span></span><br><span class="line">            <span class="keyword">while</span> (!s.empty() &amp;&amp; nums[i] &gt; s.top()) &#123;</span><br><span class="line">                third = s.top(); s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        s.push(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表">链表</h2><h3 id="翻转链表"><a href="http://lintcode.com/zh-cn/problem/reverse-linked-list/" target="_blank" rel="noopener">翻转链表</a></h3><p>翻转一个链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode * <span class="title">reverse</span><span class="params">(ListNode * head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并k个链表"><a href="http://lintcode.com/zh-cn/problem/merge-k-sorted-lists/" target="_blank" rel="noopener">合并K个链表</a></h3><p>合并k个排序链表，并且返回合并后的排序链表。尝试分析和描述其复杂度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode *&gt; &amp;lists)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// write your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂链表的复制"><a href="http://lintcode.com/zh-cn/problem/copy-list-with-random-pointer/" target="_blank" rel="noopener">复杂链表的复制</a></h3><p>给出一个链表，每个节点包含一个额外增加的随机指针可以指向链表中的任何节点或空的节点。</p><p>返回一个深拷贝的链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表求和"><a href="http://lintcode.com/zh-cn/problem/add-two-numbers-ii/#" target="_blank" rel="noopener">链表求和</a></h3><p>假定用一个链表表示两个数，其中每个节点仅包含一个数字。假设这两个数的数字顺序排列，请设计一种方法将两个数相加，并将其结果表现为链表的形式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode * <span class="title">addLists2</span><span class="params">(ListNode * l1, ListNode * l2)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// write your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表的中间节点">链表的中间节点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 找到链表的中间节点并返回</span></span><br><span class="line"><span class="comment"> * @param head</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ListNode* <span class="title">findMiddle</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *first = head, *second = head;</span><br><span class="line">    <span class="keyword">while</span>(second-&gt;next &amp;&amp; second-&gt;next-&gt;next)&#123;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        second = second-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树">二叉树</h2><h3 id="前序遍历的非递归实现"><a href="http://lintcode.com/zh-cn/problem/binary-tree-preorder-traversal/" target="_blank" rel="noopener">前序遍历的非递归实现</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode * root) &#123;</span><br><span class="line">      <span class="comment">// write your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历的非递归实现"><a href="http://lintcode.com/zh-cn/problem/binary-tree-inorder-traversal/" target="_blank" rel="noopener">中序遍历的非递归实现</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode * root) &#123;</span><br><span class="line">       <span class="comment">// write your code here</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历的非递归实现"><a href="http://lintcode.com/zh-cn/problem/binary-tree-postorder-traversal/" target="_blank" rel="noopener">后序遍历的非递归实现</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode * root) &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的最大深度"><a href="http://lintcode.com/zh-cn/problem/maximum-depth-of-binary-tree/#" target="_blank" rel="noopener">二叉树的最大深度</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的最小深度"><a href="http://lintcode.com/zh-cn/problem/minimum-depth-of-binary-tree/#" target="_blank" rel="noopener">二叉树的最小深度</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode * root)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// write your code here</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="叶子之间的最长距离">叶子之间的最长距离</h3><h3 id="堆排序">堆排序</h3><h3 id="top-k">TOP K</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="数据流的中位数"><a href="http://lintcode.com/zh-cn/problem/data-stream-median/" target="_blank" rel="noopener">数据流的中位数</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; medianII(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums) &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序">快速排序</h2><h3 id="第k大的数"><a href="http://lintcode.com/zh-cn/problem/kth-largest-element/" target="_blank" rel="noopener">第K大的数</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthLargestElement</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中位数"><a href="http://lintcode.com/zh-cn/problem/median/#" target="_blank" rel="noopener">中位数</a></h3><p>给定一个未排序的整数数组，找到其中位数。</p><p>中位数是排序后数组的中间值，如果数组的个数是偶数个，则返回排序后数组的第N/2个数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">median</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序">归并排序</h2><h3 id="数组的逆序对的个数"><a href="http://lintcode.com/zh-cn/problem/reverse-pairs/" target="_blank" rel="noopener">数组的逆序对的个数</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="字符串">字符串</h2><h3 id="kmp算法"><a href="http://lintcode.com/zh-cn/problem/strstr/" target="_blank" rel="noopener">KMP算法</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *source, <span class="keyword">const</span> <span class="keyword">char</span> *target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="字典树">字典树</h3><p>给定整数m以及n个数字A1, A2, …, An，将数列A中所有元素两两异或，共能得到n(n-1)/2个结果。请求出这些结果中大于m的有多少个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="哈夫曼编码">哈夫曼编码</h3><h2 id="一维数组">一维数组</h2><h3 id="出现一半以上的数">出现一半以上的数</h3><p>一个数组中有一个数字的出现次数超过一半(超过50%),求出这个数字。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMajority</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="数组跳跃能否达到终点">数组跳跃能否达到终点</h3><p>一个整形数组，每个元素代表可以在当前位置的基础上向后跳跃几步，问要跳跃到最后最少需要跳跃几步，如果不能到达最后返回-1;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大数据">大数据</h2><h3 id="布隆过滤器">布隆过滤器</h3>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写代码-其他</title>
      <link href="/hexoblog/2017/09/27/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81-%E5%85%B6%E4%BB%96/"/>
      <url>/hexoblog/2017/09/27/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81-%E5%85%B6%E4%BB%96/</url>
      
        <content type="html"><![CDATA[<p>【快速排序】【第K大的数】【归并排序】【逆序对】【二分查找】【冒泡排序】【单例模式】</p><a id="more"></a><h3 id="二分查找">二分查找</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不考虑重复元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = v.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">       <span class="keyword">if</span>(v[mid] == val) <span class="keyword">return</span> mid;</span><br><span class="line">       <span class="keyword">if</span>(v[mid] &gt; val)&#123;</span><br><span class="line">           j = mid - <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(v[mid] &lt; val)&#123;</span><br><span class="line">         i = mid + <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有重复的val,返回val的起始位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binaryResearch</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = v.size() <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mind;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j))&#123;</span><br><span class="line">      <span class="keyword">if</span>(v[mid] == val)&#123;</span><br><span class="line">        <span class="keyword">while</span>(v[mid] == val &amp;&amp; mid &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">          mid--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p+<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(v[mid] &gt; val)&#123;</span><br><span class="line">        j = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(v[mid] &lt; val)&#123;</span><br><span class="line">        i = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序">冒泡排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = v.size()<span class="number">-1</span>;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;j;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i] &gt; v[i+<span class="number">1</span>]) swap(v[i],v[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单例模式">单例模式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">static</span> Single* instance = null; <span class="comment">// 静态私有变量，属于类</span></span><br><span class="line">      Singleton()&#123;&#125;</span><br><span class="line">      Singleton(<span class="keyword">const</span> Singleton&amp;)&#123;&#125;</span><br><span class="line">      Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;)&#123;&#125; <span class="comment">// 防止赋值的时候拷贝</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">static</span> Singleton* getInstance() <span class="comment">// 静态方法，确保使用类可以调用</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (instance == <span class="literal">NULL</span>)&#123;</span><br><span class="line">             lock(); <span class="comment">// 线程安全的写法，如果不用确保线程安全，不需要</span></span><br><span class="line">             <span class="keyword">if</span>(instance == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                 instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">             &#125;</span><br><span class="line">             unlock();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> instance;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>// 使用方法 <code>auto instance = Singleton::getInstance();</code></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法专题_二叉树2</title>
      <link href="/hexoblog/2017/09/23/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E4%BA%8C%E5%8F%89%E6%A0%912/"/>
      <url>/hexoblog/2017/09/23/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E4%BA%8C%E5%8F%89%E6%A0%912/</url>
      
        <content type="html"><![CDATA[<p>【前序遍历】【中序遍历】【后序遍历】【路径搜索】【公共祖先】【堆】【top K】【线段树】【树状数组】【并查集】</p><a id="more"></a><h3 id="前序遍历"><a href="http://lintcode.com/zh-cn/problem/binary-tree-preorder-traversal/" target="_blank" rel="noopener">前序遍历</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left, *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val = val;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left = <span class="keyword">this</span>-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 递归前序遍历</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode * root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> re;</span><br><span class="line"></span><br><span class="line">    re.push_back(root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp = preorderTraversal(root-&gt;left);</span><br><span class="line">        re.insert(re.end(),tmp.begin(),tmp.end());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp = preorderTraversal(root-&gt;right);</span><br><span class="line">        re.insert(re.end(),tmp.begin(),tmp.end());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归前序遍历</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorder(TreeNode* root)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> re;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode* iter = root;</span><br><span class="line">    <span class="keyword">while</span>(iter || !s.empty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(iter)&#123;</span><br><span class="line">            <span class="comment">// 首先输出根</span></span><br><span class="line">            re.push_back(iter-&gt;val);</span><br><span class="line">            s.push(iter);</span><br><span class="line">            iter = iter-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        iter = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        iter = iter-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="http://lintcode.com/zh-cn/problem/binary-tree-inorder-traversal/" target="_blank" rel="noopener">中序遍历</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归中序遍历</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode *root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> re;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp = inorderTraversal(root-&gt;left);</span><br><span class="line">        re.insert(re.end(),tmp.begin(),tmp.end());</span><br><span class="line">    &#125;</span><br><span class="line">    re.push_back(root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp = inorderTraversal(root-&gt;right);</span><br><span class="line">        re.insert(re.end(),tmp.begin(),tmp.end());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归中序遍历</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder(TreeNode* root)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> re;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode* iter = root;</span><br><span class="line">    <span class="keyword">while</span>(iter || !s.empty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(iter)&#123;</span><br><span class="line">            s.push(iter);</span><br><span class="line">            iter = iter-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        iter = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        re.push_back(iter-&gt;val);</span><br><span class="line">        iter = iter-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="http://lintcode.com/zh-cn/problem/binary-tree-postorder-traversal/" target="_blank" rel="noopener">后序遍历</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归后序遍历</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode *root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> re;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp = postorderTraversal(root-&gt;left);</span><br><span class="line">        re.insert(re.end(),tmp.begin(),tmp.end());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp = postorderTraversal(root-&gt;right);</span><br><span class="line">        re.insert(re.end(),tmp.begin(),tmp.end());</span><br><span class="line">    &#125;</span><br><span class="line">    re.push_back(root-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后序遍历的非递归实现</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postOrder(TreeNode *root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> re;</span><br><span class="line"></span><br><span class="line">    TreeNode *iter = root;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode *&gt; s;</span><br><span class="line">    TreeNode *last = root;</span><br><span class="line">    s.push(iter);</span><br><span class="line">    <span class="keyword">while</span> (!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        iter = s.top();</span><br><span class="line">        <span class="comment">// 1. 当前节点是叶节点(没有左右孩子)，输出</span></span><br><span class="line">        <span class="comment">// 2. 上次访问了当前节点的左孩子，而且当前节点没有右孩子，输出</span></span><br><span class="line">        <span class="comment">// 3. 上次访问了当前节点的右孩子，输出</span></span><br><span class="line">        <span class="keyword">if</span>( (iter-&gt;left == <span class="literal">nullptr</span> &amp;&amp; iter-&gt;right == <span class="literal">nullptr</span>) ||</span><br><span class="line">                (iter-&gt;right == <span class="literal">nullptr</span> &amp;&amp; last == iter-&gt;left) ||</span><br><span class="line">                    (last == iter-&gt;right) )</span><br><span class="line">        &#123;</span><br><span class="line">            re.push_back(iter-&gt;val);</span><br><span class="line">            last = iter;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 栈是后进先出的，要先处理左孩子，所以要先放入右耗资</span></span><br><span class="line">            <span class="keyword">if</span>(iter-&gt;right)</span><br><span class="line">                s.push(iter-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(iter-&gt;left)</span><br><span class="line">                s.push(iter-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的路径搜索">二叉树的路径搜索</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 搜索根节点到叶子节点的所有路径 [http://lintcode.com/zh-cn/problem/binary-tree-paths/#]</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vv;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binaryTreePaths</span><span class="params">(TreeNode *root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;tmp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;</span><br><span class="line">        tmp.push_back(root-&gt;val);</span><br><span class="line">        vv.push_back(tmp);</span><br><span class="line">        tmp.clear();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        tmp.push_back(root-&gt;val);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp1(tmp);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp2(tmp);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) binaryTreePaths(root-&gt;left,tmp1);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) binaryTreePaths(root-&gt;right,tmp2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树最大深度"><a href="http://lintcode.com/zh-cn/problem/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">二叉树最大深度</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用方式： maxDepth2(root,0)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth2</span><span class="params">(TreeNode *root, <span class="keyword">const</span> <span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> dep;</span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> dep+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> maxDepth2(root-&gt;left,dep+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right &amp;&amp; !root-&gt;left) <span class="keyword">return</span> maxDepth2(root-&gt;right,dep+<span class="number">1</span>);     </span><br><span class="line">    <span class="keyword">return</span> max(maxDepth2(root-&gt;left,dep+<span class="number">1</span>),maxDepth2(root-&gt;right,dep+<span class="number">1</span>));   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树最小深度"><a href="http://lintcode.com/zh-cn/problem/minimum-depth-of-binary-tree/#" target="_blank" rel="noopener">二叉树最小深度</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最小深度 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDepth2</span><span class="params">(TreeNode* root,<span class="keyword">const</span> <span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> dep;</span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> dep+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left &amp;&amp; !root-&gt;right)  <span class="keyword">return</span> minDepth2(root-&gt;left,dep+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; root-&gt;right)  <span class="keyword">return</span> minDepth2(root-&gt;right,dep+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> min(minDepth2(root-&gt;left,dep+<span class="number">1</span>),minDepth2(root-&gt;right,dep+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="叶子节点到叶子节点路径的搜索">叶子节点到叶子节点路径的搜索</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;TreeNode*,<span class="built_in">vector</span>&lt;TreeNode*&gt;&gt; nodes; <span class="comment">// 存储树的结构</span></span><br><span class="line"><span class="built_in">map</span>&lt;TreeNode*,<span class="keyword">bool</span>&gt; visited;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vv;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* leaf,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span>&#123;</span><br><span class="line">    visited[leaf] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; tmp = nodes[leaf];</span><br><span class="line">    <span class="keyword">bool</span> is = <span class="literal">true</span>;</span><br><span class="line">    v.push_back(leaf-&gt;val);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tmp.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[tmp[i]] == <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1(v);</span><br><span class="line">            dfs(tmp[i],v1);</span><br><span class="line">            is = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(is)&#123; <span class="comment">// 叶节点</span></span><br><span class="line">        vv.push_back(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="top-k-问题">top K 问题</h3><p>如果是最大的K个数，那么首先使用前K个数建立一个最小堆，然后从第K+1个数开始和堆顶的元素比较，如果大于堆顶的元素，就把堆顶的元素弹出，把该元素push进堆。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; topk(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v, <span class="keyword">int</span> k)&#123;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; heap; <span class="comment">// 最小堆（堆顶元素最小）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        heap.push(v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;v.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i] &gt; heap.top())&#123;</span><br><span class="line">            heap.pop();</span><br><span class="line">            heap.push(v[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">    <span class="keyword">while</span>(!heap.empty())&#123;</span><br><span class="line">        re.push_back(heap.top());</span><br><span class="line">        heap.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据流的中位数"><a href="http://lintcode.com/zh-cn/problem/data-stream-median/" target="_blank" rel="noopener">数据流的中位数</a></h3><p>使用大顶堆(<code>priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt;</code>) 保存前半部分的数据，使用小顶堆(<code>priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;</code>) 保存后半部分的数据, 保证大顶堆的顶 小于等于 小顶堆的顶， 那么在每次需要求当前的数据的中位数的时候，只需要两个堆顶元素就可以求出来了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt;&gt; maxHeap;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; minHeap;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line">    <span class="keyword">bool</span> is_left;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MedianFinder() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;is_left = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 轮流加入左右两个堆</span></span><br><span class="line">        <span class="keyword">if</span>(is_left)&#123;</span><br><span class="line">            <span class="comment">// 如果right的堆为空，可以确保左边最大的小于等于右边最小的，直接加入</span></span><br><span class="line">            <span class="comment">// 如果要加入的元素小于等于right的堆顶，也可以保证上述条件</span></span><br><span class="line">            <span class="keyword">if</span>(minHeap.empty() || num &lt;= minHeap.top())&#123;</span><br><span class="line">                maxHeap.push(num);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果num &gt; minHeap.top(); 不能直接加入maxHeap,因为如果这样做，就不能保证maxHeap中的所有的数字都小于等于minHeap中的数字。</span></span><br><span class="line">            <span class="comment">// 这个时候的做法是， 先把num加入minHeap, 在把minHeap.top()弹出，加入maxHeap;</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                minHeap.push(num);</span><br><span class="line">                maxHeap.push(minHeap.top());</span><br><span class="line">                minHeap.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            is_left = !is_left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!is_left)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maxHeap.empty() || num &gt;= maxHeap.top())&#123;</span><br><span class="line">                minHeap.push(num);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                maxHeap.push(num);</span><br><span class="line">                minHeap.push(maxHeap.top());</span><br><span class="line">                maxHeap.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            is_left = !is_left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &gt;&gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (maxHeap.top() + minHeap.top()) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> maxHeap.top();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="合并k个排序链表"><a href="http://lintcode.com/zh-cn/problem/merge-k-sorted-lists" target="_blank" rel="noopener">合并K个排序链表</a></h3><p>这里使用小顶堆这种结构保存K个链表，每次取得堆顶的元素就可以得到K个链表中最小的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode *&gt; &amp;lists)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;ListNode*,<span class="built_in">vector</span>&lt;ListNode*&gt;,bigger&gt; minHeap;</span><br><span class="line">    <span class="keyword">if</span>(lists.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lists.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists[i]) minHeap.push(lists[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *head = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *iter = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(!minHeap.empty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            head = minHeap.top();</span><br><span class="line">            iter = head;</span><br><span class="line">            <span class="keyword">if</span>(minHeap.top()-&gt;next)&#123;</span><br><span class="line">                minHeap.push(minHeap.top()-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">            minHeap.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            iter-&gt;next = minHeap.top();</span><br><span class="line">            iter = iter-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(minHeap.top()-&gt;next)&#123;</span><br><span class="line">                minHeap.push(minHeap.top()-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">            minHeap.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序">堆排序</h3><p>使用堆这种结构维护数据的有序性，从而进行排序的算法是堆排序。堆排序的具体步骤是： 使用要排序的整个数组建立堆。然后把最后一个元素和堆顶元素交换，堆的大小减1，调整堆，然后再把新的堆的最后一个元素和堆顶元素交换，调整堆，直到全部数据有序为止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 建立最大堆</span></span><br><span class="line">    make_heap(v.begin(),v.end(),less&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="keyword">int</span> index = v.size();</span><br><span class="line">    <span class="keyword">while</span>(index &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 交换堆顶和堆尾的元素，重新调整堆</span></span><br><span class="line">        pop_heap(v.begin(),v.begin()+index,less&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        index--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的序列化和反序列化">二叉树的序列化和反序列化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    T val;</span><br><span class="line">    Node  *left,*right;</span><br><span class="line">    Node()&#123;&#125;</span><br><span class="line">    Node(T init) : val(init), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的先根遍历，非递归实现，使用栈</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preOrder(Node&lt;<span class="keyword">int</span>&gt;* root)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Node&lt;<span class="keyword">int</span>&gt;*&gt; s;</span><br><span class="line">    Node&lt;<span class="keyword">int</span>&gt;* iter = root;</span><br><span class="line">    <span class="keyword">while</span>(iter || !s.empty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(iter)&#123;</span><br><span class="line">            ans.push_back(iter-&gt;val);</span><br><span class="line">            s.push(iter);</span><br><span class="line">            iter = iter-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        iter = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        iter = iter-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的层次遍历，非递归，使用队列</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; levelOrder(Node&lt;<span class="keyword">int</span>&gt;* root)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node&lt;<span class="keyword">int</span>&gt;*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    Node&lt;<span class="keyword">int</span>&gt;* iter;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        iter = q.front();</span><br><span class="line">        <span class="keyword">if</span>(iter)&#123;</span><br><span class="line">            ans.push_back(iter-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(iter-&gt;left) q.push(iter-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(iter-&gt;right) q.push(iter-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用层次遍历的方法序列化二叉树</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; levelOrderSeries(Node&lt;<span class="keyword">int</span>&gt;* root)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node&lt;<span class="keyword">int</span>&gt;*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    Node&lt;<span class="keyword">int</span>&gt;* iter;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        iter = q.front();</span><br><span class="line">        <span class="keyword">if</span>(iter)&#123;</span><br><span class="line">            <span class="keyword">if</span>(iter-&gt;val != <span class="number">-1</span>)&#123;</span><br><span class="line">                ans.push_back(to_string(iter-&gt;val));</span><br><span class="line">                <span class="keyword">if</span>(iter-&gt;left)&#123;</span><br><span class="line">                    q.push(iter-&gt;left);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    q.push(<span class="keyword">new</span> Node&lt;<span class="keyword">int</span>&gt;(<span class="number">-1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(iter-&gt;right)&#123;</span><br><span class="line">                    q.push(iter-&gt;right);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    q.push(<span class="keyword">new</span> Node&lt;<span class="keyword">int</span>&gt;(<span class="number">-1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.push_back(<span class="string">"#"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*(--ans.end()) == <span class="string">"#"</span>) ans.erase(--ans.end());</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据二叉树的层次遍历的结果重建二叉树</span></span><br><span class="line"><span class="comment"> * @param c</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node&lt;<span class="keyword">int</span>&gt;* reConstructTree(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;c)&#123;</span><br><span class="line">    <span class="keyword">if</span>(c.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;Node&lt;<span class="keyword">int</span>&gt;*&gt; q;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(c[index] == <span class="string">"#"</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">auto</span> root = <span class="keyword">new</span> Node&lt;<span class="keyword">int</span>&gt;( stoi(c[index]) );  index++;</span><br><span class="line">    q.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        Node&lt;<span class="keyword">int</span>&gt;* parent = q.front(); q.pop();</span><br><span class="line">        Node&lt;<span class="keyword">int</span>&gt;* left = <span class="literal">nullptr</span>;</span><br><span class="line">        Node&lt;<span class="keyword">int</span>&gt;* right = <span class="literal">nullptr</span> ;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; c.size() &amp;&amp; c[index] != <span class="string">"#"</span>) &#123; left = <span class="keyword">new</span> Node&lt;<span class="keyword">int</span>&gt;(stoi(c[index]));  &#125;  index++;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; c.size() &amp;&amp; c[index] != <span class="string">"#"</span>) &#123; right = <span class="keyword">new</span> Node&lt;<span class="keyword">int</span>&gt;(stoi(c[index])); &#125;  index++;</span><br><span class="line">        <span class="keyword">if</span>(left) &#123; parent-&gt;left = left; q.push(left); &#125;</span><br><span class="line">        <span class="keyword">if</span>(right) &#123; parent-&gt;right = right; q.push(right); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v = &#123;<span class="string">"3"</span>,<span class="string">"9"</span>,<span class="string">"20"</span>,<span class="string">"#"</span>,<span class="string">"#"</span>,<span class="string">"15"</span>,<span class="string">"7"</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> re = reConstructTree(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> hh = levelOrderSeries(re);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用非递归非栈的方式遍历二叉树">使用非递归、非栈的方式遍历二叉树</h3><p>核心的思想是使用二叉树的左子树的最右边的空指针指向 在遍历完左子树之后 需要遍历的下一个节点。 具体的步骤是：</p><ol style="list-style-type: decimal"><li>令<code>iter = root</code>,<code>root</code>表示二叉树的根节点。首先让<code>iter</code>的左子树的最右节点的<code>right</code>指针指向<code>iter</code>. 完成这一步的代码类似下面这样：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Node* tp = iter-&gt;left; <span class="comment">// tp 指向iter的左子树</span></span><br><span class="line"><span class="keyword">if</span>(tp)&#123;</span><br><span class="line">    <span class="comment">// 通过循环找到最右边的节点</span></span><br><span class="line">    <span class="keyword">while</span>(tp-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">         tp = tp-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最右节点的right指针指向iter</span></span><br><span class="line">    <span class="keyword">if</span>(tp-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        tp-&gt;right = iter; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" style="list-style-type: decimal"><li>处理完<code>root</code>节点之后，循环处理<code>iter=iter-&gt;left</code>直到<code>iter</code>的<code>left</code>指针为空为止，也就是上文中的<code>tp==nullptr</code>的情况。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">    Node()&#123;&#125;</span><br><span class="line">    Node(<span class="keyword">int</span> v) : val(v),left(<span class="literal">nullptr</span>),right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的前序遍历，非递归，不用栈</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preOrder(Node* root)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    Node* iter = root;</span><br><span class="line">    Node* tp = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(iter != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="comment">// 处理iter的左子树</span></span><br><span class="line">        tp = iter-&gt;left;</span><br><span class="line">        <span class="keyword">if</span>(tp != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="comment">// 找到 iter 左子树的最右节点</span></span><br><span class="line">            <span class="keyword">while</span>(tp-&gt;right != <span class="literal">nullptr</span> &amp;&amp; tp-&gt;right != iter)&#123;</span><br><span class="line">                tp = tp-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是不满足tp-&gt;right != nullptr 而退出了上面的循环，</span></span><br><span class="line">            <span class="comment">// 说明找到的节点iter的左子树的最右面的空节点，</span></span><br><span class="line">            <span class="comment">// 把该节点指向iter</span></span><br><span class="line">            <span class="comment">// 继续处理 iter 的左孩子</span></span><br><span class="line">            <span class="keyword">if</span>(tp-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                tp-&gt;right = iter; <span class="comment">// 左子树的最右节点指向之前的节点</span></span><br><span class="line">                ans.push_back(iter-&gt;val); <span class="comment">// 一旦找到左子树最右边的节点就输出iter，因为前序遍历根节点要最先输出</span></span><br><span class="line">                iter = iter-&gt;left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是因为不满足tp-&gt;right != iter 退出了循环，</span></span><br><span class="line">            <span class="comment">// 就是说tp-&gt;right == iter</span></span><br><span class="line">            <span class="comment">// 说明已经遍历过一遍(否则不可能有指向iter的指针)</span></span><br><span class="line">            <span class="comment">// 把tp-&gt;right 置空，恢复二叉树原来的样子</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                tp-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 没有左子树，也要输出根</span></span><br><span class="line">            ans.push_back(iter-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        iter = iter-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的中序遍历，非递归，不用栈</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inOrder(Node* root)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    Node* iter = root;</span><br><span class="line">    Node* tp = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(iter != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="comment">// 处理iter的左子树</span></span><br><span class="line">        tp = iter-&gt;left;</span><br><span class="line">        <span class="keyword">if</span>(tp != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="comment">// 找到 iter 左子树的最右节点</span></span><br><span class="line">            <span class="keyword">while</span>(tp-&gt;right != <span class="literal">nullptr</span> &amp;&amp; tp-&gt;right != iter)&#123;</span><br><span class="line">                tp = tp-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是不满足tp-&gt;right != nullptr 而退出了上面的循环，</span></span><br><span class="line">            <span class="comment">// 说明找到的节点iter的左子树的最右面的空节点，</span></span><br><span class="line">            <span class="comment">// 把该节点指向iter</span></span><br><span class="line">            <span class="comment">// 继续处理 iter 的左孩子</span></span><br><span class="line">            <span class="keyword">if</span>(tp-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                tp-&gt;right = iter; <span class="comment">// 左子树的最右节点指向之前的节点</span></span><br><span class="line">                iter = iter-&gt;left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是因为不满足tp-&gt;right != iter 退出了循环，</span></span><br><span class="line">            <span class="comment">// 就是说tp-&gt;right == iter</span></span><br><span class="line">            <span class="comment">// 说明已经遍历过一遍(否则不可能有指向iter的指针)</span></span><br><span class="line">            <span class="comment">// 把tp-&gt;right 置空，恢复二叉树原来的样子</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                tp-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push_back(iter-&gt;val);</span><br><span class="line">        iter = iter-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法专题_字典树(Trie树)</title>
      <link href="/hexoblog/2017/08/23/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98-%E5%AD%97%E5%85%B8%E6%A0%91-Trie%E6%A0%91/"/>
      <url>/hexoblog/2017/08/23/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98-%E5%AD%97%E5%85%B8%E6%A0%91-Trie%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>一种字符串前缀的匹配技术。</p><a id="more"></a><h2 id="字典树">字典树</h2><h2 id="字典树的应用">字典树的应用</h2><h3 id="异或今日头条2017秋招真题">异或（今日头条2017秋招真题）</h3><p><a href="http://exercise.acmcoder.com/online/online_judge_ques?ques_id=3338&amp;konwledgeId=158" target="_blank" rel="noopener">异或（今日头条2017秋招真题）</a></p><p>题目描述</p><p>给定整数m以及n个数字A1, A2, …, An，将数列A中所有元素两两异或，共能得到n(n-1)/2个结果。请求出这些结果中大于m的有多少个。</p><p>输入 第一行包含两个整数n, m。 第二行给出n个整数A1, A2, …, An。 样例输入 3 10 6 5 10 输出 输出仅包括一行，即所求的答案。 样例输出 2 时间限制 C/C++语言：1000MS其它语言：3000MS<br>内存限制 C/C++语言：65536KB其它语言：589824K</p><p>思路：</p><ol style="list-style-type: decimal"><li>从最高位开始建立字典树，左子树表示二进制0，右子树表示二进制位1. 每个节点统计在n个数字中对应的二进制位上有多少个对应的0或者1.</li><li><p>查询每个数字a和m，比较a和m对应的位，有如下情况 2.1 a = 0, m = 0, 这个时候 b=0 , a^b = 0 不能确定谁大，继续查找下一位 2.2 a = 0, m = 1, 这个时候 b=0 , 肯定有a^b &lt; m, 不满足条件，跳过； b = 1, 继续查找下一位 2.3 a = 1, m = 0, 这个时候 b=0 , 肯定有a^b &gt; m, 满足条件，直接将对应的count加在结果上， b=1,继续查找下一位 2.4 a = 1, m = 1, 这个时候 b=0 , 继续查找下一位，b = 1,肯定不满足条件，</p></li><li><p>最后的结果除以2返回， 因为我们既统计了a与b的异或，也统计了b与a的异或。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrieTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieTree</span>* <span class="title">next</span>[2]&#123;</span><span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">    TrieTree():count(<span class="number">1</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TrieTree* <span class="title">buildTrieTree</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TrieTree* trieTree = <span class="keyword">new</span> TrieTree();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="keyword">int</span>)<span class="built_in">array</span>.size();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        TrieTree* cur = trieTree;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">16</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> digit = (<span class="built_in">array</span>[i] &gt;&gt; j) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">NULL</span> == cur-&gt;next[digit])</span><br><span class="line">                cur-&gt;next[digit] = <span class="keyword">new</span> TrieTree();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ++(cur-&gt;next[digit]-&gt;count);</span><br><span class="line">            cur = cur-&gt;next[digit];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> trieTree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">queryTrieTree</span><span class="params">(TrieTree*&amp; trieTree, <span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> m, <span class="keyword">const</span> <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == trieTree)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    TrieTree* cur = trieTree;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> aDigit = (a &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mDigit = (m &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span>==aDigit &amp;&amp; <span class="number">1</span>==mDigit)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">NULL</span> == cur-&gt;next[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            cur = cur-&gt;next[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == aDigit &amp;&amp; <span class="number">1</span>==mDigit)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">NULL</span> == cur-&gt;next[<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            cur = cur-&gt;next[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">1</span> == aDigit &amp;&amp; <span class="number">0</span> == mDigit)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> val0 =  (<span class="literal">NULL</span> == cur-&gt;next[<span class="number">0</span>]) ? <span class="number">0</span> : cur-&gt;next[<span class="number">0</span>]-&gt;count;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> val1 =  queryTrieTree(cur-&gt;next[<span class="number">1</span>],a,m,i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span> val0+val1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == aDigit &amp;&amp; <span class="number">0</span> == mDigit)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> val0 =  queryTrieTree(cur-&gt;next[<span class="number">0</span>],a,m,i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> val1 =  (<span class="literal">NULL</span> == cur-&gt;next[<span class="number">1</span>]) ? <span class="number">0</span> : cur-&gt;next[<span class="number">1</span>]-&gt;count;</span><br><span class="line">            <span class="keyword">return</span> val0+val1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">solve</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span>&amp; m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TrieTree* trieTree = buildTrieTree(<span class="built_in">array</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="keyword">int</span>)<span class="built_in">array</span>.size();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        result += queryTrieTree(trieTree,<span class="built_in">array</span>[i],m,<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result /<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"d:/A.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;<span class="built_in">array</span>[i];</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; solve(<span class="built_in">array</span>,m) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXBIT = <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trieTree</span>&#123;</span></span><br><span class="line">    ll count = <span class="number">0</span>;</span><br><span class="line">    trieTree* next[<span class="number">2</span>] = &#123;<span class="literal">nullptr</span>, <span class="literal">nullptr</span>&#125;;</span><br><span class="line">    trieTree() : count(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    trieTree(<span class="keyword">int</span> c) : count(c)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">trieTree* <span class="title">createTree</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span>&#123;</span><br><span class="line">    trieTree* root = <span class="keyword">new</span> trieTree(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = MAXBIT; <span class="comment">// int 整形最多32位</span></span><br><span class="line">        trieTree* cur = root;</span><br><span class="line">        <span class="keyword">while</span>(index &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> digit = (arr[i] &gt;&gt; index) &amp; <span class="number">1</span>; <span class="comment">// 从低位到高位第index+1位的值</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next[digit] == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                cur-&gt;next[digit] = <span class="keyword">new</span> trieTree(<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next[digit]-&gt;count ++;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next[digit];</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询trie树中有多少个数字满足a^b&gt;m</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> * @param a</span></span><br><span class="line"><span class="comment"> * @param m</span></span><br><span class="line"><span class="comment"> * @param index</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ll <span class="title">queryTree</span><span class="params">(trieTree* root,<span class="keyword">int</span> a, <span class="keyword">int</span> m, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> aDigit = (a &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mDigit = (m &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(aDigit == <span class="number">0</span> &amp;&amp; mDigit == <span class="number">0</span>)&#123;</span><br><span class="line">            ll v0 = <span class="number">0</span> , v1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;next[<span class="number">1</span>] != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                v0 = root-&gt;next[<span class="number">1</span>]-&gt;count;</span><br><span class="line">            &#125;</span><br><span class="line">            v1 = queryTree(root-&gt;next[<span class="number">0</span>],a,m,i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span> v0 + v1;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(aDigit == <span class="number">0</span> &amp;&amp; mDigit == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;next[<span class="number">1</span>] == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> queryTree(root-&gt;next[<span class="number">1</span>],a,m,i<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(aDigit == <span class="number">1</span> &amp;&amp; mDigit == <span class="number">0</span>)&#123;</span><br><span class="line">            ll v0 = <span class="number">0</span> , v1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;next[<span class="number">0</span>] != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                v0 = root-&gt;next[<span class="number">0</span>]-&gt;count;</span><br><span class="line">            &#125;</span><br><span class="line">            v1 = queryTree(root-&gt;next[<span class="number">1</span>],a,m,i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span> v0 + v1;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(aDigit == <span class="number">1</span> &amp;&amp; mDigit == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;next[<span class="number">0</span>] == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> queryTree(root-&gt;next[<span class="number">0</span>],a,m,i<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"error"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    trieTree* root = createTree(v);</span><br><span class="line">    ll result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); ++i) &#123;</span><br><span class="line">        result += queryTree(root,v[i],m,MAXBIT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"d:/A.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(n,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;solve(v,m)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="统计子目录">统计子目录</h3><p><a href="http://hihocoder.com/problemset/problem/1551" target="_blank" rel="noopener">统计子目录</a></p><p>描述 小Hi的电脑的文件系统中一共有N个文件，例如：</p><p>/hihocoder/offer22/solutions/p1</p><p>/hihocoder/challenge30/p1/test</p><p>/game/moba/dota2/uninstall</p><p>小Hi想统计其中一共有多少个不同的子目录。上例中一共有8个不同的子目录：</p><p>/hihocoder</p><p>/hihocoder/offer22</p><p>/hihocoder/offer22/solutions</p><p>/hihocoder/challenge30</p><p>/hihocoder/challenge30/p1</p><p>/game</p><p>/game/moba</p><p>/game/moba/dota2/</p><p>输入 第一行包含一个整数N (1 ≤ N ≤ 10000)</p><p>以下N行每行包含一个字符串，代表一个文件的绝对路径。保证路径从根目录“/”开始，并且文件名和目录名只包含小写字母和数字。</p><p>对于80%的数据，N个文件的绝对路径长度之和不超过10000</p><p>对于100%的数据，N个文件的绝对路径长度之和不超过500000</p><p>输出 一个整数代表不同子目录的数目。</p><p>样例输入 3<br>/hihocoder/offer22/solutions/p1<br>/hihocoder/challenge30/p1/test<br>/game/moba/dota2/uninstall 样例输出 8</p><p>思路： 用每个目录的名字建立字典树，根是空字符，然后统计整棵树节点的数目，最后返回节点的数目-1.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * [统计子目录](http://hihocoder.com/problemset/solution/1157194)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trieTree</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> description;</span><br><span class="line">    <span class="built_in">vector</span>&lt;trieTree*&gt; sons;</span><br><span class="line">    trieTree() : description(<span class="string">""</span>)&#123;&#125;</span><br><span class="line">    trieTree(<span class="built_in">string</span> &amp;s) : description(s)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 层次遍历统计节点数目</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(trieTree* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;sons.empty()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;trieTree*&gt; nodes, next;</span><br><span class="line">    nodes.push_back(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> re = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.size(); ++i) &#123;</span><br><span class="line">            next.insert(next.end(),nodes[i]-&gt;sons.begin(),nodes[i]-&gt;sons.end());</span><br><span class="line">        &#125;</span><br><span class="line">        re += nodes.size();</span><br><span class="line">        nodes = next;</span><br><span class="line">        next.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归遍历节点数目</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countNode2</span><span class="params">(trieTree *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;sons.empty()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> re = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; root-&gt;sons.size(); ++i) &#123;</span><br><span class="line">        re += countNode2(root-&gt;sons[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; splitString(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; re;</span><br><span class="line">    <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> re;</span><br><span class="line">    <span class="keyword">size_t</span> index1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> index2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(s.find(<span class="string">'/'</span>,index2) != <span class="number">-1</span>)&#123;</span><br><span class="line">        index2 = s.find(<span class="string">'/'</span>,index1+<span class="number">1</span>);</span><br><span class="line">        re.push_back(s.substr(index1+<span class="number">1</span>,index2-index1<span class="number">-1</span>));</span><br><span class="line">        index1 = index2;</span><br><span class="line">        index2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;pathes, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pathes.empty() || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    trieTree *root = <span class="keyword">new</span> trieTree();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path = splitString(pathes[i]);</span><br><span class="line">        trieTree *cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; path.size(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;sons.empty())&#123;</span><br><span class="line">                cur-&gt;sons.push_back(<span class="keyword">new</span> trieTree(path[j]));</span><br><span class="line">                result++;</span><br><span class="line">                cur = cur-&gt;sons[<span class="number">0</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> index = cur-&gt;sons.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cur-&gt;sons.size(); ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cur-&gt;sons[k]-&gt;description == path[j])&#123;</span><br><span class="line">                        index = k;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(index == cur-&gt;sons.size())&#123;</span><br><span class="line">                    cur-&gt;sons.push_back(<span class="keyword">new</span> trieTree(path[j]));</span><br><span class="line">                    result++;</span><br><span class="line">                    cur = cur-&gt;sons[cur-&gt;sons.size()<span class="number">-1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cur = cur-&gt;sons[index];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> re = countNode2(root) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"d:/A.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; pathes(n,<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; pathes[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;solve(pathes,n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并子目录">合并子目录</h3><p><a href="http://hihocoder.com/problemset/solution/1157744" target="_blank" rel="noopener">合并子目录</a></p><p>描述 小Hi的电脑的文件系统中一共有N个文件，例如：</p><p>/hihocoder/offer23/solutions/p1</p><p>/hihocoder/challenge30/p1/test</p><p>/game/moba/dota2/uninstall</p><p>经过统计，小Hi认为他的电脑中子目录实在太多了，于是他决定减少子目录的数量。小Hi发现其中一些子目录只包含另一个子目录，例如/hihocoder/offer22只包含一个子目录solution，/game只包含一个子目录moba，而moba也只包含一个子目录dota2。小Hi决定把这样的子目录合并成一个子目录，并且将被合并的子目录的名字用’-’连起来作为新子目录的名字。合并之后上例的3个文件的路径会变为：</p><p>/hihocoder/offer23-solutions/p1</p><p>/hihocoder/challenge30-p1/test</p><p>/game-moba-dota2/uninstall</p><p>输入 第一行包含一个整数N (1 ≤ N ≤ 10000)</p><p>以下N行每行包含一个字符串，代表一个文件的绝对路径。保证路径从根目录“/”开始，并且文件名和目录名只包含小写字母和数字。</p><p>对于80%的数据，N个文件的绝对路径长度之和不超过10000</p><p>对于100%的数据，N个文件的绝对路径长度之和不超过500000</p><p>输出 对于输入中的每个文件，输出合并子目录之后该文件的绝对路径。</p><p>样例输入 3 /hihocoder/offer23/solutions/p1 /hihocoder/challenge30/p1/test /game/moba/dota2/uninstall 样例输出 /hihocoder/offer23-solutions/p1 /hihocoder/challenge30-p1/test /game-moba-dota2/uninstall</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * [统计子目录](http://hihocoder.com/problemset/solution/1157194)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trieTree</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> description;</span><br><span class="line">    <span class="built_in">vector</span>&lt;trieTree*&gt; sons;</span><br><span class="line">    trieTree() : description(<span class="string">""</span>)&#123;&#125;</span><br><span class="line">    trieTree(<span class="built_in">string</span> &amp;s) : description(s)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; splitString(<span class="built_in">string</span> &amp;s)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; re;</span><br><span class="line">    <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> re;</span><br><span class="line">    s.push_back(<span class="string">'/'</span>);</span><br><span class="line">    <span class="keyword">size_t</span> index1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> index2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(s.find(<span class="string">'/'</span>,index2) != <span class="number">-1</span>)&#123;</span><br><span class="line">        index2 = s.find(<span class="string">'/'</span>,index1+<span class="number">1</span>);</span><br><span class="line">        re.push_back(s.substr(index1+<span class="number">1</span>,index2-index1<span class="number">-1</span>));</span><br><span class="line">        index1 = index2;</span><br><span class="line">        index2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">trieTree* <span class="title">createTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;pathes)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pathes.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    trieTree *root = <span class="keyword">new</span> trieTree();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pathes.size(); ++i) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path = splitString(pathes[i]);</span><br><span class="line">        trieTree *cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; path.size(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;sons.empty())&#123;</span><br><span class="line">                cur-&gt;sons.push_back(<span class="keyword">new</span> trieTree(path[j]));</span><br><span class="line">                result++;</span><br><span class="line">                cur = cur-&gt;sons[<span class="number">0</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> index = cur-&gt;sons.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cur-&gt;sons.size(); ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cur-&gt;sons[k]-&gt;description == path[j])&#123;</span><br><span class="line">                        index = k;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(index == cur-&gt;sons.size())&#123;</span><br><span class="line">                    cur-&gt;sons.push_back(<span class="keyword">new</span> trieTree(path[j]));</span><br><span class="line">                    result++;</span><br><span class="line">                    cur = cur-&gt;sons[cur-&gt;sons.size()<span class="number">-1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cur = cur-&gt;sons[index];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">trieTree* <span class="title">reduceTree</span><span class="params">(trieTree* root)</span></span>&#123;</span><br><span class="line">    trieTree* re = root;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;sons.empty()) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;sons.size() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; root-&gt;sons.size(); ++i) &#123;</span><br><span class="line">            reduceTree(root-&gt;sons[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;sons.size() == <span class="number">1</span>)&#123;</span><br><span class="line">        trieTree* next = root-&gt;sons[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(next-&gt;sons.empty())&#123;</span><br><span class="line"><span class="comment">//            root-&gt;description = root-&gt;description + "-";</span></span><br><span class="line"><span class="comment">//            root-&gt;description = root-&gt;description + next-&gt;description;</span></span><br><span class="line"><span class="comment">//            root-&gt;sons.clear();</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;sons.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; next-&gt;sons.size(); ++i) &#123;</span><br><span class="line">            root-&gt;sons.push_back(next-&gt;sons[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;description = root-&gt;description + <span class="string">"-"</span>;</span><br><span class="line">        root-&gt;description = root-&gt;description + next-&gt;description;</span><br><span class="line">        reduceTree(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTree</span><span class="params">(trieTree* root,<span class="built_in">string</span> out)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">nullptr</span> == root) <span class="keyword">return</span>;</span><br><span class="line">    out += root-&gt;description + <span class="string">"/"</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;sons.empty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(out.find_last_of(<span class="string">'/'</span>) == out.size() - <span class="number">1</span>)&#123;</span><br><span class="line">            out.erase(out.size()<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;out&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; root-&gt;sons.size(); ++i) &#123;</span><br><span class="line">            printTree(root-&gt;sons[i],out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;pathes, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    trieTree* root = createTree(pathes);</span><br><span class="line">    trieTree* reduced = reduceTree(root);</span><br><span class="line">    <span class="built_in">string</span> out = <span class="string">""</span>;</span><br><span class="line">    printTree(reduced,out);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"d:/A.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; pathes(n,<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; pathes[i];</span><br><span class="line">    &#125;</span><br><span class="line">    solve(pathes,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>今日头条_在线编程题</title>
      <link href="/hexoblog/2017/08/22/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1-%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
      <url>/hexoblog/2017/08/22/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1-%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="头条校招">头条校招</h2><p><a href="https://www.nowcoder.com/questionTerminal/57cf0b1050834901933e9b48daafbb9a" target="_blank" rel="noopener">头条校招</a></p><p>头条的2017校招开始了！为了这次校招，我们组织了一个规模宏大的出题团队，每个出题人都出了一些有趣的题目，而我们现在想把这些题目组合成若干场考试出来，在选题之前，我们对题目进行了盲审，并定出了每道题的难度系统。一场考试包含3道开放性题目，假设他们的难度从小到大分别为a,b,c，我们希望这3道题能满足下列条件：</p><p>a&lt;=b&lt;=c b-a&lt;=10 c-b&lt;=10</p><p>所有出题人一共出了n道开放性题目。现在我们想把这n道题分布到若干场考试中（1场或多场，每道题都必须使用且只能用一次），然而由于上述条件的限制，可能有一些考试没法凑够3道题，因此出题人就需要多出一些适当难度的题目来让每场考试都达到要求，然而我们出题已经出得很累了，你能计算出我们最少还需要再出几道题吗？ 输入描述:</p><p>输入的第一行包含一个整数n，表示目前已经出好的题目数量。</p><p>第二行给出每道题目的难度系数d1,d2,…,dn。</p><p>数据范围</p><p>对于30%的数据，1 ≤ n,di ≤ 5;</p><p>对于100%的数据，1 ≤ n ≤ 10^5,1 ≤ di ≤ 100。</p><p>在样例中，一种可行的方案是添加2个难度分别为20和50的题目，这样可以组合成两场考试：（20 20 23）和（35,40,50）。</p><p>输出描述:</p><p>输出只包括一行，即所求的答案。 示例1 输入</p><p>4<br>20 35 23 40 输出</p><p>2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.empty()) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    sort(v.begin(),v.end());</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> re = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n)&#123;</span><br><span class="line">           <span class="keyword">if</span>(v[i+<span class="number">1</span>] - v[i] &gt; <span class="number">20</span>)&#123;</span><br><span class="line">               re = re + <span class="number">2</span>;</span><br><span class="line">               i = i + <span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(v[i+<span class="number">1</span>] - v[i] &gt; <span class="number">10</span>)&#123;</span><br><span class="line">               re = re + <span class="number">1</span>;</span><br><span class="line">               i = i + <span class="number">2</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">if</span>(i+<span class="number">2</span> &lt; n)&#123;</span><br><span class="line">                   <span class="keyword">if</span>(v[i+<span class="number">2</span>] - v[i+<span class="number">1</span>] &gt; <span class="number">10</span>)&#123;</span><br><span class="line">                       re = re + <span class="number">1</span>;</span><br><span class="line">                       i = i + <span class="number">2</span>;</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       i = i + <span class="number">3</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   re = re + <span class="number">1</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            re = re + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"d:/A.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(n,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> re = solve(v,n);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;re&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里笔试</title>
      <link href="/hexoblog/2017/08/18/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E9%98%BF%E9%87%8C%E5%9C%A8%E7%BA%BF%E6%B5%8B%E8%AF%84-%E5%85%94%E5%AD%90%E7%B9%81%E6%AE%96%E9%97%AE%E9%A2%98/"/>
      <url>/hexoblog/2017/08/18/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E9%98%BF%E9%87%8C%E5%9C%A8%E7%BA%BF%E6%B5%8B%E8%AF%84-%E5%85%94%E5%AD%90%E7%B9%81%E6%AE%96%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>阿里巴巴网络技术有限公司（简称：阿里巴巴集团）是以曾担任英语教师的马云为首的18人于1999年在浙江杭州创立，他们相信互联网能够创造公平的竞争环境，让小企业通过创新与科技扩展业务，并在参与国内或全球市场竞争时处于更有利的位置</p><a id="more"></a><h2 id="兔子繁殖问题">兔子繁殖问题</h2><p>问题</p><ol style="list-style-type: decimal"><li>猎人把一对兔子婴儿(一公一母称为一对)放到一个荒岛上，两年之后，它们生下一对小兔，之后开始每年都会生下一对小兔。生下的小兔又会以同样的方式继续繁殖。</li><li>兔子的寿命都是x(x&gt;=3)年，并且生命的最后一年不繁殖。</li><li>如果岛上的兔子多于10对，那么猎人会每年在兔子们完成繁殖或者仙逝之后，从岛上带走两对最老的兔子。 请问y年(y&gt;=3)后荒岛上所有的兔子加起来多少岁?(注意, 在条件3执行完之后)</li></ol><p>输入: 从命令行输入两行整数，第一行是x，第二行是y 输出: y年后荒岛上所有的兔子岁数的总和</p><p>测试数据：</p><table><thead><tr class="header"><th>x</th><th>y</th><th>n</th></tr></thead><tbody><tr class="odd"><td>3</td><td>3</td><td>2</td></tr><tr class="even"><td>3</td><td>7</td><td>2</td></tr><tr class="odd"><td>3</td><td>8</td><td>4</td></tr><tr class="even"><td>4</td><td>5</td><td>12</td></tr><tr class="odd"><td>5</td><td>6</td><td>26</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x ;</span><br><span class="line">    <span class="keyword">int</span> y ;</span><br><span class="line">    x = <span class="number">10</span>;</span><br><span class="line">    y = <span class="number">12</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> year = <span class="number">1</span>; year &lt;= y; year++) &#123;</span><br><span class="line">        <span class="comment">// // 每年长一岁</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.size();i++) &#123;</span><br><span class="line">            res[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// over</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.size();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res[i] &gt;= x)</span><br><span class="line">                res.erase(res.begin() + i);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生孩子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.size();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res[i]&gt;= <span class="number">2</span> &amp;&amp; res[i] &lt; x)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res.size() &gt; <span class="number">10</span>) &#123;</span><br><span class="line">            res.erase(res.begin());</span><br><span class="line">            res.erase(res.begin());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : res)</span><br><span class="line">        num += x;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; num * <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法专题_贪心法</title>
      <link href="/hexoblog/2017/08/17/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98-%E8%B4%AA%E5%BF%83%E6%B3%95/"/>
      <url>/hexoblog/2017/08/17/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98-%E8%B4%AA%E5%BF%83%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。 贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。</p><a id="more"></a><h3 id="任务安排问题">任务安排问题</h3><p><a href="https://leetcode.com/problems/maximum-length-of-pair-chain/description/" target="_blank" rel="noopener">Maximum Length of Pair Chain</a></p><p>按照结束时间排序，贪心的选择结束时间最早的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="整数分解求乘积最大">整数分解求乘积最大</h2><p><a href="https://leetcode.com/problems/integer-break/description/" target="_blank" rel="noopener">leetcode</a></p><p>分解策略是尽可能的分解成2，3， 尽可能均匀的分解成2，3</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">6</span>) <span class="keyword">return</span> dp[n<span class="number">-2</span>];</span><br><span class="line">        <span class="keyword">int</span> c3 = <span class="number">0</span>, c2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n - <span class="number">3</span> &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">            n = n - <span class="number">3</span>;</span><br><span class="line">            c3++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            c2 = n / <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( n % <span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            c3 = c3 + n / <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> re = <span class="built_in">pow</span>(<span class="number">2.0</span>,c2) * <span class="built_in">pow</span>(<span class="number">3.0</span>,c3);</span><br><span class="line">        <span class="keyword">int</span> res = re;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法专题_hihocoder</title>
      <link href="/hexoblog/2017/08/13/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98-hihocoder/"/>
      <url>/hexoblog/2017/08/13/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98-hihocoder/</url>
      
        <content type="html"><![CDATA[<p>hihocoder 每周编程比赛</p><a id="more"></a><h2 id="offer收割编程练习赛22"><a href="http://hihocoder.com/contest/offers22" target="_blank" rel="noopener">[Offer收割]编程练习赛22</a></h2><h3 id="顺序三元组"><a href="http://hihocoder.com/problemset/problem/1550" target="_blank" rel="noopener">顺序三元组</a></h3><p>给定一个长度为N的数组A=[A1, A2, … AN]，已知其中每个元素Ai的值都只可能是1, 2或者3。 请求出有多少下标三元组(i, j, k)满足1 ≤ i &lt; j &lt; k ≤ N且Ai &lt; Aj &lt; Ak。</p><p>分析：统计2前面有多少个1，2前面有多少个12就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.empty() || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll c1 = <span class="number">0</span>, c12 = <span class="number">0</span>, c123 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i] == <span class="number">1</span>)&#123;</span><br><span class="line">            c1++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(v[i] == <span class="number">2</span>)&#123;</span><br><span class="line">            c12 = c12 + c1;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(v[i] == <span class="number">3</span>)&#123;</span><br><span class="line">            c123 = c123 + c12;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 输入数据有错</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"d:/A.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(n,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ll result = solve(v,n);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;result&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并子目录"><a href="http://hihocoder.com/problemset/problem/1551" target="_blank" rel="noopener">合并子目录</a></h3><p>小Hi的电脑的文件系统中一共有N个文件，例如：</p><p>/hihocoder/offer22/solutions/p1</p><p>/hihocoder/challenge30/p1/test</p><p>/game/moba/dota2/uninstall</p><p>小Hi想统计其中一共有多少个不同的子目录。上例中一共有8个不同的子目录：</p><p>/hihocoder</p><p>/hihocoder/offer22</p><p>/hihocoder/offer22/solutions</p><p>/hihocoder/challenge30</p><p>/hihocoder/challenge30/p1</p><p>/game</p><p>/game/moba</p><p>/game/moba/dota2/</p><p>前缀树</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FS</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, FS*&gt; subs;</span><br><span class="line">    FS(<span class="keyword">const</span> <span class="built_in">string</span> &amp;n): name(n)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; parse(<span class="keyword">const</span> <span class="built_in">string</span> &amp;path) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">    <span class="comment">// 需要的字符串前后都有/,first_表示前面/的位置，second_表示后面.的位置</span></span><br><span class="line">    <span class="keyword">int</span> first_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> second_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(first_ &lt; path.size()) &#123;</span><br><span class="line">        second_ = path.find(<span class="string">'/'</span>, first_);</span><br><span class="line">        <span class="comment">// 没有找到/,退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (second_ == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (second_ &gt; first_) &#123;</span><br><span class="line">            ret.push_back(<span class="built_in">string</span>(path.begin() + first_, path.begin() + second_));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        first_ = second_ + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(FS *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    ret++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p: root-&gt;subs) &#123;</span><br><span class="line">        dfs(p.second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"d:/A.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">    FS* root= <span class="keyword">new</span> FS(<span class="string">""</span>);</span><br><span class="line">    <span class="built_in">string</span> path;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; path;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; dirs = parse(path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造前缀树</span></span><br><span class="line">        <span class="keyword">auto</span> cur = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> dir: dirs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;subs.count(dir) == <span class="number">0</span>) &#123;</span><br><span class="line">                FS *ndir = <span class="keyword">new</span> FS(dir);</span><br><span class="line">                cur-&gt;subs[dir] = ndir;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;subs[dir];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历树，统计结果</span></span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ret - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缺失的拼图"><a href="http://hihocoder.com/problemset/problem/1552" target="_blank" rel="noopener">缺失的拼图</a></h3><p>小Hi在玩一个拼图游戏。如下图所示，整个拼图是由N块小矩形组成的大矩形。现在小Hi发现其中一块小矩形不见了。给定大矩形以及N-1个小矩形的顶点坐标，你能找出缺失的那块小矩形的顶点坐标吗？</p><p>分析： 每个矩形用四个点的坐标来表示，那么如果不缺失矩形，每个点应该出现偶数次。缺失矩形的地方，每个点只出现奇数次，这样就能找到缺失矩形的坐标。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    freopen(<span class="string">"d:/A.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> x1,y1,x2,y2;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">        m[make_pair(x1,y1)]++;</span><br><span class="line">        m[make_pair(x1,y2)]++;</span><br><span class="line">        m[make_pair(x2,y1)]++;</span><br><span class="line">        m[make_pair(x2,y2)]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; xx;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; yy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : m) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i.second % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        xx.push_back(i.first.first);</span><br><span class="line">        yy.push_back(i.first.second);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(xx.begin(),xx.end());</span><br><span class="line">    sort(yy.begin(),yy.end());</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;xx[<span class="number">0</span>]&lt;&lt;<span class="string">" "</span>&lt;&lt;yy[<span class="number">0</span>]&lt;&lt;<span class="string">" "</span>&lt;&lt;xx[<span class="number">3</span>]&lt;&lt;<span class="string">" "</span>&lt;&lt;yy[<span class="number">3</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法专题_归并排序</title>
      <link href="/hexoblog/2017/08/07/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/hexoblog/2017/08/07/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>归并排序是分治法思想的典型应用。归并排序要处理好两件事，划分和合并。划分就是将待排序序列划分成子序列。合并就是如何将两个有序的子序列合并为一个有序的子序列。</p><p>归并的排序的思想是：首先把原来序列划分成n个子序列，每个子序列一个元素，这样每个子序列都可以看作是有序的。然后分别合并相邻的两个子序列，使合并之后的序列保持有序。这样，一趟归并之后子序列减少二分之一，直到最后归并为一个序列为止。</p><a id="more"></a><h2 id="归并排序的实现">归并排序的实现</h2><p>归并排序中最重要的操作是如何将两个有序的序列合并为一个有序的序列。</p><div class="figure"><img src="2017-04-16_213443.png"></div><p>这里合并两个有序序列的方法可以自己设计，我们使用逐个元素比较的方法，时间复杂度是<code>O(a1+a2)</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> a:v)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">" | "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并两个有序的数组,返回新的有序的数组</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; merge(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v1,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v2)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">    <span class="keyword">size_t</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;v1.size() &amp;&amp; j&lt;v2.size())&#123;</span><br><span class="line">        <span class="keyword">if</span>(v1[i] &lt;= v2[j])&#123;</span><br><span class="line">            re.push_back(v1[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            re.push_back(v2[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把剩下的放在最后</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> a = i;a&lt;v1.size();a++)&#123;</span><br><span class="line">        re.push_back(v1[a]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> a=j;a&lt;v2.size();a++)&#123;</span><br><span class="line">        re.push_back(v2[a]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序的非递归实现</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mergeSort2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; group;</span><br><span class="line">    <span class="comment">// 一开始，每一个元素单独为一组，然后一步一步的合并相邻的组，直到最后只剩下一组。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();i++) &#123;</span><br><span class="line">        group.push_back(&#123;v[i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> group_end = group.size(); <span class="comment">// 指示结果，每次归并，都是合并相邻的两组数据，所以group的元素个数每次都减少一半，为了减少开销，</span></span><br><span class="line">    <span class="comment">//我们每次合并之后的数组还是放在原来的数组中，用group指示数组的结束。</span></span><br><span class="line">    <span class="comment">//当group_end = 1的时候，所有的数组已经归并到一起了</span></span><br><span class="line">    <span class="keyword">while</span>(group_end &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> b=<span class="number">0</span>;b&lt;group_end;b++)&#123;</span><br><span class="line">            print(group[b]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j+<span class="number">1</span>&lt;group.size())&#123;</span><br><span class="line">            group[j/<span class="number">2</span>]  = merge(group[j],group[j+<span class="number">1</span>]);</span><br><span class="line">            j = j + <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 个数是奇数的情况</span></span><br><span class="line">        <span class="keyword">if</span>(j == group_end <span class="number">-1</span> )&#123;</span><br><span class="line">            group[<span class="built_in">ceil</span>(group_end / <span class="number">2.0</span>)<span class="number">-1</span>] = group[group_end<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        group_end = <span class="built_in">ceil</span>(group_end / <span class="number">2.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    print(group[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> group[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>,<span class="number">13</span>,<span class="number">27</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> a = mergeSort2(v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">49</span>  | <span class="number">38</span>  | <span class="number">65</span>  | <span class="number">97</span>  | <span class="number">76</span>  | <span class="number">13</span>  | <span class="number">27</span>  |</span><br><span class="line"><span class="number">38</span> <span class="number">49</span>  | <span class="number">65</span> <span class="number">97</span>  | <span class="number">13</span> <span class="number">76</span>  | <span class="number">27</span>  |</span><br><span class="line"><span class="number">38</span> <span class="number">49</span> <span class="number">65</span> <span class="number">97</span>  | <span class="number">13</span> <span class="number">27</span> <span class="number">76</span>  |</span><br><span class="line"><span class="number">13</span> <span class="number">27</span> <span class="number">38</span> <span class="number">49</span> <span class="number">65</span> <span class="number">76</span> <span class="number">97</span>  |</span><br></pre></td></tr></table></figure></p><p>归并排序的递归实现方法 ： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  归并排序的递归实现</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mergeSort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> start,<span class="keyword">int</span> end)&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;v[start]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">auto</span> v1 = mergeSort(v,start,mid); <span class="comment">// 递归左半部分的排序</span></span><br><span class="line">    <span class="keyword">auto</span> v2 = mergeSort(v,mid+<span class="number">1</span>,end); <span class="comment">// 递归右半部分的排序</span></span><br><span class="line">    <span class="keyword">return</span> merge(v1,v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="归并排序的应用">归并排序的应用</h2><h3 id="统计数组的逆序对">统计数组的逆序对</h3><p>归并排序是一种稳定的排序（合并两个有序数组的时候是稳定的），所以可以用来求数组的逆序对这样的问题。</p><p>归并排序是将数列a[l,h]分成两半a[l,mid]和a[mid+1,h]分别进行归并排序，然后再将这两半合并起来。 在合并的过程中（设<code>l&lt;=i&lt;=mid，mid+1&lt;=j&lt;=h</code>），当a[i]&lt;=a[j]时，并不产生逆序数；当a[i]&gt;a[j]时，在 前半部分中比a[i]大的数都比a[j]大，将a[j]放在a[i]前面的话，逆序数要加上<code>mid-i+1</code>。因此，可以在归并 排序中的合并过程中计算逆序数.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并两个有序的数组,返回新的有序的数组</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; merge(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v1,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v2,<span class="keyword">int</span> &amp;cc)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">    <span class="keyword">size_t</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;v1.size() &amp;&amp; j&lt;v2.size())&#123;</span><br><span class="line">        <span class="keyword">if</span>(v1[i] &lt;= v2[j])&#123;</span><br><span class="line">            re.push_back(v1[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            re.push_back(v2[j]);</span><br><span class="line">            cc = cc + v1.size() -  i; <span class="comment">//增加统计逆序对的功能，以传递引用的方法返回结果，注意传入的参数的初始值要为0；</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把剩下的放在最后</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> a = i;a&lt;v1.size();a++)&#123;</span><br><span class="line">        re.push_back(v1[a]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> a=j;a&lt;v2.size();a++)&#123;</span><br><span class="line">        re.push_back(v2[a]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序的递归实现</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mergeSort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> &amp;cc)&#123;</span><br><span class="line">  <span class="keyword">if</span>(start &gt;= end)&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;v[start]&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">auto</span> v1 = mergeSort(v,start,mid,cc); <span class="comment">// 递归左半部分的排序</span></span><br><span class="line">  <span class="keyword">auto</span> v2 = mergeSort(v,mid+<span class="number">1</span>,end,cc); <span class="comment">// 递归右半部分的排序</span></span><br><span class="line">  <span class="keyword">return</span> merge(v1,v2,cc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用的使用定义int cc = 0; 传入函数即可。</span></span><br></pre></td></tr></table></figure><p>统计数组的逆序对，还可以使用树状数组，不过就复杂度而言，使用归并排序已经足够了。</p><p>另外一种归并排序的实现方法，尽量少的占用额外的空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> s1,<span class="keyword">int</span> e1, <span class="keyword">int</span> s2, <span class="keyword">int</span> e2)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="keyword">int</span> ss1 = s1, ss2 = s2;</span><br><span class="line">    <span class="keyword">while</span>(s1&lt;=e1 &amp;&amp; s2 &lt;= e2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[s1] &lt; v[s2])&#123;</span><br><span class="line">            tmp.push_back(v[s1]);</span><br><span class="line">            s1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(v[s1] &gt;= v[s2])&#123;</span><br><span class="line">            tmp.push_back(v[s2]);</span><br><span class="line">            s2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s1 &lt;= e1)&#123;</span><br><span class="line">        tmp.insert(tmp.end(),v.begin() + s1,v.begin() + e1+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s2 &lt;= e2)&#123;</span><br><span class="line">        tmp.insert(tmp.end(),v.begin() + s2,v.begin() + e2+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=ss1;i&lt;=e1;i++)&#123;</span><br><span class="line">        v[i] = tmp[t];</span><br><span class="line">        t++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = ss2;i&lt;=e2;i++)&#123;</span><br><span class="line">        v[i] = tmp[t];</span><br><span class="line">        t++;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp.clear();</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (start+end) / <span class="number">2</span>;</span><br><span class="line">    mergeSort(v,start,mid);</span><br><span class="line">    mergeSort(v,mid+<span class="number">1</span>,end);</span><br><span class="line">    merge(v,start,mid,mid+<span class="number">1</span>,end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>统计逆序对</p><p>在归并排序归并两个已经排好序的数组的时候，是统计逆序对的最好时机。假设两个待合并的序列为<code>v1</code>,<code>v2</code>, 有两个指针<code>s1</code>,<code>s2</code>分别指向<code>v1</code>,<code>v2</code>,当<code>v1[s1] &gt; v2[s2]</code>的时候，<code>(v1.size() - s1)</code>, 也就是从<code>s1</code>到<code>v1</code>的结尾的所有元素都会和<code>v[s2]</code>组成逆序对。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> s1,<span class="keyword">int</span> e1, <span class="keyword">int</span> s2, <span class="keyword">int</span> e2, <span class="keyword">int</span> &amp;cc)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="keyword">int</span> ss1 = s1, ss2 = s2;</span><br><span class="line">    <span class="keyword">while</span>(s1&lt;=e1 &amp;&amp; s2 &lt;= e2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[s1] &lt;= v[s2])&#123;</span><br><span class="line">            tmp.push_back(v[s1]);</span><br><span class="line">            s1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(v[s1] &gt; v[s2])&#123;</span><br><span class="line">            tmp.push_back(v[s2]);</span><br><span class="line">            s2++;</span><br><span class="line">            cc += e1-s1+<span class="number">1</span>; <span class="comment">// 记录逆序对的数量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s1 &lt;= e1)&#123;</span><br><span class="line">        tmp.insert(tmp.end(),v.begin() + s1,v.begin() + e1+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s2 &lt;= e2)&#123;</span><br><span class="line">        tmp.insert(tmp.end(),v.begin() + s2,v.begin() + e2+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=ss1;i&lt;=e1;i++)&#123;</span><br><span class="line">        v[i] = tmp[t];</span><br><span class="line">        t++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = ss2;i&lt;=e2;i++)&#123;</span><br><span class="line">        v[i] = tmp[t];</span><br><span class="line">        t++;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp.clear();</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> &amp;cc)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = (start+end) / <span class="number">2</span>;</span><br><span class="line">    mergeSort(v,start,mid,cc);</span><br><span class="line">    mergeSort(v,mid+<span class="number">1</span>,end,cc);</span><br><span class="line">    merge(v,start,mid,mid+<span class="number">1</span>,end,cc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法专题_快速排序</title>
      <link href="/hexoblog/2017/08/07/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/hexoblog/2017/08/07/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>快速排序是分治思想的典型应用，它的时间复杂度是<code>o(nlogn)</code>,在数据没有特殊的规律的情况下，快速排序是首选的排序方法。它的思想也经常用来出各种算法题目。</p><a id="more"></a><h2 id="快排算法">快排算法</h2><div class="figure"><img src="2017-04-17_182740.png"></div><p>快速排序的基本思想是每次选择一个基准元素，调整数组，使得所有比基准元素小的元素都位于左边，所有比基准元素大的元素都位于基准元素的右边，从而使得基准元素放在了正确的位置上。然后以基准元素为准，把数组分成两个部分，递归的应用上面的方法，得到最终的结果。所以，快速排序的实现也有递归的版本和非递归的版本。一般使用递归的版本就够了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 以i指向的元素为基准元素</span></span><br><span class="line">    <span class="keyword">bool</span> base = <span class="literal">true</span>; <span class="comment">// base = true 表示此时 i 指向base 元素， base = false 表示此时j 指向base元素</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i] &gt; v[j] &amp;&amp; base)&#123;</span><br><span class="line">            swap(v[i],v[j]);</span><br><span class="line">            base = <span class="literal">false</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(v[i] &gt; v[j] &amp;&amp; !base)&#123;</span><br><span class="line">            swap(v[i],v[j]);</span><br><span class="line">            base = <span class="literal">true</span>;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(base)&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!base)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> * @param v  待排序数组</span></span><br><span class="line"><span class="comment"> * @param start  起始位置下标</span></span><br><span class="line"><span class="comment"> * @param end  结束位置下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">     <span class="keyword">int</span> mid = partition(v,start,end);</span><br><span class="line">     quickSort(v,start,mid<span class="number">-1</span>);</span><br><span class="line">     quickSort(v,mid+<span class="number">1</span>,end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快排的应用">快排的应用</h2><h3 id="n个元素中查找第k小的元素on时间内">N个元素中查找第K小的元素(o(n)时间内)</h3><p>如果查找最小的元素，只需要遍历一遍数组即可。如果是第2小的，首先遍历一遍找到最小的，然后再遍历一遍就可以找到第二小的了。所以，朴素的解法需要的时间复杂度是o(kn),与k有关系。</p><p>快速排序<code>partition</code>函数的特点是每次能确定一个元素排好序之后应该在的位置。假设partition(0,n-1) = i, 我们可以获得这样的信息，[0..i-1]位置的元素都比A[i]小，而i后面的元素都比A[i]大。这样，我们每次调用<code>partition</code>都可以去掉一半元素，这样时间复杂度就能降到o(n)了。</p><p><a href="http://lintcode.com/en/problem/kth-largest-element/#" target="_blank" rel="noopener">lintcode</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kth</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.empty() || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = v.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">         <span class="keyword">int</span> i = partition(v,begin,end);</span><br><span class="line">         <span class="keyword">if</span>(i+<span class="number">1</span> == k) <span class="keyword">return</span> v[i];</span><br><span class="line">         <span class="keyword">if</span>(i+<span class="number">1</span> &lt; k)&#123;</span><br><span class="line">            begin = i + <span class="number">1</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            end = i - <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/description/" target="_blank" rel="noopener">leetcode</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; j) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">int</span> start = i;</span><br><span class="line">    <span class="keyword">int</span> end = j;</span><br><span class="line">    <span class="keyword">bool</span> base = <span class="literal">true</span>; <span class="comment">// 指示 i 是否指向base 元素，如果i 不指向base元素，则j肯定指向base元素。</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i] &gt; v[j] &amp;&amp; base)&#123;</span><br><span class="line">            tmp = v[j];</span><br><span class="line">            v[j] = v[i];</span><br><span class="line">            v[i] = tmp;</span><br><span class="line">            i = i + <span class="number">1</span>;</span><br><span class="line">            base = <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(v[i] &gt; v[j] &amp;&amp; !base)&#123;</span><br><span class="line">            tmp = v[j];</span><br><span class="line">            v[j] = v[i];</span><br><span class="line">            v[i] = tmp;</span><br><span class="line">            j = j - <span class="number">1</span>;</span><br><span class="line">            base = <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(base)&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthLargestElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>, len = nums.size();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = partition(nums, left, right);</span><br><span class="line">        <span class="keyword">if</span> (len - pos == k ) <span class="keyword">return</span> nums[pos];</span><br><span class="line">        <span class="keyword">if</span> (len - pos &lt; k) right = pos - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> left = pos + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找中位数">查找中位数</h3><p>一般的做法是排序，返回中间的数字，但是这样的时间复杂度是o(nlogn). 其实还有o(n)的算法，和上面一样，也是利用了快速排序的partition函数。</p><p><a href="http://lintcode.com/zh-cn/problem/median/" target="_blank" rel="noopener">lintcode</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">median</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> len = nums.size();</span><br><span class="line">    <span class="keyword">return</span> kthLargestElement(nums,len / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法专题_二叉堆</title>
      <link href="/hexoblog/2017/08/06/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E4%BA%8C%E5%8F%89%E5%A0%86/"/>
      <url>/hexoblog/2017/08/06/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E4%BA%8C%E5%8F%89%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<p>堆，或者更准确的叫作二叉堆，是一种特殊的完全二叉树，通常分为最大堆和最小堆。最大堆是指堆顶的元素最大，堆顶的左右孩子的值小于等于它，然后左右子树也满足这个条件。最小堆是指堆顶的元素最小，左右孩子大于等于堆顶元素，左右子树也满足这个条件。 可以看到，堆是递归定义了，而且是一种完全二叉树。节点之间是有大小次序关系的。但是左右子树是没有顺序的。而二叉搜索树左右孩子是有次序的，不能颠倒。</p><p>既然堆是完全二叉树，就可以使用数组来简便的表示一棵树。假设一个节点的下标是<code>i</code>,那么它的左孩子为<code>2*i</code>,右孩子为<code>2*i+1</code>,父节点为<code>i/2</code>. 本文主要介绍二叉堆的构建，调整和有关应用(堆排序和优先队列)。注意这里假设根节点的标号是1.</p><p>如果根节点是从0开始标号的，那么对于节点<code>i</code>, 左孩子为<code>2*i+1</code>,右孩子为<code>2*i+2</code>,父节点为<code>(i-1)/2</code>.</p><p><a href="2017-04-11_091249.png"></a></p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根节点从0开始标号，对于节点i，求其左孩子，右孩子和父节点</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i&lt;&lt;<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i&lt;&lt;<span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> (i<span class="number">-1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大堆">最大堆</h2><p>最大堆就是满足父节点大于等于子节点的堆。最大堆的根节点是所有元素中最大的(但可能不是唯一的最大的，注意这里是大于等于)。</p><h3 id="维护最大堆调整最大堆">维护最大堆(调整最大堆)</h3><p>假设<code>A</code>是存储堆的数组,<code>A.length()</code>表示数组的大小，<code>heap_size</code>表示堆中元素的个数, 满足<code>heap_size &lt;= A.length()</code>.假设我们需要调整节点<code>i</code>以使得堆重新满足最大堆的性质(注意这个时候只有节点i是不满足最大堆的性质的)，步骤如下：</p><ol style="list-style-type: decimal"><li>找出节点<code>i</code>的左右孩子<code>l</code>,<code>r</code>;</li><li>如果<code>l</code>,<code>r</code>超过了堆的大小，直接返回，如果A[i]大于等于<code>l</code>,<code>r</code>,直接返回</li><li>找到<code>l</code>,<code>r</code>中的较大者,记为<code>maxIndex</code>，和<code>A[i]</code>交换</li><li>令i = maxIndex, 转到1。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调整节点i,使得整个堆保持最大堆的性质</span></span><br><span class="line"><span class="comment"> * @param A</span></span><br><span class="line"><span class="comment"> * @param i</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_heap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> heap_size = A.size();</span><br><span class="line">    <span class="comment">// 不存在这个样的节点（节点从0开始编号）</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt;= heap_size || i &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">auto</span> l = left(i);</span><br><span class="line">    <span class="keyword">auto</span> r = right(i);</span><br><span class="line">    <span class="comment">// 如果没有孩子节点了，不需要调整了</span></span><br><span class="line">    <span class="keyword">if</span>(l &gt;= heap_size ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> maxIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(r &gt;= heap_size )&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &gt;= A[l]) <span class="keyword">return</span>;</span><br><span class="line">        maxIndex = l;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 如果节点i比它两个孩子节点都大，则满足最大堆的性质，不用调整</span></span><br><span class="line">        <span class="keyword">if</span>(A[i] &gt;= A[l] &amp;&amp; A[i] &gt;= A[r]) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 找到两个孩子节点中较大的那一个</span></span><br><span class="line">        A[l] &gt;= A[r] ? maxIndex = l : maxIndex = r;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(A[i],A[maxIndex]);</span><br><span class="line">    max_heap(A,maxIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调整节点i,使得整个堆保持最小堆的性质</span></span><br><span class="line"><span class="comment"> * @param A </span></span><br><span class="line"><span class="comment"> * @param i </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">min_heap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> heap_size = A.size();</span><br><span class="line">    <span class="comment">// 不存在这个样的节点（节点从0开始编号）</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt;= heap_size || i &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">auto</span> l = left(i);</span><br><span class="line">    <span class="keyword">auto</span> r = right(i);</span><br><span class="line">    <span class="comment">// 如果没有孩子节点了，不需要调整了</span></span><br><span class="line">    <span class="keyword">if</span>(l &gt;= heap_size ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> minIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(r &gt;= heap_size ) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &lt;= A[l]) <span class="keyword">return</span>;</span><br><span class="line">        minIndex = l;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 如果节点i比它两个孩子节点都小，则满足最小堆的性质，不用调整</span></span><br><span class="line">        <span class="keyword">if</span>(A[i] &lt;= A[l] &amp;&amp; A[i] &lt;= A[r]) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 找到两个孩子节点中较大的那一个</span></span><br><span class="line">        A[l] &lt;= A[r] ? minIndex = l : minIndex = r;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(A[i],A[minIndex]);</span><br><span class="line">    min_heap(A,minIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="建堆">建堆</h3><p>如何从一个无序的数组建立一个堆是堆操作中一个基本的，但很重要的问题，它通常是很多问题的第一步。</p><p>根据完全二叉树的性质，一个包含n个元素的数组形成的完全二叉树中，n - ([n/2] + 1) + 1个元素是叶子节点。我们只需要针对所有的叶子节点之外的节点调用上面的重建堆的函数，就可以构建一个最大堆。 时间复杂度是O(n).</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从无序数组建立最大堆</span></span><br><span class="line"><span class="comment"> * @param A</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_max_heap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leaf = A.size() / <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = leaf - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; --i) &#123;</span><br><span class="line">        max_heap(A,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从无序数组建立最小堆</span></span><br><span class="line"><span class="comment"> * @param A</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_min_heap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leaf = A.size() / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = leaf - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; --i) &#123;</span><br><span class="line">        min_heap(A,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序">堆排序</h2><p>堆排序就是利用堆的结构来维护最大值或者最小值实现排序的一种算法，这里以最大堆为例来说明。 首先把无序数组重建一个最大堆，使用上面提到的函数，这一步可以轻松的在O(n)的时间复杂度内完成。 此时A[0]存储的是这个数组的最大值，将它与数组的最后一个元素交换位置，然后堆的长度减少1，也就是数组的最后一个元素不再当作堆的元素，因为它已经在正确的位置上了，然后调整堆使之符合最大堆的性质。 重复这个步骤直到所有的元素放到了正确的位置之上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_heap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="keyword">int</span> heap_size,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 不存在这个样的节点（节点从0开始编号）</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt;= heap_size || i &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">auto</span> l = left(i);</span><br><span class="line">    <span class="keyword">auto</span> r = right(i);</span><br><span class="line">    <span class="comment">// 如果没有孩子节点了，不需要调整了</span></span><br><span class="line">    <span class="keyword">if</span>(l &gt;= heap_size ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> maxIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(r &gt;= heap_size )&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &gt;= A[l]) <span class="keyword">return</span>;</span><br><span class="line">        maxIndex = l;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 如果节点i比它两个孩子节点都大，则满足最大堆的性质，不用调整</span></span><br><span class="line">        <span class="keyword">if</span>(A[i] &gt;= A[l] &amp;&amp; A[i] &gt;= A[r]) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 找到两个孩子节点中较大的那一个</span></span><br><span class="line">        A[l] &gt;= A[r] ? maxIndex = l : maxIndex = r;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(A[i],A[maxIndex]);</span><br><span class="line">    max_heap(A,heap_size,maxIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_max_heap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leaf = A.size() / <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = leaf - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; --i) &#123;</span><br><span class="line">        max_heap(A,A.size(),i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_with_max_heap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span>&#123;</span><br><span class="line">    build_max_heap(v);</span><br><span class="line">    <span class="keyword">int</span> heap_size = v.size();</span><br><span class="line">    <span class="keyword">while</span>(heap_size)&#123;</span><br><span class="line">        swap(v[<span class="number">0</span>],v[heap_size<span class="number">-1</span>]);</span><br><span class="line">        heap_size--;</span><br><span class="line">        max_heap(v,heap_size,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆排序的时间性能是nlogn,但是实际使用的时候，快速排序的性能更好一些，一般情况下都是使用快速排序。</p><h2 id="优先队列">优先队列</h2><p>优先队列是能够<code>快速</code>的完成以下操作的数据结构：</p><ol style="list-style-type: decimal"><li>返回最大值</li><li>返回最大值并删除该元素</li><li>将任意一个已在优先队列中的元素增加k.</li><li>插入一个任意值</li></ol><p>能够维护一个数据结构，快速的实现以上所有操作的叫做优先队列。使用堆来实现优先队列，可以保证所有的操作都可以在<code>o(lgn)</code>完成。</p><ol style="list-style-type: decimal"><li>返回最大值</li></ol><p>使用最大堆实现优先队列这种结构，直接返回<code>A[0]</code>就是最大值。</p><ol start="2" style="list-style-type: decimal"><li>返回最大值并删除该元素</li></ol><p>首先输出<code>A[0]</code>, 然后把最后一个元素赋值给<code>A[0]</code>,调整堆使之符合最大堆性质。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxP</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxV = A[<span class="number">0</span>];</span><br><span class="line">    A[<span class="number">0</span>] = A[A.size()<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">int</span> heap_size = A.size()<span class="number">-1</span>;</span><br><span class="line">    max_heap(A,heap_size,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> maxV;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="直接使用stl进行堆操作">直接使用STL进行堆操作</h2><p>C++11 中的STL已经有了堆的各种操作的高效实现，我们可以直接使用。既能减少自己编写出错的概率，也能使得代码更加简洁，效率更高。</p><h3 id="建堆-1">建堆</h3><p><strong>建立最大堆</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// v 是一个无序的数组</span></span><br><span class="line">make_heap(v.begin(),v.end());</span><br><span class="line"><span class="comment">// 或者使用</span></span><br><span class="line">make_heap(v.begin(),v.end(),less&lt;<span class="keyword">int</span>&gt;());</span><br></pre></td></tr></table></figure><p><strong>建立最小堆</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make_heap(v.begin(),v.end(),greater&lt;<span class="keyword">int</span>&gt;());</span><br></pre></td></tr></table></figure><p>make_heap()方法的第三个参数其实可以传入一个函数的实例，表示你怎样比较两个元素。例如我们可以自己实现<code>less</code>方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mless</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a,<span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt;= b;</span><br><span class="line">&#125;</span><br><span class="line">make_heap(v.begin(),v.end(),mless);</span><br><span class="line"></span><br><span class="line"><span class="comment">//小根堆</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mgreater</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a,<span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt;= b;</span><br><span class="line">&#125;</span><br><span class="line">make_heap(v.begin(),v.end(),mgreater);</span><br></pre></td></tr></table></figure><p>当堆中存放的数据不是简单的数字，而是复杂的结构体或者类数据的时候，自定义比较函数就十分有用了，可以自定义依据类中哪个字段生成堆。</p><h3 id="其他与堆有关的操作">其他与堆有关的操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 弹出大根堆的顶部元素，重排堆，注意这个时候顶部元素没有删除，放在了数组的最后</span></span><br><span class="line">pop_heap(v.begin(),v.end(),less&lt;<span class="keyword">int</span>&gt;())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹出小根堆的顶部元素</span></span><br><span class="line">pop_heap(v.begin(),v.end(),greater&lt;<span class="keyword">int</span>&gt;())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把[v.begin(), v.end()-2] 作为大根堆，v.end()-1, 也就是最后一个元素作为插入元素插入到大根堆中，重新调整好顺序</span></span><br><span class="line">push_heap(v.begin(),v.end(),less&lt;<span class="keyword">int</span>&gt;())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入小根堆</span></span><br><span class="line">push_heap(v.begin(),v.end(),less&lt;<span class="keyword">int</span>&gt;())</span><br></pre></td></tr></table></figure><h3 id="优先队列-1">优先队列</h3><p><code>priority_queue&lt;Type, Container, Functional&gt;</code> 实现了优先队列的结构和相应的操作方法，可以用他来实现大根堆，小根堆，优先队列等数据结构。</p><p><strong>大根堆</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="comment">// 或者使用完整的声明形式</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; less&lt;<span class="keyword">int</span>&gt;()&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从无序数组建立大顶堆</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">30</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); ++i) &#123;</span><br><span class="line">    q.push(v[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹出最大元素</span></span><br><span class="line">q.pop()</span><br></pre></td></tr></table></figure><p><strong>小根堆</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从无序数组建立小顶堆</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">30</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); ++i) &#123;</span><br><span class="line">    q.push(v[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹出最大元素</span></span><br><span class="line">q.pop()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法专题_链表2</title>
      <link href="/hexoblog/2017/07/26/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E9%93%BE%E8%A1%A82/"/>
      <url>/hexoblog/2017/07/26/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E9%93%BE%E8%A1%A82/</url>
      
        <content type="html"><![CDATA[<p>【翻转链表】【删除重复元素】【判断有环】【合并链表】【复杂链表的复制】【…】</p><a id="more"></a><h3 id="反转链表"><a href="http://lintcode.com/zh-cn/problem/reverse-linked-list/" target="_blank" rel="noopener">反转链表</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1. 如果是空链表，或者只有一个元素，直接返回头节点</span></span><br><span class="line"><span class="comment">* 2. pre --&gt; head, iter --&gt; head-&gt;next, pre-&gt;next = nullptr;</span></span><br><span class="line"><span class="comment">* pre 指向第一个元素，iter指向第二个节点(可能为空，为空说明到达了链表的结尾)，断开前两个节点之间的连接</span></span><br><span class="line"><span class="comment">* 3. while(iter!=nullptr) 转换pre iter指向的节点的连接。</span></span><br><span class="line"><span class="comment">* 首先用一个新的节点变量存储iter的下一个节点信息，node = iter-&gt;next</span></span><br><span class="line"><span class="comment">* iter-&gt;next = pre;</span></span><br><span class="line"><span class="comment">* pre = iter;</span></span><br><span class="line"><span class="comment">* iter = node;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">ListNode *<span class="title">reverse</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode* pre = head;</span><br><span class="line">    ListNode* iter = head-&gt;next;</span><br><span class="line">    pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(iter)&#123;</span><br><span class="line">        ListNode* next = iter-&gt;next;</span><br><span class="line">        iter-&gt;next = pre;</span><br><span class="line">        pre = iter;</span><br><span class="line">        iter = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="局部翻转链表"><a href="http://lintcode.com/zh-cn/problem/reverse-linked-list-ii/" target="_blank" rel="noopener">局部翻转链表</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode * <span class="title">reverseBetween</span><span class="params">(ListNode * head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 翻转从m到n之间的链表，连接在原来的链表上</span></span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next || m &lt;=<span class="number">0</span> || n &lt;=<span class="number">0</span> || m &gt;= n) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// 1. 增加一个头节点</span></span><br><span class="line">    ListNode* g = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    g-&gt;next = head;</span><br><span class="line">    head = g;</span><br><span class="line"></span><br><span class="line">    ListNode* pre_start = head;</span><br><span class="line">    ListNode* end_next = head;</span><br><span class="line">    <span class="comment">// 1. 找到第m个节点的前一个节点</span></span><br><span class="line">    m = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(pre_start &amp;&amp; m--)&#123;</span><br><span class="line">        pre_start = pre_start-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 找到第n个节点的后一个节点</span></span><br><span class="line">    n = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(end_next &amp;&amp; n--)&#123;</span><br><span class="line">        end_next = end_next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(m &gt;<span class="number">0</span> || n&gt;<span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 翻转m 到 n之间的链表</span></span><br><span class="line">    ListNode* stmp = pre_start-&gt;next;</span><br><span class="line">    ListNode* start = pre_start-&gt;next;</span><br><span class="line">    ListNode* end = start-&gt;next;</span><br><span class="line">    start-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(end != end_next)&#123;</span><br><span class="line">        ListNode* tmp = end-&gt;next;</span><br><span class="line">        end-&gt;next = start;</span><br><span class="line">        start = end;</span><br><span class="line">        end = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 连接到原来的链表上</span></span><br><span class="line">    pre_start-&gt;next = start;</span><br><span class="line">    stmp-&gt;next = end;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="k组翻转链表"><a href="http://lintcode.com/zh-cn/problem/reverse-nodes-in-k-group/" target="_blank" rel="noopener">K组翻转链表</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">reverseKGroup</span><span class="params">(ListNode *head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每K个节点翻转一下链表</span></span><br><span class="line">    <span class="keyword">if</span>(!head || k &lt;= <span class="number">1</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// 增加一个头节点</span></span><br><span class="line">    ListNode* g = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    g-&gt;next = head;</span><br><span class="line">    head = g;</span><br><span class="line"></span><br><span class="line">    ListNode* pre_start = head;</span><br><span class="line">    ListNode* end_next = head;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">// 1. 找到第K个节点的下一个节点</span></span><br><span class="line">        <span class="keyword">int</span> cc = k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(end_next &amp;&amp; cc--)&#123;</span><br><span class="line">            end_next = end_next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cc &gt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 不足K个节点的部分不翻转</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 翻转K个节点</span></span><br><span class="line">        ListNode* start = pre_start-&gt;next;</span><br><span class="line">        ListNode* stmp = pre_start-&gt;next;</span><br><span class="line">        ListNode* end = start-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(end &amp;&amp; end != end_next)&#123;</span><br><span class="line">            ListNode* tmp = end-&gt;next;</span><br><span class="line">            end-&gt;next = start;</span><br><span class="line">            start = end;</span><br><span class="line">            end = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 连接到原来的链表</span></span><br><span class="line">        pre_start-&gt;next = start;</span><br><span class="line">        stmp-&gt;next = end_next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 维护pre_start, end_start在正确的位置上，执行下一次循环</span></span><br><span class="line">        pre_start = end_next = stmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除链表中倒数第n个节点"><a href="http://lintcode.com/zh-cn/problem/remove-nth-node-from-end-of-list/#" target="_blank" rel="noopener">删除链表中倒数第n个节点</a></h3><p>使用两个指针，遍历一遍链表就能解决；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  删除倒数第K个节点，我们需要找到倒数第K+1个节点</span></span><br><span class="line"><span class="comment">* 1. 设链表的长度是n, 1&lt;=k&lt;=n</span></span><br><span class="line"><span class="comment">* 2. 用两个间隔是K的指针，当第二个指针指向链表的null元素的时候，第一个指针指向导数第K+1个节点</span></span><br><span class="line"><span class="comment">* 3. 在链表的第一个节点的前面添加一个节点guard; first --&gt; guard</span></span><br><span class="line"><span class="comment">* 4. second = guard-&gt;next; second向后移动K步，如果在K大于0的时候循环结束，表示没有导数第K个元素，返回原来的链表</span></span><br><span class="line"><span class="comment">* 循环退出的时候，first 和second间隔K个节点，此时同时移动first second, second到达链表结尾的时候，first指向导数第K+1个节点，</span></span><br><span class="line"><span class="comment">* 5. 删除节点： first-&gt;next = first-&gt;next-&gt;next;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">ListNode *<span class="title">removeNthFromEnd</span><span class="params">(ListNode *head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode *g = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    g-&gt;next = head;</span><br><span class="line">    head = g;</span><br><span class="line">    ListNode* first = g;</span><br><span class="line">    ListNode* second = g-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(second &amp;&amp; n--)&#123;</span><br><span class="line">        second = second -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>) <span class="keyword">return</span> head-&gt;next; <span class="comment">// n超过了链表的长度</span></span><br><span class="line">    <span class="keyword">while</span>(second)&#123;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        second = second-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    first-&gt;next = first-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断链表是否有环"><a href="http://lintcode.com/zh-cn/problem/linked-list-cycle/" target="_blank" rel="noopener">判断链表是否有环</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1. head=null 或者 head-&gt;next = null，肯定无环</span></span><br><span class="line"><span class="comment">* 2. first = second = head;</span></span><br><span class="line"><span class="comment">* 3. do&#123;&#125;while();  first == second时候循环结束，说明链表有环；</span></span><br><span class="line"><span class="comment">* 4. 一旦找到环，把first = head, 然后一步一步的移动first second, 再次相遇的地方就是环的入口。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ListNode* first = head;</span><br><span class="line">    ListNode* second = head;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        second = second-&gt;next-&gt;next;</span><br><span class="line">    &#125;<span class="keyword">while</span>(first &amp;&amp; second &amp;&amp; second-&gt;next &amp;&amp; second != first);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!first || !second || !second-&gt;next) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 找到入口节点</span></span><br><span class="line">    first = head;</span><br><span class="line">    <span class="keyword">while</span>(first != second)&#123;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        second = second-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断链表是否相交"><a href="http://lintcode.com/zh-cn/problem/intersection-of-two-linked-lists/" target="_blank" rel="noopener">判断链表是否相交</a></h3><p>两种思路： 一种先遍历一遍两个链表，得出每个链表的长度，将尾部对其，判断</p><p>另外一种，将一个链表的尾部连接到其头结点，从另外一个链表的头节点开始遍历，转换成判断链表是否有环的问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head,ListNode* &amp;enter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next || !head-&gt;next-&gt;next) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ListNode* first = head;</span><br><span class="line">    ListNode* second = head;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        second = second-&gt;next-&gt;next;</span><br><span class="line">    &#125;<span class="keyword">while</span>(first &amp;&amp; second &amp;&amp; second-&gt;next &amp;&amp; first != second);</span><br><span class="line">    <span class="keyword">if</span>(!first || !second || !second-&gt;next) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 找到入口节点</span></span><br><span class="line">    first = head;</span><br><span class="line">    <span class="keyword">while</span>(first != second)&#123;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        second = second-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    enter = first;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!headA || !headB) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* iterA = headA;</span><br><span class="line">    <span class="keyword">while</span>(iterA-&gt;next !=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        iterA = iterA-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    iterA-&gt;next = headA;</span><br><span class="line">    ListNode* enter;</span><br><span class="line">    hasCycle(headB,enter);</span><br><span class="line">    <span class="keyword">return</span> enter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并k个排序的链表"><a href="http://lintcode.com/zh-cn/problem/merge-k-sorted-lists/" target="_blank" rel="noopener">合并K个排序的链表</a></h3><ol style="list-style-type: decimal"><li><p>第一方法，用一个数组保存K个链表的头指针，每次都比较K个元素的大小，选出最小的元素，链接到新的链表的结尾，然后该链表向下一个节点移动一位。</p></li><li><p>利用上面的思路，每次都要从K个元素中选择最小的元素，可以使用一个K个元素的最小堆实现，降低时间复杂度。</p></li><li><p>利用归并的思想，两两合并；</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次找出最小值的方式</span></span><br><span class="line"> <span class="function">ListNode *<span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode *&gt; &amp;lists)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    ListNode* guard = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode* head = guard;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// current 指向K个链表的头指针</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;ListNode*&gt; currents;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> link : lists)&#123;</span><br><span class="line">        <span class="keyword">if</span>(link != <span class="literal">nullptr</span>)</span><br><span class="line">            currents.push_back(link);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!currents.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> minV = INT32_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; currents.size();++i)&#123;</span><br><span class="line">            <span class="comment">// 去掉已经为空的链表</span></span><br><span class="line">            <span class="keyword">if</span>(currents[i] == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                currents.erase(currents.begin()+i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(currents[i]-&gt;val &lt; minV)&#123;</span><br><span class="line">                index = i;</span><br><span class="line">                minV = currents[i]-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        guard-&gt;next = currents[index];</span><br><span class="line">        guard = guard-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(currents[index]-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">            currents[index] = currents[index]-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            currents.erase(currents.begin()+index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方法， 最小堆</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二种方法， 最小堆</span></span><br><span class="line"><span class="function">ListNode *<span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode *&gt; &amp;lists)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;ListNode*,<span class="built_in">vector</span>&lt;ListNode*&gt;,bigger&gt; minHeap;</span><br><span class="line">    <span class="keyword">if</span>(lists.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lists.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists[i]) minHeap.push(lists[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *head = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *iter = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(!minHeap.empty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            head = minHeap.top();</span><br><span class="line">            iter = head;</span><br><span class="line">            <span class="keyword">if</span>(minHeap.top()-&gt;next)&#123;</span><br><span class="line">                minHeap.push(minHeap.top()-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">            minHeap.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            iter-&gt;next = minHeap.top();</span><br><span class="line">            iter = iter-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(minHeap.top()-&gt;next)&#123;</span><br><span class="line">                minHeap.push(minHeap.top()-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">            minHeap.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三种方法,归并排序的方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第三种方法,归并排序的方式</span></span><br><span class="line"><span class="comment">// 通过调用合并两个排序链表的方式实现</span></span><br><span class="line"><span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    ListNode* guard = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode* head = guard;</span><br><span class="line">    <span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &gt; l2-&gt;val)&#123;</span><br><span class="line">            guard-&gt;next = l2;</span><br><span class="line">            guard = guard-&gt;next;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            guard-&gt;next = l1;</span><br><span class="line">            guard = guard-&gt;next;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l1)&#123;</span><br><span class="line">        guard-&gt;next = l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l2)&#123;</span><br><span class="line">        guard-&gt;next = l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode *<span class="title">mergeKLists</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;ListNode *&gt; &amp;lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lists.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(lists.size() == <span class="number">1</span>) <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(lists.size() == <span class="number">2</span>) <span class="keyword">return</span> mergeTwoLists(lists[<span class="number">0</span>],lists[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> n = lists.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;ListNode*&gt; left((n+<span class="number">1</span>)/<span class="number">2</span>),right(n-(n+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">    copy(lists.begin(),lists.begin()+(n+<span class="number">1</span>)/<span class="number">2</span>,left.begin());</span><br><span class="line">    copy(lists.begin()+(n+<span class="number">1</span>)/<span class="number">2</span>,lists.end(),right.begin());</span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(mergeKLists(left),mergeKLists(right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面采用的是自顶向下的递归归并的方式，下面采用非递归的自底向上的方法来实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的实现一个数据的归并求和</span></span><br><span class="line"><span class="comment">// 自底向上归并</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> end = v.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(end &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span>(end == <span class="number">0</span>) <span class="keyword">return</span> v[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(end &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=end;i+=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span> &lt;= end)&#123;</span><br><span class="line">                v[index] = add(v[i],v[i+<span class="number">1</span>]);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                v[index] = v[i];</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        end = index - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode *&gt; &amp;lists)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(lists.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(lists.size() == <span class="number">1</span>) <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(lists.size() == <span class="number">2</span>) <span class="keyword">return</span> mergeTwoLists(lists[<span class="number">0</span>],lists[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> end = lists.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(end &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=end;i+=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span> &lt;= end)&#123;</span><br><span class="line">                lists[index] = mergeTwoLists(lists[i],lists[i+<span class="number">1</span>]);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                lists[index] = lists[i];</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        end = index - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带随机指针链表的复制复杂链表的复制"><a href="http://lintcode.com/zh-cn/problem/copy-list-with-random-pointer/" target="_blank" rel="noopener">带随机指针链表的复制|复杂链表的复制</a></h3><p>使用O（1）的额外空间完成链表的复制，基本思路是把拷贝的新节点链接在原来节点的后面，设置完随机指针之后再断开与原来旧链表的连接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">if</span>(!head) <span class="keyword">return</span> head;</span><br><span class="line">    RandomListNode* iter = head;</span><br><span class="line">    <span class="comment">// 1. 复制每个节点连接在原来节点的后面</span></span><br><span class="line">    <span class="keyword">while</span>(iter)&#123;</span><br><span class="line">        RandomListNode* node = <span class="keyword">new</span> RandomListNode(iter-&gt;label);</span><br><span class="line">        node-&gt;next = iter-&gt;next;</span><br><span class="line">        iter-&gt;next = node;</span><br><span class="line">        iter = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 设置随机指针</span></span><br><span class="line">    RandomListNode* newHead = head-&gt;next;</span><br><span class="line">    head-&gt;next-&gt;random = head-&gt;random==<span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : head-&gt;random-&gt;next;</span><br><span class="line">    iter = newHead-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(iter)&#123;</span><br><span class="line">        RandomListNode* next = iter-&gt;next-&gt;next;</span><br><span class="line">        iter-&gt;next-&gt;random = iter-&gt;random == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : iter-&gt;random-&gt;next;</span><br><span class="line">        iter = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 断开和旧链表的连接</span></span><br><span class="line">    iter = newHead;</span><br><span class="line">    <span class="keyword">while</span>(iter-&gt;next)&#123;</span><br><span class="line">        iter-&gt;next = iter-&gt;next-&gt;next;</span><br><span class="line">        iter = iter-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除链表元素"><a href="http://lintcode.com/zh-cn/problem/remove-linked-list-elements/" target="_blank" rel="noopener">删除链表元素</a></h3><p>删除链表节点为某个值的所有元素。(某个值可能有多个，也可能全部都是)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">removeElements</span><span class="params">(ListNode *head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Write your code here</span></span><br><span class="line">       ListNode *guard=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">       guard-&gt;next = head;</span><br><span class="line">       head = guard;</span><br><span class="line"></span><br><span class="line">       ListNode *pre = guard;</span><br><span class="line">       ListNode *tmp = guard-&gt;next;</span><br><span class="line">       <span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">           <span class="keyword">if</span>(tmp-&gt;val == val)&#123;</span><br><span class="line">               pre-&gt;next = tmp-&gt;next;</span><br><span class="line">               tmp = tmp-&gt;next;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               pre = tmp;</span><br><span class="line">               tmp = tmp -&gt; next;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>不使用哨兵的方法，在要求不使用额外空间的时候可以用这种方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">removeElements</span><span class="params">(ListNode *head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Write your code here</span></span><br><span class="line">       <span class="comment">// 删除链表中等于给定值val的所有节点</span></span><br><span class="line">       <span class="keyword">while</span>(head &amp;&amp; head-&gt;val == val)&#123;</span><br><span class="line">           head = head-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">       ListNode *pre = head;</span><br><span class="line">       ListNode *c = head-&gt;next; <span class="comment">// 头结点已经不可能==val了，因为前面已经删除了</span></span><br><span class="line">       <span class="keyword">while</span>(c)&#123;</span><br><span class="line">           <span class="keyword">if</span>(c-&gt;val == val)&#123;</span><br><span class="line">               pre-&gt;next = c-&gt;next;</span><br><span class="line">               c-&gt;next= <span class="literal">nullptr</span>;</span><br><span class="line">               c = pre-&gt;next;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               pre = c;</span><br><span class="line">               c = c-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在o1时间复杂度删除链表节点"><a href="http://lintcode.com/zh-cn/problem/delete-node-in-the-middle-of-singly-linked-list/" target="_blank" rel="noopener">在O(1)时间复杂度删除链表节点</a></h3><p>思路：给出要删除的节点，是不可能在O(1)的时间内删除该节点的，因为想要删除该节点，必须找到它前面的节点，这个操作只能从头遍历(在没有指向前面的指针的情况下)，复杂度不可能是O(1). 但是可以把要删除的节点后面的节点的值赋给要删除的节点，再删除要删除的节点后面的节点，这样’看起来’好像删除了当前的节点。实际上在计算机内存中真正的变化是要删除的节点的值变成了它后面节点的值.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode *node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除排序链表中的重复元素"><a href="http://lintcode.com/zh-cn/problem/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">删除排序链表中的重复元素</a></h3><p>给定一个排序链表，删除所有重复的元素每个重复元素只留下一个。</p><p>遇到不同的元素的时候再删除。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">deleteDuplicates</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *pre = head;</span><br><span class="line">        ListNode *current = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(current)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre-&gt;val == current-&gt;val)&#123;</span><br><span class="line">                current = current-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pre-&gt;next = current;</span><br><span class="line">                pre = current;</span><br><span class="line">                current = current-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 链表结尾有重复元素的情况</span></span><br><span class="line">        pre-&gt;next = current;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦遇到相同的元素就删除。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">deleteDuplicates</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 给定一个排序链表，删除所有重复的元素每个元素只留下一个。</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next-&gt;next == <span class="literal">nullptr</span> &amp;&amp; head-&gt;val == head-&gt;next-&gt;val) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        ListNode *pre = head;</span><br><span class="line">        ListNode *c = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(c)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre-&gt;val == c-&gt;val)&#123;</span><br><span class="line">                pre-&gt;next = c-&gt;next;</span><br><span class="line">                c = c-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">                c = c-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除排序链表中的重复元素2"><a href="http://lintcode.com/zh-cn/problem/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">删除排序链表中的重复元素2</a></h3><p>给定一个排序链表，删除所有重复的元素只留下原链表中没有重复的元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode * <span class="title">deleteDuplicates</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//给定一个排序链表，删除所有重复的元素只留下原链表中没有重复的元素。</span></span><br><span class="line">       ListNode *guard = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">       guard-&gt;next = head;</span><br><span class="line">       head = guard;</span><br><span class="line"></span><br><span class="line">       ListNode *pre = guard;</span><br><span class="line">       ListNode *start = guard-&gt;next;</span><br><span class="line">       ListNode *end = guard-&gt;next;</span><br><span class="line">       <span class="keyword">while</span>(end)&#123;</span><br><span class="line">           <span class="keyword">while</span>(end &amp;&amp; start-&gt;val == end-&gt;val)&#123;</span><br><span class="line">               end = end-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(start-&gt;next == end)&#123;</span><br><span class="line">               pre = start;</span><br><span class="line">               start = end;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               pre-&gt;next = end;</span><br><span class="line">               start = end;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不使用哨兵节点的方案</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode * <span class="title">deleteDuplicates</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//给定一个排序链表，删除所有重复的元素只留下原链表中没有重复的元素。</span></span><br><span class="line">    ListNode *pre = head;</span><br><span class="line">    ListNode *start = head;</span><br><span class="line">    ListNode *end = head;</span><br><span class="line">    <span class="keyword">while</span>(end)&#123;</span><br><span class="line">        <span class="keyword">while</span>(end &amp;&amp; start-&gt;val == end-&gt;val)&#123;</span><br><span class="line">            end = end-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(start-&gt;next == end)&#123;</span><br><span class="line">            pre = start;</span><br><span class="line">            start = end;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre == start &amp;&amp; pre == head)&#123;</span><br><span class="line">                head = end;</span><br><span class="line">                pre = end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    pre-&gt;next = end;</span><br><span class="line">            start = end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除单向链表中倒数第k个节点">删除单向链表中倒数第K个节点</h3><p>例如：<code>head--&gt;1--&gt;2--&gt;3--&gt;4--&gt;5--&gt;6</code> K=2 返回：<code>head--&gt;1--&gt;2--&gt;3--&gt;4--&gt;6</code></p><p>思路一： 先遍历一遍链表，统计链表有多少个元素。然后就可以知道倒数第K个元素就是 正数第n-k+1个元素，从head开始移动指针，移动n-k次就是要删除的节点。 删除一个节点，只需要把原来指向这个元素的指针指向它后面的元素就可以了。所以我们要做的 操作就是从head开始，移动n-k-1次，找到要删除的节点前面的节点a,然后执行a-&gt;next = a-&gt;next-&gt;next</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">removeNthFromEnd</span><span class="params">(ListNode *head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    ListNode *tmp = head;</span><br><span class="line">    <span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">        len ++;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len &lt; n) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(len == n) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line"></span><br><span class="line">    tmp = head;</span><br><span class="line">    <span class="keyword">int</span> count = len + <span class="number">1</span> - n  ;<span class="comment">// 正数第count个节点</span></span><br><span class="line">    count = count - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(count--)&#123;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp-&gt;next = tmp-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：使用两个间隔K个元素的指针遍历一遍链表，当前面的指针走到尾节点的时候，后面的节点指向的就是倒数第K个节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">removeNthFromEnd</span><span class="params">(ListNode *head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *first = head;</span><br><span class="line">    ListNode *second = head;</span><br><span class="line">    <span class="keyword">int</span> count = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(first &amp;&amp; count--)&#123;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(first == <span class="literal">nullptr</span>) <span class="keyword">return</span> head-&gt;next; <span class="comment">// 删除第一个节点</span></span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 没有导数第n个节点</span></span><br><span class="line">    <span class="keyword">while</span>(first)&#123;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        second = second-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    second-&gt;next = second-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找链表的中间节点">查找链表的中间节点</h3><p>思路： 设置两个指针同时指向头部，一个指针每次移动两步，一个指针每次移动一步，这样在快的指针走到尽头的时候，慢的指针恰好走到了中部。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 找到链表的中间节点并返回</span></span><br><span class="line"><span class="comment"> * @param head</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ListNode* <span class="title">findMiddle</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *first = head, *second = head;</span><br><span class="line">    <span class="keyword">while</span>(second-&gt;next &amp;&amp; second-&gt;next-&gt;next)&#123;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        second = second-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序使用单链表实现">插入排序（使用单链表实现）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">insertionSortList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用链表实现插入排序</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    ListNode *guard = <span class="keyword">new</span> ListNode(INT32_MIN);</span><br><span class="line">    guard-&gt;next = head;</span><br><span class="line">    head = guard;</span><br><span class="line"></span><br><span class="line">    ListNode *sorted = guard;</span><br><span class="line">    ListNode *ends = guard-&gt;next;</span><br><span class="line">    ListNode *unsorted = ends-&gt;next;</span><br><span class="line">    ends-&gt;next = <span class="literal">nullptr</span>; <span class="comment">// 链表断开</span></span><br><span class="line">    <span class="keyword">while</span>(unsorted)&#123;</span><br><span class="line">        <span class="comment">// 找到插入的位置</span></span><br><span class="line">        <span class="keyword">while</span>(sorted != ends)&#123;</span><br><span class="line">            <span class="keyword">if</span>(unsorted-&gt;val &gt;= sorted-&gt;val &amp;&amp; unsorted-&gt;val &lt; sorted-&gt;next-&gt;val)&#123;</span><br><span class="line">                <span class="comment">// 插入到iter1后面</span></span><br><span class="line">                ListNode *tmp = unsorted;</span><br><span class="line">                unsorted = unsorted-&gt;next;</span><br><span class="line">                tmp-&gt;next = sorted-&gt;next;</span><br><span class="line">                sorted-&gt;next = tmp;</span><br><span class="line">                sorted = guard;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sorted = sorted-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sorted == ends &amp;&amp; unsorted-&gt;val &gt;= ends-&gt;val)&#123;</span><br><span class="line">            ends-&gt;next = unsorted;</span><br><span class="line">            unsorted = unsorted-&gt;next;</span><br><span class="line">            ends = ends-&gt;next;</span><br><span class="line">            ends-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            sorted = guard;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序单链表实现">快速排序(单链表实现)</h3><p>快速排序一般的思想是首尾两个指针相向运动，但是单链表没有向前的指针，这要求我们换一种思路。如何从前往后遍历找到支点的位置。假设支点的值是value. 我们需要遍历一遍链表，使得所有小于value的值都在前面，所有大于value的值都在后面，这个时候就找到的value应该在的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单链表实现快排</span></span><br></pre></td></tr></table></figure><h3 id="交换链表当中两个节点"><a href="http://lintcode.com/zh-cn/problem/swap-two-nodes-in-linked-list/" target="_blank" rel="noopener">交换链表当中两个节点</a></h3><p>给你一个链表以及两个权值v1和v2，交换链表中权值为v1和v2的这两个节点。保证链表中节点权值各不相同，如果没有找到对应节点，那么什么也不用做。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">swapNodes</span><span class="params">(ListNode* head, <span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Write your code here</span></span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add a guard</span></span><br><span class="line">    ListNode *guard = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    guard-&gt;next = head;</span><br><span class="line">    head = guard;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//search the value</span></span><br><span class="line">    ListNode *pre_v1=<span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *pre_v2=<span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *pre_tmp=guard;</span><br><span class="line">    ListNode *tmp=pre_tmp-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp-&gt;val==v1)&#123;</span><br><span class="line">            pre_v1 = pre_tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp-&gt;val==v2)&#123;</span><br><span class="line">            pre_v2 = pre_tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        pre_tmp = tmp;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// not find v1 or v2</span></span><br><span class="line">    <span class="keyword">if</span>(pre_v1==<span class="literal">nullptr</span> || pre_v2==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// swap the two nodes</span></span><br><span class="line">    ListNode *v1s = pre_v1-&gt;next;</span><br><span class="line">    ListNode *v2s = pre_v2-&gt;next;</span><br><span class="line">    ListNode *next_v1 = v1s-&gt;next;</span><br><span class="line">    ListNode *next_v2 = v2s-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pre_v1 == v2s)&#123;</span><br><span class="line">        pre_v2-&gt;next = v1s;</span><br><span class="line">        v1s-&gt;next = v2s;</span><br><span class="line">        v2s-&gt;next = next_v1;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pre_v2 == v1s)&#123;</span><br><span class="line">        pre_v1-&gt;next = v2s;</span><br><span class="line">        v2s-&gt;next = v1s;</span><br><span class="line">        v1s-&gt;next = next_v2;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        v1s-&gt;next = next_v2;</span><br><span class="line">        v2s-&gt;next = next_v1;</span><br><span class="line">        pre_v1-&gt;next = v2s;</span><br><span class="line">        pre_v2-&gt;next = v1s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两两交换链表中的节点"><a href="http://lintcode.com/zh-cn/problem/swap-nodes-in-pairs/" target="_blank" rel="noopener">两两交换链表中的节点</a></h3><p>给一个链表，两两交换其中的节点，然后返回交换后的链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Write your code here</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode *guard = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        guard-&gt;next = head;</span><br><span class="line">        head = guard;</span><br><span class="line"></span><br><span class="line">        ListNode *pres1 = guard;</span><br><span class="line">        ListNode *s1 = guard-&gt;next;</span><br><span class="line">        ListNode *s2 = guard-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(s1!=<span class="literal">nullptr</span> &amp;&amp; s2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            pres1-&gt;next = s2;</span><br><span class="line">            s1-&gt;next = s2-&gt;next;</span><br><span class="line">            s2-&gt;next = s1;</span><br><span class="line">            <span class="keyword">if</span>(s1-&gt;next==<span class="literal">nullptr</span> || s1-&gt;next-&gt;next==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pres1 = s1;</span><br><span class="line">                s1 = s1-&gt;next;</span><br><span class="line">                s2 = s2-&gt;next-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="旋转链表"><a href="http://lintcode.com/zh-cn/problem/rotate-list/" target="_blank" rel="noopener">旋转链表</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">rotateRight</span><span class="params">(ListNode *head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//给定一个链表，旋转链表，使得每个节点向右移动k个位置，其中k是一个非负数</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span> || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *end = head;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(end-&gt;next)&#123;</span><br><span class="line">        end = end-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    k = k % len;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">int</span> index = (len - <span class="number">1</span> - k) % len;</span><br><span class="line">    ListNode *tmp = head;</span><br><span class="line">    <span class="keyword">while</span>(tmp &amp;&amp; index --)&#123;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(index == <span class="number">-1</span>)&#123;</span><br><span class="line">        end-&gt;next = head;</span><br><span class="line">        head = tmp-&gt;next;</span><br><span class="line">        tmp-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="首尾交错重排链表"><a href="http://lintcode.com/zh-cn/problem/reorder-list/" target="_blank" rel="noopener">首尾交错重排链表</a></h3><p>给定一个单链表L: L0→L1→…→Ln-1→Ln,重新排列后为：L0→Ln→L1→Ln-1→L2→Ln-2→…必须在不改变节点值的情况下进行原地操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 找到链表的中间节点并返回</span></span><br><span class="line"><span class="comment"> * @param head</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ListNode* <span class="title">findMiddle</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *first = head, *second = head;</span><br><span class="line">    <span class="keyword">while</span>(second-&gt;next &amp;&amp; second-&gt;next-&gt;next)&#123;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        second = second-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反转链表</span></span><br><span class="line"><span class="comment"> * @param head</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ListNode *<span class="title">reverse</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *iter =head;</span><br><span class="line">    ListNode *next_iter = head-&gt;next;</span><br><span class="line">    iter-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(next_iter)&#123;</span><br><span class="line">        ListNode *tmp = next_iter-&gt;next;</span><br><span class="line">        next_iter-&gt;next = iter;</span><br><span class="line">        iter = next_iter;</span><br><span class="line">        next_iter = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    head = iter;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交叉合并两个链表</span></span><br><span class="line"><span class="comment"> * @param l1</span></span><br><span class="line"><span class="comment"> * @param l2</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果其中一个链表为空，直接返回另外一个链表就是结果</span></span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span>(l2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l1;</span><br><span class="line">    ListNode *head = l1;</span><br><span class="line">    l1 = l1-&gt;next;</span><br><span class="line">    ListNode *iter = head;</span><br><span class="line">    <span class="keyword">bool</span> odd = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="literal">nullptr</span> || l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!odd)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l2)&#123;</span><br><span class="line">                iter-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">                iter = iter-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(odd)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1)&#123;</span><br><span class="line">                iter-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">                iter = iter-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        odd = !odd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">reorderList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// 给定一个单链表L: L0→L1→…→Ln-1→Ln,重新排列后为：L0→Ln→L1→Ln-1→L2→Ln-2→…必须在不改变节点值的情况下进行原地操作</span></span><br><span class="line">    <span class="comment">// 找到中间节点， 反转后半段，然后交叉拼接起来，可以确保不适用额外的空间</span></span><br><span class="line">    ListNode* middle = findMiddle(head);</span><br><span class="line">    ListNode* head2 = reverse(middle-&gt;next);</span><br><span class="line">    middle-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    head = mergeTwoLists(head,head2);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回文链表"><a href="http://lintcode.com/zh-cn/problem/palindrome-linked-list/" target="_blank" rel="noopener">回文链表</a></h3><p>判断一个链表中的值是否是回文</p><p>找到中间节点，把后面的链表反转，然后与前面的逐个节点比较，如果完全一样或者只有最后一个节点不一样，则是回文的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Write your code here</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    ListNode *middle = findMiddle(head);</span><br><span class="line">    ListNode *head2 = reverse(middle-&gt;next);</span><br><span class="line">    middle-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *iter1 = head, *iter2 = head2;</span><br><span class="line">    <span class="keyword">while</span>(iter1 &amp;&amp; iter2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(iter1-&gt;val != iter2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        iter1 = iter1-&gt;next;</span><br><span class="line">        iter2 = iter2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(iter1 &amp;&amp; iter1-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(iter2 &amp;&amp; iter2-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(iter1 == <span class="literal">nullptr</span> &amp;&amp; iter2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表求和"><a href="http://lintcode.com/zh-cn/problem/add-two-numbers/" target="_blank" rel="noopener">链表求和</a></h3><p>你有两个用链表代表的整数，其中每个节点包含一个数字。数字存储按照在原来整数中相反的顺序，使得第一个数字位于链表的开头。写出一个函数将两个整数相加，用链表形式返回和。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">addLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span>(l2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="comment">// 链表求和</span></span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    ListNode *head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode *iter = head;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        number = (l1-&gt;val + l2-&gt;val + carry ) % <span class="number">10</span> ;</span><br><span class="line">        carry = (l1-&gt;val + l2-&gt;val + carry ) / <span class="number">10</span> ;</span><br><span class="line">        ListNode *node = <span class="keyword">new</span> ListNode(number);</span><br><span class="line">        iter-&gt;next = node;</span><br><span class="line">        iter = iter-&gt;next;</span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">        l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l1)&#123;</span><br><span class="line">        number = (l1-&gt;val + carry) % <span class="number">10</span>;</span><br><span class="line">        carry = (l1-&gt;val + carry) / <span class="number">10</span>;</span><br><span class="line">        ListNode *node = <span class="keyword">new</span> ListNode(number);</span><br><span class="line">        iter-&gt;next = node;</span><br><span class="line">        iter = iter-&gt;next;</span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l2)&#123;</span><br><span class="line">        number = (l2-&gt;val + carry) % <span class="number">10</span>;</span><br><span class="line">        carry = (l2-&gt;val + carry) / <span class="number">10</span>;</span><br><span class="line">        ListNode *node = <span class="keyword">new</span> ListNode(number);</span><br><span class="line">        iter-&gt;next = node;</span><br><span class="line">        iter = iter-&gt;next;</span><br><span class="line">        l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry)&#123;</span><br><span class="line">        ListNode *node = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        iter-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表求和-ii"><a href="http://lintcode.com/zh-cn/problem/add-two-numbers-ii/#" target="_blank" rel="noopener">链表求和 II</a></h3><p>假定用一个链表表示两个数，其中每个节点仅包含一个数字。假设这两个数的数字顺序排列，请设计一种方法将两个数相加，并将其结果表现为链表的形式。</p><p>先翻转链表，求和，在翻转回去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">addLists2</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reverse(addLists(reverse(l1),reverse(l2)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英语</title>
      <link href="/hexoblog/2017/07/24/%E6%8A%80%E6%9C%AF/%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD/%E6%9C%AF%E8%AF%AD/"/>
      <url>/hexoblog/2017/07/24/%E6%8A%80%E6%9C%AF/%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD/%E6%9C%AF%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<p>英语语言方面相关的内容，包括专业术语，缩写，常用短语，小故事。 <a id="more"></a></p><h2 id="常用短语">常用短语</h2><ol style="list-style-type: decimal"><li>提供极有用的信息 – provide invalueable information</li><li>右利手的被试 – right-handed participants</li><li>构建于Matlab内部的 – with in-house MATLAB scripts</li><li>提供机制方面的解释能力 – afford mechanistic interpretability</li><li>相比于传统的方法 – over conventional method</li><li>外部的|内部的 – extrinsic|intrinsic</li><li>把…归因为… – ascribes</li><li>变量未知和随机 – unknown and stochastic</li><li>在括号里的 – in brackets</li></ol><h2 id="广告">广告</h2><p><strong>DAU</strong>, dailyactive user, 日活跃用户</p><p><strong>MAU</strong>, monthactive user, 月活跃用户</p><p><strong>CPM</strong>, cost per mille, 前人展现成本，按照看到的人数付费。</p><p><strong>CPC</strong>, cost per click, 按照点击广告的用户数量付费。</p><p><strong>CPA</strong>, cost per action, 按照回应付费，即用户不仅仅点击了广告，还回应了(注册、互动、下载、下单、购买)。</p><p><strong>pv</strong>, pageview, 页面浏览量或点击量</p><p><strong>uv</strong>, uniquevisitor,统计访问网站的不同IP数量</p><h2 id="其他">其他</h2><p><strong>IP</strong>, intellectual property, 知识产权</p><p><strong>ACG</strong>, animation, comic, game, 动画，漫画，游戏</p><p><strong>KOL</strong>, key opinion leader, 有话语权的人</p><p><strong>UGC</strong>, user generated content, 用户生成内容</p><p><strong>TMT</strong>, technology, media, telecom, 数字新媒体。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 专业术语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Visual Studio Code使用技巧</title>
      <link href="/hexoblog/2017/07/24/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8BIDE/VSCode/Visual-Studio-Code%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/hexoblog/2017/07/24/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8BIDE/VSCode/Visual-Studio-Code%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>Visual Studio Code 是微软出的一个文本编辑工具，与SublimeText, Atom, Vim定位是一样的，都是带扩展功能的文本编辑器，可以安装多种扩张插件，实现IDE的功能。</p><a id="more"></a><p>Visual Studio Code 与Atom相比，最大的优点就是响应速度快，如果使用Windows系统，Visual Studio Code无疑是首选。使用习惯与Atom, SumlimeText都是一样的。</p><p>安装地址：<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">VSCode</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工具 </category>
          
          <category> 编程IDE </category>
          
          <category> VSCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_Numpy使用技巧</title>
      <link href="/hexoblog/2017/07/23/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-Numpy%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/hexoblog/2017/07/23/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-Numpy%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>NumPy的主要对象是齐次多维数组。表由相同类型的元素组成（通常为数字），由一个正整数元组索引。在NumPy中维数被称为轴，轴数称为秩。例如，一个三维空间中点的坐标[1,2,1]是一个秩为1的数组，因为其轴数为1，轴的长度为3。在下图中，数组的秩为2（2维），第二维的长度为3。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[ 1., 0., 0.],</span><br><span class="line"> [ 0., 1., 2.]]</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="随机打乱数据">随机打乱数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">random_y = np.random.permutation(y)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法专题_并查集</title>
      <link href="/hexoblog/2017/07/23/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/hexoblog/2017/07/23/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>并查集可以高效的维护数据的分组信息，并可以快速完成以下操作：</p><blockquote><ul><li>查询元素a和元素b是否属于同一个组</li><li>合并元素a和元素b所在的组</li></ul></blockquote><p>并查集使用一棵树来维护一个分组的信息，多棵树构成的森林表示这个完整的数据结构。如果查询a和b是否属于同一组，只需要向上搜索直到树根，看a和b的树根是否一样就可以了。如果要合并a和b所在的分组，只需要把a和b连在一起就可以了，通常是把a和b所在树的树根连在一起。</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法专题_树状数组</title>
      <link href="/hexoblog/2017/07/23/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
      <url>/hexoblog/2017/07/23/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>树状数组是一个能够快速完成下术操作的数据结构：</p><blockquote><ul><li>给定一个初始值全为0的数列，a1,a2,a3,a4,…an</li><li>给定i,计算a1+a2+…+ai</li><li>给定i和x,计算ai = ai + x;</li></ul></blockquote><a id="more"></a><p>上面提到的线段树其实已经满足了上面的要求，只不过有些(大材小用了)。可以用更简单的结构实现这个要求。</p><div class="figure"><img src="2017-04-12_161624.png" alt="2017-04-12_161624.png"><p class="caption">2017-04-12_161624.png</p></div><p>把线段树所有的右节点去掉，只剩下左节点，然后对应的位置不变，投射到最下面一行，就形成了树状数组的结构。例如8个元素的树状数组的结构是：</p><table><thead><tr class="header"><th>A[1]</th><th>A[2]</th><th>A[3]</th><th>A[4]</th><th>A[5]</th><th>A[6]</th><th>A[7]</th><th>A[8]</th><th></th></tr></thead><tbody><tr class="odd"><td>1</td><td>[1,2]</td><td>3</td><td>[1,4]</td><td>5</td><td>[5,6]</td><td>7</td><td>[1,8]</td><td></td></tr><tr class="even"><td>0001</td><td>0010</td><td>0011</td><td>0100</td><td>0101</td><td>0110</td><td>0111</td><td>1000</td><td></td></tr></tbody></table><p>有了上面的结构，如果想求<code>c[3]+c[4]+c[5]</code>就是<code>A[4]-A[2]+A[5]</code>; 如果想求<code>c[4]</code>,就是<code>A[4]-A[3]-A[2]</code>; 总之，一个区间内的和总可以在常数时间内通过树状数组中的值求出来。树状数组可以使用位来保存，通过寻找其中的规律，可以使用简单的位操作实现树状数组的求和和更新。上面表格的最后一行是对树状数组A进行的二进制的编码。 求树状数组的前i项和：</p><table><thead><tr class="header"><th>i</th><th>表达式</th><th>二进制表示</th></tr></thead><tbody><tr class="odd"><td>1</td><td>A[1]</td><td>0001</td></tr><tr class="even"><td>2</td><td>A[2]</td><td>0010</td></tr><tr class="odd"><td>3</td><td>A[3]+A[2]</td><td>0011+0010</td></tr><tr class="even"><td>4</td><td>A[4]</td><td>0100</td></tr><tr class="odd"><td>5</td><td>A[5]+A[4]</td><td>0101+0100</td></tr><tr class="even"><td>6</td><td>A[6]+A[4]</td><td>0110+0100</td></tr><tr class="odd"><td>7</td><td>A[7]+A[6]+A[4]</td><td>0111+0110+0100</td></tr><tr class="even"><td>8</td><td>A[8]</td><td>1000</td></tr></tbody></table><p>从二进制当中寻找规律，求前i项：</p><blockquote><ol style="list-style-type: decimal"><li>初始化sum=0;</li><li>从树状数组A[i]开始，把A[i]加入到结果中去。然后从i中减去i最低位1对应的数字。i的最低位的1对应的数字的值的大小可以用<code>i&amp;(-i)</code>求得。</li><li>直到i的结果为0停止。</li></ol></blockquote><p>按照上面的步骤分析上面表格中的每一行的求解：</p><blockquote><ul><li>0001减去最后一位二进制1对应的数字（1）之后为0，所以最后结果是A[1]</li><li>0010减去最后一位二进制1对应的数字(2)之后为0，所以最后的结果是A[2]</li><li>0011减去最后以为二进制1对应的数字(1)之后为(0010,A[2]),而0010减去最后一位二进制1对应的数字(2)之后为0,所以最后的结果是A[3]+A[2]</li><li>0100减去最后以为二进制1对应的数字(4)之后为0,所以最后的结果是A[4]</li><li>0101减去最后以为二进制1对应的数字(1)之后为0100,0100减去最后以为二进制1对应的数字(4)之后为0,所以最后的结果是A[5]+A[4]</li><li>0110 = 0110 + 0100 = A[6] + A[4]</li><li>0111 = 0111 + 0110 + 0100 + A[7] + A[6] + A[4]</li><li>1000 = 1000 = A[8]</li></ul></blockquote><p>上面就是BIT数组求和的详细解释，了解了这个过程，在知道如何求解一个数字最低位1对应的值，实现BIT的求和应该不难。下面看看BIT如何更新。 假如我们想更新c[2]的值，那么A中所有包含c[2]的值都可能发生变化，到底哪些值包含c[2]呢？从上面的表格我们看出，包含c[2]的A元素有A[2],A[4],A[8];下面再列一个表格，显示每个元素的更新都涉及哪些元素，这样就比较容易找到其中的规律。</p><table><thead><tr class="header"><th>更新的值</th><th>涉及的BIT</th><th>二进制表示</th></tr></thead><tbody><tr class="odd"><td>c[1]</td><td>A[1],A[2],A[4],A[8]</td><td>0001,0010,0100,1000</td></tr><tr class="even"><td>c[2]</td><td>A[2],A[4],A[8]</td><td>0010,0100,1000</td></tr><tr class="odd"><td>c[3]</td><td>A[3],A[4],A[8]</td><td>0011,0100,1000</td></tr><tr class="even"><td>c[4]</td><td>A[4],A[8]</td><td>0100,1000</td></tr><tr class="odd"><td>c[5]</td><td>A[5],A[6],A[8]</td><td>0101,0110,1000</td></tr><tr class="even"><td>c[6]</td><td>A[6],A[8]</td><td>0110,1000</td></tr><tr class="odd"><td>c[7]</td><td>A[7],A[8]</td><td>0111,1000</td></tr><tr class="even"><td>c[8]</td><td>A[8]</td><td>1000</td></tr></tbody></table><p>可以看到，更新的时候和求和的时候顺序似乎相反，规律是：如果要更新c[i],那么就从i开始，更新A[i]之后将i更新为<code>i = i+(i&amp;(-i))</code>,直到最后一个元素为止。因为无论更新哪个元素，最后一个元素包含所有值的和，所以必须更新最后一个元素。<code>i&amp;(-i)</code>是得到i的最后一位二进制1对应的数值的大小，然后加到i上，对比上面的表格。i的更新情况是：</p><blockquote><ul><li>0001(1)-0001+0001(2)-0010+0010(4)-0100+0100(8)=1000 停止</li><li>0010(2)-0010+0010(4)-0100+0100(8)=1000 停止</li><li>0011(3)-0011+0001(4)-0100+0100(8)=1000 停止</li><li>0100(4)-0100+0100(8)=1000 停止</li><li>0101(5)-0101+0001(6)-0110+0010(8)=1000 停止</li><li>0110(6)-0110+0010(8)=1000 停止</li><li>0111(7)-0111+0001(8)=1000 停止</li><li>1000(8) = 1000 停止</li></ul></blockquote><p>树状数组的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BIT</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    BIT()&#123;&#125;</span><br><span class="line">    <span class="comment">// 构建n个元素的空树状数组</span></span><br><span class="line">    BIT(<span class="keyword">int</span> num)&#123;</span><br><span class="line">        n = num+<span class="number">1</span>; <span class="comment">// v[0]不用，下标从1开始。</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">           v.push_back(<span class="number">0</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求前i项的和</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            s += v[i];</span><br><span class="line">            i -= i &amp; (-i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第i 项加上x</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">           v[i] += x;</span><br><span class="line">            i += i&amp;(-i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据传入的数组c构建它的树状数组</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c.size();i++)&#123;</span><br><span class="line">            add(i+<span class="number">1</span>,c[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printV</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> aa:a)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;aa&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c = &#123;<span class="number">3</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    BIT *b = <span class="keyword">new</span> BIT(c.size());</span><br><span class="line">    b-&gt;create(c);</span><br><span class="line">    printV(b-&gt;v);</span><br><span class="line">    b-&gt;add(<span class="number">8</span>,<span class="number">10</span>);</span><br><span class="line">    printV(b-&gt;v);</span><br><span class="line">    b-&gt;add(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    printV(b-&gt;v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 3 10 6 21 4 6 8 36</span><br><span class="line">0 3 10 6 21 4 6 8 46</span><br><span class="line">0 4 11 6 22 4 6 8 47</span><br></pre></td></tr></table></figure><p>可以看到，树状数组仅仅使用位操作就可以实现求和和更新，比线段树的开销要少很多，所以，一些能用树状数组解决的问题，不宜使用线段树。</p><p>参考博文：</p><p>http://www.cnblogs.com/wuwangchuxin0924/p/5921130.html http://www.cnblogs.com/GeniusYang/p/5756975.html</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法专题_线段树</title>
      <link href="/hexoblog/2017/07/23/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/hexoblog/2017/07/23/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>线段树是一棵二叉树，他的每个节点包含了两个额外的属性<code>start</code>和<code>end</code>用于表示该节点所代表的区间。start和end都是整数，并按照如下的方式赋值:</p><p>根节点的 <code>start</code> 和 <code>end</code> 由 <code>build</code> 方法所给出。 对于节点 A 的左儿子，有 <code>start=A.left, end=(A.left + A.right) / 2</code>。 对于节点 A 的右儿子，有 <code>start=(A.left + A.right) / 2 + 1, end=A.right</code>。 如果 start 等于 end, 那么该节点是叶子节点，不再有左右儿子。 实现一个 build 方法，接受 start 和 end 作为参数, 然后构造一个代表区间<code>[start, end]</code>的线段树，返回这棵线段树的根。</p><a id="more"></a><p>线段树(又称区间树), 是一种高级数据结构，他可以支持这样的一些操作:</p><blockquote><ul><li>查找给定的点包含在了哪些区间内</li><li>查找给定的区间包含了哪些点</li></ul></blockquote><p>样例: 比如给定start=1, end=6，对应的线段树为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">               [<span class="number">1</span>,  <span class="number">6</span>]</span><br><span class="line">             /        \</span><br><span class="line">      [<span class="number">1</span>,  <span class="number">3</span>]           [<span class="number">4</span>,  <span class="number">6</span>]</span><br><span class="line">      /     \           /     \</span><br><span class="line">   [<span class="number">1</span>, <span class="number">2</span>]  [<span class="number">3</span>,<span class="number">3</span>]     [<span class="number">4</span>, <span class="number">5</span>]   [<span class="number">6</span>,<span class="number">6</span>]</span><br><span class="line">   /    \           /     \</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>]   [<span class="number">2</span>,<span class="number">2</span>]     [<span class="number">4</span>,<span class="number">4</span>]   [<span class="number">5</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><h2 id="线段树结构的定义">线段树结构的定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Definition of SegmentTreeNode:</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">SegmentTreeNode</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">int</span> start, end;</span><br><span class="line">      SegmentTreeNode *left, *right;</span><br><span class="line">      SegmentTreeNode(<span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">          <span class="keyword">this</span>-&gt;start = start, <span class="keyword">this</span>-&gt;end = end;</span><br><span class="line">          <span class="keyword">this</span>-&gt;left = <span class="keyword">this</span>-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="线段树的构造">线段树的构造</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *@param start, end: Denote an segment / interval</span></span><br><span class="line"><span class="comment">     *@return: The root of Segment Tree</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">SegmentTreeNode * <span class="title">build</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        SegmentTreeNode *node = <span class="keyword">new</span> SegmentTreeNode(start,end);</span><br><span class="line">        <span class="keyword">if</span>( start &lt; end ) &#123;</span><br><span class="line">            node-&gt;left = build(node-&gt;start,(node-&gt;start+node-&gt;end)/<span class="number">2</span>);</span><br><span class="line">            node-&gt;right = build((node-&gt;start+node-&gt;end)/<span class="number">2</span>+<span class="number">1</span>,node-&gt;end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>自底向上构造线段树<a href="http://lintcode.com/zh-cn/problem/segment-tree-build-ii/" target="_blank" rel="noopener">online judge</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SegmentTreeNode * <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// write your code here</span></span><br><span class="line">       <span class="keyword">if</span> (A.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> build(<span class="number">0</span>, A.size() - <span class="number">1</span>, A);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function">SegmentTreeNode * <span class="title">build</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// write your code here</span></span><br><span class="line">       <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       SegmentTreeNode *root = <span class="keyword">new</span> SegmentTreeNode(start, end, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">if</span> (start != end) &#123;</span><br><span class="line">           root-&gt;left = build(start, (start + end) / <span class="number">2</span>, nums);</span><br><span class="line">           root-&gt;right = build((start + end) / <span class="number">2</span> + <span class="number">1</span>, end, nums);</span><br><span class="line">           root-&gt;max = max(root-&gt;left-&gt;max, root-&gt;right-&gt;max);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           root-&gt;max = nums[start];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="线段树的查询">线段树的查询</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *@param root, start, end: The root of segment tree and</span></span><br><span class="line"><span class="comment">     *                         an segment / interval</span></span><br><span class="line"><span class="comment">     *@return: The maximum number in the interval [start, end]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(SegmentTreeNode *root, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="comment">// 区间比根区间还大的情况</span></span><br><span class="line">        <span class="keyword">if</span>(start &lt;= root-&gt;start &amp;&amp; end &gt;= root-&gt;end)&#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果左边界已经大于等于又边界  或者  右边界已经大于等于左边界， 则不存在的这样的区域</span></span><br><span class="line">        <span class="comment">//返回不影响计算最大值的数字</span></span><br><span class="line">        <span class="keyword">if</span>(start&gt;root-&gt;end || end &lt; root-&gt;start)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ll = query(root-&gt;left,start,end);</span><br><span class="line">        <span class="keyword">int</span> rr = query(root-&gt;right,start,end);</span><br><span class="line">        <span class="keyword">return</span> max(ll,rr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="线段树的更新">线段树的更新</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(Node *root, <span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;start == root-&gt;end &amp;&amp; root-&gt;start == idx)</span><br><span class="line">        &#123;</span><br><span class="line">            ++(root-&gt;cnt);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = root-&gt;start + ((root-&gt;end - root-&gt;start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (mid &gt;= idx)</span><br><span class="line">        &#123;</span><br><span class="line">            modify(root-&gt;left, idx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            modify(root-&gt;right, idx);</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;cnt = root-&gt;left-&gt;cnt + (root-&gt;right ? root-&gt;right-&gt;cnt : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="统计前面比自己大的数有多少个">统计前面比自己大的数有多少个</h2><p>使用线段树存储每个区间有多少个数字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node(<span class="keyword">int</span> _start, <span class="keyword">int</span> _end) :</span><br><span class="line">            start(_start), end(_end), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>),</span><br><span class="line">            cnt(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start, end;</span><br><span class="line">    Node *left, *right;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">build</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (start == end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    Node *root = <span class="keyword">new</span> Node(start, end);</span><br><span class="line">    root-&gt;left = build(start, mid);</span><br><span class="line">    root-&gt;right = build(mid + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(Node *root, <span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;start == root-&gt;end &amp;&amp; root-&gt;start == idx)</span><br><span class="line">    &#123;</span><br><span class="line">        ++(root-&gt;cnt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = root-&gt;start + ((root-&gt;end - root-&gt;start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= idx)</span><br><span class="line">    &#123;</span><br><span class="line">        modify(root-&gt;left, idx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        modify(root-&gt;right, idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    root-&gt;cnt = root-&gt;left-&gt;cnt + (root-&gt;right ? root-&gt;right-&gt;cnt : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(Node *root, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;end &lt; start || root-&gt;start &gt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;start &gt;= start &amp;&amp; root-&gt;end &lt;= end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = root-&gt;start + ((root-&gt;end - root-&gt;start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> query(root-&gt;left, start, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; start)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> query(root-&gt;right, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> leftRes = query(root-&gt;left, start, mid);</span><br><span class="line">    <span class="keyword">int</span> rightRes = query(root-&gt;right, mid + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> leftRes + rightRes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countOfSmallerNumberII(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A) &#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">int</span> len = A.size();</span><br><span class="line">    Node *root = build(<span class="number">0</span>, <span class="number">2</span>*len);</span><br><span class="line">    <span class="keyword">int</span> maxV = INT32_MIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j) &#123;</span><br><span class="line">        maxV = max(maxV,A[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = query(root,A[i] + <span class="number">1</span>, maxV);</span><br><span class="line">        res.push_back(cnt);</span><br><span class="line">        modify(root, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> re = countOfSmallerNumberII(v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="统计前面比自己小的数字有多少个">统计前面比自己小的数字有多少个</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node(<span class="keyword">int</span> _start, <span class="keyword">int</span> _end) :</span><br><span class="line">            start(_start), end(_end), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>),</span><br><span class="line">            cnt(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start, end;</span><br><span class="line">    Node *left, *right;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * @param A: An integer array</span></span><br><span class="line"><span class="comment">      * @return: Count the number of element before this element 'ai' is</span></span><br><span class="line"><span class="comment">      *          smaller than it and return count number array</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countOfSmallerNumberII(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A) &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        Node *root = build(<span class="number">0</span>, <span class="number">20000</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = query(root, <span class="number">0</span>, A[i] - <span class="number">1</span>);</span><br><span class="line">            res.push_back(cnt);</span><br><span class="line">            modify(root, A[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">Node *<span class="title">build</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (start == end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(start, end);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Node *root = <span class="keyword">new</span> Node(start, end);</span><br><span class="line">        root-&gt;left = build(start, mid);</span><br><span class="line">        root-&gt;right = build(mid + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(Node *root, <span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;start == root-&gt;end &amp;&amp; root-&gt;start == idx)</span><br><span class="line">        &#123;</span><br><span class="line">            ++(root-&gt;cnt);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = root-&gt;start + ((root-&gt;end - root-&gt;start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (mid &gt;= idx)</span><br><span class="line">        &#123;</span><br><span class="line">            modify(root-&gt;left, idx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            modify(root-&gt;right, idx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root-&gt;cnt = root-&gt;left-&gt;cnt + (root-&gt;right ? root-&gt;right-&gt;cnt : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(Node *root, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;end &lt; start || root-&gt;start &gt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;start &gt;= start &amp;&amp; root-&gt;end &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;cnt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = root-&gt;start + ((root-&gt;end - root-&gt;start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (mid &gt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> query(root-&gt;left, start, end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mid &lt; start)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> query(root-&gt;right, start, end);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftRes = query(root-&gt;left, start, mid);</span><br><span class="line">        <span class="keyword">int</span> rightRes = query(root-&gt;right, mid + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leftRes + rightRes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>N皇后问题</title>
      <link href="/hexoblog/2017/07/20/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
      <url>/hexoblog/2017/07/20/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>在一个N*N的棋盘上放置N个皇后，要求任意两个皇后不能在同一行、同一列和同一对角线上，求有多少种放置的方法。</p><a id="more"></a><p>该问题的基本思路是搜索所有的状态。先在第一行的第一个位置放置皇后，然后在第二行找一个合法的位置，接着在第三行找一个合法的位置，一旦达到最后一行，就产生了一个解，如果到某一行的时候没有解了，就回溯到上一行，移动刚才放置的皇后到下一个可行的位置，继续向下搜索。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断在棋盘的row,col位置是否可以放置皇后</span></span><br><span class="line"><span class="comment"> * @param C  c[i]=j 表示第i行第j列有皇后</span></span><br><span class="line"><span class="comment"> * @param row</span></span><br><span class="line"><span class="comment"> * @param col</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;C,<span class="keyword">int</span> &amp;row,<span class="keyword">int</span> &amp;col)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">        <span class="comment">// 在col列已经有皇后</span></span><br><span class="line">        <span class="keyword">if</span>(C[i] == col) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 对角线上的皇后行坐标相减总是等于列坐标</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(i-row) == <span class="built_in">abs</span>(C[i]-col)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param C</span></span><br><span class="line"><span class="comment"> * @param row</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;C,<span class="keyword">int</span> row,<span class="keyword">int</span> &amp;sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = C.size();</span><br><span class="line">    <span class="keyword">if</span>(row == N)&#123;</span><br><span class="line">        sum++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//测试每一列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isValid(C,row,j))&#123;</span><br><span class="line">            C[row] = j; <span class="comment">//(row,j) 放置一个皇后</span></span><br><span class="line">            dfs(C,row+<span class="number">1</span>,sum);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 不行就尝试下一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//N皇后问题</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C(n,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    dfs(C,<span class="number">0</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;totalNQueens(<span class="number">4</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于放置和不放置皇后只需要一个标识，所以可以使用位来标记，这样可以大大节省空间，也可以使用位运算来加速算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo中使用gist存储代码片段</title>
      <link href="/hexoblog/2017/07/17/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/Hexo/Hexo%E7%9A%84%E4%BD%BF%E7%94%A806-%E4%BD%BF%E7%94%A8gist%E5%AD%98%E5%82%A8%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"/>
      <url>/hexoblog/2017/07/17/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/Hexo/Hexo%E7%9A%84%E4%BD%BF%E7%94%A806-%E4%BD%BF%E7%94%A8gist%E5%AD%98%E5%82%A8%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/</url>
      
        <content type="html"><![CDATA[<p>以前都是直接把代码用代码块的形式写在markdown里面，这样有的时候代码太长，文件就会变得很长，不方便阅读。最近发现了GitHub上面的gist,能不限量的存储代码块，而且可以方便的引用和分享。就想着以后Hexo博客里面的代码直接放在Gist里面再引用好了。这样代码片段都可以保存在一起，还有代码管理功能，修改起来也方便。</p><a id="more"></a><p>如果每次引用Gist的时候都需要打开Github,创建代码块，就太麻烦了。今天发现了Clion可以方便的创建Gist，只要登陆了自己的GitHub帐号，创建的Gist就全部都在自己的帐号里面，以后可以很方便的管理。</p><p>使用Clion创建Gist非常方便，选中需要创建Gist的片段，右键选择创建Gist,就会自动创建Gist。</p><script src="//gist.github.com/47a29853e7ab427a7850c0da7cca9695.js"></script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工具 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> gist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵的遍历</title>
      <link href="/hexoblog/2017/07/12/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%9F%A9%E9%98%B5%E7%9A%84%E9%81%8D%E5%8E%86/"/>
      <url>/hexoblog/2017/07/12/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%9F%A9%E9%98%B5%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p>矩阵的各种遍历方法。</p><a id="more"></a><h2 id="斜对角线遍历数组主对角线">斜对角线遍历数组(主对角线)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//斜对角线遍历数组(主对角线)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; printMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; re;</span><br><span class="line">    <span class="keyword">int</span> m = v.size(); <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">return</span> re; <span class="keyword">if</span>(m==<span class="number">1</span>)&#123;<span class="keyword">return</span> v;&#125;</span><br><span class="line">    <span class="keyword">int</span> n = v[<span class="number">0</span>].size(); <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = m+n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> col = n - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    tmp.push_back(v[row][col]);</span><br><span class="line">    re.push_back(tmp);</span><br><span class="line">    <span class="keyword">int</span> i = row + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = col <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> i1=row;</span><br><span class="line">        <span class="keyword">int</span> j1=j;</span><br><span class="line">        tmp.clear();</span><br><span class="line">        <span class="keyword">while</span>(i1&lt;=i &amp;&amp; j1&lt;=col)&#123;</span><br><span class="line">            tmp.push_back(v[i1][j1]);</span><br><span class="line">            i1++;</span><br><span class="line">            j1++;</span><br><span class="line">        &#125;</span><br><span class="line">        re.push_back(tmp);</span><br><span class="line">        <span class="keyword">if</span>(i==m<span class="number">-1</span>)&#123;</span><br><span class="line">            col--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">            row++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i == m<span class="number">-1</span> &amp;&amp; j == <span class="number">0</span> &amp;&amp; col==<span class="number">0</span> &amp;&amp; row == m<span class="number">-1</span>)&#123;</span><br><span class="line">            tmp.clear();</span><br><span class="line">            tmp.push_back(v[row][col]);</span><br><span class="line">            re.push_back(tmp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="斜对角线遍历数组副对角线">斜对角线遍历数组(副对角线)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//斜对角线遍历数组(副对角线)</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; printMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; re;</span><br><span class="line">    <span class="keyword">int</span> m = v.size(); <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">return</span> re; <span class="keyword">if</span>(m==<span class="number">1</span>)&#123;<span class="keyword">return</span> v;&#125;</span><br><span class="line">    <span class="keyword">int</span> n = v[<span class="number">0</span>].size(); <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = m+n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> col = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    tmp.push_back(v[row][col]);</span><br><span class="line">    re.push_back(tmp);</span><br><span class="line">    <span class="keyword">int</span> i = row + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = col + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> i1=row;</span><br><span class="line">        <span class="keyword">int</span> j1=j;</span><br><span class="line">        tmp.clear();</span><br><span class="line">        <span class="keyword">while</span>(i1&lt;=i &amp;&amp; j1&gt;=col)&#123;</span><br><span class="line">            tmp.push_back(v[i1][j1]);</span><br><span class="line">            i1++;</span><br><span class="line">            j1--;</span><br><span class="line">        &#125;</span><br><span class="line">        re.push_back(tmp);</span><br><span class="line">        <span class="keyword">if</span>(i==m<span class="number">-1</span>)&#123;</span><br><span class="line">            col++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==n<span class="number">-1</span>)&#123;</span><br><span class="line">            row++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i == m<span class="number">-1</span> &amp;&amp; j == n<span class="number">-1</span> &amp;&amp; col==n<span class="number">-1</span> &amp;&amp; row == m<span class="number">-1</span>)&#123;</span><br><span class="line">            tmp.clear();</span><br><span class="line">            tmp.push_back(v[row][col]);</span><br><span class="line">            re.push_back(tmp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/hexoblog/2017/07/12/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/hexoblog/2017/07/12/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="网络分层">网络分层</h2><p>OSI七层模型：</p><table><thead><tr class="header"><th>OSI层</th><th>功能</th><th>协议</th></tr></thead><tbody><tr class="odd"><td>应用层</td><td>文件传输、电子邮件、文件服务、虚拟终端</td><td>TFTP、HTTP、SNMP、FTP、SMTP、DNS、Telnet</td></tr><tr class="even"><td>表示层</td><td>数据格式化、代码转换、数据加密</td><td>没有协议</td></tr><tr class="odd"><td>会话层</td><td>解除或建立与别的接点的联系</td><td>没有协议</td></tr><tr class="even"><td>传输层</td><td>提供端对端的接口</td><td>TCP、UDP</td></tr><tr class="odd"><td>网络层</td><td>为数据包选择路由 IP</td><td>ICMP，RIP，OSPF，BGP，IGMP</td></tr><tr class="even"><td>数据链路层</td><td>传输有地址的帧以及错误检测功能</td><td>SLIP，CSLIP，PPP，ARP，RARP，MTU</td></tr><tr class="odd"><td>物理层</td><td>以二进制数据形式在物理媒体上传输数据</td><td>ISO2110，IEEE802，IEEE802.2</td></tr></tbody></table><p>TCP|IP 四层模型：</p><ul><li>网络接口层（链路层）：</li><li>网络层： IP,ICMP,IGMP，【ARP,RARP】</li><li>传输层：TCP ,UDP,UGP</li><li>应用层：Telnet,FTP,SMTP,SNMP.</li></ul><blockquote><p>ARP, RARP 在OSI七层模型中，是属于数据链路层的，但是在TCPIP模型中，它属于整个TCPIP协议簇的一部分，属于网络层。</p></blockquote><p><strong>物理层</strong></p><p>以二进制数据的形式在物理媒介上传送数据（无线，光钎）</p><p><strong>数据链路层</strong></p><p>提供一个设备到另外一个设备的数据传输功能，寻找设备依靠设备的MAC地址。所以在这一层传送的数据包需要源MAC地址和目的MAC地址的信息。</p><blockquote><p>ARP : 地址解析协议，把IP地址解析程Mac地址；RARP是逆地址解析协议，把Mac解析成IP地址； 网络层的通信依靠的是IP地址，而数据链路层通信依靠的是Mac地址。</p></blockquote><blockquote><p>ARP协议的过程： 主机A将包含 本机IP地址和本机Mac地址 和 要请求的目标IP地址 的ARP请求广播到网络上的所有主机，网络上的所有主机收到ARP请求的广播之后比较目标IP地址和自己的IP地址是否一样，如果不一致就忽略，如果一致，记录下此ARP包中的源IP和Mac地址的对应关系，然后发送自己的IP地址和Mac地址。</p></blockquote><blockquote><p>ARP 欺骗： 通过伪造ARP应答包的方式 改变目标主机中IP-MAc地址的对应关系，从而劫持目标主机的通信信息。 这种方式只有在局域网内有效。</p></blockquote><p><strong>网络层</strong></p><p>提供终端对终端的数据传输功能，寻找目标依靠的是IP地址，在这一层传输的数据包需要有源IP地址和目的IP地址。</p><blockquote><p>ICMP: 网际控制报文协议(差错与控制协议)，运行与IP协议之上(ICMP报文封装与IP数据包的数据部分，在IP数据报的头部中的协议字段指出数据中存在ICMP报文), 主要的功能是传输差错信息和传输控制信息。</p></blockquote><p><strong>传输层</strong></p><p>提供应用程序到应用程序的数据传输服务，区分不同的应用程序依靠的是端口号，在这一层传输的数据包需要有源端口号，目的端口号。</p><p><strong>访问一个网址的过程</strong></p><ol style="list-style-type: decimal"><li>根据网址解析出主机名称，例如www.baidu.com</li><li>根据主机名，查找对应的IP地址，首先在本机的hosts中寻找，没有则根据本机配置的首选DNS服务器的地址，使用DNS协议去DNS服务器上查找，DNS协议使用UDP传输数据，默认端口号是53. DNS服务器是一个树形结构，如果该DNS服务器查询不到，会将请求发送到上一级的DNS服务器查询。</li><li>发送HTTP请求。 HTTP是工作在TCP协议之上的应用层的协议，它和服务器的连接使用的三次握手和四次挥手的机制，可以确保可靠的传输。</li><li>服务器收到HTTP请求之后，解析该请求，发送所请求的内容。</li></ol><h2 id="tcp三次握手和四次挥手">TCP三次握手和四次挥手</h2><h3 id="tcp协议的头部格式">TCP协议的头部格式</h3><div class="figure"><img src="2017-10-06_102204.png" alt="TCP 头部格式"><p class="caption">TCP 头部格式</p></div><ul><li><code>Source Port</code>和<code>Destination Port</code>:分别占用16位，表示源端口号和目的端口号；用于区别主机中的不同进程，而IP地址是用来区分不同的主机的，源端口号和目的端口号配合上IP首部中的源IP地址和目的IP地址就能唯一的确定一个TCP连接；</li><li><code>Sequence Number</code>:用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节在数据流中的序号；主要用来解决网络报乱序的问题；</li><li><code>Acknowledgment Number</code>:32位确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加1。不过，只有当标志位中的ACK标志（下面介绍）为1时该确认序列号的字段才有效。主要用来解决不丢包的问题；</li><li><code>Offset</code>:给出首部中32 bit字的数目，需要这个值是因为任选字段的长度是可变的。这个字段占4bit（最多能表示15个32bit的的字，即4*15=60个字节的首部长度），因此TCP最多有60字节的首部。然而，没有任选字段，正常的长度是20字节；</li></ul><h3 id="三次握手">三次握手</h3><div class="figure"><img src="2017-10-06_102640.png" alt="三次握手"><p class="caption">三次握手</p></div><ol style="list-style-type: decimal"><li><p>第一次，客户端发送请求连接报文(编程中一般用connect())，SYN = 1， ACK = 0，seq = x, （这两个标志位是<code>TCP Flag</code>中的两个，每个用一个比特位表示，连接请求的时候，ACK=0，SYN = 1； 连接响应的时候， ACK = 1， SYN = 1）. 发送完之后客户端进入<code>SYN_SEND</code>状态，等待服务器的响应。</p></li><li><p>服务器收到客户端发送的请求建立连接的报文，设置<code>Acknowledgment Number = x + 1, Sequence Number = y, SYN = 1</code>, 发送给客户端，服务器进入<code>SYN_RECV</code>状态； 服务器这次发送的包含两个信息，一个是应答客户端请求的信息，ACK = x + 1, 另外一个和客户端一样，是请求和客户端建立连接的请求报文，两者在一起合成一个报文发送。</p></li><li><p>客户端收到服务器来的消息后，发送确认消息<code>ack = y + 1</code>, 发送完之后, 进入<code>established</code>状态，服务器收到消息之后也进入这一状态。</p></li></ol><h3 id="四次挥手">四次挥手</h3><div class="figure"><img src="2017-10-06_104237.png" alt="四次挥手"><p class="caption">四次挥手</p></div><ol style="list-style-type: decimal"><li><p>主机1向主机2发送<code>FIN</code>报文，进入<code>FIN_WAIT1</code>状态</p></li><li><p>主机2收到主机1发送的<code>FIN</code>报文，向主机1回一个<code>ACK</code>报文，主机1进入<code>FIN_WAIT2</code>状态，这个时候主机2其实是告诉了主机1， 我同意了关闭连接的请求。 主机1已经确认主机2同意了关闭连接的请求，此时主机1不再发送数据到主机2，等待主机2请求关闭连接的信息。</p></li><li><p>主机2向主机1发送<code>FIN</code>报文，主机2进入<code>LAST_ACK</code>状态。</p></li><li><p>主机1收到主机2发来的<code>FIN</code>报文，知道主机2该处理的都已经处理完了，不会再发送来消息了，所以发送<code>ACK</code>报文到主机2，主机1进入<code>TIME_WAIT</code>状态， 主机2收到<code>ACK</code>报文，关闭连接。 主机1在等待2MSL之后，没有收到来自主机2的消息，正常关闭连接。</p></li></ol><p>参考文献: <a href="http://www.jellythink.com/archives/705" target="_blank" rel="noopener">简析TCP三次握手与四次挥手</a></p><h2 id="tcp-流量控制">TCP 流量控制</h2><p>如果发送方数据发送的过快，接收方来不及接收，就会造成数据的丢失，而TCP协议需要确保数据的有序到达，所以流量控制是很重要的一个方面。 利用<strong>滑动窗口</strong>可以方便的在TCP连接上实现对发送方的流量控制。</p><p>A向B发送数据，则在建立连接的时候，B会告诉A，我的接收窗口是 400 字节，发送方A的窗口不能超过B给出的接收窗口的值。 A在发送数据的时候，会记录已经发送的数据量，如果超过400字节，就不再发送新的数据，但是可以发送以前发送过的数据(比如丢失的数据)， 收到B端发送过来的带有调整接收窗口大小的报文，可以重新按照新的窗口大小发送数据。下面是一个示意图：</p><div class="figure"><img src="QQ截图20171006173539.png" alt="使用滑动窗口进行流量控制"><p class="caption">使用滑动窗口进行流量控制</p></div><p><strong>TCP拥塞控制</strong></p><p>拥塞控制与流量控制不同，拥塞控制是对整个网络的控制，需要在节点之间交换信息和各种命令，所以拥塞控制本身增加了网络的开销。 拥塞控制的主要方法有： <strong>慢开始</strong>， <strong>拥塞避免</strong>， <strong>快重传</strong>和<strong>快恢复</strong>。具体方法参考<a href="http://blog.csdn.net/yechaodechuntian/article/details/25429143" target="_blank" rel="noopener">这里</a>.</p><h2 id="tcp和udp的区别">TCP和UDP的区别</h2><p>TCP和UDP都属于传输层的协议，正常工作都需要端口号。</p><p>TCP协议是面向连接的，需要先建立连接之后才能发送数据，它的传输是可靠传输，可以确保发送的信息到达目标端口。因为其提供了流量控制，超时重发，数据检验等功能，所以负载比较大，传输速度慢，特别是在拥挤的网络中。</p><p>UDP协议是非连接的协议，发送数据之前不需要首先建立连接，直接根据数据包中的目标地址发送数据过去。正因为这样，UDP是不可靠的传输，不能确保发出去的信息能够达到目标地址。 它的优点是负载小，传输速度较快，可以支持一对一，多对一，一对多，和多对多的通信。要是使用UDP协议来实现可靠传输，需要自己实现上层的控制逻辑。</p><h2 id="ip地址和子网掩码">IP地址和子网掩码</h2><h3 id="ip地址">IP地址</h3><p>在TCPIP通信协议的基础上进行通信的两台电脑，必须有自己的IP地址唯一的标识自己，如果是广域网，IP地址由NIC统一分配，如果是一个局域网，可以按照自己的喜好分配IP地址(不与其他的网络通信的情况下)。</p><p>IP协议有版本4和版本6之分，版本4是目前广泛使用的协议，它使用32个字节表示一个IP地址。IP地址分为4段，每段8位，可以表示0-255的数字。最多能够区分的主机数量是42亿9千多万，在今天已经不够使用了。</p><p>IP地址右两部分组成： 网络号 + 主机号； 前面若干位表示网络号，唯一的标识一个网络，后面剩下的位数标识一个主机。 根据网络号所占用的位数的不同，IP地址可以分为A,B,C,D,E五类IP地址。</p><p>假设IP地址用<code>w.x.y.z</code>表示，每个字母代表8位二进制位</p><table><thead><tr class="header"><th>类别</th><th>网络号</th><th>主机号</th><th>W的取值范围</th><th>每个网络的主机数量</th></tr></thead><tbody><tr class="odd"><td>A</td><td>w</td><td>x.y.z</td><td>1-126 (0)</td><td>2^(24) - 2</td></tr><tr class="even"><td>B</td><td>w.x</td><td>y.z</td><td>128-191 (10)</td><td>2^(16) - 2</td></tr><tr class="odd"><td>C</td><td>w.x.y</td><td>z</td><td>192-223 (110)</td><td>2^(8) - 2</td></tr><tr class="even"><td>D</td><td>w.x.y.z</td><td></td><td>224-239 (1110)</td><td>用于多播</td></tr><tr class="odd"><td>E</td><td>w.x.y.z</td><td></td><td>240-247 (1111)</td><td>保留未用</td></tr></tbody></table><p><strong>每个网络上主机数量的计算方法</strong></p><p>2^(主机号占用的比特位) - 2； -2是因为规定了两个保留地址：主机部分全部为0的地址引用为一个网络(表示这个网络), 主机部分全为1的地址称为广播地址，它同时指向一个网络上的所有主机。</p><p><strong>网络号能表示的网络数量的计算方法</strong></p><p>A类地址，只能取1-126，所以A类地址可以表示126个网络；</p><p>B类地址，用两个字节表示网络号，第一个字节的取值是128-191,第二个字节可以取0-255，所以总的数量是(191-128+1)*256=16384个；</p><p>C类地址，三个字节，同理，可以表示的网络数量为(223-192+1)<em>256</em>256=2097152个。</p><p><strong>常用的十进制和二进制的对应</strong></p><table><thead><tr class="header"><th align="right">十进制</th><th align="right">二进制</th></tr></thead><tbody><tr class="odd"><td align="right">128</td><td align="right">1000 0000</td></tr><tr class="even"><td align="right">192</td><td align="right">1100 0000</td></tr><tr class="odd"><td align="right">224</td><td align="right">1110 0000</td></tr><tr class="even"><td align="right">240</td><td align="right">1111 0000</td></tr><tr class="odd"><td align="right">248</td><td align="right">1111 1000</td></tr><tr class="even"><td align="right">252</td><td align="right">1111 1100</td></tr><tr class="odd"><td align="right">254</td><td align="right">1111 1110</td></tr><tr class="even"><td align="right">255</td><td align="right">1111 1111</td></tr></tbody></table><h3 id="子网掩码">子网掩码</h3><p>子网掩码是用来判断任意两台的计算机是否是属于同一子网络的：将IP地址和子网掩码按位与之后，如果结果相同，则两台电脑处于同一个子网中。</p><p>子网掩码由连续的1和连续的0组成，连续的1的个数等于子网网络号的长度。</p><blockquote><p>子网 ： 这里指的是广播报文可以直达的所有连接在一起的主机构成的网络，和网络号不是一回事。网络号相同的网络是同一个网络，在该网络下还可以划分子网，占用一些比特位给子网标号，使得IP地址变成：网络号+ 子网号+主机号 三段的格式。</p></blockquote><blockquote><p>划分子网一是为了节约IP地址空间，更好的利用好每一个IP地址； 二是为了不同子网之间的隔离。</p></blockquote><h2 id="httpgetpost">HTTP|GET|POST</h2><h3 id="http协议">HTTP协议</h3><p>HTTP协议是应用层无状态(对事务处理没有记忆能力，如果后面的处理必须使用前面的信息，需要重新传输前面的结果),无连接(每次连接(TCP连接)只处理一个请求，处理完成之后就断开连接)的协议，它可以传输任意的数据类型(数据类型在HTTP协议字段<code>Content-Type</code>指出)。 它提供的请求方法主要有<code>get</code>,<code>post</code>,<code>head</code>等方法。</p><p>HTTP状态码：</p><p>一共有五类：1xx 表示请求已经被成功接收； 2xx 表示成功; 3xx 表示重定向，要完成请求还需要进一步的操作； 4xx 表示客户端错误； 5xx表示服务器端错误。</p><table><thead><tr class="header"><th>常见的HTTP错误代码</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>200</td><td>OK，客户端请求成功</td></tr><tr class="even"><td>301</td><td>请求的资源永久移动到新位置</td></tr><tr class="odd"><td>302</td><td>请求的资源临时移动到了新的位置，下次请求还应该使用原来的位置</td></tr><tr class="even"><td>304</td><td>请求的资源未被修改过</td></tr><tr class="odd"><td>400</td><td>bad request, 客户端请求有语法错误</td></tr><tr class="even"><td>401</td><td>unauthorized, 请求未经过授权</td></tr><tr class="odd"><td>403</td><td>forbidden, 服务器收到请求，拒绝提供服务</td></tr><tr class="even"><td>404</td><td>not found, 请求的资源不存在</td></tr><tr class="odd"><td>500</td><td>internal sever error, 服务器发生不可预期的错误</td></tr><tr class="even"><td>503</td><td>sever unavailable, 服务器当前不能处理请求</td></tr></tbody></table><p>参考文献： <a href="http://www.cnblogs.com/li0803/archive/2008/11/03/1324746.html" target="_blank" rel="noopener">HTTP协议</a></p><h3 id="get-和-post">GET 和 POST</h3><p>get 和 post 是HTTP协议中定义的两种请求的方法，<code>get</code>的含义是请求信息，不改变服务器上的信息； <code>post</code>的含义是提交信息，可能会改变服务器的信息。但是实际使用的时候并不是严格按照这样的要求使用的，一般可以把两种方式都看成传输信息的方式，只是信息传输的方式不同。</p><p>GET方式是把传输的数据附在URL的末尾传输的，优点是可以添加到书签，缺点是安全性差，长度受限制。</p><p>POST方式是把传输的数据放在HTTP报文里面的，优点是传输的数据量大(理论上是无限大的，但是通常服务器端会有一个最大容量的限制，这个可以通过修改服务器的设置改变)， 缺点是不能添加书签，意思就是不能记录当前的状态。</p><h2 id="路由协议">路由协议</h2><p>路由的作用是找到一条路径，一条从一个主机到达另外一个主机的路径。 路由表可以是静态的，由网络管理员手工配置，也可以是动态的，基于学习算法自动学习出对应的路由，动态更新路由表。 这里值介绍最简单的，使用最普遍的RIP协议。</p><p>RIP适用与数据链路故障低，规模较小的局域网(小于15跳), RIP使用UDP数据包更新路由信息，路由器每隔30s更新一次路由信息，如果在180s内没有收到相邻的路由器的回应，则认为去往该路由器的路由不可用，如果超过240s，则删除该路由。</p><p>RIP使用距离向量路由算法实现，基本原理是这样的： 使用到达目标主机经过的路由器的个数表示一条路由的距离，认为距离越近路由质量越好。 路由器每隔一定的时间把自己的路由表发送到与自己相邻的所有路由器上，路由器在接收到路由表信息之后与自己的路由表比较，如果发现一条更好的路由（经过更少的路由器可以到达目标），就合并该路由表，把新的路由表发送到与自己相邻的所有路由器上。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四等分数组</title>
      <link href="/hexoblog/2017/07/12/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%9B%9B%E7%AD%89%E5%88%86%E6%95%B0%E7%BB%84/"/>
      <url>/hexoblog/2017/07/12/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%9B%9B%E7%AD%89%E5%88%86%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>题目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对于一个长度为N的整型数组A， 数组里所有的数都是正整数，对于两个满足0&lt;=X &lt;= Y &lt;N的整数，</span><br><span class="line">A[X], A[X+1] … A[Y]构成A的一个切片，记作(X, Y).</span><br><span class="line">用三个下标 m1, m2, m3下标满足条件0 &lt; m1, m1 + 1 &lt; m2, m2 +1 &lt; m3 &lt; N – 1。</span><br><span class="line">可以把这个整型数组分成(0, m1-1), (m1+1, m2-1), (m2+1, m3-1), (m3+1, N-1) 四个切片。</span><br><span class="line">如果这四个切片的整数求和相等，称作“四等分”。 编写一个函数，求一个给定的整型数组是否可以四等分</span><br><span class="line">要求： 函数的计算复杂度为O(N)，使用的额外存储空间（除了输入的数组之外）最多为O(N)。</span><br></pre></td></tr></table></figure><a id="more"></a><p>思路：如果不去掉中间的元素，直接判断一个数组是否能够四等分，只需要看数组的和被4整除的情况下能否依次加和成sum/4就可以了，代码可以写成下面这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> vv:v)&#123;</span><br><span class="line">        sum += vv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum % <span class="number">4</span> != <span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> partSum = sum / <span class="number">4</span>;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();i++)&#123;</span><br><span class="line">        sum += v[i];</span><br><span class="line">        <span class="keyword">if</span>(sum == partSum)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; partSum)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是本题要复杂的多，需要确定三个分割元素的位置，数组的和也不再一定是4的倍数。本题可以从两边入手，如果一个数组可以四等分，则两边一定可以有连续的若干个元素的和是相等的，即a[0]+a[1]+…a[low] = a[N-1]+a[N-2]+a[high]. 找到第一个这样的分割，确定low,和high, 然后在low,high的基础上，搜索是否有一个介于low和high中间的元素m可以被剩下的数组分成和相等的两部分，并且和==第一部分和第四部分。如果存在，就完成了数组的四等分，如果不存在，就递增low, 找到第二个low,high的值，继续重复上面的步骤。</p><p>在中间阶段查找的时候，m的位置可以定在low,high的中间，使用二分查找的方式快速定位。因为左右和相等的情况不会特别多，所以该算法的时间复杂度应该能够满足要求。</p><p>查找一个数组两端连续个元素和相等的所有情况的代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 找到数组两侧和相等的连续序列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bothSidesSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">    <span class="keyword">if</span>(v.size()&lt;<span class="number">2</span>) <span class="keyword">return</span> re;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = v.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> leftSum = v[left++];</span><br><span class="line">    <span class="keyword">int</span> rightSum = v[right--];</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftSum &lt; rightSum)&#123;</span><br><span class="line">            leftSum += v[left++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(leftSum &gt; rightSum)&#123;</span><br><span class="line">            rightSum += v[right--];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            re.push_back(leftSum);</span><br><span class="line">            leftSum += v[left++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在假设确定了某一次的low,high的值。即从最左侧开始到low-1的和等于从最右侧开始到high+1的值。现在看如何搜索m应该的位置，使得以m为分割的两段和是相等的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 找到和相等的分界点，没有返回0，有的话返回和的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMiddle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sums,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = low + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = high <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> middle = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> leftSum = sums[middle<span class="number">-1</span>] - sums[low];</span><br><span class="line">        <span class="keyword">int</span> rightSum = sums[high<span class="number">-1</span>] - sums[middle];</span><br><span class="line">        <span class="keyword">if</span>(leftSum &lt; rightSum)&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(leftSum &gt; rightSum)&#123;</span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> leftSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把上面的两个操作结合起来搜索，就是本题的解。具体的步骤是外层首先搜索low,high,一旦搜索到low,high，就调用findMiddle方法看是否能够找到分界。如果能够找到分界，还要看其sum是否等于第一个sum，如果相等，解就找到了，如果不相等，递增low,继续下一次搜索。</p><p>完整的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.size() &lt; <span class="number">7</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> sums = sumArray(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = v.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> leftSum = v[left++];</span><br><span class="line">    <span class="keyword">int</span> rightSum = v[right--];</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftSum &lt; rightSum)&#123;</span><br><span class="line">            leftSum += v[left++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(leftSum &gt; rightSum)&#123;</span><br><span class="line">            rightSum += v[right--];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">auto</span> secondSum = findMiddle(sums,left,right);</span><br><span class="line">            <span class="keyword">if</span>(leftSum == secondSum)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                leftSum += v[left++];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习_Python使用技巧</title>
      <link href="/hexoblog/2017/06/15/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_Python%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/hexoblog/2017/06/15/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_Python%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>记录所有涉及Python的短语句的写法。</p><a id="more"></a><p>常用的包的引入和别名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> scipy.io <span class="keyword">as</span> sio</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report,accuracy_score,confusion_matrix,roc_curve, auc</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> LinearSVC,SVC</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest, f_classif,RFECV</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> cross_validation</span><br><span class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> StratifiedKFold,LeavePOut,LeaveOneOut</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br></pre></td></tr></table></figure><h2 id="python">Python</h2><p><strong>目录操作</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">dirs_and_files = os.listdir(<span class="string">r'd:/'</span>)   <span class="comment">#</span></span><br><span class="line">os.chdir(<span class="string">r'd:/'</span>)</span><br><span class="line">os.path.join(path1,path2)  <span class="comment"># 拼接路径</span></span><br></pre></td></tr></table></figure><p><strong>读写文本文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file_object = open(filepath, <span class="string">'w'</span>)</span><br><span class="line">file_object.write(string)</span><br><span class="line">file_object.close()</span><br></pre></td></tr></table></figure><p><strong>读写Excel</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line">data = xlrd.open_workbook(excelfile)</span><br><span class="line">table = data.sheets()[<span class="number">0</span>]          <span class="comment">#通过索引顺序获取</span></span><br><span class="line">table = data.sheet_by_index(<span class="number">0</span>)   <span class="comment">#通过索引顺序获取</span></span><br><span class="line">table = data.sheet_by_name(<span class="string">u'详细信息'</span>)<span class="comment">#通过名称获取</span></span><br><span class="line">cellij = table.cell(i,j).value</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line">workbook = xlwt.Workbook(encoding = <span class="string">'ascii'</span>)</span><br><span class="line">worksheet = workbook.add_sheet(<span class="string">'sheet1'</span>)</span><br><span class="line">worksheet.write(i, j, label = value)</span><br><span class="line">workbook.save(<span class="string">r'excel.xls'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">dataframe = pd.read_excel(filepath,sheetname=<span class="string">'sheet1'</span>,header=<span class="literal">None</span>,index_col=<span class="literal">None</span>)</span><br><span class="line">dataframe = pd.read_csv(filepath,sheetname=<span class="string">'sheet1'</span>,header=<span class="literal">None</span>,index_col=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">dataframe.to_excel(filepath,sheet_name=<span class="string">'sheet2'</span>,header=<span class="literal">False</span>,index=<span class="literal">False</span>)</span><br><span class="line">dataframe.to_csv(filepath,sheet_name=<span class="string">'sheet2'</span>,header=<span class="literal">False</span>,index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h3 id="list类型转换成string类型输出">list类型转换成string类型输出</h3><p>使用python将list类型的数据转换成string类型的。eg: [1,2,3,4,5,6] to 1,2,3,4,5,6</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_to_str</span><span class="params">(list)</span>:</span></span><br><span class="line">    str1 = str(list)</span><br><span class="line">    str1 = str1.replace(<span class="string">']'</span>,<span class="string">''</span>).replace(<span class="string">'['</span>,<span class="string">''</span>).replace(<span class="string">' '</span>,<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">return</span> str1</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'e:/test_sigmoid222.txt'</span>,<span class="string">'r'</span>):</span><br><span class="line">    aa =  line.strip(<span class="string">'\n'</span>)  .split(<span class="string">'\t'</span>);</span><br><span class="line">    bb = map(int,aa[<span class="number">1</span>].split(<span class="string">','</span>));</span><br><span class="line">    cc = []</span><br><span class="line">    maxValues = max(bb)</span><br><span class="line">    minValues = min(bb)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> bb:</span><br><span class="line">        y = (float)(x-minValues)/(maxValues-minValues)</span><br><span class="line">        y = (int)(y*<span class="number">1000</span>)</span><br><span class="line">        cc.append(y)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'e:/test_sigmoid.txt'</span>,<span class="string">'a'</span>) <span class="keyword">as</span> of:</span><br><span class="line">        outstr = aa[<span class="number">0</span>]</span><br><span class="line">        outstr = outstr + <span class="string">"\t"</span></span><br><span class="line">        outstr = outstr + list_to_str(cc)</span><br><span class="line">        outstr = outstr + <span class="string">"\n"</span></span><br><span class="line">        of.write(outstr)</span><br></pre></td></tr></table></figure><h2 id="输入和输出">输入和输出</h2><h3 id="读取首行是字段名称的csv数据或者文本数据">读取首行是字段名称的CSV数据，或者文本数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># pandas.dataFrame 类型</span></span><br><span class="line">data = pd.read_csv(file_path)</span><br><span class="line"><span class="comment"># numpy  ndarray 类型</span></span><br><span class="line">data_matrix = data.as_matrix()</span><br></pre></td></tr></table></figure><h3 id="从控制台读取整数">从控制台读取整数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    lists = []</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        line = raw_input().split()</span><br><span class="line">        lists.append(string.atoi(line[<span class="number">0</span>]))</span><br><span class="line"><span class="keyword">except</span> EOFError:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 或者这样写</span></span><br><span class="line">(x,y) = (int(x) <span class="keyword">for</span> x <span class="keyword">in</span> raw_input().split())</span><br></pre></td></tr></table></figure><h3 id="读取控制台一行字符串">读取控制台一行字符串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    lineStrings=[]</span><br><span class="line">    lineStrings.append(raw_input())</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> EOFError:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者这样写</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">num = sys.stdin.readline()[:<span class="number">-1</span>] <span class="comment"># -1 to discard the '\n' in input stream</span></span><br></pre></td></tr></table></figure><h3 id="每次输出一个字符">每次输出一个字符</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.stdout.write(<span class="string">'a'</span>)</span><br><span class="line">sys.stdout.write(<span class="string">' '</span>)</span><br></pre></td></tr></table></figure><h3 id="倒序输出一个list">倒序输出一个List</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> range(<span class="number">10</span>)[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="格式转换">格式转换</h2><h3 id="字符串转整形和浮点型">字符串转整形和浮点型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line">string.atoi()</span><br><span class="line">string.atof()</span><br></pre></td></tr></table></figure><h2 id="数序运算">数序运算</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="keyword">print</span> a*<span class="number">2</span></span><br><span class="line"><span class="keyword">print</span> a**<span class="number">2</span></span><br><span class="line"><span class="keyword">print</span> a**<span class="number">0.5</span></span><br><span class="line"><span class="keyword">print</span> a%<span class="number">10</span></span><br><span class="line"><span class="keyword">print</span> a%<span class="number">3</span></span><br><span class="line"><span class="keyword">print</span> a/<span class="number">3</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_Scipy使用技巧</title>
      <link href="/hexoblog/2017/06/15/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_Scipy%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/hexoblog/2017/06/15/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_Scipy%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>scipy是一个统计工具包，包含各种各种的统计方法。本文主要记录各种统计计算需要调用的函数名称和函数的调用格式。</p><a id="more"></a><h2 id="单样本t检验">单样本T检验</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br><span class="line">pvalues = stats.ttest_1samp(dffeatures,mean=<span class="number">0.0</span>,axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="双样本t检验">双样本T检验</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br><span class="line">pvalues = stats.ttest_ind(group1,group2)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML,统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_分类器性能的度量</title>
      <link href="/hexoblog/2017/06/03/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB%E5%99%A8%E6%80%A7%E8%83%BD%E7%9A%84%E5%BA%A6%E9%87%8F/"/>
      <url>/hexoblog/2017/06/03/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB%E5%99%A8%E6%80%A7%E8%83%BD%E7%9A%84%E5%BA%A6%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>分类器性能的度量指标，包括<code>accuracy</code>,<code>recall</code>,<code>Specificity</code>,<code>precision</code>,<code>f1</code>,<code>ROC</code>,等概念的定义和如何使用<code>matplotlib</code>绘制相应的图形。</p><a id="more"></a><p>导入需要用到的包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br></pre></td></tr></table></figure><p>对于二分类问题，我们用列表示真正的类别标签，用行表示分类器预测的类别标签。</p><table><thead><tr class="header"><th></th><th>positive</th><th>negative</th></tr></thead><tbody><tr class="odd"><td>positive</td><td>TP</td><td>FP</td></tr><tr class="even"><td>negative</td><td>FN</td><td>TN</td></tr></tbody></table><p>两个大写字母表示的简写可以这样理解：T表示预测正确，F表示预测错误。P表示正例(例如病人的分类，病人是正例，健康的是负例。)， N表示负例。TP表示正确的预测为正例(可知该样本本身为正例。)，FP表示错误的预测为正例(可知该样本本身为负例)，FN表示错误的预测成为负例(可知该样本本身为正例)，TN表示正确的预测成为负例(可知该样本本身为负例).</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># get the table</span></span><br><span class="line">cm = confusion_matrix(y_true,y_pred)</span><br></pre></td></tr></table></figure><h3 id="accuracy">Accuracy</h3><p>中文一般翻译成<strong>准确率</strong>，这个是最容易理解的，就是分类正确的样本数量占样本总量的百分比。</p><p><span class="math display">\[Accuracy = \dfrac {TP+TN} {TP+FP+TN+FN}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accuracy_scores = metrics.accuracy_score(y_true,y_pred)</span><br></pre></td></tr></table></figure><h3 id="sensitivity">Sensitivity</h3><p><strong>Sensitivity(灵敏度)</strong>==<strong>recall(召回率)</strong>==<strong>true positive rate(真阳性率)</strong>==<strong>probability of detection</strong></p><p><span class="math display">\[recall = \dfrac {TP} {TP+FN}\]</span></p><p>含义是，所有病人中被分类成病人的 占 所有病人的百分比。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recall_scores=metrics.recall_score(y_true,y_pred)</span><br></pre></td></tr></table></figure><h3 id="specificity">Specificity</h3><p><strong>Specificity</strong>==<strong>true negative rate</strong></p><p><span class="math display">\[Specificity = \dfrac {TN} {TN+FP}\]</span></p><p>健康人被误分类成病人 占 所有健康人的 百分比。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">specificity_scores = cm[<span class="number">1</span>][<span class="number">1</span>] / (float)(cm[<span class="number">1</span>][<span class="number">1</span>]+cm[<span class="number">0</span>][<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h3 id="precision">precision</h3><p><strong>precision</strong> == <strong>positive predictive value</strong></p><p><span class="math display">\[precision = \dfrac {TP} {TP+FP}\]</span></p><p>在所有被分类成病人的样本中，真正的病人 占的百分比。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">precision_scores=metrics.precision_score(y_true,y_pred)</span><br></pre></td></tr></table></figure><h3 id="f1">F1</h3><p>精确率和召回率的调和平均值。</p><p><span class="math display">\[\dfrac 2 {F1}=\dfrac 1 {precision}+\dfrac 1 {recall}=\dfrac {2TP} {2TP+FP+FN}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f1_scores = metrics.f1_score(y_true,y_pred)</span><br></pre></td></tr></table></figure><h3 id="roc">ROC</h3><p>一种度量分类器性能的标准，曲线下面的面积越大，表示分类器越好。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_roc</span><span class="params">(pfAcc)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Parameters</span></span><br><span class="line"><span class="string">        ----------</span></span><br><span class="line"><span class="string">        pfAcc : (n_classifier, ) of dict, in each dict, it is a dict which has the key 'y_true','y_pred','y_predproba'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns</span></span><br><span class="line"><span class="string">        --------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        color=[<span class="string">'r'</span>,<span class="string">'b'</span>,<span class="string">'g'</span>,<span class="string">'y'</span>,<span class="string">'k'</span>,<span class="string">'#eeefff'</span>,<span class="string">'#e44fff'</span>,<span class="string">'#eee44f'</span>,<span class="string">'#eeef22'</span>,<span class="string">'#e99fff'</span>]</span><br><span class="line">        <span class="keyword">for</span> i,(key,value) <span class="keyword">in</span> enumerate(pfAcc.iteritems()):</span><br><span class="line">            y_true = np.asarray([x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> value[<span class="string">'y_true'</span>]])</span><br><span class="line">            y_pred_prob = np.asarray([x[<span class="number">0</span>][<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> value[<span class="string">'y_predprob'</span>]])</span><br><span class="line">            false_positive_rate, recall, thresholds = roc_curve(y_true,y_pred_prob,pos_label=<span class="number">2</span>)</span><br><span class="line">            roc_auc = auc(false_positive_rate, recall)</span><br><span class="line">            plt.plot(false_positive_rate, recall, color[i], label=key+<span class="string">',AUC = %0.2f'</span> % roc_auc)</span><br><span class="line">        plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>], <span class="string">'--'</span>, color=(<span class="number">0.6</span>, <span class="number">0.6</span>, <span class="number">0.6</span>), label=<span class="string">'Luck'</span>)</span><br><span class="line">        plt.xlim([<span class="number">-0.05</span>, <span class="number">1.05</span>])</span><br><span class="line">        plt.ylim([<span class="number">-0.05</span>, <span class="number">1.05</span>])</span><br><span class="line">        plt.xlabel(<span class="string">'False Positive Rate'</span>)</span><br><span class="line">        plt.ylabel(<span class="string">'True Positive Rate'</span>)</span><br><span class="line">        plt.legend(loc=<span class="string">"lower right"</span>)</span><br><span class="line">        plt.legend().draggable()</span><br><span class="line">        plt.show()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fMRI相关问题汇总</title>
      <link href="/hexoblog/2017/05/30/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/fMRI%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>/hexoblog/2017/05/30/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/fMRI%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>记录fMRI中还没有十分理解的概念。</p><a id="more"></a><h3 id="functional-connection-和-functional-connectivity"><code>functional connection</code> 和 <code>functional connectivity</code></h3><h2 id="相关的英文短语">相关的英文短语</h2><ol style="list-style-type: decimal"><li><p>At present, we do not have any biological tests which can contribute towards a diagnosis of depression.</p></li><li><p>is feasible 可行的。</p></li><li><p>These findings provide an important step in the development of potential neuroimaging based tools for clinical diagnosis as the findings demonstrate that the identification of depression is feasible within a multi-ethnic group from the general community.</p></li><li><p>understanding of the neuropsychopathology of depression.</p></li><li><p>Alzheimer’s disease has been linked to decreased default mode functional connectivity.</p></li><li><p>in line with</p></li><li><p>can be interpreted as 可以被解读为</p></li><li><p>The spDCM uses cross spectra through Fourier transform of the correlation of the time series instead of the original time series. Thus, spDCM is a deterministic DCM approach, which can computationally explain functional connectivity in an explicit and direct way. spDCM和功能连接的关系的一种解释。</p></li><li><p>respectively. 各自的，分别的。</p></li></ol><p>10.hexo</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 认知神经科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fMRI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法专题_字符串匹配</title>
      <link href="/hexoblog/2017/05/28/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
      <url>/hexoblog/2017/05/28/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p>字符串匹配问题的相关算法。</p><a id="more"></a><h2 id="kmp算法">KMP算法</h2><p>设有字符串T，模式串P，要从T中找出P，通常的做法是逐个比较T和P的第一个字符，如果相同，就比较T和P的第二个字符，一旦匹配失败，T后移一个字符重新开始与P的第一个字符比较。但是这样的方法如果遇到特别“刁钻”的T和P的组合，就会浪费很多比较的时间，例如，每次都是比较到P的最后一个字符才不匹配。KMP算法就是为了减少不必要的比较，使得每次比较不成功的时候，P可以向后移动尽可能远的距离。</p><p>每次失败后要向后移动多少呢？这个由P的next数组决定。next数组是一个与P等长，只与模式串P有关系，而与T没有关系的一个整数数组。它的值表示当前这个字符比较失败后，模式串向后移动的距离。</p><p>next数组如何求解呢？ P中任何一个字符对应的next数组的值，等于从P开始到它所对应的前缀和后缀的共有元素的长度。举例来说，P=“ABCDABD”</p><p>“A”的前缀和后缀都是0，共有的长度也是0；</p><p>“AB”的前缀是“A”,后缀是“B”,共有的长度是0；</p><p>“ABC”的前缀是“A”,“AB”,后缀是“C”,“BC”,共有的长度为0；</p><p>“ABCD”的前缀是“A”,“AB”,“ABC”,后缀是“D”,“CD”,“BCD”,共有的长度为0；</p><p>“ABCDA”的前缀是“A”,“AB”,“ABC”,“ABCD”,后缀是“A”,“DA”,“CDA”,“BCDA”,二者都有A，所有共有的长度是1.</p><p>“ABCDAB” 共有的长度为2</p><p>“ABCDABD” 共有的长度为0.</p><p>所以P的next数组为[0,0,0,0,1,2,0]. 可以看到，求解next数组的过程还是很清晰的，但是这个next数组并不是真正在KMP算法中使用的next数组。但是KMP算法中使用的next数组可以可容易的由这个数组生成，规则是：所有的元素右移一位。最右边的元素丢弃不要了，最左边补-1，这样新的next数组为[-1,0,0,0,0,1,2].</p><p>直到next数组的值，KMP算法其实就算实现了，接下来只需要在每次匹配失败的时候，模式串向右移动的位数是： 失配字符所在的位置-失配字符对应的next数组的值。</p><p>求解next数组的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  求解模式串的next数组</span></span><br><span class="line"><span class="comment"> * @param p</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; GetNext(<span class="built_in">string</span> p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> pLen = p.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next(pLen,<span class="number">0</span>);</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//p[k]表示前缀，p[j]表示后缀</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span> || p[j] == p[k])</span><br><span class="line">        &#123;</span><br><span class="line">            ++k;</span><br><span class="line">            ++j;</span><br><span class="line">            next[j] = k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法求解next数组其实并不是最优的，因为还有可能存在重复的比较，具体的实例可以参考<a href="http://blog.csdn.net/v_july_v/article/details/7041827" class="uri" target="_blank" rel="noopener">http://blog.csdn.net/v_july_v/article/details/7041827</a>, 优化后的next数组求解方法可以进一步减少比较的次数，只是这个会更不容易理解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; OGetNext(<span class="built_in">string</span> p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> pLen = p.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next(pLen,<span class="number">0</span>);</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//p[k]表示前缀，p[j]表示后缀</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span> || p[j] == p[k])</span><br><span class="line">        &#123;</span><br><span class="line">            ++j;</span><br><span class="line">            ++k;</span><br><span class="line">            <span class="comment">//较之前next数组求法，改动在下面4行</span></span><br><span class="line">            <span class="keyword">if</span> (p[j] != p[k])</span><br><span class="line">                next[j] = k;   <span class="comment">//之前只有这一行</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//因为不能出现p[j] = p[ next[j ]]，所以当出现时需要继续递归，k = next[k] = next[next[k]]</span></span><br><span class="line">                next[j] = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用next数组查找模式串第一次出现的位置，并返回索引的函数，不存在会返回-1.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KmpSearch</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="built_in">string</span> &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sLen = s.size();</span><br><span class="line">    <span class="keyword">int</span> pLen = p.size();</span><br><span class="line">    <span class="keyword">auto</span> next = OGetNext(p);</span><br><span class="line">    <span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == p[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]</span></span><br><span class="line">            <span class="comment">//next[j]即为j所对应的next值</span></span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == pLen)</span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用next数组比较字符串，返回模式串在S中出现的次数的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KmpSearch</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="built_in">string</span> &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sLen = s.size();</span><br><span class="line">    <span class="keyword">int</span> pLen = p.size();</span><br><span class="line">    <span class="keyword">auto</span> next = OGetNext(p);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;sLen)&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++</span></span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == p[j])</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]</span></span><br><span class="line">                <span class="comment">//next[j]即为j所对应的next值</span></span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == pLen)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            j=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字典树">字典树</h2><h3 id="异或今日头条2017秋招真题">异或（今日头条2017秋招真题）</h3><p><a href="http://exercise.acmcoder.com/online/online_judge_ques?ques_id=3338&amp;konwledgeId=158" target="_blank" rel="noopener">异或（今日头条2017秋招真题）</a></p><p>题目描述</p><p>给定整数m以及n个数字A1, A2, …, An，将数列A中所有元素两两异或，共能得到n(n-1)/2个结果。请求出这些结果中大于m的有多少个。</p><p>输入 第一行包含两个整数n, m。 第二行给出n个整数A1, A2, …, An。 样例输入 3 10 6 5 10 输出 输出仅包括一行，即所求的答案。 样例输出 2 时间限制 C/C++语言：1000MS其它语言：3000MS<br>内存限制 C/C++语言：65536KB其它语言：589824K</p><p>思路：</p><ol style="list-style-type: decimal"><li>从最高位开始建立字典树，左子树表示二进制0，右子树表示二进制位1. 每个节点统计在n个数字中对应的二进制位上有多少个对应的0或者1.</li><li><p>查询每个数字a和m，比较a和m对应的位，有如下情况 2.1 a = 0, m = 0, 这个时候 b=0 , a^b = 0 不能确定谁大，继续查找下一位 2.2 a = 0, m = 1, 这个时候 b=0 , 肯定有a^b &lt; m, 不满足条件，跳过； b = 1, 继续查找下一位 2.3 a = 1, m = 0, 这个时候 b=0 , 肯定有a^b &gt; m, 满足条件，直接将对应的count加在结果上， b=1,继续查找下一位 2.4 a = 1, m = 1, 这个时候 b=0 , 继续查找下一位，b = 1,肯定不满足条件，</p></li><li><p>最后的结果除以2返回， 因为我们既统计了a与b的异或，也统计了b与a的异或。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrieTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieTree</span>* <span class="title">next</span>[2]&#123;</span><span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">    TrieTree():count(<span class="number">1</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TrieTree* <span class="title">buildTrieTree</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TrieTree* trieTree = <span class="keyword">new</span> TrieTree();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="keyword">int</span>)<span class="built_in">array</span>.size();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        TrieTree* cur = trieTree;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">16</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> digit = (<span class="built_in">array</span>[i] &gt;&gt; j) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">NULL</span> == cur-&gt;next[digit])</span><br><span class="line">                cur-&gt;next[digit] = <span class="keyword">new</span> TrieTree();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ++(cur-&gt;next[digit]-&gt;count);</span><br><span class="line">            cur = cur-&gt;next[digit];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> trieTree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">queryTrieTree</span><span class="params">(TrieTree*&amp; trieTree, <span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> m, <span class="keyword">const</span> <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == trieTree)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    TrieTree* cur = trieTree;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> aDigit = (a &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mDigit = (m &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span>==aDigit &amp;&amp; <span class="number">1</span>==mDigit)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">NULL</span> == cur-&gt;next[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            cur = cur-&gt;next[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == aDigit &amp;&amp; <span class="number">1</span>==mDigit)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">NULL</span> == cur-&gt;next[<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            cur = cur-&gt;next[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">1</span> == aDigit &amp;&amp; <span class="number">0</span> == mDigit)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> val0 =  (<span class="literal">NULL</span> == cur-&gt;next[<span class="number">0</span>]) ? <span class="number">0</span> : cur-&gt;next[<span class="number">0</span>]-&gt;count;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> val1 =  queryTrieTree(cur-&gt;next[<span class="number">1</span>],a,m,i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span> val0+val1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == aDigit &amp;&amp; <span class="number">0</span> == mDigit)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> val0 =  queryTrieTree(cur-&gt;next[<span class="number">0</span>],a,m,i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> val1 =  (<span class="literal">NULL</span> == cur-&gt;next[<span class="number">1</span>]) ? <span class="number">0</span> : cur-&gt;next[<span class="number">1</span>]-&gt;count;</span><br><span class="line">            <span class="keyword">return</span> val0+val1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">solve</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span>&amp; m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TrieTree* trieTree = buildTrieTree(<span class="built_in">array</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="keyword">int</span>)<span class="built_in">array</span>.size();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        result += queryTrieTree(trieTree,<span class="built_in">array</span>[i],m,<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result /<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"d:/A.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;<span class="built_in">array</span>[i];</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; solve(<span class="built_in">array</span>,m) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXBIT = <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trieTree</span>&#123;</span></span><br><span class="line">    ll count = <span class="number">0</span>;</span><br><span class="line">    trieTree* next[<span class="number">2</span>] = &#123;<span class="literal">nullptr</span>, <span class="literal">nullptr</span>&#125;;</span><br><span class="line">    trieTree() : count(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    trieTree(<span class="keyword">int</span> c) : count(c)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">trieTree* <span class="title">createTree</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span>&#123;</span><br><span class="line">    trieTree* root = <span class="keyword">new</span> trieTree(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = MAXBIT; <span class="comment">// int 整形最多32位</span></span><br><span class="line">        trieTree* cur = root;</span><br><span class="line">        <span class="keyword">while</span>(index &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> digit = (arr[i] &gt;&gt; index) &amp; <span class="number">1</span>; <span class="comment">// 从低位到高位第index+1位的值</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next[digit] == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                cur-&gt;next[digit] = <span class="keyword">new</span> trieTree(<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next[digit]-&gt;count ++;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next[digit];</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询trie树中有多少个数字满足a^b&gt;m</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> * @param a</span></span><br><span class="line"><span class="comment"> * @param m</span></span><br><span class="line"><span class="comment"> * @param index</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ll <span class="title">queryTree</span><span class="params">(trieTree* root,<span class="keyword">int</span> a, <span class="keyword">int</span> m, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> aDigit = (a &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mDigit = (m &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(aDigit == <span class="number">0</span> &amp;&amp; mDigit == <span class="number">0</span>)&#123;</span><br><span class="line">            ll v0 = <span class="number">0</span> , v1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;next[<span class="number">1</span>] != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                v0 = root-&gt;next[<span class="number">1</span>]-&gt;count;</span><br><span class="line">            &#125;</span><br><span class="line">            v1 = queryTree(root-&gt;next[<span class="number">0</span>],a,m,i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span> v0 + v1;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(aDigit == <span class="number">0</span> &amp;&amp; mDigit == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;next[<span class="number">1</span>] == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> queryTree(root-&gt;next[<span class="number">1</span>],a,m,i<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(aDigit == <span class="number">1</span> &amp;&amp; mDigit == <span class="number">0</span>)&#123;</span><br><span class="line">            ll v0 = <span class="number">0</span> , v1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;next[<span class="number">0</span>] != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                v0 = root-&gt;next[<span class="number">0</span>]-&gt;count;</span><br><span class="line">            &#125;</span><br><span class="line">            v1 = queryTree(root-&gt;next[<span class="number">1</span>],a,m,i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span> v0 + v1;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(aDigit == <span class="number">1</span> &amp;&amp; mDigit == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;next[<span class="number">0</span>] == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> queryTree(root-&gt;next[<span class="number">0</span>],a,m,i<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"error"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    trieTree* root = createTree(v);</span><br><span class="line">    ll result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); ++i) &#123;</span><br><span class="line">        result += queryTree(root,v[i],m,MAXBIT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"d:/A.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(n,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;solve(v,m)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="统计子目录">统计子目录</h3><p><a href="http://hihocoder.com/problemset/problem/1551" target="_blank" rel="noopener">统计子目录</a></p><p>描述 小Hi的电脑的文件系统中一共有N个文件，例如：</p><p>/hihocoder/offer22/solutions/p1</p><p>/hihocoder/challenge30/p1/test</p><p>/game/moba/dota2/uninstall</p><p>小Hi想统计其中一共有多少个不同的子目录。上例中一共有8个不同的子目录：</p><p>/hihocoder</p><p>/hihocoder/offer22</p><p>/hihocoder/offer22/solutions</p><p>/hihocoder/challenge30</p><p>/hihocoder/challenge30/p1</p><p>/game</p><p>/game/moba</p><p>/game/moba/dota2/</p><p>输入 第一行包含一个整数N (1 ≤ N ≤ 10000)</p><p>以下N行每行包含一个字符串，代表一个文件的绝对路径。保证路径从根目录“/”开始，并且文件名和目录名只包含小写字母和数字。</p><p>对于80%的数据，N个文件的绝对路径长度之和不超过10000</p><p>对于100%的数据，N个文件的绝对路径长度之和不超过500000</p><p>输出 一个整数代表不同子目录的数目。</p><p>样例输入 3<br>/hihocoder/offer22/solutions/p1<br>/hihocoder/challenge30/p1/test<br>/game/moba/dota2/uninstall 样例输出 8</p><p>思路： 用每个目录的名字建立字典树，根是空字符，然后统计整棵树节点的数目，最后返回节点的数目-1.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * [统计子目录](http://hihocoder.com/problemset/solution/1157194)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trieTree</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> description;</span><br><span class="line">    <span class="built_in">vector</span>&lt;trieTree*&gt; sons;</span><br><span class="line">    trieTree() : description(<span class="string">""</span>)&#123;&#125;</span><br><span class="line">    trieTree(<span class="built_in">string</span> &amp;s) : description(s)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 层次遍历统计节点数目</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(trieTree* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;sons.empty()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;trieTree*&gt; nodes, next;</span><br><span class="line">    nodes.push_back(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> re = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.size(); ++i) &#123;</span><br><span class="line">            next.insert(next.end(),nodes[i]-&gt;sons.begin(),nodes[i]-&gt;sons.end());</span><br><span class="line">        &#125;</span><br><span class="line">        re += nodes.size();</span><br><span class="line">        nodes = next;</span><br><span class="line">        next.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归遍历节点数目</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countNode2</span><span class="params">(trieTree *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;sons.empty()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> re = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; root-&gt;sons.size(); ++i) &#123;</span><br><span class="line">        re += countNode2(root-&gt;sons[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; splitString(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; re;</span><br><span class="line">    <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> re;</span><br><span class="line">    <span class="keyword">size_t</span> index1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> index2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(s.find(<span class="string">'/'</span>,index2) != <span class="number">-1</span>)&#123;</span><br><span class="line">        index2 = s.find(<span class="string">'/'</span>,index1+<span class="number">1</span>);</span><br><span class="line">        re.push_back(s.substr(index1+<span class="number">1</span>,index2-index1<span class="number">-1</span>));</span><br><span class="line">        index1 = index2;</span><br><span class="line">        index2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;pathes, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pathes.empty() || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    trieTree *root = <span class="keyword">new</span> trieTree();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path = splitString(pathes[i]);</span><br><span class="line">        trieTree *cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; path.size(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;sons.empty())&#123;</span><br><span class="line">                cur-&gt;sons.push_back(<span class="keyword">new</span> trieTree(path[j]));</span><br><span class="line">                result++;</span><br><span class="line">                cur = cur-&gt;sons[<span class="number">0</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> index = cur-&gt;sons.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cur-&gt;sons.size(); ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cur-&gt;sons[k]-&gt;description == path[j])&#123;</span><br><span class="line">                        index = k;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(index == cur-&gt;sons.size())&#123;</span><br><span class="line">                    cur-&gt;sons.push_back(<span class="keyword">new</span> trieTree(path[j]));</span><br><span class="line">                    result++;</span><br><span class="line">                    cur = cur-&gt;sons[cur-&gt;sons.size()<span class="number">-1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cur = cur-&gt;sons[index];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> re = countNode2(root) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"d:/A.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; pathes(n,<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; pathes[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;solve(pathes,n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并子目录">合并子目录</h3><p><a href="http://hihocoder.com/problemset/solution/1157744" target="_blank" rel="noopener">合并子目录</a></p><p>描述 小Hi的电脑的文件系统中一共有N个文件，例如：</p><p>/hihocoder/offer23/solutions/p1</p><p>/hihocoder/challenge30/p1/test</p><p>/game/moba/dota2/uninstall</p><p>经过统计，小Hi认为他的电脑中子目录实在太多了，于是他决定减少子目录的数量。小Hi发现其中一些子目录只包含另一个子目录，例如/hihocoder/offer22只包含一个子目录solution，/game只包含一个子目录moba，而moba也只包含一个子目录dota2。小Hi决定把这样的子目录合并成一个子目录，并且将被合并的子目录的名字用’-’连起来作为新子目录的名字。合并之后上例的3个文件的路径会变为：</p><p>/hihocoder/offer23-solutions/p1</p><p>/hihocoder/challenge30-p1/test</p><p>/game-moba-dota2/uninstall</p><p>输入 第一行包含一个整数N (1 ≤ N ≤ 10000)</p><p>以下N行每行包含一个字符串，代表一个文件的绝对路径。保证路径从根目录“/”开始，并且文件名和目录名只包含小写字母和数字。</p><p>对于80%的数据，N个文件的绝对路径长度之和不超过10000</p><p>对于100%的数据，N个文件的绝对路径长度之和不超过500000</p><p>输出 对于输入中的每个文件，输出合并子目录之后该文件的绝对路径。</p><p>样例输入 3 /hihocoder/offer23/solutions/p1 /hihocoder/challenge30/p1/test /game/moba/dota2/uninstall 样例输出 /hihocoder/offer23-solutions/p1 /hihocoder/challenge30-p1/test /game-moba-dota2/uninstall</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * [统计子目录](http://hihocoder.com/problemset/solution/1157194)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trieTree</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> description;</span><br><span class="line">    <span class="built_in">vector</span>&lt;trieTree*&gt; sons;</span><br><span class="line">    trieTree() : description(<span class="string">""</span>)&#123;&#125;</span><br><span class="line">    trieTree(<span class="built_in">string</span> &amp;s) : description(s)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; splitString(<span class="built_in">string</span> &amp;s)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; re;</span><br><span class="line">    <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> re;</span><br><span class="line">    s.push_back(<span class="string">'/'</span>);</span><br><span class="line">    <span class="keyword">size_t</span> index1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> index2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(s.find(<span class="string">'/'</span>,index2) != <span class="number">-1</span>)&#123;</span><br><span class="line">        index2 = s.find(<span class="string">'/'</span>,index1+<span class="number">1</span>);</span><br><span class="line">        re.push_back(s.substr(index1+<span class="number">1</span>,index2-index1<span class="number">-1</span>));</span><br><span class="line">        index1 = index2;</span><br><span class="line">        index2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">trieTree* <span class="title">createTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;pathes)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pathes.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    trieTree *root = <span class="keyword">new</span> trieTree();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pathes.size(); ++i) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path = splitString(pathes[i]);</span><br><span class="line">        trieTree *cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; path.size(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;sons.empty())&#123;</span><br><span class="line">                cur-&gt;sons.push_back(<span class="keyword">new</span> trieTree(path[j]));</span><br><span class="line">                result++;</span><br><span class="line">                cur = cur-&gt;sons[<span class="number">0</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> index = cur-&gt;sons.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cur-&gt;sons.size(); ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cur-&gt;sons[k]-&gt;description == path[j])&#123;</span><br><span class="line">                        index = k;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(index == cur-&gt;sons.size())&#123;</span><br><span class="line">                    cur-&gt;sons.push_back(<span class="keyword">new</span> trieTree(path[j]));</span><br><span class="line">                    result++;</span><br><span class="line">                    cur = cur-&gt;sons[cur-&gt;sons.size()<span class="number">-1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cur = cur-&gt;sons[index];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">trieTree* <span class="title">reduceTree</span><span class="params">(trieTree* root)</span></span>&#123;</span><br><span class="line">    trieTree* re = root;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;sons.empty()) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;sons.size() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; root-&gt;sons.size(); ++i) &#123;</span><br><span class="line">            reduceTree(root-&gt;sons[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;sons.size() == <span class="number">1</span>)&#123;</span><br><span class="line">        trieTree* next = root-&gt;sons[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(next-&gt;sons.empty())&#123;</span><br><span class="line"><span class="comment">//            root-&gt;description = root-&gt;description + "-";</span></span><br><span class="line"><span class="comment">//            root-&gt;description = root-&gt;description + next-&gt;description;</span></span><br><span class="line"><span class="comment">//            root-&gt;sons.clear();</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;sons.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; next-&gt;sons.size(); ++i) &#123;</span><br><span class="line">            root-&gt;sons.push_back(next-&gt;sons[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;description = root-&gt;description + <span class="string">"-"</span>;</span><br><span class="line">        root-&gt;description = root-&gt;description + next-&gt;description;</span><br><span class="line">        reduceTree(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTree</span><span class="params">(trieTree* root,<span class="built_in">string</span> out)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">nullptr</span> == root) <span class="keyword">return</span>;</span><br><span class="line">    out += root-&gt;description + <span class="string">"/"</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;sons.empty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(out.find_last_of(<span class="string">'/'</span>) == out.size() - <span class="number">1</span>)&#123;</span><br><span class="line">            out.erase(out.size()<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;out&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; root-&gt;sons.size(); ++i) &#123;</span><br><span class="line">            printTree(root-&gt;sons[i],out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;pathes, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    trieTree* root = createTree(pathes);</span><br><span class="line">    trieTree* reduced = reduceTree(root);</span><br><span class="line">    <span class="built_in">string</span> out = <span class="string">""</span>;</span><br><span class="line">    printTree(reduced,out);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"d:/A.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; pathes(n,<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; pathes[i];</span><br><span class="line">    &#125;</span><br><span class="line">    solve(pathes,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计蒜之道2017程序设计大赛</title>
      <link href="/hexoblog/2017/05/27/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E8%AE%A1%E8%92%9C%E4%B9%8B%E9%81%932017%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B/"/>
      <url>/hexoblog/2017/05/27/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E8%AE%A1%E8%92%9C%E4%B9%8B%E9%81%932017%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<p>记录计蒜之道竞赛题目的相关解题方案。</p><a id="more"></a><h2 id="计蒜之道-初赛-第一场">2017 计蒜之道 初赛 第一场</h2><h3 id="阿里的新游戏">阿里的新游戏</h3><p><strong>题目要求</strong></p><p>题库链接：<a href="https://nanti.jisuanke.com/t/15499" class="uri" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/15499</a></p><p><strong>题目分析</strong></p><p>仔细分析能够成三的坐标，发现非常有规律。可以按照这个规律遍历成三的坐标，一旦成三的坐标上都有小红的棋子在，结果就加1.</p><p>小红棋子的坐标我们用一个二维数组H来存储，H[i][j]=1表示在棋盘的x,y位置有小红的棋子。那么我们必须找出x,y和i,j之间的映射关系。这个是一个简单的坐标变换问题，直接给出变换关系如下：</p><p><span class="math display">\[i = -y+3 \\j = x+3\]</span></p><p>接下来就可以从行和列的角度分别遍历成三的坐标，检查是否成三了。完整的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">int</span> hong[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">int</span> x = -b+<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> y = a+<span class="number">3</span>;</span><br><span class="line">        hong[x][y] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">-3</span>;x&lt;=<span class="number">3</span>;x++)&#123;</span><br><span class="line">        <span class="keyword">int</span> i1 = -x+<span class="number">3</span>,i2=x+<span class="number">3</span>,i3=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> j = x+<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">            (hong[i1][j]==<span class="number">1</span> &amp;&amp; hong[i2][j]==<span class="number">1</span> &amp;&amp; hong[i3][j]==<span class="number">1</span>)?num++:num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> ii1=<span class="number">-1</span>+<span class="number">3</span>,ii2=<span class="number">-2</span>+<span class="number">3</span>,ii3=<span class="number">-3</span>+<span class="number">3</span>;</span><br><span class="line">            (hong[ii1][j]==<span class="number">1</span> &amp;&amp; hong[ii2][j]==<span class="number">1</span> &amp;&amp; hong[ii3][j]==<span class="number">1</span>)?num++:num;</span><br><span class="line">            ii3=<span class="number">3</span>+<span class="number">3</span>, ii1= <span class="number">1</span> + <span class="number">3</span>, ii2= <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">            (hong[ii1][j]==<span class="number">1</span> &amp;&amp; hong[ii2][j]==<span class="number">1</span> &amp;&amp; hong[ii3][j]==<span class="number">1</span>)?num++:num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">-3</span>;y&lt;=<span class="number">3</span>;y++)&#123;</span><br><span class="line">        <span class="keyword">int</span> i = -y+<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> j1 = -y+<span class="number">3</span>,j2=y+<span class="number">3</span>,j3=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(y!=<span class="number">0</span>)&#123;</span><br><span class="line">            (hong[i][j1]==<span class="number">1</span> &amp;&amp; hong[i][j2]==<span class="number">1</span> &amp;&amp; hong[i][j3]==<span class="number">1</span>)?num++:num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(y==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> jj1=<span class="number">-3</span>+<span class="number">3</span>,jj2=<span class="number">-2</span>+<span class="number">3</span>,jj3=<span class="number">-1</span>+<span class="number">3</span>;</span><br><span class="line">            (hong[i][jj1]==<span class="number">1</span> &amp;&amp; hong[i][jj2]==<span class="number">1</span> &amp;&amp; hong[i][jj3]==<span class="number">1</span>)?num++:num;</span><br><span class="line">            jj1=<span class="number">3</span>+<span class="number">3</span>,jj2=<span class="number">2</span>+<span class="number">3</span>,jj3=<span class="number">1</span>+<span class="number">3</span>;</span><br><span class="line">            (hong[i][jj1]==<span class="number">1</span> &amp;&amp; hong[i][jj2]==<span class="number">1</span> &amp;&amp; hong[i][jj3]==<span class="number">1</span>)?num++:num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="阿里天池的新任务">阿里天池的新任务</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; OGetNext(<span class="built_in">string</span> p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> pLen = p.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next(pLen,<span class="number">0</span>);</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//p[k]表示前缀，p[j]表示后缀</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span> || p[j] == p[k])</span><br><span class="line">        &#123;</span><br><span class="line">            ++j;</span><br><span class="line">            ++k;</span><br><span class="line">            <span class="comment">//较之前next数组求法，改动在下面4行</span></span><br><span class="line">            <span class="keyword">if</span> (p[j] != p[k])</span><br><span class="line">                next[j] = k;   <span class="comment">//之前只有这一行</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//因为不能出现p[j] = p[ next[j ]]，所以当出现时需要继续递归，k = next[k] = next[next[k]]</span></span><br><span class="line">                next[j] = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KmpSearch</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="built_in">string</span> &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sLen = s.size();</span><br><span class="line">    <span class="keyword">int</span> pLen = p.size();</span><br><span class="line">    <span class="keyword">auto</span> next = OGetNext(p);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;sLen)&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++</span></span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == p[j])</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]</span></span><br><span class="line">                <span class="comment">//next[j]即为j所对应的next值</span></span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == pLen)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            j=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,a,b,L,R;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;L&gt;&gt;R;</span><br><span class="line">    <span class="built_in">string</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(n,<span class="string">' '</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> wi = (i*a+b)%n;</span><br><span class="line">        <span class="keyword">if</span>((wi&lt;L||wi&gt;R)&amp;&amp;wi%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            s[i] = <span class="string">'G'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((wi&lt;L||wi&gt;R)&amp;&amp;wi%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            s[i] = <span class="string">'C'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((wi&gt;=L&amp;&amp;wi&lt;=R)&amp;&amp;wi%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            s[i]=<span class="string">'A'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((wi&gt;=L&amp;&amp;wi&lt;=R)&amp;&amp;wi%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            s[i]=<span class="string">'T'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;KmpSearch(s,t)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计蒜之道-初赛-第二场">2017 计蒜之道 初赛 第二场</h2><h3 id="百度的年会游戏">百度的年会游戏</h3><p><strong>题目要求</strong></p><p><a href="https://nanti.jisuanke.com/t/15503" class="uri" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/15503</a></p><p><strong>题目分析</strong></p><p>建立合适的坐标系，把人和第几个木块对应到建立的坐标系上，只要坐标的转换过程不出错。题目很容易解决。可以暴力遍历每一种组合，看是否能够赢。毕竟解的空间很小，完全不用考虑时间复杂度的问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1,num2,num3,num4,k,d;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;num1&gt;&gt;num2&gt;&gt;num3&gt;&gt;num4&gt;&gt;k&gt;&gt;d;</span><br><span class="line">    <span class="keyword">int</span> total = num1+num2+num3+num4;</span><br><span class="line">    <span class="comment">// 0 表示普通的，1表示获胜的木块</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; zh(total,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line">        zh[d<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">        zh[d] = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="number">2</span>)&#123;</span><br><span class="line">        zh[num1+num4+num3+d<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">        zh[num1+num4+num3+d] = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="number">3</span>)&#123;</span><br><span class="line">        zh[num1+num4+d<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">        zh[num1+num4+d] = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        zh[num1+d<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">        zh[num1+d] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=<span class="number">6</span>;x++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y=x;y&lt;=<span class="number">6</span>;y++)&#123;</span><br><span class="line">            <span class="comment">// 从谁的面前开始数</span></span><br><span class="line">            <span class="keyword">int</span> people = (x+y)%<span class="number">4</span>==<span class="number">0</span> ? <span class="number">4</span> : (x+y)%<span class="number">4</span>;</span><br><span class="line">            <span class="comment">//数多少个开始拿</span></span><br><span class="line">            <span class="keyword">int</span> kth = min(x,y)+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//判断能不能获胜</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计蒜之道-初赛-第三场">2017 计蒜之道 初赛 第三场</h2><h3 id="腾讯课堂的物理实验">腾讯课堂的物理实验</h3><p><strong>题目要求</strong></p><div class="figure"><img src="2017-05-27_223022.png"></div><p>题库链接：<a href="https://nanti.jisuanke.com/t/15546" class="uri" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/15546</a></p><p><strong>题目分析</strong></p><p>光滑跑道，两个小球都是匀速运动，碰撞之后向反方向运动，各自的速度不变(依然保持<code>1m/s</code>),所以可以看作两个小球不受干扰的各自在跑道上运动，运动到跑道的边缘返回(因为题目中只是求解两个小球的距离，并不要求区分哪个小球是A, 哪个是B.)</p><p>我们把0时刻A所在的位置定位坐标原点，B所在的位置的坐标就是<code>L</code>,只要求解出T时刻A的坐标x1和B的坐标x2，就能轻松得到二者的距离为<code>|x1-x2|</code>. T时刻A走过的路程是T，此时它的坐标应该是<code>x=(T/L)%2==0 ? T%L : L-(T%L)</code>,T时刻B走过的路程要分情况讨论，当<code>T&lt;=t</code>的时候，B在L处，此时y=L;当<code>T&gt;t</code>时，B运动的时间是<code>T-t</code>,路程也是<code>T-t</code>,此时它的坐标是<code>y=((T-t)/L%2==0) ? L-(T-t)%L : (T-t)%L</code>.</p><p>完整的解题代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L,t,T;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;L&gt;&gt;t&gt;&gt;T;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,y=L,dis=<span class="number">0</span>;</span><br><span class="line">    x=(T/L)%<span class="number">2</span>==<span class="number">0</span> ? T%L : L-(T%L);</span><br><span class="line">    <span class="keyword">if</span>(T&gt;t)&#123;</span><br><span class="line">        y=((T-t)/L%<span class="number">2</span>==<span class="number">0</span>) ? L-(T-t)%L : (T-t)%L;</span><br><span class="line">    &#125;</span><br><span class="line">    dis = <span class="built_in">abs</span>(x-y);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dis&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="腾讯狼人杀">腾讯狼人杀</h3><p><strong>题目要求</strong></p><div class="figure"><img src="2017-05-27_224751.png"></div><p>题库链接：<a href="https://nanti.jisuanke.com/t/15547" class="uri" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/15547</a></p><p><strong>题目分析</strong></p><p>最终要 求的是 <span class="math inline">\(value = \dfrac {\sum w_i} {k(2n-k)}\)</span> 的最大值，所以要确定的是k的值，选几个人，还有就是都选哪些人。这些确定了就可以计算答案了。这个题目给出了简单，中等，困难三个难度等级。按照一般的套路，简单的问题是可以暴力求解的。所以，我们首先试着用遍历的方式求解该题目的简单版本。</p><p>如果暂时不考虑最后一个限制条件，那么这就是一个全排列问题。假设m=3，有3条记录。那么所有的情况是：(1),(2),(3),(1,2),(1,3),(2,3),(1,2,3), 共有6种情况，计算这6种情况下对应的value,取最大的输出就可以。</p><p>枚举所有的情况是找一个集合的子集的问题，集合元素是m的时候，它的所有子集是 <span class="math inline">\(2^m\)</span>,这里空集没有意义，所以要枚举的情况有 <span class="math inline">\(2^m-1\)</span> 种。枚举一个集合的所有子集的问题可以使用<strong>位操作</strong>加快速度，对于每个枚举出来的项，首先判断是否满足限制条件，不满足的直接舍弃。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_损失函数</title>
      <link href="/hexoblog/2017/05/22/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"/>
      <url>/hexoblog/2017/05/22/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>衡量预测标签和真实标签之间的差别，通常使用损失函数。</p><a id="more"></a><h2 id="log对数损失函数逻辑回归">log对数损失函数（逻辑回归）</h2><h2 id="平方损失最小二乘法">平方损失(最小二乘法)</h2><h2 id="指数损失函数adaboost">指数损失函数（Adaboost）</h2><h2 id="hinge损失函数svm">Hinge损失函数（SVM）</h2><h2 id="section"></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_逻辑回归</title>
      <link href="/hexoblog/2017/05/19/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
      <url>/hexoblog/2017/05/19/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p>本文总结常见的线性模型和他们之间的区别和联系。线性模型是一种比较简单的模型，实际使用中已经有了多种变化，来满足不同的需求。</p><a id="more"></a><h2 id="线性模型">线性模型</h2><p>最基本的线性模型是下面这样的形式：</p><p><span class="math display">\[y = w_1x_1+w_2x_2+...+w_nx_n = w * x + b\]</span></p><p>给定一组训练数据 <span class="math inline">\((X,y)\)</span>, 只要确定了 <span class="math inline">\(w\)</span> 和 <span class="math inline">\(b\)</span>, 这个线性模型就确定了，就可以利用它来预测。</p><h2 id="广义线性模型">广义线性模型</h2><p>简单的说，在 <span class="math inline">\(w*x+b\)</span>的基础上再增加一个函数映射，把结果赋值给y,这样的模型叫做广义线性模型。</p><p><span class="math display">\[y = f(w*x+b)\]</span></p><p>式子中的 <span class="math inline">\(f(x)\)</span> 可以是各种映射函数，当 <span class="math inline">\(f(x)=x\)</span> 的时候，就是普通的线性模型了。</p><h2 id="逻辑回归">逻辑回归</h2><p>逻辑回归应该也算作是一种广义的线性模型，它就是 <span class="math inline">\(f(x) = sigmoid\)</span> 函数的的广义线性模型。最常使用的<code>sigmoid</code>函数定义为：</p><p><span class="math display">\[f(x) = \dfrac {1} {1+e^{-z}}\]</span></p><h2 id="softmax-回归">softmax 回归</h2><p>逻辑回归的<code>sigmoid</code>函数取值范围是0-1，通常只能用来解决二分类问题。我们可以扩展该方法，使之能处理n类的分类问题。这里其实就是把原来的<code>sigmoid</code>函数换成<code>softmax</code>函数.<code>softmax</code>函数是逻辑函数的一种推广。它能将一个含任意实数的 <span class="math inline">\(K\)</span>维的向量 <span class="math inline">\(z\)</span> 压缩”到另一个K维实向量中，使得每一个元素的范围都在(0, 1)之间，并且所有元素的和为1.</p><p><span class="math display">\[{\displaystyle \sigma (\mathbf {z} )_{j}={\frac {e^{z_{j}}}{\sum _{k=1}^{K}e^{z_{k}}}}}    for j = 1, …, K.\]</span></p><h2 id="线性模型与神经网络的关系">线性模型与神经网络的关系</h2><div class="figure"><img src="QQ截图20170519205705.png"></div>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_感知机</title>
      <link href="/hexoblog/2017/05/19/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
      <url>/hexoblog/2017/05/19/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>感知机是神经网络的基本组成单元，这里有一篇文章是从零基础开始介绍感知机的，本文就是参考她实现的感知机。<a href="https://www.zybuluo.com/hanbingtao/note/433855" class="uri" target="_blank" rel="noopener">https://www.zybuluo.com/hanbingtao/note/433855</a></p><a id="more"></a><h2 id="自己动手实现感知机">自己动手实现感知机</h2><p>感知机是只有一层功能神经元的最简单的神经网络，它只能处理简单的线性分类。它的基本形式是：</p><div class="figure"><img src="2017-05-19_145930.png" alt="perception"><p class="caption">perception</p></div><p>设 <span class="math inline">\(x\)</span> 表示输入向量，<span class="math inline">\(y\)</span> 表示输出，感知机其实就是实现了以下的函数的结构：</p><p><span class="math display">\[y = f(w \times x + b)\]</span></p><p>其中，<span class="math inline">\(w\)</span> 是一个和 <span class="math inline">\(x\)</span> 长度相同的向量，代表每个 <span class="math inline">\(x_i\)</span> 的权重，<span class="math inline">\(b\)</span> 是一个实数，表示偏置。<span class="math inline">\(f(x)\)</span> 是任意一个定义在实数域上的函数，输入是一个实数，输出是一个实数。</p><p>感知机的<strong>学习</strong>就是根据给出的 <span class="math inline">\(x\)</span> 和对应的 <span class="math inline">\(y\)</span>, 求解出参数 <span class="math inline">\(w\)</span> 和偏置 <span class="math inline">\(b\)</span>. 感知机的<strong>预测</strong>就是利用训练好的模型( <span class="math inline">\(w\)</span> 和 <span class="math inline">\(b\)</span> 已经确定)，给出 <span class="math inline">\(x\)</span>, 求解 <span class="math inline">\(y\)</span>.</p><p>开始的时候，<span class="math inline">\(w\)</span> 和 <span class="math inline">\(b\)</span> 都初始化为0，用python代码表示就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_num, activator)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        初始化感知器，设置输入参数的个数，以及激活函数。</span></span><br><span class="line"><span class="string">        激活函数的类型为double -&gt; double</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.activator = activator</span><br><span class="line">        <span class="comment"># 权重向量初始化为0</span></span><br><span class="line">        self.weights = [<span class="number">0.0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(input_num)]</span><br><span class="line">        <span class="comment"># 偏置项初始化为0</span></span><br><span class="line">        self.bias = <span class="number">0.0</span></span><br></pre></td></tr></table></figure><p>其中，<code>input_num</code>表示向量 <span class="math inline">\(x\)</span> 包含多少个数字，<code>activator</code> 是上式中的 <span class="math inline">\(f(x)\)</span>.</p><p>感知机的预测就是在已知 <span class="math inline">\(w\)</span> 和 <span class="math inline">\(b\)</span> 的情况下， 计算 <span class="math inline">\(y\)</span>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, input_vec)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        输入向量，输出感知器的计算结果</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="comment"># 把input_vec[x1,x2,x3...]和weights[w1,w2,w3,...]打包在一起</span></span><br><span class="line">        <span class="comment"># 变成[(x1,w1),(x2,w2),(x3,w3),...]</span></span><br><span class="line">        <span class="comment"># 然后利用map函数计算[x1*w1, x2*w2, x3*w3]</span></span><br><span class="line">        <span class="comment"># 最后利用reduce求和</span></span><br><span class="line">        <span class="keyword">return</span> self.activator(</span><br><span class="line">            reduce(<span class="keyword">lambda</span> a, b: a + b,</span><br><span class="line">                   map(<span class="keyword">lambda</span> (x, w): x * w,</span><br><span class="line">                       zip(input_vec, self.weights))</span><br><span class="line">                , <span class="number">0.0</span>) + self.bias)</span><br></pre></td></tr></table></figure><p>感知机的训练就是在给出 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 的情况下，一步一步调整 <span class="math inline">\(w\)</span> 和 <span class="math inline">\(b\)</span> 的取值，使得输入和输出尽可能的匹配。这里直接给出参数调整的方法，至于为什么会是这样，为什么这样可以保证得到结果，可以看算法导论上相关的数学推导。</p><p><span class="math display">\[w_i \leftarrow w_i + \triangle w_i \\b \leftarrow b + \triangle b \\其中 \\\triangle w = \beta (t-y) x_i \\\triangle b = \beta (t-y)\]</span></p><p><span class="math inline">\(y\)</span> 是感知机在当前的参数设置条件下(初始化的时候都是0) 的输出， <span class="math inline">\(y\)</span> 是训练数据实际的标签，<span class="math inline">\(\beta\)</span> 称为<strong>学习率</strong>，控制参数更新的程度大小。可以看到，参数学习的时候，感知机是一条一条的处理的训练数据的，每处理一条训练数据，参数就更新一次，先来看看权重更新的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_update_weights</span><span class="params">(self, input_vec, output, label, rate)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        按照感知器规则更新权重</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="comment"># 把input_vec[x1,x2,x3,...]和weights[w1,w2,w3,...]打包在一起</span></span><br><span class="line">        <span class="comment"># 变成[(x1,w1),(x2,w2),(x3,w3),...]</span></span><br><span class="line">        <span class="comment"># 然后利用感知器规则更新权重</span></span><br><span class="line">        delta = label - output</span><br><span class="line">        self.weights = map(</span><br><span class="line">            <span class="keyword">lambda</span> (x, w): w + rate * delta * x,</span><br><span class="line">            zip(input_vec, self.weights))</span><br><span class="line">        <span class="comment"># 更新bias</span></span><br><span class="line">        self.bias += rate * delta</span><br></pre></td></tr></table></figure><p>把所有的训练数据都循环处理一遍，就完成了一次<strong>迭代</strong>，通常，只处理一次参数是不能得到充分的学习的，训练的时候要根据模型的复杂程度进行多次迭代，每次迭代参数都会更新。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_one_iteration</span><span class="params">(self, input_vecs, labels, rate)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        一次迭代，把所有的训练数据过一遍</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="comment"># 把输入和输出打包在一起，成为样本的列表[(input_vec, label), ...]</span></span><br><span class="line">        <span class="comment"># 而每个训练样本是(input_vec, label)</span></span><br><span class="line">        samples = zip(input_vecs, labels)</span><br><span class="line">        <span class="comment"># 对每个样本，按照感知器规则更新权重</span></span><br><span class="line">        <span class="keyword">for</span> (input_vec, label) <span class="keyword">in</span> samples:</span><br><span class="line">            <span class="comment"># 计算感知器在当前权重下的输出</span></span><br><span class="line">            output = self.predict(input_vec)</span><br><span class="line">            <span class="comment"># 更新权重</span></span><br><span class="line">            self._update_weights(input_vec, output, label, rate)</span><br></pre></td></tr></table></figure><p>上面的代码就是完成一次迭代的过程，首先用现有的感知机的参数，预测输入 <span class="math inline">\(x\)</span> 对应的输出 <span class="math inline">\(y\)</span>, 然后调用上面的参数更新函数，更新参数。</p><p>我们这里用<strong>迭代次数</strong>控制算法的停止时间，得到训练的方法. 当然，实际当中也可以用误差小于某一个给定的值来作为算法终止的条件。为什么要有误差，而不是百分之百的匹配上呢? 这是因为，在机器学习当中，百分之百拟合了训练数据，往往意味着过拟合了，在测试数据并不一定表现好，而我们需要的是在测试集上表现好。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(self, input_vecs, labels, iteration, rate)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        输入训练数据：一组向量、与每个向量对应的label；以及训练轮数、学习率</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(iteration):</span><br><span class="line">            self._one_iteration(input_vecs, labels, rate)</span><br></pre></td></tr></table></figure><p>一个简单的感知机的实现就是这样，实际使用的时候，还可以添加一些模型可视化的方法，例如输出模型参数 <span class="math inline">\(w\)</span> 和 <span class="math inline">\(b\)</span> 的方法，显示每次迭代过程的方法等等。下面是完整的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Perceptron</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_num, activator)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        初始化感知器，设置输入参数的个数，以及激活函数。</span></span><br><span class="line"><span class="string">        激活函数的类型为double -&gt; double</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.activator = activator</span><br><span class="line">        <span class="comment"># 权重向量初始化为0</span></span><br><span class="line">        self.weights = [<span class="number">0.0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(input_num)]</span><br><span class="line">        <span class="comment"># 偏置项初始化为0</span></span><br><span class="line">        self.bias = <span class="number">0.0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        打印学习到的权重、偏置项</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'weights\t:%s\nbias\t:%f\n'</span> % (self.weights, self.bias)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, input_vec)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        输入向量，输出感知器的计算结果</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="comment"># 把input_vec[x1,x2,x3...]和weights[w1,w2,w3,...]打包在一起</span></span><br><span class="line">        <span class="comment"># 变成[(x1,w1),(x2,w2),(x3,w3),...]</span></span><br><span class="line">        <span class="comment"># 然后利用map函数计算[x1*w1, x2*w2, x3*w3]</span></span><br><span class="line">        <span class="comment"># 最后利用reduce求和</span></span><br><span class="line">        <span class="keyword">return</span> self.activator(</span><br><span class="line">            reduce(<span class="keyword">lambda</span> a, b: a + b,</span><br><span class="line">                   map(<span class="keyword">lambda</span> (x, w): x * w,</span><br><span class="line">                       zip(input_vec, self.weights))</span><br><span class="line">                , <span class="number">0.0</span>) + self.bias)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(self, input_vecs, labels, iteration, rate)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        输入训练数据：一组向量、与每个向量对应的label；以及训练轮数、学习率</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(iteration):</span><br><span class="line">            self._one_iteration(input_vecs, labels, rate)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_one_iteration</span><span class="params">(self, input_vecs, labels, rate)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        一次迭代，把所有的训练数据过一遍</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="comment"># 把输入和输出打包在一起，成为样本的列表[(input_vec, label), ...]</span></span><br><span class="line">        <span class="comment"># 而每个训练样本是(input_vec, label)</span></span><br><span class="line">        samples = zip(input_vecs, labels)</span><br><span class="line">        <span class="comment"># 对每个样本，按照感知器规则更新权重</span></span><br><span class="line">        <span class="keyword">for</span> (input_vec, label) <span class="keyword">in</span> samples:</span><br><span class="line">            <span class="comment"># 计算感知器在当前权重下的输出</span></span><br><span class="line">            output = self.predict(input_vec)</span><br><span class="line">            <span class="comment"># 更新权重</span></span><br><span class="line">            self._update_weights(input_vec, output, label, rate)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_update_weights</span><span class="params">(self, input_vec, output, label, rate)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        按照感知器规则更新权重</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="comment"># 把input_vec[x1,x2,x3,...]和weights[w1,w2,w3,...]打包在一起</span></span><br><span class="line">        <span class="comment"># 变成[(x1,w1),(x2,w2),(x3,w3),...]</span></span><br><span class="line">        <span class="comment"># 然后利用感知器规则更新权重</span></span><br><span class="line">        delta = label - output</span><br><span class="line">        self.weights = map(</span><br><span class="line">            <span class="keyword">lambda</span> (x, w): w + rate * delta * x,</span><br><span class="line">            zip(input_vec, self.weights))</span><br><span class="line">        <span class="comment"># 更新bias</span></span><br><span class="line">        self.bias += rate * delta</span><br></pre></td></tr></table></figure><p>下面我们使用写好的代码实现一个计算<code>and</code>功能的感知机。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">and_f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    定义激活函数f</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 训练and感知器</span></span><br><span class="line">    X = [[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">    y = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">    and_perception = Perceptron(<span class="number">2</span>,and_f)</span><br><span class="line">    and_perception.train(X,y,<span class="number">10</span>,<span class="number">0.1</span>)</span><br><span class="line">    <span class="comment"># 打印训练获得的权重</span></span><br><span class="line">    <span class="keyword">print</span> and_perception</span><br><span class="line">    <span class="comment"># 测试</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'1 and 1 = %d'</span> % and_perception.predict([<span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'0 and 0 = %d'</span> % and_perception.predict([<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'1 and 0 = %d'</span> % and_perception.predict([<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'0 and 1 = %d'</span> % and_perception.predict([<span class="number">0</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>输出类似这样子： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">weights :[0.2, 0.1]</span><br><span class="line">bias    :-0.200000</span><br><span class="line"></span><br><span class="line">1 and 1 = 1</span><br><span class="line">0 and 0 = 0</span><br><span class="line">1 and 0 = 0</span><br><span class="line">0 and 1 = 0</span><br></pre></td></tr></table></figure></p><p>从中我们可以看出，对于<code>and</code>的计算全部正确。我们从训练好的模型中可以提取出实现该<code>and</code>功能的函数。</p><p><span class="math display">\[y = f(0.2x_1 + 0.1x_2 -0.2)\]</span></p><p><span class="math inline">\(f(x)\)</span> 就是上面代码自定义的函数，当 <span class="math inline">\(x&gt;0\)</span> 时输出1，否则输出0.</p><h2 id="scikit-learn中的感知机">scikit-learn中的感知机</h2><p>多数情况下我们不需要自己实现感知机，有很多已经写好的代码可以使用，scikit-learn中就实现了感知机。我们直接调用它的函数，看看会是什么结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line">lmper = linear_model.Perceptron(n_iter=<span class="number">10</span>)</span><br><span class="line">lmper.fit(X,y)</span><br><span class="line">print(lmper.coef_)</span><br><span class="line">print(lmper.intercept_)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'1 and 1 = %d'</span> % lmper.predict([<span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line"><span class="keyword">print</span> <span class="string">'0 and 0 = %d'</span> % lmper.predict([<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line"><span class="keyword">print</span> <span class="string">'1 and 0 = %d'</span> % lmper.predict([<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"><span class="keyword">print</span> <span class="string">'0 and 1 = %d'</span> % lmper.predict([<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">## output</span></span><br><span class="line">[[ <span class="number">3.</span>  <span class="number">2.</span>]]</span><br><span class="line">[<span class="number">-4.</span>]</span><br><span class="line"><span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">and</span> <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">and</span> <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">and</span> <span class="number">1</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>我们可以得到，<code>scikit-learn</code>得到的可以用来计算<code>and</code>的函数是：</p><p><span class="math display">\[ y = f(3x_1+2x_2-4)\]</span></p><p>虽然和我们自己实现的不一样，但是功能都是一样的。目前还没有明白激活函数在哪里设置，所以最终参数的不同可能和激活函数的设置有关。</p><h2 id="keras-实现感知机">keras 实现感知机</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">X = [[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">y = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Dropout</span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> RMSprop</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">X = np.array(X)</span><br><span class="line">y = np.array(y)</span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(<span class="number">1</span>, activation=<span class="string">'relu'</span>, input_shape=(<span class="number">2</span>,)))</span><br><span class="line">model.compile(loss=<span class="string">'mean_squared_error'</span>,</span><br><span class="line">            optimizer=<span class="string">'SGD'</span>,</span><br><span class="line">            metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line">print(model.summary())</span><br><span class="line">history = model.fit(X, y,batch_size=<span class="number">128</span>, epochs=<span class="number">1</span>)</span><br><span class="line">print(model.get_weights())</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">print(<span class="string">'1 and 1 = %d'</span> % model.predict(np.array([<span class="number">1</span>, <span class="number">1</span>]).reshape(<span class="number">1</span>,<span class="number">2</span>)))</span><br><span class="line">print(<span class="string">'0 and 0 = %d'</span> % model.predict(np.array([<span class="number">0</span>, <span class="number">0</span>]).reshape(<span class="number">1</span>,<span class="number">2</span>)))</span><br><span class="line">print(<span class="string">'1 and 0 = %d'</span> % model.predict(np.array([<span class="number">1</span>, <span class="number">0</span>]).reshape(<span class="number">1</span>,<span class="number">2</span>)))</span><br><span class="line">print(<span class="string">'0 and 1 = %d'</span> % model.predict(np.array([<span class="number">0</span>, <span class="number">1</span>]).reshape(<span class="number">1</span>,<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">[array([[<span class="number">-1.21217406</span>],</span><br><span class="line">       [<span class="number">-1.16362488</span>]], dtype=float32), array([ <span class="number">0.</span>], dtype=float32)]</span><br><span class="line"><span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span> = <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">and</span> <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">and</span> <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">and</span> <span class="number">1</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>使用神经网络训练的并没有达到最优的结果，可能和我们训练的样本过少有关系。我们同样得到了训练出来的感知机：</p><p><span class="math display">\[y = f(-1.2121x_1-1.1636x_2+0)\]</span></p><p>不过这里只有75%的准确率，现在还不清楚里面的原理。</p><h2 id="感知机的扩展">感知机的扩展</h2><p>上面我们介绍的感知机使用了如下的激活函数：</p><p><span class="math display">\[f(x)=\begin{cases}        0   &amp;  \text{x&gt;0}\\        1   &amp;  \text{x&lt;=0}      \end{cases}\]</span></p><p>这导致我们的输出智能是<code>0</code>,<code>1</code>,我们可以改变一下这个函数，使得输出的值是连续的，这样就可以用来解决回归的问题了。例如，我们直接使用 <span class="math inline">\(f(x)=x\)</span> 来作为激活函数。这样，我们实现了下面这样的线性函数：</p><p><span class="math display">\[ y = w * x + b\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fx</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">X = [[<span class="number">5</span>], [<span class="number">3</span>], [<span class="number">8</span>], [<span class="number">1.4</span>], [<span class="number">10.1</span>]]</span><br><span class="line">y = [<span class="number">5500</span>, <span class="number">2300</span>, <span class="number">7600</span>, <span class="number">1800</span>, <span class="number">11400</span>]</span><br><span class="line">linear_perception = Perceptron(<span class="number">1</span>,fx)</span><br><span class="line">linear_perception.train(X,y,<span class="number">10</span>,<span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">print</span> linear_perception</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Work 3.4 years, monthly salary = %.2f'</span> % linear_perception.predict([<span class="number">3.4</span>])</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Work 15 years, monthly salary = %.2f'</span> % linear_perception.predict([<span class="number">15</span>])</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Work 1.5 years, monthly salary = %.2f'</span> % linear_perception.predict([<span class="number">1.5</span>])</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Work 6.3 years, monthly salary = %.2f'</span> % linear_perception.predict([<span class="number">6.3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">weights :[<span class="number">765.63113396072</span>]</span><br><span class="line">bias    :<span class="number">-778.455331</span></span><br><span class="line"></span><br><span class="line">Work <span class="number">3.4</span> years, monthly salary = <span class="number">1824.69</span></span><br><span class="line">Work <span class="number">15</span> years, monthly salary = <span class="number">10706.01</span></span><br><span class="line">Work <span class="number">1.5</span> years, monthly salary = <span class="number">369.99</span></span><br><span class="line">Work <span class="number">6.3</span> years, monthly salary = <span class="number">4045.02</span></span><br></pre></td></tr></table></figure><p>上面训练了一个简单的一次线性函数：</p><p><span class="math display">\[y = 765x-778\]</span></p><h2 id="更新规则的推导梯度下降法">更新规则的推导(梯度下降法)</h2><p>上面介绍感知机的时候，我们直接给出了参数更新的方法，但是没有说明这个方法是如何得出来的，现在我们给出推导的方法。</p><p><span class="math display">\[w_i \leftarrow w_i + \triangle w_i \\b \leftarrow b + \triangle b \\其中 \\\triangle w = \beta (t-y) x_i \\\triangle b = \beta (t-y)\]</span></p><p>设模型的输出是 $ $, 真实的标签是 <span class="math inline">\(y\)</span>, 那么我们训练模型的目的是使得 <span class="math inline">\(\hat y\)</span> 尽可能的接近 <span class="math inline">\(y\)</span>, 那么，如何度量它们之间的接近程度呢？ 一个简单的想法就是使用平方和. <span class="math display">\[E = \sum_{i=1}^{n}( {\hat y_i}-y_i )^2\]</span></p><p>有了损失函数，接下来我们的目标就是使得该函数达到极小值，这样 <span class="math inline">\(\hat y\)</span>和 <span class="math inline">\(y\)</span> 之间就尽可能接近了。</p><p>如何求解函数的极小值呢，我们可以求函数的导数，令导数等于0，这样我们就能找到它的极值点。不幸的是，并不是所有的函数我们都能求解出导数的，所以求导数的方法并没有什么普适性，计算机有强大的计算能力，所以遇到这类问题，基本上都使用数值计算的方法解决。</p><p>我们直到一个函数的梯度表示一个函数上升最快的方向，那么她的反方向就是下降最快的方向，而梯度的计算就是函数对每一个变量的偏导数，这个我们可以事先计算出来。然后随机初始化一个 <span class="math inline">\(x\)</span>, 求解<span class="math inline">\(f(x)\)</span> 的值，然后朝着梯度下降的方向更新 <span class="math inline">\(x\)</span>, 经过无数次迭代之后，我们就能找到函数的极小值点对应的那个 <span class="math inline">\(x\)</span>.</p><p>$ y = f(w*x+b)$ , 令<span class="math inline">\(x_0 = 1,w_0=b\)</span>, 可以把它写成统一的形式<span class="math inline">\(\hat y = f(w*x)\)</span> , 这样我们最终的目标是求解 <span class="math inline">\(w\)</span>, 所以我们把 <span class="math inline">\(E\)</span> 看作 <span class="math inline">\(w\)</span> 的函数，这样优化函数变形为：</p><p><span class="math display">\[E(w) = \sum_{i=1}^n ({\hat y_i}-y_i)^2\]</span></p><p>求偏导的时候2次方会有一个系数2，所以我们把函数乘以 <span class="math inline">\(\dfrac 1 2\)</span>, 消除求导时候的系数，这样优化的目标函数变为：</p><p><span class="math display">\[E(w) =\dfrac 1 2 \sum_{i=1}^n ({\hat y_i}-y_i)^2\]</span></p><p>下面就是求这个函数对 <span class="math inline">\(w\)</span> 的梯度了。首先我们复习一下链式求导法则。</p><p><span class="math display">\[\dfrac {\partial E(w)} {\partial w} = \dfrac {E(w)} {\partial \hat y} * \dfrac {\partial \hat y} {\partial w}\]</span></p><p>根据以上的链式求导法则，我们可以求解得到目标函数的梯度：</p><p><span class="math display">\[\Delta {E(w)} = - \sum_{i=1}^n (y^i-\hat y^i)x\]</span></p><p>有了函数的梯度，就可以按照梯度的方向更新参数了。</p><p><span class="math display">\[w_{new} = w_{old} + \beta  \sum_{i=1}^n (y^i-\hat y^i)x^i\]</span></p><p>式子中，<span class="math inline">\(y^i\)</span> 是真实的标签值，<span class="math inline">\(x\)</span>是训练的样本， <span class="math inline">\(\beta\)</span>是学习率，也就是每次梯度下降的步长。这个步长的设置是一个技术活，太小的话，收敛太慢，太大的话，一不小心就过了，找不到最小的位置。</p><p>把上面感知机的参数更新规则拿过来对比：</p><p><span class="math display">\[w_i \leftarrow w_i + \triangle w_i \\b \leftarrow b + \triangle b \\其中 \\\triangle w = \beta (t-y) x_i \\\triangle b = \beta (t-y)\]</span></p><p>我们发现二者是完全一致的， 原来，感知机也是按照梯度下降的方向更新参数的。</p><p>需要注意的是，我们上面介绍的是最朴素的梯度下降法，实际应用中，经常使用随机梯度下降法，就是每次更新参数的时候，并不是把所有的训练数据都遍历一边再计算一次更新，而是每一个样本都计算一次更新，这样可能会导致有使参数的更新不是朝着下降的方向，但是实际经验证明，总体趋势上还是下降的，并且这样的方法计算开销小，还很有可能收敛速度更快。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> perception </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习_Pandas使用技巧</title>
      <link href="/hexoblog/2017/05/17/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_Pandas%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/hexoblog/2017/05/17/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_Pandas%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>pandas 是提供一种类似表格结构的数据结构的Python工具包，使用它可以很方便的完成若干在电子表格中的操作。</p><a id="more"></a><h2 id="安装">安装</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pandas</span><br></pre></td></tr></table></figure><h2 id="数据结构">数据结构</h2><h3 id="引入">引入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure><h3 id="series">Series</h3><p>One-dimensional ndarray with axis labels (including time series).</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建Series</span></span><br><span class="line">s1 = pd.Series(<span class="number">5</span>, index=[<span class="string">'a'</span>],name=<span class="string">'s1'</span>)</span><br><span class="line">s2 = pd.Series([<span class="string">'first'</span>,<span class="string">'second'</span>,],index=[<span class="number">0</span>,<span class="number">1</span>],name=<span class="string">'s3'</span>)</span><br><span class="line">s3 = pd.Series(&#123;<span class="string">'a'</span>:<span class="number">1</span>,<span class="string">'b'</span>:<span class="number">2</span>,<span class="string">'c'</span>:<span class="number">3</span>&#125;)</span><br><span class="line"><span class="comment"># 获取</span></span><br><span class="line">s1[<span class="number">0</span>] <span class="comment"># 按照索引</span></span><br><span class="line">s3[<span class="string">'a'</span>] <span class="comment"># 按照键值</span></span><br><span class="line">s2.index <span class="comment"># 获得所有的索引</span></span><br><span class="line">s2.get(<span class="string">'a'</span>,<span class="string">'empty'</span>) <span class="comment"># 使用get,不存在的键返回自定义的值</span></span><br><span class="line">s2[<span class="number">0</span>:<span class="number">2</span>] <span class="comment"># 范围截取</span></span><br><span class="line">s1.name <span class="comment"># 获得name属性</span></span><br><span class="line">s1.rename(<span class="string">"different"</span>)</span><br></pre></td></tr></table></figure><h3 id="dataframe">DataFrame</h3><p>a 2-dimensional labeled data structure with columns of potentially different types.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建</span></span><br><span class="line"></span><br><span class="line">d1 = &#123;<span class="string">'one'</span> : [<span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'third'</span>],</span><br><span class="line">     <span class="string">'two'</span> : [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]&#125;</span><br><span class="line"><span class="comment"># 每个键值一列</span></span><br><span class="line">df1 = pd.DataFrame(d1)</span><br><span class="line"><span class="comment"># list 中是 dict</span></span><br><span class="line">d2 = [&#123;<span class="string">'a'</span>:<span class="number">1</span>,<span class="string">'b'</span>:<span class="number">2</span>,<span class="string">'c'</span>:<span class="number">3</span>&#125;,&#123;<span class="string">'a'</span>:<span class="number">1</span>,<span class="string">'b'</span>:<span class="number">2</span>,<span class="string">'c'</span>:<span class="number">3</span>&#125;,&#123;<span class="string">'a'</span>:<span class="number">1</span>,<span class="string">'b'</span>:<span class="number">2</span>,<span class="string">'c'</span>:<span class="number">3</span>&#125;]</span><br><span class="line">df2 = pd.DataFrame(d2,index=[<span class="string">'aa'</span>,<span class="string">'bb'</span>,<span class="string">'cc'</span>])</span><br><span class="line">d3 = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line">df3 = pd.DataFrame(d3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取</span></span><br><span class="line">df1.index  <span class="comment"># 行标号</span></span><br><span class="line">df1.columns <span class="comment"># 列标号</span></span><br><span class="line">df2[<span class="string">'a'</span>] <span class="comment"># 一列</span></span><br><span class="line">df2.head() <span class="comment"># 显示部分信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改</span></span><br><span class="line"><span class="keyword">del</span> df2[<span class="string">'a'</span>]</span><br><span class="line">df2.pop(<span class="string">'a'</span>)  <span class="comment"># 删除一列</span></span><br><span class="line">df2[<span class="string">'inserted'</span>] = <span class="string">'a'</span> <span class="comment"># 插入一列</span></span><br><span class="line">df2[<span class="string">'insert2'</span>] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">df2.insert(<span class="number">0</span>,<span class="string">'between'</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment"># 指定插入的位置</span></span><br><span class="line">df2[<span class="string">'aa'</span>] <span class="comment">#</span></span><br></pre></td></tr></table></figure><h3 id="对dataframe的某一列进行one-hot编码">对DataFrame的某一列进行one-hot编码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line"></span><br><span class="line"><span class="comment"># name 列的名称</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">one_hot_colum</span><span class="params">(small_data,name)</span>:</span></span><br><span class="line"></span><br><span class="line">    enc = OneHotEncoder()</span><br><span class="line">    data = small_data[name].reshape(len(small_data[name]),<span class="number">1</span>)</span><br><span class="line">    enc.fit(data)</span><br><span class="line">    transformed_data = enc.transform(data).toarray()</span><br><span class="line">    small_data.pop(name)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(transformed_data.shape[<span class="number">1</span>]):</span><br><span class="line">        small_data.insert(small_data.shape[<span class="number">1</span>],name+str(i),transformed_data[:,i])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> small_data</span><br></pre></td></tr></table></figure><h3 id="对dataframe行进行切分和过滤">对DataFrame行进行切分和过滤</h3><p>下面划分的数据集是腾讯高校算法大赛第一届比赛的数据，实现了按照天为单位划分数据集。总体的思路是使用<code>isin()</code>生成<code>mask</code>,使用<code>mask</code>筛选数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split_data</span><span class="params">(data,train_data,test_data)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    按照天划分数据集</span></span><br><span class="line"><span class="string">    :data, DataFrame 类型的数据</span></span><br><span class="line"><span class="string">    :train_data, 训练数据集，[17,18,19]</span></span><br><span class="line"><span class="string">    :test_data,测试数据集,[30]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    times = np.unique( train[<span class="string">'clickTime'</span>] )</span><br><span class="line">    day = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">14</span>):</span><br><span class="line">        day.append(times[<span class="number">24</span>*<span class="number">60</span>*i:<span class="number">24</span>*<span class="number">60</span>*(i+<span class="number">1</span>)])</span><br><span class="line">    train_data = [i<span class="number">-17</span> <span class="keyword">for</span> i <span class="keyword">in</span> train_data ]</span><br><span class="line">    test_data = [i<span class="number">-17</span> <span class="keyword">for</span> i <span class="keyword">in</span> test_data ]</span><br><span class="line">    mask_train = np.array([<span class="literal">False</span>]*train.shape[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> train_data:</span><br><span class="line">        mask = train[<span class="string">'clickTime'</span>].isin(day[i])</span><br><span class="line">        mask_train |= mask</span><br><span class="line"></span><br><span class="line">    mask_test = np.array([<span class="literal">False</span>]*train.shape[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> test_data:</span><br><span class="line">        mask = train[<span class="string">'clickTime'</span>].isin(day[i])</span><br><span class="line">        mask_test |= mask</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data[mask_train],data[mask_test]</span><br></pre></td></tr></table></figure><h3 id="两个list生成dataframe并按照某个list排序">两个list生成DataFrame并按照某个list排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aa = pd.DataFrame(&#123;<span class="string">'feature'</span>:col,<span class="string">'importance'</span>:importance&#125;)</span><br><span class="line">bb=  aa.sort_values(by=<span class="string">'importance'</span>)</span><br></pre></td></tr></table></figure><h3 id="dataframe按照某一列的关键字合并">DataFrame按照某一列的关键字合并</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train = pd.merge(dfTrain, dfAd, on=<span class="string">"creativeID"</span>)</span><br><span class="line">data = pd.merge(data, dfCvr, how=<span class="string">"left"</span>, on=<span class="string">"keyid"</span>)</span><br></pre></td></tr></table></figure><h3 id="dataframe随机选择n个样本">DataFrame随机选择n个样本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe.sample(n=selected_sample_num)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片处理01-合并多张图片</title>
      <link href="/hexoblog/2017/05/17/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%8601-%E5%90%88%E5%B9%B6%E5%A4%9A%E5%BC%A0%E5%9B%BE%E7%89%87/"/>
      <url>/hexoblog/2017/05/17/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%8601-%E5%90%88%E5%B9%B6%E5%A4%9A%E5%BC%A0%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>找了很多工具都没有将PPT导出成长的PNG图片的，自己探索了一个流程，效果还可以。 <a id="more"></a></p><p>首先，把PPT导出成PNG图片，默认一张PPT就会生成一张PNG图片，然后使用一个Python的机器学习库可以实现把多张PNG图片拼接在一起。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergei</span><span class="params">(files, output_file)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    横向拼接</span></span><br><span class="line"><span class="string">    :param files:需要拼接的文件,list</span></span><br><span class="line"><span class="string">    :param output_file: 拼接完成后的输出文件</span></span><br><span class="line"><span class="string">    :return：生成拼接后的新的图片</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    tot = len(files)</span><br><span class="line">    img = Image.open(files[<span class="number">0</span>])</span><br><span class="line">    w, h = img.size[<span class="number">0</span>], img.size[<span class="number">1</span>]</span><br><span class="line">    merge_img = Image.new(<span class="string">'RGB'</span>, (w * tot, h), <span class="number">0xffffff</span>)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> files:</span><br><span class="line">        print(f)</span><br><span class="line">        img = Image.open(f)</span><br><span class="line">        merge_img.paste(img, (i, <span class="number">0</span>))</span><br><span class="line">        i += w</span><br><span class="line">    merge_img.save(output_file)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergej</span><span class="params">(files, output_file)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    纵向拼接</span></span><br><span class="line"><span class="string">    :param files:需要拼接的文件,list</span></span><br><span class="line"><span class="string">    :param output_file: 拼接完成后的输出文件</span></span><br><span class="line"><span class="string">    :return：生成拼接后的新的图片</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    tot = len(files)</span><br><span class="line">    img = Image.open(files[<span class="number">0</span>])</span><br><span class="line">    w, h = img.size[<span class="number">0</span>], img.size[<span class="number">1</span>]</span><br><span class="line">    merge_img = Image.new(<span class="string">'RGB'</span>, (w, h * tot), <span class="number">0xffffff</span>)</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> files:</span><br><span class="line">        print(f)</span><br><span class="line">        img = Image.open(f)</span><br><span class="line">        merge_img.paste(img, (<span class="number">0</span>, j))</span><br><span class="line">        j += h</span><br><span class="line">    merge_img.save(output_file)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">listFiles</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    枚举某个路径下的全部文件名，返回list</span></span><br><span class="line"><span class="string">    :param path 路径</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">import</span> os</span><br><span class="line">    files = os.listdir(path)</span><br><span class="line">    <span class="keyword">return</span> files</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    files = listFiles(<span class="string">r'D:\ML'</span>)</span><br><span class="line">    os.chdir(<span class="string">r'D:\ML'</span>)</span><br><span class="line">    mergej(files, <span class="string">"merge.png"</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工具 </category>
          
          <category> 图片处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 合并图片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_算法汇总</title>
      <link href="/hexoblog/2017/05/15/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/"/>
      <url>/hexoblog/2017/05/15/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>机器学习是人工智能的一个分支,机器学习是实现人工智能的一个途径，即以机器学习为手段解决人工智能中的问题。机器学习算法是一类从数据中自动分析获得规律，并利用规律对未知数据进行预测的算法.机器学习已广泛应用于数据挖掘、计算机视觉、自然语言处理、生物特征识别、搜索引擎、医学诊断、检测信用卡欺诈、证券市场分析、DNA序列测序、语音和手写识别、战略游戏和机器人等领域。本文主要介绍机器学习的基础算法和一些适用的问题。</p><a id="more"></a><p>机器学习的应用领域：</p><div class="figure"><img src="QQ截图20170515230814.png"></div><h1 id="监督学习">监督学习</h1><p>监督学习是给出<strong>特征</strong>和特征对应的<strong>标签</strong>，让算法学习其中蕴含的规律。利用训练好的模型预测新的特征的标签的一类算法的统称。监督学习是最常见的机器学习算法，也是发展最成熟的一类。</p><h2 id="线性模型linear-model">线性模型(linear model)</h2><p>线性模型试图学得一个通过属性的线性组合来进行预测的函数：</p><p><span class="math display">\[ f(x)=w_1 x_1+x_2 x_2 + ... + w_d x_d + b\]</span></p><p>线性模型中的<span class="math inline">\(w\)</span>直观的表达了各个属性在预测过程中的重要性，所以线性模型有很好的可解释性。</p><p>如果在线性模型基础上，在输出之前用一个非线性的函数处理一下，就能得到非线性的决策边界，这样的模型叫做<strong>广义线性模型</strong>. 她有下面这样的形式：</p><p><span class="math display">\[y = f(wx+b)\]</span></p><p>其中，<span class="math inline">\(f(x)\)</span> 是非线性的函数。当他是<code>sigmoid</code>函数的时候，这个模型叫做<strong>逻辑回归</strong>,当它是<code>softmax</code>函数的时候，这个模型叫做<strong>softmax</strong>回归。</p><h3 id="逻辑回归">逻辑回归</h3><p>Logistic回归优点：</p><p>　　1、实现简单；</p><p>　　2、分类时计算量非常小，速度很快，存储资源低；</p><p>缺点：</p><p>　　1、容易欠拟合，一般准确度不太高</p><p>　　2、只能处理两分类问题（在此基础上衍生出来的softmax可以用于多分类），且必须线性可分；</p><h3 id="softmax回归">softmax回归</h3><h3 id="线性判别分析">线性判别分析</h3><h2 id="决策树">决策树</h2><p>根据树的结构进行决策，主要算法有ID3，C4.5.</p><blockquote><ul><li><p>决策树的优点：计算量简单，可解释性强，比较适合处理有缺失属性值的样本，能够处理不相关的特征；</p></li><li><p>缺点：容易过拟合（后续出现了随机森林，减小了过拟合现象）.</p></li></ul></blockquote><h2 id="k近邻">K近邻</h2><p>KNN算法的优点：</p><p>　　1. 思想简单，理论成熟，既可以用来做分类也可以用来做回归；</p><p>　　2. 可用于非线性分类；</p><p>　　3. 训练时间复杂度为O(n)；</p><p>　　4. 准确度高，对数据没有假设，对outlier不敏感；</p><p>缺点：</p><p>　　1. 计算量大；</p><p>　　2. 样本不平衡问题（即有些类别的样本数量很多，而其它样本的数量很少）；</p><p>　　3. 需要大量的内存；</p><h2 id="支持向量机">支持向量机</h2><blockquote><ul><li>SVM算法优点： – 可用于线性/非线性分类，也可以用于回归；</li><li>低泛化误差；</li><li>容易解释；</li><li>计算复杂度较低；</li></ul></blockquote><blockquote><ul><li>缺点：</li></ul></blockquote><p>　　对参数和核函数的选择比较敏感；</p><p>　　原始的SVM只比较擅长处理二分类问题；</p><h2 id="相关向量机">相关向量机</h2><h2 id="贝叶斯方法">贝叶斯方法</h2><h3 id="朴素贝叶斯">朴素贝叶斯</h3><h3 id="半朴素贝叶斯">半朴素贝叶斯</h3><h3 id="贝叶斯网络">贝叶斯网络</h3><h3 id="em算法">EM算法</h3><h2 id="神经网络">神经网络</h2><h3 id="感知机">感知机</h3><p>感知机是一种最简单的神经网络，单层神经网络。</p><h3 id="径向基函数网络radial-basis-function">径向基函数网络(Radial Basis Function)</h3><p>一种单隐层的前馈神经网络，使用径向基函数作为隐层神经元激活函数，输出层是对隐层神经元的线性组合。</p><h3 id="竞争型学习网络competitive-learning">竞争型学习网络(competitive learning)</h3><h3 id="自组织映射网络self-organizing-map">自组织映射网络(Self-Organizing Map)</h3><h3 id="elman网络">Elman网络</h3><p>Elman是最常用的递归神经网络之一。</p><h3 id="boltzmann机">Boltzmann机</h3><p>一种基于能量概念的模型。</p><h3 id="卷积神经网络cnn">卷积神经网络(CNN)</h3><h3 id="深度信念网络dbn">深度信念网络(DBN)</h3><h3 id="循环神经网络rnn">循环神经网络(RNN)</h3><h3 id="稀疏自编码sae">稀疏自编码(SAE)</h3><h2 id="集成学习ensemble-learning">集成学习(ensemble learning)</h2><p>通过构建并结合多个分类器来完成学习任务。</p><h3 id="boosting方法">Boosting方法</h3><p>一类可以将若分类器提升为强分类器的算法。</p><p><strong>adaboost</strong></p><p><strong>Gradient Boosted Decision Tree</strong></p><h3 id="随机森林random-forest">随机森林(Random Forest)</h3><h1 id="半监督学习">半监督学习</h1><p>半监督学习是介于有监督学习和无监督学习之间的，它是指训练样本中只有少量是有标签的数据，大量数据是都是无标签的，要从这样的数据中学习出数据内在的规律，从而能够把哪些无标签的数据也推断出一个合理的标签。半监督学习几乎是最符合实际情况的一类算法，因为在实际中，很多时候都只有少量的有标签的数据，大量的都是无标签的数据。所以，半监督学习方法的研究对实际应用很重要。</p><p>半监督学习之所以可行，是基于一个基本的假设：相似的样本又有相似的输出。如果我们拥有少量的带标记的样本，恰巧这些样本均匀分布在每个类别中，这样我们就可以先使用聚类来确定哪些样本是相似的，然后从这些相似的样本中找出一个带标签的，所有的这一簇样本就都属于这个标签。这就是半监督学习的基本思想。当然，度量样本相似性的方法不止<strong>聚类</strong>一种，还有一种是<strong>流行假设</strong>(manifold assumption).</p><p><strong>主动学习</strong>，<strong>纯半监督学习</strong> 和 <strong>直推式学习</strong></p><p>三种方法都是针对的都是 <em>训练集中少量样本是标记数据，大量样本是未标记数据</em> 这种情况，不同是，<strong>主动学习</strong>(active learning)是指首先用已经标记的数据训练一个模型，然后使用这个模型去预测未标记的数据，把预测出来的数据和<em>专家</em>给出的标记结果做比较，更新模型，使得模型越来越好。可以看到，本质上，它还是利用有标记的数据进行学习的。 <strong>纯半监督学习</strong> 是指用训练集训练模型，用测试集测试效果，训练集是包含有标记数据和未标记数据的。 <strong>直推式学习</strong> 是指学习到的模型要预测的数据就是训练集中未标记的数据，只需要把训练集中未标记的数据预测准确就好，不需要再考虑其他的未标记数据。</p><h3 id="生成式方法generative-methods">生成式方法(generative methods)</h3><p>这类方法假定所有的数据都是基于一个<em>模型</em>生成的。此类方法简单，易于实现，而且效果不错，但是，这必须保证之前的假设是正确的。如果假设是错误的，该方法会得到很差的结果。遗憾的是，现实的世界中的数据，你很难准确的知道它是基于什么样的模型生成的。也许根本就不是基于同一个模型生成的。</p><h3 id="半监督支持向量机semi-supervised-support-vector-machine">半监督支持向量机(semi-supervised support vector machine)</h3><p>这是在支持向量机的算法基础上进行扩展得到的。它的基本思想是：寻找能把有标记的数据区分开，并且穿过数据的低密度区域的分类超平面。这显然是基于我们上面提到过的聚类假设，假设相似的样本会聚集在一起。这类方法有很多，例如*<strong>S3VM</strong>、<strong>S4VM</strong>、<strong>CS4VM</strong>、<strong>TSVM</strong>；</p><h3 id="图论方法graph-based-methods">图论方法(graph-based methods)</h3><p>我们把训练样本中每个样本对应图中的一个节点，而节点之间的边表示两个样本之间的相似性(相似性越强，边的权值越大)，我们把已经有标记的节点想象成已经染过色，而没有标记的节点还没有染色，这样问题转化成了在给定的图模型上为节点染色的问题。这类问题主要借助一类叫做<strong>标记传播算法</strong>(label propagation)的方法解决。</p><p>图论方法思路清晰，计算上可以有各种基于矩阵乘法的优化，但是其缺点很明显：</p><ol style="list-style-type: decimal"><li>存储开销大，不适合处理大数据。</li><li>构图过程只考虑训练集，测试集中的样本到来的时候，难以判断其在图中的位置。</li></ol><h3 id="基于分歧的方法disagreement-based-methods">基于分歧的方法(disagreement-based methods)</h3><p><strong>多视图数据</strong>(multi-view data)</p><p>视图可能是从数据库中的术语借鉴过来的，一个视图就是一个属性的几何。我们可以把视图理解为某一个大的方面。例如针对电影数据来说，图像是一个视图，声音是一个视图，网上所有关于该电影的讨论也可以构成一个视图。把这些数据都收集起来放在一起，就构成了多视图数据。</p><p><strong>协同训练</strong>(co-training)</p><p>协同训练是利用数据的多视图来进行训练的一类算法，它的基本假设是多视图数据的<em>相容互补性</em>。 <em>相容</em>是指通过任何一个视图推测出来的标签都应该是一样的，是匹配的。一个动作电影，只通过声音，只通过画面，都可以推断出是一个动作片(当然这不一定是真的)。 <em>互补</em> 是指通过一个视图的数据能够帮助另外一个视图的数据决定其标签。协同训练的过程是这样的：首先在每个视图数据上基于有标签的数据训练一个模型。然后，让每个模型去没有标记的数据中挑选自己最有把握分类的数据预测其标签，把预测出来标签的数据当作有标签的数据送给其他的分类器继续更新模型的参数，这样“互相学习，共同进步”，直到在所有视图数据上训练的模型都趋于稳定之后结束。</p><h3 id="半监督聚类semi-supervised-clustering">半监督聚类(semi-supervised clustering)</h3><p>聚类虽然是一种典型的无监督算法，但是如果实现有一些有标记的数据，很有可能提高聚类算法的效果。例如，直到哪些样本之间必然属于同一类，直到哪些样本根本不可能在一起，或者直接直到某个样本属于什么类别。 这类方法主要是在聚类算法的基础上加上相应的约束实现的，主要有<strong>约束K均值</strong>(constrained k-means) <strong>约束种子K均值</strong>(constrained seed k-means).</p><h1 id="无监督学习">无监督学习</h1><p>无监督学习的含义是训练数据不包含任何标签，既然不包含任何标签，那么无论如何也学习不到数据内部和标签的对应关系(没有标签嘛，怎么学得到)。所以，无监督学习主要是用来发现数据自身的内部规律，例如，哪些数据和哪些数据比较相似。无监督学习的应用主要在<strong>聚类</strong>上.</p><h2 id="hierarchical-methods">Hierarchical methods</h2><h3 id="birchbalanced-iterative-reducing-and-clustering-using-hierarchies">BIRCH(Balanced Iterative Reducing and Clustering Using Hierarchies)</h3><h3 id="rocka-hierarchical-clustering-algorithm-for-categorical-attributes">ROCK(A Hierarchical Clustering Algorithm for Categorical Attributes)</h3><h3 id="chameleona-hierarchical-clustering-algorithm-using-dynamic-modeling">Chameleon(A Hierarchical Clustering Algorithm Using Dynamic Modeling)</h3><h2 id="partition-based-methods">Partition-based methods</h2><h3 id="k-means">k-means</h3><h3 id="k-means-1">k-means++</h3><h3 id="kernel-k-means">kernel k-means</h3><h3 id="k-medoids">k-medoids</h3><h3 id="k-medians">k-medians</h3><h2 id="density-based-methods">Density-based methods</h2><h3 id="dbscandensity-based-spatial-clustering-of-applications-with-noise">DBSCAN(Density-Based Spatial Clustering of Applications with Noise)</h3><h3 id="opticsordering-points-to-identify-clustering-structure">OPTICS(Ordering Points To Identify Clustering Structure)</h3><h3 id="denclue">DENCLUE</h3><h3 id="wavecluster">WaveCluster</h3><h2 id="grid-based-methods">Grid-based methods</h2><h3 id="stingstatistical-information-grid">STING(Statistical Information Grid)</h3><h3 id="cliqueclustering-in-quest">CLIQUE(Clustering In Quest)</h3><h2 id="model-based-methods">Model-based methods</h2><h3 id="gmmgaussian-mixture-models">GMM(Gaussian Mixture Models)</h3><h3 id="somself-organized-maps">SOM(Self Organized Maps)</h3><h1 id="强化学习">强化学习</h1><p>强化学习对于包含长期反馈的问题比短期反馈的表现更好。它在许多问题上得到应用，包括机器人控制、电梯调度、电信通讯、双陆棋和西洋跳棋。</p><h2 id="q-learning">Q Learning</h2><h2 id="sarsa">Sarsa</h2><h2 id="policy-gradients">Policy Gradients</h2><h2 id="actor-critic">Actor-Critic</h2><h2 id="monte-carlo-learning">Monte-Carlo Learning</h2><h2 id="deep-q-network">Deep Q network</h2><h1 id="规则学习rule-base-learning">规则学习(rule-base learning)</h1><p>规则学习是最早开始研究的一类机器学习方法，它的基本思想是从数据中学习到一些基本的规则，用这些规则作用在新的数据上，决定新数据对应的输出。规则学习是<em>白箱模型</em>，每一步决策都会清晰的展现出来，算法学习得到的规则可以直接输出出来，对于一些简单的问题，我们甚至可以根据经验判断它学习的对不对。规则学习是最容易融合<strong>专家知识</strong>的机器学习方法。</p><p>规则学习的基本框架是<strong>序贯覆盖</strong>，<strong>CN2</strong> 采用集束搜索，是最早考虑过拟合问题的规则学习算法，<strong>归纳逻辑程序设计</strong>(ILP) 成为机器学习和知识工程的重要桥梁。</p><p>机器学习方法一开始是规则学习的天下，各种专家系统层出不穷，后来，统计学习方法逐渐占了上风，但是由于统计学习方法普遍都是黑箱模型，很难解释里面的原因，我们并不能直接从中学习得到知识。而且，在富含<strong>结构信息</strong>和<strong>领域知识</strong>的任务中，规则学习往往更适合。所以，未来的发展趋势是<strong>基于规则的学习方法</strong> 和 <strong>统计学习方法</strong> 的结合，使得我们的算法既有强大的学习能力，又能够教会我们数据中蕴含的<strong>知识</strong>，目前，这方便已经有了一些有益的探索。例如 <strong>概率归纳逻辑程序设计</strong>,<strong>关系贝叶斯网</strong>,<strong>贝叶斯逻辑程序</strong>,<strong>马尔科夫逻辑网</strong>.</p><h1 id="其他算法">其他算法</h1><h2 id="数据挖掘">数据挖掘</h2><h3 id="apriori">Apriori</h3><h3 id="fp-growth">FP Growth:</h3><h2 id="ffmgdbtlr">FFM+GDBT+LR</h2><h2 id="神经风格迁移">神经风格迁移</h2><h2 id="genetic-algorithm">genetic algorithm</h2><h2 id="模拟退火算法simulated-annealing">模拟退火算法(Simulated annealing)</h2><h2 id="禁忌搜索tabu-search">禁忌搜索(Tabu Search)</h2><h2 id="蚁群算法antcolonyoptimization">蚁群算法(Ant Colony Optimization)</h2><h2 id="粒子群优化particle-swarm-optimization">粒子群优化(Particle Swarm Optimization)</h2><h2 id="引力搜索算法gsa">引力搜索算法(GSA)</h2><h2 id="人工免疫算法">人工免疫算法</h2><p><img src="MachineLearningAlgorithms.png"> p scikit-learn 实现的机器学习算法:</p><div class="figure"><img src="ml_map.png"></div><h2 id="一个ppt">一个PPT</h2><p><a href="https://1drv.ms/p/s!AsOuy4DDdLyCglfNtqwGpHPShTFo" target="_blank" rel="noopener">机器学习算法汇总</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_时间序列预测の广告效果预测</title>
      <link href="/hexoblog/2017/05/15/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E9%A2%84%E6%B5%8B%E3%81%AE%E5%B9%BF%E5%91%8A%E6%95%88%E6%9E%9C%E9%A2%84%E6%B5%8B/"/>
      <url>/hexoblog/2017/05/15/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E9%A2%84%E6%B5%8B%E3%81%AE%E5%B9%BF%E5%91%8A%E6%95%88%E6%9E%9C%E9%A2%84%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<p>预测问题在实际中的应用比较多，比如广告的点击率预测，转化率预测，未来的价格走势等等。这类问题通常有一个框架，数据预处理上也有很多相似之处。比如广告的点击率的预测，业内比较成熟的方法有，人工特征工程，依靠人工分析，提取出有效的特征，然后用逻辑回归或者其他简单的线性分类器分类。随着特征的增多和样本的增加，人工的方法不能满足要求，现在很多公司用的算法都是改进的GDBT特征提取+逻辑回归分类，或者GDBT+FFM+逻辑回归分类。 <a id="more"></a></p><h2 id="判断给定的数据集是否与时间关联">判断给定的数据集是否与时间关联</h2><p>在很多线性模型中，都假设数据之间是独立的，如果数据之间不是时间独立的(有明显的随着时间变化的趋势)，很多预测模型的效果就会出现偏差。所以，拿到数据首先要检查一下数据的分布情况。</p><p><a href="https://datamarket.com/data/set/235k/daily-total-female-births-in-california-1959#!ds=235k&amp;display=line" target="_blank" rel="noopener">数据集</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断时间序列数据是否有时间趋势</span></span><br><span class="line"><span class="comment"># Augmented Dickey-Fuller test 用来检查数据集是否有时间趋势</span></span><br><span class="line"><span class="comment"># 判断标准 p &lt; 0.05 认为没有时间依赖</span></span><br><span class="line"><span class="comment"># p&gt;0.05 认为有时间依赖</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series</span><br><span class="line"><span class="keyword">from</span> statsmodels.tsa.stattools <span class="keyword">import</span> adfuller</span><br><span class="line">root = <span class="string">r'D:\deeplearning\Daily Female Births'</span></span><br><span class="line">os.chdir(root)</span><br><span class="line">series = Series.from_csv(<span class="string">'daily-total-female-births.csv'</span>, header=<span class="number">0</span>)</span><br><span class="line">X = series.values</span><br><span class="line">result = adfuller(X)</span><br><span class="line">print(<span class="string">'ADF Statistic: %f'</span> % result[<span class="number">0</span>])</span><br><span class="line">print(<span class="string">'p-value: %f'</span> % result[<span class="number">1</span>])</span><br><span class="line">print(<span class="string">'Critical Values:'</span>)</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> result[<span class="number">4</span>].items():</span><br><span class="line">print(<span class="string">'\t%s: %.3f'</span> % (key, value))</span><br></pre></td></tr></table></figure><p>这个是用<a href="https://en.wikipedia.org/wiki/Augmented_Dickey%E2%80%93Fuller_test" target="_blank" rel="noopener">Augmented Dickey–Fuller test</a>做的假设检验，根据p值确定结果，p值小于某个阈值就可以认为原数据是时间独立的。</p><h2 id="特征工程">特征工程</h2><p>点击率预测和转化率预测的题目，特征的选择往往最对最后的结果至关重要，这里有一个使用sklearn做特征处理的教程可以参考。 <a href="http://www.cnblogs.com/jasonfreak/p/5448385.html" class="uri" target="_blank" rel="noopener">http://www.cnblogs.com/jasonfreak/p/5448385.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时间序列 </tag>
            
            <tag> 预测算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习_Scikit-Learn机器学习算法的使用</title>
      <link href="/hexoblog/2017/05/14/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_Scikit-Learn%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/hexoblog/2017/05/14/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_Scikit-Learn%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p><code>scikit-learn</code>是一个很受欢迎的机器学习方面的<code>python</code>工具包，它定义的一些范式和处理流程影响深远，所以，认识和了解一些这个工具包对于自己实现一些机器学习算法是很有帮助的。它已经实现了很多方法帮助我们便捷的处理数据，例如，划分数据集为训练集和验证集，交叉验证，数据预处理，归一化等等。</p><a id="more"></a><h3 id="预测结果与真实结果的比较">预测结果与真实结果的比较</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算均方误差</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line">rmse = sqrt(metrics.mean_squared_error(y_test, y_pred))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算准确率</span></span><br><span class="line">acc = metrics.accuracy_score(y_test, y_pred)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 混淆矩阵</span></span><br><span class="line">cm = metrics.confusion_matrix(y_test, y_pred)</span><br><span class="line"></span><br><span class="line"><span class="comment"># classification_report</span></span><br><span class="line">cr = metrics.classification_report(y_true, y_pred)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ROC AUC曲线</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_curve, auc</span><br></pre></td></tr></table></figure><h3 id="划分数据集">划分数据集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> cross_validation</span><br><span class="line">X_train, X_test, y_train, y_test = cross_validation.train_test_split(X,y,test_size=<span class="number">0.3</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分折</span></span><br><span class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> KFold</span><br><span class="line">kf = KFold(n_samples, n_folds=<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> train, test <span class="keyword">in</span> kf:</span><br><span class="line">    print(<span class="string">"%s %s"</span> % (train, test))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保证不同的类别之间的均衡，这里需要用到标签labels</span></span><br><span class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> StratifiedKFold</span><br><span class="line">labels = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">skf = StratifiedKFold(labels, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> train, test <span class="keyword">in</span> skf:</span><br><span class="line">    print(<span class="string">"%s %s"</span> % (train, test))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 留一交叉验证</span></span><br><span class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> LeaveOneOut</span><br><span class="line">loo = LeaveOneOut(n_samples)</span><br><span class="line"><span class="keyword">for</span> train, test <span class="keyword">in</span> loo:</span><br><span class="line">    print(<span class="string">"%s %s"</span> % (train, test))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 留P交叉验证</span></span><br><span class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> LeavePOut</span><br><span class="line">lpo = LeavePOut(n_samples, p=<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> train, test <span class="keyword">in</span> lpo:</span><br><span class="line">    print(<span class="string">"%s %s"</span> % (train, test))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照额外提供的标签留一交叉验证,常用的情况是按照时间序列</span></span><br><span class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> LeaveOneLabelOut</span><br><span class="line">labels = [<span class="number">1</span>, <span class="number">1</span>,<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">lolo = LeaveOneLabelOut(labels)</span><br><span class="line"><span class="keyword">for</span> train, test <span class="keyword">in</span> lolo:</span><br><span class="line">    print(<span class="string">"%s %s"</span> % (train, test))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照额外提供的标签留P交叉验证</span></span><br><span class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> LeavePLabelOut</span><br><span class="line">labels = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">lplo = LeavePLabelOut(labels, p=<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> train, test <span class="keyword">in</span> lplo:</span><br><span class="line">    print(<span class="string">"%s %s"</span> % (train, test))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机分组</span></span><br><span class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> ShuffleSplit</span><br><span class="line">ss = ShuffleSplit(<span class="number">16</span>, n_iter=<span class="number">3</span>, test_size=<span class="number">0.25</span>,random_state=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> train_index, test_index <span class="keyword">in</span> ss:</span><br><span class="line">    print(<span class="string">"%s %s"</span> % (train_index, test_index))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 考虑类别均衡的随机分组</span></span><br><span class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> StratifiedShuffleSplit</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">X = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">y = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">sss = StratifiedShuffleSplit(y, <span class="number">3</span>, test_size=<span class="number">0.5</span>, random_state=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> train, test <span class="keyword">in</span> sss:</span><br><span class="line">    print(<span class="string">"%s %s"</span> % (train, test))</span><br></pre></td></tr></table></figure><h3 id="特征选择方法">特征选择方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 去除方差较小的特征</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> feature_selection</span><br><span class="line">vt = feature_selection.VarianceThreshold(threshold=<span class="string">''</span>)</span><br><span class="line">vt.fit(X_train)</span><br><span class="line">X_train_transformed = vt.transform(X_train)</span><br><span class="line">X_test_transformed = vt.transform(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照某种排序规则 选择前K个特征</span></span><br><span class="line"><span class="comment"># 除了使用系统定义好的函数f_classif，还可以自己定义函数</span></span><br><span class="line">sk = SelectKBest(feature_selection.f_classif,k=<span class="number">100</span>)</span><br><span class="line">sk.fit(X_train,y_train)</span><br><span class="line">X_train_transformed = sk.transform(X_train)</span><br><span class="line">X_test_transformed = sk.transform(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归特征消除</span></span><br><span class="line">rfecv = RFECV(estimator=svc, step=step, cv=StratifiedKFold(y, n_folds = n_folds),scoring=<span class="string">'accuracy'</span>)</span><br><span class="line">rfecv.fit(X_train, y_train)</span><br><span class="line">X_train_transformed = rfecv.transform(X_train)</span><br><span class="line">X_test_transformed = rfecv.transform(y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用L1做特征选择</span></span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> LinearSVC</span><br><span class="line">lsvc = LinearSVC(C=<span class="number">1</span>, penalty=<span class="string">"l1"</span>, dual=<span class="literal">False</span>)</span><br><span class="line">lsvc.fit(X_train,y_train)</span><br><span class="line">X_train_transformed = lsvc.transform(X_train)</span><br><span class="line">X_test_transformed = lsvc.transform(y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于树的特征选择</span></span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> ExtraTreesClassifier</span><br><span class="line">etc = ExtraTreesClassifier()</span><br><span class="line">etc.fit(X_train, y_train)</span><br><span class="line">X_train_transformed = etc.transform(X_train)</span><br><span class="line">X_test_transformed = etc.transform(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于线性判别分析做特征选择</span></span><br><span class="line"><span class="keyword">from</span> sklearn.discriminant_analysis <span class="keyword">import</span> LinearDiscriminantAnalysis</span><br><span class="line">lda = LinearDiscriminantAnalysis(solver=<span class="string">'lsqr'</span>,shrinkage=<span class="string">'auto'</span>)</span><br><span class="line">lda.fit(X_train, y_train)</span><br><span class="line">X_train_transformed = lda.transform(X_train)</span><br><span class="line">X_test_transformed = lda.transform(X_test)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> VarianceThreshold</span><br><span class="line">X = [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]]</span><br><span class="line">sel = VarianceThreshold(threshold=(<span class="number">.8</span> * (<span class="number">1</span> - <span class="number">.8</span>)))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;sel</span><br><span class="line">&gt;&gt;&gt;VarianceThreshold(threshold=<span class="number">0.16</span>)</span><br><span class="line"></span><br><span class="line">X2 = sel.fit_transform(X)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;X2</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>]])</span><br></pre></td></tr></table></figure><p>计算每维特征的方差 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a1 = np.array([<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;a1.var()</span><br><span class="line">&gt;&gt;&gt;<span class="number">0.13888888888888892</span></span><br><span class="line"></span><br><span class="line">a2 = np.array([<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;a2.var()</span><br><span class="line">&gt;&gt;&gt;Out[<span class="number">161</span>]: <span class="number">0.22222222222222224</span></span><br><span class="line"></span><br><span class="line">a3 = np.array([<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;a3.var()</span><br><span class="line">&gt;&gt;&gt;Out[<span class="number">163</span>]: <span class="number">0.25</span></span><br></pre></td></tr></table></figure></p><p>可以看到，方差小于0.16的只有第一维特征，所以X2保留下来的是原来的第二维和第三维特征。 &gt;这应该是最简单的特征选择方法了：假设某特征的特征值只有0和1，并且在所有输入样本中，95%的实例的该特征取值都是1，那就可以认为这个特征作用不大。如果100%都是1，那这个特征就没意义了。当特征值都是离散型变量的时候这种方法才能用，如果是连续型变量，就需要将连续变量离散化之后才能用，而且实际当中，一般不太会有95%以上都取某个值的特征存在，所以这种方法虽然简单但是不太好用。可以把它作为特征选择的预处理，先去掉那些取值变化小的特征，然后再从接下来提到的的特征选择方法中选择合适的进行进一步的特征选择。</p><h4 id="univariate-feature-selection-单变量特征选择">Univariate feature selection （单变量特征选择）</h4><p>主要使用统计的方法计算各个统计值，再根据一定的阈值筛选出符合要求的特征，去掉不符合要求的特征。 #### 主要的统计方法 - F值分类 <code>f_classif</code> - F值回归 <code>f_regression</code> - 卡方统计 <code>chi2</code> (适用于非负特征值 和 稀疏特征值)</p><h4 id="主要的选择策略">主要的选择策略</h4><ul><li>选择排名前K的特征 <code>SelectKbest</code></li><li>选择前百分之几的特征 <code>SelectPercentile</code></li><li><code>SelectFpr</code> Select features based on a false positive rate test.</li><li><code>SelectFdr</code> Select features based on an estimated false discovery rate.</li><li><code>SelectFwe</code> Select features based on family-wise error rate.</li><li><code>GenericUnivariateSelect</code> Univariate feature selector with configurable mode.</li></ul><blockquote><p><code>false positive rate</code>: FP / (FP + TP) 假设类别为0，1；记0为negative,1为positive, <code>FPR</code>就是实际的类别是0，但是分类器错误的预测为1的个数 与 分类器预测的类别为1的样本的总数（包括正确的预测为1和错误的预测为1） 的比值。 <code>estimated false discovery rate</code>: 错误的拒绝原假设的概率 <code>family-wise error rate</code>: 至少有一个检验犯第一类错误的概率</p></blockquote><p>假设检验的两类错误： &gt; - 第一类错误：原假设是正确的，但是却被拒绝了。(用α表示） &gt; - 第二类错误：原假设是错误的，但是却被接受了。(用β表示)</p><h4 id="具体应用">具体应用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest</span><br><span class="line"><span class="comment">#SelectKBest -- f_classif</span></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> f_classif</span><br><span class="line">iris = load_iris()</span><br><span class="line">X, y = iris.data, iris.target</span><br><span class="line">X_fitted = SelectKBest(f_classif, k=<span class="number">3</span>).fit(X,y)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"SelectKBest -- f_classif"</span></span><br><span class="line"><span class="keyword">print</span> X_fitted.scores_</span><br><span class="line"><span class="keyword">print</span> X_fitted.pvalues_</span><br><span class="line"><span class="keyword">print</span> X_fitted.get_support()</span><br><span class="line">X_transformed = X_fitted.transform(X)</span><br><span class="line"><span class="keyword">print</span> X_transformed.shape</span><br><span class="line"><span class="comment">#SelectKBest -- chi2</span></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> chi2</span><br><span class="line">X_fitted_2 = SelectKBest(chi2, k=<span class="number">3</span>).fit(X,y)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"SelectKBest -- chi2"</span></span><br><span class="line"><span class="keyword">print</span> X_fitted_2.scores_</span><br><span class="line"><span class="keyword">print</span> X_fitted_2.pvalues_</span><br><span class="line"><span class="keyword">print</span> X_fitted_2.get_support()</span><br><span class="line">X_transformed_2 = X_fitted_2.transform(X)</span><br><span class="line"><span class="keyword">print</span> X_transformed_2.shape</span><br><span class="line"></span><br><span class="line"><span class="comment">#SelectPercentile -- f_classif</span></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectPercentile</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> f_classif</span><br><span class="line">X_fitted_3 = SelectPercentile(f_classif, percentile=<span class="number">50</span>).fit(X,y)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"SelectPercentile -- f_classif"</span></span><br><span class="line"><span class="keyword">print</span> X_fitted_3.scores_</span><br><span class="line"><span class="keyword">print</span> X_fitted_3.pvalues_</span><br><span class="line"><span class="keyword">print</span> X_fitted_3.get_support()</span><br><span class="line">X_transformed_3 = X_fitted_3.transform(X)</span><br><span class="line"><span class="keyword">print</span> X_transformed_3.shape</span><br><span class="line"></span><br><span class="line"><span class="comment">#SelectPercentile -- chi2</span></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectPercentile</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> chi2</span><br><span class="line">X_fitted_4 = SelectPercentile(chi2, percentile=<span class="number">50</span>).fit(X,y)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"SelectPercentile -- chi2"</span></span><br><span class="line"><span class="keyword">print</span> X_fitted_4.scores_</span><br><span class="line"><span class="keyword">print</span> X_fitted_4.pvalues_</span><br><span class="line"><span class="keyword">print</span> X_fitted_4.get_support()</span><br><span class="line">X_transformed_4 = X_fitted_4.transform(X)</span><br><span class="line"><span class="keyword">print</span> X_transformed_4.shape</span><br><span class="line"></span><br><span class="line"><span class="comment">#SelectFpr --- chi2</span></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectFpr</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> chi2</span><br><span class="line">X_fitted_5 = SelectFpr(chi2, alpha=<span class="number">2.50017968e-15</span>).fit(X,y)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"SelectFpr --- chi2"</span></span><br><span class="line"><span class="keyword">print</span> X_fitted_5.scores_</span><br><span class="line"><span class="keyword">print</span> X_fitted_5.pvalues_</span><br><span class="line"><span class="keyword">print</span> X_fitted_5.get_support()</span><br><span class="line">X_transformed_5 = X_fitted_5.transform(X)</span><br><span class="line"><span class="keyword">print</span> X_transformed_5.shape</span><br><span class="line"></span><br><span class="line"><span class="comment">#SelectFpr --- f_classif</span></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectFpr</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> f_classif</span><br><span class="line">X_fitted_6 = SelectFpr(f_classif, alpha=<span class="number">1.66966919e-31</span> ).fit(X,y)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"SelectFpr --- f_classif"</span></span><br><span class="line"><span class="keyword">print</span> X_fitted_6.scores_</span><br><span class="line"><span class="keyword">print</span> X_fitted_6.pvalues_</span><br><span class="line"><span class="keyword">print</span> X_fitted_6.get_support()</span><br><span class="line">X_transformed_6 = X_fitted_6.transform(X)</span><br><span class="line"><span class="keyword">print</span> X_transformed_6.shape</span><br><span class="line"></span><br><span class="line"><span class="comment"># SelectFdr  和 SelectFwe 的用法和上面类似，只是选择特征时候的依据不同，真正决定得分不同的是</span></span><br><span class="line"><span class="comment">#统计检验方法，从上面可以看到，使用f_classif的得出的参数都相同。</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">SelectKBest -- f_classif</span><br><span class="line">[  <span class="number">119.26450218</span>    <span class="number">47.3644614</span>   <span class="number">1179.0343277</span>    <span class="number">959.32440573</span>]</span><br><span class="line">[  <span class="number">1.66966919e-31</span>   <span class="number">1.32791652e-16</span>   <span class="number">3.05197580e-91</span>   <span class="number">4.37695696e-85</span>]</span><br><span class="line">[ <span class="literal">True</span> <span class="literal">False</span>  <span class="literal">True</span>  <span class="literal">True</span>]</span><br><span class="line">(<span class="number">150L</span>, <span class="number">3L</span>)</span><br><span class="line">SelectKBest -- chi2</span><br><span class="line">[  <span class="number">10.81782088</span>    <span class="number">3.59449902</span>  <span class="number">116.16984746</span>   <span class="number">67.24482759</span>]</span><br><span class="line">[  <span class="number">4.47651499e-03</span>   <span class="number">1.65754167e-01</span>   <span class="number">5.94344354e-26</span>   <span class="number">2.50017968e-15</span>]</span><br><span class="line">[ <span class="literal">True</span> <span class="literal">False</span>  <span class="literal">True</span>  <span class="literal">True</span>]</span><br><span class="line">(<span class="number">150L</span>, <span class="number">3L</span>)</span><br><span class="line">SelectPercentile -- f_classif</span><br><span class="line">[  <span class="number">119.26450218</span>    <span class="number">47.3644614</span>   <span class="number">1179.0343277</span>    <span class="number">959.32440573</span>]</span><br><span class="line">[  <span class="number">1.66966919e-31</span>   <span class="number">1.32791652e-16</span>   <span class="number">3.05197580e-91</span>   <span class="number">4.37695696e-85</span>]</span><br><span class="line">[<span class="literal">False</span> <span class="literal">False</span>  <span class="literal">True</span>  <span class="literal">True</span>]</span><br><span class="line">(<span class="number">150L</span>, <span class="number">2L</span>)</span><br><span class="line">SelectPercentile -- chi2</span><br><span class="line">[  <span class="number">10.81782088</span>    <span class="number">3.59449902</span>  <span class="number">116.16984746</span>   <span class="number">67.24482759</span>]</span><br><span class="line">[  <span class="number">4.47651499e-03</span>   <span class="number">1.65754167e-01</span>   <span class="number">5.94344354e-26</span>   <span class="number">2.50017968e-15</span>]</span><br><span class="line">[<span class="literal">False</span> <span class="literal">False</span>  <span class="literal">True</span>  <span class="literal">True</span>]</span><br><span class="line">(<span class="number">150L</span>, <span class="number">2L</span>)</span><br><span class="line">SelectFpr --- chi2</span><br><span class="line">[  <span class="number">10.81782088</span>    <span class="number">3.59449902</span>  <span class="number">116.16984746</span>   <span class="number">67.24482759</span>]</span><br><span class="line">[  <span class="number">4.47651499e-03</span>   <span class="number">1.65754167e-01</span>   <span class="number">5.94344354e-26</span>   <span class="number">2.50017968e-15</span>]</span><br><span class="line">[<span class="literal">False</span> <span class="literal">False</span>  <span class="literal">True</span> <span class="literal">False</span>]</span><br><span class="line">(<span class="number">150L</span>, <span class="number">1L</span>)</span><br><span class="line">SelectFpr --- f_classif</span><br><span class="line">[  <span class="number">119.26450218</span>    <span class="number">47.3644614</span>   <span class="number">1179.0343277</span>    <span class="number">959.32440573</span>]</span><br><span class="line">[  <span class="number">1.66966919e-31</span>   <span class="number">1.32791652e-16</span>   <span class="number">3.05197580e-91</span>   <span class="number">4.37695696e-85</span>]</span><br><span class="line">[<span class="literal">False</span> <span class="literal">False</span>  <span class="literal">True</span>  <span class="literal">True</span>]</span><br><span class="line">(<span class="number">150L</span>, <span class="number">2L</span>)</span><br></pre></td></tr></table></figure><h4 id="recursive-feature-elimination-递归特征消除">Recursive feature elimination （递归特征消除）</h4><p>使用某种方法，给每一维特征赋一个权重（例如线性回归的系数），去除系数最小的K个特征，然后在剩下的特征上重复上述方法，直到剩下的特征满足特征选择个数的要求。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">用SVM获得每个特征对分类结果的贡献程度，按照贡献程度从大到小排名，选出贡献程度最大的</span></span><br><span class="line"><span class="string">前K个特征作为特征选择的结果,使用SVM的时候，排名的依据是fit之后的coef_值。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">这里的估计器可以替换成任何其他方法，如GLM</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_digits</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> RFE</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># Load the digits dataset</span></span><br><span class="line">digits = load_digits()</span><br><span class="line">X = digits.images.reshape((len(digits.images), <span class="number">-1</span>))</span><br><span class="line">y = digits.target</span><br><span class="line"><span class="keyword">print</span> <span class="string">"原来的特征："</span></span><br><span class="line"><span class="keyword">print</span> X.shape</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the RFE object and rank each pixel</span></span><br><span class="line">svc = SVC(kernel=<span class="string">"linear"</span>, C=<span class="number">1</span>)</span><br><span class="line">rfe = RFE(estimator=svc, n_features_to_select=<span class="number">10</span>, step=<span class="number">1</span>)</span><br><span class="line">ref = rfe.fit(X, y)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"选择的特征的个数"</span></span><br><span class="line"><span class="keyword">print</span> np.sum(ref._get_support_mask())</span><br><span class="line"><span class="keyword">print</span> ref._get_support_mask()</span><br><span class="line"><span class="keyword">print</span> rfe.ranking_</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">原来的特征：</span><br><span class="line">(<span class="number">1797L</span>, <span class="number">64L</span>)</span><br><span class="line">选择的特征的个数</span><br><span class="line"><span class="number">10</span></span><br><span class="line">[<span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span>  <span class="literal">True</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span></span><br><span class="line"> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span>  <span class="literal">True</span> <span class="literal">False</span> <span class="literal">False</span></span><br><span class="line"> <span class="literal">False</span> <span class="literal">False</span>  <span class="literal">True</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span>  <span class="literal">True</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span></span><br><span class="line"> <span class="literal">False</span> <span class="literal">False</span>  <span class="literal">True</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span>  <span class="literal">True</span> <span class="literal">False</span> <span class="literal">False</span>  <span class="literal">True</span>  <span class="literal">True</span> <span class="literal">False</span></span><br><span class="line"> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span>  <span class="literal">True</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span>  <span class="literal">True</span> <span class="literal">False</span></span><br><span class="line"> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span>]</span><br><span class="line">[<span class="number">55</span> <span class="number">41</span> <span class="number">22</span> <span class="number">14</span>  <span class="number">1</span>  <span class="number">8</span> <span class="number">25</span> <span class="number">42</span> <span class="number">48</span> <span class="number">28</span> <span class="number">21</span> <span class="number">34</span>  <span class="number">5</span> <span class="number">23</span> <span class="number">35</span> <span class="number">43</span> <span class="number">45</span> <span class="number">32</span> <span class="number">10</span>  <span class="number">6</span> <span class="number">19</span>  <span class="number">1</span> <span class="number">30</span> <span class="number">44</span> <span class="number">46</span></span><br><span class="line"> <span class="number">36</span>  <span class="number">1</span>  <span class="number">9</span> <span class="number">11</span> <span class="number">29</span>  <span class="number">1</span> <span class="number">50</span> <span class="number">54</span> <span class="number">33</span> <span class="number">16</span> <span class="number">26</span> <span class="number">20</span>  <span class="number">7</span>  <span class="number">1</span> <span class="number">53</span> <span class="number">52</span> <span class="number">31</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">4</span>  <span class="number">1</span>  <span class="number">1</span> <span class="number">49</span> <span class="number">47</span> <span class="number">38</span></span><br><span class="line"> <span class="number">17</span> <span class="number">27</span> <span class="number">15</span>  <span class="number">1</span> <span class="number">13</span> <span class="number">39</span> <span class="number">51</span> <span class="number">40</span>  <span class="number">1</span> <span class="number">18</span> <span class="number">24</span> <span class="number">12</span>  <span class="number">3</span> <span class="number">37</span>]</span><br></pre></td></tr></table></figure></p><p>使用上面的方法，需要人为的确定最后输出的特征的个数，如果不知道需要多少特征才能达到好的效果，可以使用下面的交叉验证方法自动确定输出几个特征最优。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> StratifiedKFold</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> RFECV</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_classification</span><br><span class="line"></span><br><span class="line"><span class="comment">#产生人工数据</span></span><br><span class="line"><span class="comment"># Build a classification task using 3 informative features</span></span><br><span class="line">X, y = make_classification(n_samples=<span class="number">1000</span>, n_features=<span class="number">25</span>, n_informative=<span class="number">5</span>,</span><br><span class="line">                           n_redundant=<span class="number">2</span>, n_repeated=<span class="number">0</span>, n_classes=<span class="number">8</span>,</span><br><span class="line">                           n_clusters_per_class=<span class="number">1</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the RFE object and compute a cross-validated score.</span></span><br><span class="line">svc = SVC(kernel=<span class="string">"linear"</span>)</span><br><span class="line"><span class="comment"># The "accuracy" scoring is proportional to the number of correct</span></span><br><span class="line"><span class="comment"># classifications</span></span><br><span class="line">rfecv = RFECV(estimator=svc, step=<span class="number">1</span>, cv=StratifiedKFold(y, <span class="number">5</span>),</span><br><span class="line">              scoring=<span class="string">'accuracy'</span>)</span><br><span class="line">rfecv = rfecv.fit(X, y)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Optimal number of features : %d"</span> % rfecv.n_features_)</span><br><span class="line">print(<span class="string">"选择的特征："</span>)</span><br><span class="line"><span class="keyword">print</span> rfecv.support_</span><br></pre></td></tr></table></figure></p><h4 id="feature-selection-using-selectfrommodel从模型中选择特征">Feature selection using SelectFromModel(从模型中选择特征)</h4><p>许多估计模型在执行完fit方法以后都会有<code>coef_</code>参数，这个参数实际上是各个特征的权重，所以我们可以根据这个权重选择特征，把权重小的特征去除。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">print(__doc__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_boston</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectFromModel</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LassoCV</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load the boston dataset.</span></span><br><span class="line">boston = load_boston()</span><br><span class="line">X, y = boston[<span class="string">'data'</span>], boston[<span class="string">'target'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># We use the base estimator LassoCV since the L1 norm promotes sparsity of features.</span></span><br><span class="line">clf = LassoCV()</span><br><span class="line">clf.fit(X,y)</span><br><span class="line"><span class="comment"># Set a minimum threshold of 0.25</span></span><br><span class="line">sfm = SelectFromModel(clf, threshold=<span class="string">'mean'</span>,prefit=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">print</span> X.shape</span><br><span class="line"><span class="comment">#sfm = sfm.fit(X, y)</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"============LassoCV================"</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"选择的特征"</span></span><br><span class="line"><span class="keyword">print</span> sfm._get_support_mask();</span><br><span class="line">n_features = sfm.transform(X).shape[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">print</span> n_features</span><br><span class="line"></span><br><span class="line"><span class="comment"># We use LinearSVC</span></span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> LinearSVC</span><br><span class="line"><span class="comment">#C 越小，选择的特征越少</span></span><br><span class="line">lsvc = LinearSVC(C=<span class="number">0.001</span>, penalty=<span class="string">"l1"</span>, dual=<span class="literal">False</span>)</span><br><span class="line">y = y.astype(np.int64) <span class="comment">#转换成整数，因为是分类器，不是回归</span></span><br><span class="line">lsvc.fit(X,y)</span><br><span class="line">model = SelectFromModel(lsvc, prefit=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"============线性SVM==============================="</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"选择的特征"</span></span><br><span class="line"><span class="keyword">print</span> model._get_support_mask();</span><br><span class="line">n_features = model.transform(X).shape[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">print</span> n_features</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line">clf = linear_model.LogisticRegression(C=<span class="number">0.001</span>, penalty=<span class="string">'l1'</span>, tol=<span class="number">1e-6</span>)</span><br><span class="line">y = y.astype(np.int64) <span class="comment">#转换成整数，因为是分类器，不是回归</span></span><br><span class="line">clf.fit(X,y)</span><br><span class="line">model = SelectFromModel(clf, prefit=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"============逻辑回归==============================="</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"选择的特征"</span></span><br><span class="line"><span class="keyword">print</span> model._get_support_mask();</span><br><span class="line">n_features = model.transform(X).shape[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">print</span> n_features</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> ExtraTreesClassifier</span><br><span class="line">clf = ExtraTreesClassifier()</span><br><span class="line">y = y.astype(np.int64) <span class="comment">#转换成整数，因为是分类器，不是回归</span></span><br><span class="line">clf = clf.fit(X, y)</span><br><span class="line">model = SelectFromModel(clf, prefit=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"============基于树的特征选择==============================="</span></span><br><span class="line"><span class="keyword">print</span> clf.feature_importances_</span><br><span class="line"><span class="keyword">print</span> <span class="string">"选择的特征："</span></span><br><span class="line"><span class="keyword">print</span> model._get_support_mask();</span><br><span class="line">n_features = model.transform(X).shape[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">print</span> n_features</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">(<span class="number">506L</span>, <span class="number">13L</span>)</span><br><span class="line">============LassoCV================</span><br><span class="line">选择的特征</span><br><span class="line">[<span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span>  <span class="literal">True</span> <span class="literal">False</span>  <span class="literal">True</span> <span class="literal">False</span> <span class="literal">False</span>  <span class="literal">True</span> <span class="literal">False</span></span><br><span class="line">  <span class="literal">True</span>]</span><br><span class="line"><span class="number">4</span></span><br><span class="line">============线性SVM===============================</span><br><span class="line">选择的特征</span><br><span class="line">[<span class="literal">False</span>  <span class="literal">True</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span>  <span class="literal">True</span> <span class="literal">False</span> <span class="literal">False</span>  <span class="literal">True</span> <span class="literal">False</span>  <span class="literal">True</span></span><br><span class="line"> <span class="literal">False</span>]</span><br><span class="line"><span class="number">4</span></span><br><span class="line">============逻辑回归===============================</span><br><span class="line">选择的特征</span><br><span class="line">[<span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span>  <span class="literal">True</span> <span class="literal">False</span>  <span class="literal">True</span></span><br><span class="line"> <span class="literal">False</span>]</span><br><span class="line"><span class="number">2</span></span><br><span class="line">============基于树的特征选择===============================</span><br><span class="line">[ <span class="number">0.12196356</span>  <span class="number">0.02193675</span>  <span class="number">0.03935991</span>  <span class="number">0.01633832</span>  <span class="number">0.0721041</span>   <span class="number">0.13938681</span></span><br><span class="line">  <span class="number">0.11703915</span>  <span class="number">0.10962258</span>  <span class="number">0.03116833</span>  <span class="number">0.04455059</span>  <span class="number">0.04134067</span>  <span class="number">0.1074465</span></span><br><span class="line">  <span class="number">0.13774273</span>]</span><br><span class="line">选择的特征</span><br><span class="line">[ <span class="literal">True</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span>  <span class="literal">True</span>  <span class="literal">True</span>  <span class="literal">True</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span>  <span class="literal">True</span></span><br><span class="line">  <span class="literal">True</span>]</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure></p><h3 id="分类器">分类器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># linear_model</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"></span><br><span class="line">lmlr = linear_model.LinearRegression()</span><br><span class="line">lmlr.fit(X_train,y_train)</span><br><span class="line">lmlr.coef_</span><br><span class="line">predicted_y = lmlr.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># L1 惩罚项</span></span><br><span class="line">lmr = linear_model.Ridge (alpha = <span class="number">.5</span>)</span><br><span class="line">lmr.fit(X_train,y_train)</span><br><span class="line">lmr.coef_</span><br><span class="line">lmr.intercept_</span><br><span class="line">predicted_y = lmr.predict(X_test)</span><br><span class="line"></span><br><span class="line">lmrcv = linear_model.RidgeCV(alphas=[<span class="number">0.1</span>, <span class="number">0.5</span>,<span class="number">1.0</span>, <span class="number">10.0</span>]) <span class="comment"># 自带交叉验证</span></span><br><span class="line">lmrcv.fit(X_train,y_train)</span><br><span class="line">lmrcv.alpha_</span><br><span class="line">predicted_y = lmrcv.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># L2 惩罚项</span></span><br><span class="line">lmla = linear_model.Lasso(alpha = <span class="number">0.001</span>)</span><br><span class="line">lmla.fit(X_train,y_train)</span><br><span class="line">predicted_y = lmla.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># L1 + L2 惩罚项的一个混合</span></span><br><span class="line">lmela = linear_model.ElasticNet(alpha=<span class="number">0.01</span>,l1_ratio=<span class="number">0.9</span>)</span><br><span class="line">lmela.fit(X_train,y_train)</span><br><span class="line">predicted_y = lmela.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Least Angle Regression : 适用于高维数据，缺点是对噪声比较敏感</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">lmlar = linear_model.Lars(n_nonzero_coefs=<span class="number">10</span>)</span><br><span class="line">lmlar.fit(X_train,y_train)</span><br><span class="line">predicted_y = lmlar.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">BayesianRidge : Bayesian Ridge Regression</span></span><br><span class="line"><span class="string">小特征数目表现不佳</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">lmbr = linear_model.BayesianRidge()</span><br><span class="line">lmbr.fit(X_train,y_train)</span><br><span class="line">lmbr.coef_</span><br><span class="line">predicted_y = lmbr.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">ARDRegression : similar to BayesianRidge, but tend to sparse</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">lmardr = linear_model.ARDRegression(compute_score=<span class="literal">True</span>)</span><br><span class="line">lmardr.fit(X_train, y_train)</span><br><span class="line">predicted_y = lmardr.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">逻辑回归</span></span><br><span class="line"><span class="string">Logistic regression</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">lmlr1 = linear_model.LogisticRegression(C=<span class="number">1</span>, penalty=<span class="string">'l1'</span>, tol=<span class="number">0.01</span>)</span><br><span class="line">lmlr2 = linear_model.LogisticRegression(C=<span class="number">1</span>, penalty=<span class="string">'l2'</span>, tol=<span class="number">0.01</span>)</span><br><span class="line">lmlr1.fit(X_train,y_train)</span><br><span class="line">predicted_y = lmlr1.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">SGDClassifier</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">lmsdg = linear_model.SGDClassifier()</span><br><span class="line">lmsdg.fit(X_train,y_train)</span><br><span class="line">predicted_y = lmsdg.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Perceptron : 感知机算法</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">lmper = linear_model.Perceptron()</span><br><span class="line">lmper.fit(X_train,y_train)</span><br><span class="line">predicted_y = lmper.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">PassiveAggressiveClassifier : similar to Perceptron but have peny</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">lmpac = linear_model.PassiveAggressiveClassifier()</span><br><span class="line">lmpac.fit(X_train,y_test)</span><br><span class="line">predicted_y = lmpac.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Linear discriminant analysis  &amp;&amp; quadratic discriminant analysis</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> sklearn.lda <span class="keyword">import</span> LDA</span><br><span class="line">lda = LDA(solver=<span class="string">"svd"</span>, store_covariance=<span class="literal">True</span>)</span><br><span class="line">lda.fit(X, y)</span><br><span class="line">predicted_y = lda.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.qda <span class="keyword">import</span> QDA</span><br><span class="line">qda = QDA()</span><br><span class="line">qda.fit(X, y, store_covariances=<span class="literal">True</span>)</span><br><span class="line">predicted_y = qda.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Kernel ridge regression:</span></span><br><span class="line"><span class="string">combines Ridge Regression (linear least squares with l2-norm regularization)</span></span><br><span class="line"><span class="string">with the kernel trick</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> sklearn.kernel_ridge <span class="keyword">import</span> KernelRidge</span><br><span class="line">kr = KernelRidge(alpha=<span class="number">0.1</span>)</span><br><span class="line">kr.fit(X,y)</span><br><span class="line">predicted_y = kr.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Support Vector Machines : 支持向量机分类</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line">svmsvc = svm.SVC(C=<span class="number">0.1</span>,kernel=<span class="string">'rbf'</span>)</span><br><span class="line">svmsvc.fit(X_train,y_train)</span><br><span class="line">svmsvc.score(X_test,y_test)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Support Vector Regression.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">svmsvr = svm.SVR()</span><br><span class="line">svmsvr.fit(X_train,y_train)</span><br><span class="line">svmsvr.score(X_test,y_test)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Nearest Neighbors : 最近邻</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> NearestNeighbors</span><br><span class="line">nbrs = NearestNeighbors(n_neighbors=<span class="number">2</span>, algorithm=<span class="string">'ball_tree'</span>).fit(X)</span><br><span class="line">distances, indices = nbrs.kneighbors(X)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line">nkc = KNeighborsClassifier(<span class="number">15</span>, weights=<span class="string">'uniform'</span>)</span><br><span class="line">nkc.fit(X_train,y_train)</span><br><span class="line">nkc.score(X_test,y_test)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> NearestCentroid</span><br><span class="line">clf = NearestCentroid(shrink_threshold=<span class="number">0.1</span>)</span><br><span class="line">clf.fit(X_train, y_train)</span><br><span class="line">clf.score(X_test,y_test)</span><br></pre></td></tr></table></figure><h4 id="支持向量机svm">支持向量机（SVM）</h4><h5 id="简介">简介</h5><p>scikit-learn支持稠密的(dense)和稀疏的（sparse）数据，但是当测试数据是稀疏的时候，训练数据必须也是稀疏的。为了达到最优的性能，建议稠密数据使用<code>numpy.ndarray</code>,稀疏数据使用<code>scipy.sparse.csr_matrix</code> and <code>dtype=float64</code>.</p><h5 id="用途">用途</h5><ul><li>分类（classfication）</li><li>回归 (regression)</li><li>离群点检测 (outliers detection)</li></ul><h5 id="优点">优点</h5><ul><li>当特征维数很高时很有效(effective in high dimensional space)</li><li>当特征的维数远大于样本的数量的时候依然有效</li><li>使用的是训练点（training points）的子集进行决策函数（decision function）的计算，所以是内存高效的（memory efficient）</li><li>多种可供选择的核函数(kernel function)提高了算法的灵活性，核函数是可以根据自己的需要自定义的。</li></ul><h5 id="缺点">缺点</h5><ul><li>当特征的数量远大于样本的数量的时候，算法的性能会下降（poor performance）</li><li>SVM不直接提供概率估计（probability estimates），而是使用一个五折交叉验证（five-fold cross-validation）,计算复杂性较高，一般不适合海量数据的处理。</li></ul><h5 id="使用方法">使用方法</h5><h6 id="二分类">二分类</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#准备数据</span></span><br><span class="line">X = [[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>]]</span><br><span class="line">y = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="comment">#引入支持向量机</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">创建模型,这里有三种方法:</span></span><br><span class="line"><span class="string">svm.SVC(); svm.NuSVC(); svm.LinearSVC()</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">clf = svm.SVC()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">训练数据，这里X是[n_samples,n_features],y是[n_labels]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">clf = clf.fit(X_train, y)</span><br><span class="line"><span class="comment">#使用训练好的模型预测</span></span><br><span class="line">y_predicted = clf.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获得训练好的模型的一些参数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># get support vectors</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>clf.support_vectors_</span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">1.</span>,  <span class="number">1.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># get indices of support vectors</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>clf.support_</span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>]...)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># get number of support vectors for each class</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>clf.n_support_</span><br><span class="line">array([<span class="number">1</span>, <span class="number">1</span>]...)</span><br><span class="line"><span class="comment">#get the params of the svm</span></span><br><span class="line">&gt;&gt;&gt;clf.coef_</span><br></pre></td></tr></table></figure><blockquote><p>上面是最简单的支持向量机的使用方式，下一步还需要了解可以设置的各个参数是什么意思，如何设置，如何交叉验证，如何选择和函数。</p></blockquote><h6 id="多分类">多分类</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line">X = [[<span class="number">0</span>], [<span class="number">1</span>], [<span class="number">2</span>], [<span class="number">3</span>]]</span><br><span class="line">Y = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># "one-against-one"</span></span><br><span class="line">clf = svm.SVC(decision_function_shape=<span class="string">'ovo'</span>)</span><br><span class="line">clf.fit(X, Y)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">one-against-one 就是一对一，假设这四类的名称为a,b,c,d.</span></span><br><span class="line"><span class="string">则需要训练区分(a,b)(a,c)(a,d)(b,c)(b,d)(c,d)的6种模型，所以</span></span><br><span class="line"><span class="string">one-against-one这种策略在做多分类问题的时候会生成n*(n-1)/2个模型，每个模型区分其中的两个类。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">dec = clf.decision_function([[<span class="number">1</span>]])</span><br><span class="line">dec.shape[<span class="number">1</span>] <span class="comment"># 4 classes: 4*3/2 = 6</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string"> "one-vs-the-rest" 就是一对余下所有的，假设四类的名称为a,b,c,d;</span></span><br><span class="line"><span class="string"> 则需要训练区分(a,bcd),(b,acd)(c,abd)(d,abc)的4种模型，每个模型区分其中一个类，被除此类之外的所有类当作另外一个类处理。</span></span><br><span class="line"><span class="string"> 这种策略在做多分类问题的时候会生成n个模型。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">clf.decision_function_shape = <span class="string">"ovr"</span></span><br><span class="line">dec = clf.decision_function([[<span class="number">1</span>]])</span><br><span class="line">dec.shape[<span class="number">1</span>] <span class="comment"># 4 classes</span></span><br></pre></td></tr></table></figure><blockquote><p>一些补充说明：<code>SVC</code>和<code>NuSVC</code>实现了<code>one-against-one</code>(<code>ovo</code>)方法，<code>LinearSVC</code>实现了<code>one-vs-test</code>(<code>ovr</code>)和另外一个叫做<code>Crammer and Singer</code>的实现多分类的方法， 可以通过指定<code>multi_class='crammer_singer'</code>来使用它。不多实践证明，在使用<code>LinearSVC</code>的进行多分类的时候，优先选择<code>one-vs-test</code>(<code>ovr</code>)， 因为<code>one-vs-test</code>(<code>ovr</code>)和<code>crammer_singer</code>得到的结果差不多，但是前者的计算时间要短。</p></blockquote><h4 id="模型参数说明">模型参数说明</h4><h5 id="linearsvc">LinearSVC</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line">X = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">y = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">clf = svm.LinearSVC()</span><br><span class="line">clf.fit(X,y)</span><br><span class="line"><span class="keyword">print</span> clf</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">LinearSVC(C=<span class="number">1.0</span>, class_weight=<span class="literal">None</span>, dual=<span class="literal">True</span>, fit_intercept=<span class="literal">True</span>,</span><br><span class="line">     intercept_scaling=<span class="number">1</span>, loss=<span class="string">'squared_hinge'</span>, max_iter=<span class="number">1000</span>,</span><br><span class="line">     multi_class=<span class="string">'ovr'</span>, penalty=<span class="string">'l2'</span>, random_state=<span class="literal">None</span>, tol=<span class="number">0.0001</span>,</span><br><span class="line">     verbose=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><strong>参数</strong> - <code>C</code>：可选参数，类型<code>float</code>,默认为1.0；误差的惩罚参数 - <code>class_weight</code>: 类型<code>dict</code>,可选参数，默认每个class的权重都是1.用来设置每个class的权重。 - <code>dual</code>:默认为<code>True</code>,类型<code>bool</code>,当<code>n_samples</code> &gt; <code>n_features</code>时，设置成<code>False</code>. - <code>fit_intercept</code>: 可选参数，类型为bool,默认为True. 意思是为模型计算截距（intercept），当数据事先已经是centered的时候，可以设置成False，不计算截距。 - <code>intercept_scaling</code>： 可选参数，类型为float,默认为1.意思是截距是否缩放。 - <code>loss</code>: 类型string,只能取“hinge” 和 “squared_hinge”,默认取“squared_hinge”；定义SVM的损失函数，“hinge”是标准的SVM损失函数，“squared_hinge”是标准损失函数的平方。 - <code>max_iter</code>： 类型为int,默认为1000，模型最大的迭代次数。 - <code>multi_class</code>：类型string，只能取’ovr’ 和 ‘crammer_singer’ (默认值是’ovr’)，当计算多分类的时候，指定多分类采取的策略。‘ovr’是将其中一类和剩下所有类二分，默认用这个策略就好。 - <code>penalty</code>： 类型string,只能取’l1’ or ‘l2’ (默认值是’l2’)，l1使参数稀疏，l2使大部分参数接近为0但是不是0，详细信息参考“机器学习中的范数” - <code>random_state</code>： 只能取int seed, RandomState instance, None 三个中的一个，默认值是None,指定产生伪随机数的时候使用的种子（seed） - <code>tol</code>：可选参数，类型为float,默认值是1e-4,指定停止时候的允许的误差。 - <code>verbose</code>：类型为int,默认值是0，是否开启详细的输出，默认不要开启就好。如果开启，在多线程的时候可能运行不正确。</p><p><strong>属性</strong> - <code>coef_</code>：训练好之后的SVM模型中的参数的取值（就是系数），当是二分类的时候，shape=[n_features],多分类的时候，shape = [n_classes,n_features] - <code>intercept_</code>:截距，二分类的时候shape = [1] ,多分类的时候shape=[n_classes]</p><h5 id="svc">SVC</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line">X = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">y = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">clf = svm.SVC()</span><br><span class="line">clf.fit(X,y)</span><br><span class="line"><span class="keyword">print</span> clf</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">SVC(C=<span class="number">1.0</span>, cache_size=<span class="number">200</span>, class_weight=<span class="literal">None</span>, coef0=<span class="number">0.0</span>,</span><br><span class="line">  decision_function_shape=<span class="literal">None</span>, degree=<span class="number">3</span>, gamma=<span class="string">'auto'</span>, kernel=<span class="string">'rbf'</span>,</span><br><span class="line">  max_iter=<span class="number">-1</span>, probability=<span class="literal">False</span>, random_state=<span class="literal">None</span>, shrinking=<span class="literal">True</span>,</span><br><span class="line">  tol=<span class="number">0.001</span>, verbose=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><strong>参数</strong> - <code>C</code>=1.0, 可选参数，类型<code>float</code>,默认为1.0；误差的惩罚参数 - <code>cache_size</code>=200, 定义模型计算时使用的缓存大小，单位MB。 - <code>class_weight</code>=None,类型dict,默认为None,可以设置成’balanced’，这样会根据y自动计算每个class的权重。还可以手动设置每个class的权重。 - <code>coef0</code>=0.0,可选参数，类型为float,默认为0.0，独立于核函数（kernel function）的参数，只在’poly’ and ‘sigmoid’的时候有影响。 - <code>decision_function_shape</code>=None, ’ovo’, ‘ovr’ or None, default=None - <code>degree</code>=3, 可选参数，类型为int,默认为3，多项式和函数的度，其他类型的和函数自动忽略该参数。 - <code>gamma</code>=‘auto’, 可选参数，类型为float,默认为‘auto’,默认取 1/n_features作为gamma的值。 - <code>kernel</code>=‘rbf’,可选参数，类型为string，默认值为‘rbf’,定义SVM所使用的核函数，可选择的项如下： - linear - poly - rbf - sigmoid - precomputed - a callable(一个回调函数) - <code>max_iter</code>=-1, 最大迭代次数，默认为-1，意思是无限制。 - <code>probability</code>=False, 可选参数，类型bool,默认值为False. 是否进行概率估计，使用之前需要先调用fit方法。 - <code>random_state</code>=None, 只能取int seed, RandomState instance, None 三个中的一个，默认值是None,指定产生伪随机数的时候使用的种子（seed） - <code>shrinking</code>=True,可选参数，类型boolean,默认值为True,是否开启“shrinking heuristic” - <code>tol</code>=0.001, 可选参数，类型为float,默认值是1e-4,指定停止时候的允许的误差。 - <code>verbose</code>=False，类型为int,默认值是0，是否开启详细的输出，默认不要开启就好。如果开启，在多线程的时候可能运行不正确。</p><p><strong>属性</strong> - <code>support_</code> : array-like, shape = [n_SV]，支持向量的下标 - <code>n_support_</code> : array-like, dtype=int32, shape = [n_class] 每个类的支持向量的个数。 - <code>support_vectors_</code> ：shape = [n_SV, n_features]，支持向量(SVM确定了一个分类超平面，支持向量就是平移这个超平面，最先与数据集的交点。) - <code>dual_coef_</code> : array, shape = [n_class-1, n_SV] 在决策函数（decision function）中支持向量的系数 - <code>coef_</code> : array, shape = [n_class-1, n_features]，特征的权重，只在线性核的时候可用。 - <code>intercept_</code> : array, shape = [n_class * (n_class-1) / 2]，决策函数（decision function）中的常量。</p><h5 id="nusvc">NuSVC</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line">X = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">y = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">clf = svm.NuSVC()</span><br><span class="line">clf.fit(X,y)</span><br><span class="line"><span class="keyword">print</span> clf</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">NuSVC(cache_size=<span class="number">200</span>, class_weight=<span class="literal">None</span>, coef0=<span class="number">0.0</span>,</span><br><span class="line">   decision_function_shape=<span class="literal">None</span>, degree=<span class="number">3</span>, gamma=<span class="string">'auto'</span>, kernel=<span class="string">'rbf'</span>,</span><br><span class="line">   max_iter=<span class="number">-1</span>, nu=<span class="number">0.5</span>, probability=<span class="literal">False</span>, random_state=<span class="literal">None</span>,</span><br><span class="line">   shrinking=<span class="literal">True</span>, tol=<span class="number">0.001</span>, verbose=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><strong>参数</strong> 大部分都与<code>SVC</code>一样，只是使用了一个额外的参数控制支持向量（support vector）的个数。 - <code>nu</code>:可选参数，类型float，默认值是0.5，值必须要(0,1]之间。</p><p><strong>属性</strong> - <code>support_</code> : array-like, shape = [n_SV]，支持向量的下标 - <code>n_support_</code> : array-like, dtype=int32, shape = [n_class] 每个类的支持向量的个数。 - <code>support_vectors_</code> ：shape = [n_SV, n_features]，支持向量 - <code>dual_coef_</code> : array, shape = [n_class-1, n_SV] 在决策函数（decision function）中支持向量的系数 - <code>coef_</code> : array, shape = [n_class-1, n_features]，特征的权重，只在线性核的时候可用。 - <code>intercept_</code> : array, shape = [n_class * (n_class-1) / 2]，决策函数（decision function）中的常量。</p><h4 id="查看训练好的模型的参数">查看训练好的模型的参数</h4><h4 id="决策函数decision-function">决策函数（decision function）</h4><h4 id="核函数kernel-function">核函数（kernel function）</h4><p>优先使用‘rbf’调节参数，当特征的数量远远大于样本的数量的时候，考虑使用线性核函数。</p><hr><h4 id="随机梯度下降stochastic-gradient-descen">随机梯度下降（Stochastic Gradient Descen）</h4><p>分类，回归 ##### 简介 随机梯度下降法适用于特征数据大于10的5次方，样本数量大于10的5次方的大规模数据的处理领域。</p><h5 id="用途-1">用途</h5><p>可以处理大规模数据和稀疏数据。</p><h5 id="优点-1">优点</h5><ul><li>高效</li><li>易于实现</li></ul><h5 id="缺点-1">缺点</h5><ul><li>需要很多超参数</li><li>对特征的缩放敏感</li></ul><h5 id="使用方法-1">使用方法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> SGDClassifier</span><br><span class="line">X = [[<span class="number">0.</span>, <span class="number">0.</span>], [<span class="number">1.</span>, <span class="number">1.</span>]]</span><br><span class="line">y = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">clf = SGDClassifier()</span><br><span class="line">clf.fit(X, y) <span class="comment">#训练</span></span><br><span class="line">clf.predict([[<span class="number">2.</span>, <span class="number">2.</span>]])  <span class="comment">#预测</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> clf</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">SGDClassifier(alpha=<span class="number">0.0001</span>, average=<span class="literal">False</span>, class_weight=<span class="literal">None</span>, epsilon=<span class="number">0.1</span>,</span><br><span class="line">       eta0=<span class="number">0.0</span>, fit_intercept=<span class="literal">True</span>, l1_ratio=<span class="number">0.15</span>,</span><br><span class="line">       learning_rate=<span class="string">'optimal'</span>, loss=<span class="string">'hinge'</span>, n_iter=<span class="number">5</span>, n_jobs=<span class="number">1</span>,</span><br><span class="line">       penalty=<span class="string">'l2'</span>, power_t=<span class="number">0.5</span>, random_state=<span class="literal">None</span>, shuffle=<span class="literal">True</span>,</span><br><span class="line">       verbose=<span class="number">0</span>, warm_start=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;clf.coef_  <span class="comment">#模型系数</span></span><br><span class="line">&gt;&gt;&gt;Out[<span class="number">31</span>]: array([[ <span class="number">9.91080278</span>,  <span class="number">9.91080278</span>]])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;clf.intercept_    <span class="comment">#截距</span></span><br><span class="line">&gt;&gt;&gt;array([<span class="number">-9.99002993</span>])</span><br></pre></td></tr></table></figure><p><strong>参数</strong> - <code>alpha</code>=0.0001, - <code>average</code>=False, - <code>class_weight</code>=None, epsilon=0.1, - <code>eta0</code>=0.0, - <code>fit_intercept</code>=True, - <code>l1_ratio</code>=0.15, - <code>learning_rate</code>=‘optimal’, - <code>loss</code>=‘hinge’, - <code>n_iter</code>=5, n_jobs=1, - <code>penalty</code>=‘l2’, - <code>power_t</code>=0.5, - <code>random_state</code>=None, - <code>shuffle</code>=True, - <code>verbose</code>=0, - <code>warm_start</code>=False</p><p><strong>属性</strong> - coef_ : array, shape (1, n_features) if n_classes == 2 else (n_classes,n_features);Weights assigned to the features.</p><ul><li>intercept_ : array, shape (1,) if n_classes == 2 else (n_classes,);Constants in decision function.</li></ul><h4 id="最近邻方法nearest-neighbors">最近邻方法（Nearest Neighbors）</h4><p>如果一个样本在特征空间中的k个最相 似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别.</p><h5 id="简介-1">简介</h5><p>scikit-learn实现了监督的和非监督的最近邻方法，决定最近邻的算法有<code>ball_tree</code>,<code>kd_tree</code>,<code>brute</code>,可以通过指定模型参数<code>algorithm</code>的值来指定到底使用哪一个算法。 主要功能是实现<strong><em>分类</em></strong>和<strong><em>回归</em></strong>。</p><h5 id="用法">用法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> NearestNeighbors</span><br><span class="line">X = np.array([[<span class="number">-1</span>, <span class="number">-1</span>], [<span class="number">-2</span>, <span class="number">-1</span>], [<span class="number">-3</span>, <span class="number">-2</span>], [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">2</span>]])</span><br><span class="line">nbrs = NearestNeighbors(n_neighbors=<span class="number">2</span>, algorithm=<span class="string">'ball_tree'</span>).fit(X)</span><br></pre></td></tr></table></figure><h3 id="模型持久化">模型持久化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.externals <span class="keyword">import</span> joblib</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line">clf_l1_LR = LogisticRegression(C=<span class="number">0.1</span>, penalty=<span class="string">'l1'</span>, tol=<span class="number">0.01</span>)</span><br><span class="line">joblib.dump(clf_l1_LR, <span class="string">'LogisticRegression.model'</span>)</span><br></pre></td></tr></table></figure><h3 id="结果的可视化">结果的可视化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.title(<span class="string">"VarianceThreshold For Feature Selection"</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Number of features selected"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Cross validation score (nb of correct classifications)"</span>)</span><br><span class="line">plt.plot(lsvc_feature_num, lsvc_score)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="数据预处理">数据预处理</h3><p><code>scikit-learn</code>提供了很多数据预处理的方法，使用的时候需要引入的包是<code>preprocessing</code>.</p><p><strong>缩放scale</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据最大值和最小值缩放到[0,1]范围</span></span><br><span class="line">min_max_scaler = MinMaxScaler()</span><br><span class="line">X_transformed = min_max_scaler.fit_transform(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据标准化，使得均值为0，方差为1</span></span><br><span class="line">ss = StandardScaler()</span><br><span class="line">X_transformed = ss.fit_transform(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 考虑离群点的缩放，首先排除离群点再缩放</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> RobustScaler</span><br><span class="line">robust_scaler = RobustScaler()</span><br><span class="line">X_transformed = robust_scaler.fit_transform(X)</span><br></pre></td></tr></table></figure><p><strong>one-hot编码</strong></p><p>对于离散的类别特征，可以使用<code>one-hot</code>编码来处理特征，这样处理之后的特征可以直接被一些学习器使用。该方法默认会根据类别的数量生成能够表示该类别的二进制编码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line">enc = OneHotEncoder()</span><br><span class="line">transformed_data = enc.transform(data).toarray()</span><br></pre></td></tr></table></figure><p><strong>特征组合</strong></p><p>特征组合的一个最简单的尝试是生成多项式特征，例如，如果有两个特征x_1,x_2,多项式为2的特征会自动生成1, x1,x2,x1*x2,x1<sup>2,x2</sup>2 这些特征。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures</span><br><span class="line"></span><br><span class="line">poly = PolynomialFeatures(<span class="number">2</span>)</span><br><span class="line">X_transformed = poly.fit_transform(X)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> scikit-learn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fMRI相关的资源汇总</title>
      <link href="/hexoblog/2017/05/14/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/fMRI%E7%9B%B8%E5%85%B3%E7%9A%84%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/"/>
      <url>/hexoblog/2017/05/14/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/fMRI%E7%9B%B8%E5%85%B3%E7%9A%84%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>记录一些fMRI经常用到的网站和资源的下载地址。</p><a id="more"></a><h2 id="研究机构和网站">研究机构和网站</h2><ol style="list-style-type: decimal"><li><p>一个致力于改进fMRI 数据获取和分析方法的组织：<a href="https://amri.ninds.nih.gov/index.html" class="uri" target="_blank" rel="noopener">https://amri.ninds.nih.gov/index.html</a></p></li><li><p>美国国立卫生研究院神经科学研究所:<a href="https://www.nitrc.org" class="uri" target="_blank" rel="noopener">https://www.nitrc.org</a></p></li><li><p>一个基于Python的神经影像数据的开源代码社区：<a href="http://nipy.org" class="uri" target="_blank" rel="noopener">http://nipy.org</a></p></li><li><p>Open Science Framework:<a href="https://osf.io" class="uri" target="_blank" rel="noopener">https://osf.io</a></p></li></ol><h2 id="公开数据库">公开数据库</h2><ol style="list-style-type: decimal"><li><p>老年痴呆证AD的公开数据库：<a href="http://adni.loni.usc.edu/data-samples" class="uri" target="_blank" rel="noopener">http://adni.loni.usc.edu/data-samples</a></p></li><li><p>The National Database for Autism Research (NDAR) autism spectrum disorders（ASD） 孤独症数据库(需要注册授权，申请吗，等待回复) <a href="https://www.nitrc.org/projects/ndarportal" class="uri" target="_blank" rel="noopener">https://www.nitrc.org/projects/ndarportal</a></p></li><li><p>34个公开fmri数据库:<a href="http://home.52brain.com/thread-28111-2-1.html" class="uri" target="_blank" rel="noopener">http://home.52brain.com/thread-28111-2-1.html</a></p></li><li><p>提供fMRI公开数据的一个网站: <a href="https://openfmri.org/dataset" class="uri" target="_blank" rel="noopener">https://openfmri.org/dataset</a></p></li><li><p>静息态功能影像数据:<a href="http://fcon_1000.projects.nitrc.org/fcpClassic/FcpTable.html" class="uri" target="_blank" rel="noopener">http://fcon_1000.projects.nitrc.org/fcpClassic/FcpTable.html</a></p></li><li><p>Autism spectrum disorder (ASD) : <a href="http://fcon_1000.projects.nitrc.org/indi/abide" class="uri" target="_blank" rel="noopener">http://fcon_1000.projects.nitrc.org/indi/abide</a></p></li><li><p>精神分裂症:<a href="http://fcon_1000.projects.nitrc.org/indi/retro/cobre.html" class="uri" target="_blank" rel="noopener">http://fcon_1000.projects.nitrc.org/indi/retro/cobre.html</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 认知神经科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fMRI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习_TensorFlow使用技巧</title>
      <link href="/hexoblog/2017/05/12/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_TensorFlow%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/hexoblog/2017/05/12/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_TensorFlow%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>TensorFlow 基础使用。</p><a id="more"></a><h2 id="定义变量和执行运算">定义变量和执行运算：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">node1 = tf.constant(<span class="number">3.0</span>, tf.float32)</span><br><span class="line">node2 = tf.constant(<span class="number">4.0</span>) <span class="comment"># also tf.float32 implicitly</span></span><br><span class="line">print(node1, node2)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 运行程序</span></span><br><span class="line">sess = tf.Session()</span><br><span class="line">print(sess.run([node1, node2]))</span><br><span class="line"></span><br><span class="line">node3 = tf.add(node1, node2)</span><br><span class="line">print(<span class="string">"node3: "</span>, node3)</span><br><span class="line">print(<span class="string">"sess.run(node3): "</span>,sess.run(node3))</span><br><span class="line"></span><br><span class="line">a = tf.placeholder(tf.float32)</span><br><span class="line">b = tf.placeholder(tf.float32)</span><br><span class="line">adder_node = a + b  <span class="comment"># + provides a shortcut for tf.add(a, b)</span></span><br><span class="line"></span><br><span class="line">print(sess.run(adder_node, &#123;a: <span class="number">3</span>, b:<span class="number">4.5</span>&#125;))</span><br><span class="line">print(sess.run(adder_node, &#123;a: [<span class="number">1</span>,<span class="number">3</span>], b: [<span class="number">2</span>, <span class="number">4</span>]&#125;))</span><br></pre></td></tr></table></figure><h2 id="卷积">卷积</h2><h3 id="一维卷积">一维卷积</h3><div class="figure"><img src="2017-05-12_192455.png"></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="comment"># 输入的 feature_map</span></span><br><span class="line">input_feature_map = np.array([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">0</span>]).astype(np.float32)</span><br><span class="line"><span class="comment"># 卷积核</span></span><br><span class="line">filter_kernel = np.array([<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>]).astype(np.float32)</span><br><span class="line"></span><br><span class="line">graph1 = tf.Graph()</span><br><span class="line"><span class="keyword">with</span> graph1.as_default():</span><br><span class="line">    <span class="comment">#inputs = [batch, in_width, in_channels]</span></span><br><span class="line">    <span class="comment">#filter =  [filter_width, in_channels, out_channels]</span></span><br><span class="line">    <span class="comment"># reshape成需要的输入格式</span></span><br><span class="line">    f=tf.constant( input_feature_map.reshape(<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>) )</span><br><span class="line">    g=tf.constant(  filter_kernel.reshape(<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>)   )</span><br><span class="line">    conv1=tf.nn.conv1d( f,g, stride=<span class="number">1</span> , padding=<span class="string">"VALID"</span>,name=<span class="string">"conv1"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session(graph=graph1) <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line">    result = (sess.run(conv1))</span><br><span class="line">    print(result[<span class="number">0</span>])</span><br><span class="line">    sess.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出 [[-2.]</span></span><br><span class="line">    <span class="comment">#  [ 2.]</span></span><br><span class="line">    <span class="comment">#  [ 1.]</span></span><br><span class="line">    <span class="comment">#  [ 2.]</span></span><br><span class="line">    <span class="comment">#  [ 1.]]</span></span><br></pre></td></tr></table></figure><p>用上面的代码计算的结果和例子中步长为1的一维卷积结果是一致的。把代码中的<code>stride=1</code>改为<code>stride=2</code>就可以得到例子中的另外一个结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[-2.]</span><br><span class="line"> [ 1.]</span><br><span class="line"> [ 1.]]</span><br></pre></td></tr></table></figure><h3 id="二维卷积">二维卷积</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="comment"># 输入的 feature_map</span></span><br><span class="line">input_feature_map = np.array([[<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">                              [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">                              [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">                              [<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">                              [<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]]).astype(np.float32)</span><br><span class="line"></span><br><span class="line">filter_kernel = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">                       [<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>],</span><br><span class="line">                       [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]]).astype(np.float32)</span><br><span class="line"></span><br><span class="line">graph1 = tf.Graph()</span><br><span class="line"><span class="keyword">with</span> graph1.as_default():</span><br><span class="line">    <span class="comment">#inputs = [batch, in_height, in_width, in_channels]</span></span><br><span class="line">    <span class="comment">#filter =  [filter_height, filter_width, in_channels, out_channels]</span></span><br><span class="line">    <span class="comment"># reshape成需要的输入格式</span></span><br><span class="line">    f=tf.constant( input_feature_map.reshape(<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>) )</span><br><span class="line">    g=tf.constant(  filter_kernel.reshape(<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>)   )</span><br><span class="line">    conv2=tf.nn.conv2d( f,g, strides=[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] , padding=<span class="string">"VALID"</span>,name=<span class="string">"conv1"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session(graph=graph1) <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line">    result = (sess.run(conv2))</span><br><span class="line">    print(result)</span><br><span class="line">    sess.close()</span><br></pre></td></tr></table></figure><p>得到的卷积结果：</p><div class="figure"><img src="2017-05-12_194134.png"></div><p>这里附上使用theano计算的相同的二维卷积的代码和结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> theano <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> theano.tensor <span class="keyword">as</span> T</span><br><span class="line"><span class="keyword">from</span> theano.tensor.nnet <span class="keyword">import</span> conv2d</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">inputs = T.tensor4(<span class="string">'input'</span>)</span><br><span class="line">filters = T.tensor4(<span class="string">'filters'</span>)</span><br><span class="line">input_feature_map = np.array([[<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">                              [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">                              [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">                              [<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">                              [<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]]).reshape(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>).astype(float)</span><br><span class="line"></span><br><span class="line">filter_map = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">                       [<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>],</span><br><span class="line">                       [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]]).reshape(<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>).astype(float)</span><br><span class="line">output = conv2d(</span><br><span class="line">    inputs, filters, input_shape=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>), filter_shape=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>),</span><br><span class="line">    border_mode=<span class="string">'valid'</span>, subsample=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">f = function([inputs, filters], output)</span><br><span class="line"></span><br><span class="line">out_feature_map = f(input_feature_map,filter_map)</span><br></pre></td></tr></table></figure><div class="figure"><img src="2017-05-12_194346.png"></div><p>这两个工具包具体的计算过程还没有弄明白，不知道为什么计算结果不一样。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
            <tag> TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用3D卷积神经神经网络提取脑成像数据的特征</title>
      <link href="/hexoblog/2017/05/11/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/%E4%BD%BF%E7%94%A83D%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%8F%90%E5%8F%96%E8%84%91%E6%88%90%E5%83%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E7%89%B9%E5%BE%81/"/>
      <url>/hexoblog/2017/05/11/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/%E4%BD%BF%E7%94%A83D%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%8F%90%E5%8F%96%E8%84%91%E6%88%90%E5%83%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E7%89%B9%E5%BE%81/</url>
      
        <content type="html"><![CDATA[<p>3D 卷积神经网络可以捕获3D空间的约束信息，利用它可以将原始的fMRI数据转换到另外的特征空间。 <a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Thu May 11 19:40:32 2017</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: FF120</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> nibabel <span class="keyword">as</span> nib</span><br><span class="line"><span class="keyword">import</span> nilearn</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#############################################################################</span></span><br><span class="line"><span class="comment">## 加载神经影像数据</span></span><br><span class="line"><span class="comment">#############################################################################</span></span><br><span class="line">data_root = <span class="string">r'D:\FMRI_ROOT\YIYU\4D_data\funImg'</span></span><br><span class="line">os.chdir(data_root)</span><br><span class="line">lists_files = os.listdir()</span><br><span class="line"></span><br><span class="line">subjects = []</span><br><span class="line">subjects_data = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(lists_files)):</span><br><span class="line">    img = nib.load(lists_files[i])</span><br><span class="line">    subjects.append(img)</span><br><span class="line">    subjects_data.append(img.get_data())</span><br><span class="line"></span><br><span class="line"><span class="comment">#############################################################################</span></span><br><span class="line"><span class="comment">## 配置autoencoder的结构</span></span><br><span class="line"><span class="comment">## input_dim --&gt; encoding_dim --&gt; input_dim</span></span><br><span class="line"><span class="comment">#############################################################################</span></span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Input, Dense</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Model</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中间隐藏层的 神经元 数目</span></span><br><span class="line">encoding_dim = <span class="number">150</span></span><br><span class="line"><span class="comment">#  输入神经元的数目</span></span><br><span class="line">input_dim = <span class="number">125</span></span><br><span class="line"><span class="comment"># 输入层神经元的数目</span></span><br><span class="line">input_img = Input(shape=(input_dim,))</span><br><span class="line"><span class="comment"># "encoded" is the encoded representation of the input</span></span><br><span class="line">encoded = Dense(encoding_dim, activation=<span class="string">'relu'</span>)(input_img)</span><br><span class="line"><span class="comment"># "decoded" is the lossy reconstruction of the input</span></span><br><span class="line">decoded = Dense(input_dim, activation=<span class="string">'sigmoid'</span>)(encoded)</span><br><span class="line"></span><br><span class="line"><span class="comment"># this model maps an input to its reconstruction</span></span><br><span class="line">autoencoder = Model(input_img, decoded)</span><br><span class="line"></span><br><span class="line"><span class="comment"># this model maps an input to its encoded representation</span></span><br><span class="line">encoder = Model(input_img, encoded)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create a placeholder for an encoded (32-dimensional) input</span></span><br><span class="line">encoded_input = Input(shape=(encoding_dim,))</span><br><span class="line"><span class="comment"># retrieve the last layer of the autoencoder model</span></span><br><span class="line">decoder_layer = autoencoder.layers[<span class="number">-1</span>]</span><br><span class="line"><span class="comment"># create the decoder model</span></span><br><span class="line">decoder = Model(encoded_input, decoder_layer(encoded_input))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备训练和测试用的数据</span></span><br><span class="line"><span class="comment"># 卷积核的大小</span></span><br><span class="line">kernel_size = <span class="number">5</span></span><br><span class="line">subject0_0 = subjects_data[<span class="number">0</span>][:,:,:,<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 每个scan取100个样本</span></span><br><span class="line">sample_num = <span class="number">100</span></span><br><span class="line">list_kernels = []</span><br><span class="line"><span class="keyword">for</span> subject <span class="keyword">in</span> range(len(subjects_data)):</span><br><span class="line">    subject_data = subjects_data[subject]</span><br><span class="line">    <span class="keyword">for</span> scan <span class="keyword">in</span> range(subject_data.shape[<span class="number">3</span>]):</span><br><span class="line">        scan_data = subject_data[:,:,:,scan]</span><br><span class="line">        x_ = (np.random.random(size=sample_num)*(<span class="number">64</span>-kernel_size)).astype(int)</span><br><span class="line">        y_ = (np.random.random(size=sample_num)*(<span class="number">64</span>-kernel_size)).astype(int)</span><br><span class="line">        z_ = (np.random.random(size=sample_num)*(<span class="number">36</span>-kernel_size)).astype(int)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(sample_num):</span><br><span class="line">            kernel_one = scan_data[x_[i]:(x_[i]+kernel_size),y_[i]:(y_[i]+kernel_size),z_[i]:(z_[i]+kernel_size)]</span><br><span class="line">            list_kernels.append(kernel_one)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">matrix_kernel = np.array(list_kernels)</span><br><span class="line">matrix_kernel = matrix_kernel.reshape((len(matrix_kernel), np.prod(matrix_kernel.shape[<span class="number">1</span>:])))</span><br><span class="line"><span class="comment"># 共抽取出来55*240*100 = 1320000个5*5*5的kernel，这个作为autoencoder的学习数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">autoencoder.compile(optimizer=<span class="string">'adadelta'</span>, loss=<span class="string">'binary_crossentropy'</span>)</span><br><span class="line">autoencoder.fit(matrix_kernel, matrix_kernel,</span><br><span class="line">                epochs=<span class="number">500</span>,</span><br><span class="line">                batch_size=<span class="number">100</span>,</span><br><span class="line">                shuffle=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 保存模型</span></span><br><span class="line"><span class="comment"># 保存模型</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_model</span><span class="params">(model,name)</span>:</span></span><br><span class="line">    <span class="comment">## fit完成之后，保存整个模型的配置</span></span><br><span class="line">    root_path = <span class="string">r'd:\deeplearning'</span></span><br><span class="line">    model_config = model.get_config()</span><br><span class="line">    model_weight = model.get_weights()</span><br><span class="line">    <span class="keyword">import</span> pickle</span><br><span class="line">    <span class="keyword">import</span> os</span><br><span class="line">    config_save_path = os.path.join(root_path,name+<span class="string">"_config.txt"</span>)</span><br><span class="line">    weight_save_path = os.path.join(root_path,name+<span class="string">"_weights.txt"</span>)</span><br><span class="line">    pickle.dump(model_config, open(config_save_path, <span class="string">'wb'</span>))</span><br><span class="line">    pickle.dump(model_weight, open(weight_save_path, <span class="string">'wb'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> model_from_json</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_model</span><span class="params">(name)</span>:</span></span><br><span class="line">    root_path = <span class="string">r'd:\deeplearning'</span></span><br><span class="line">    <span class="keyword">import</span> pickle</span><br><span class="line">    <span class="keyword">import</span> os</span><br><span class="line">    config_save_path = os.path.join(root_path,name+<span class="string">"_config.txt"</span>)</span><br><span class="line">    weight_save_path = os.path.join(root_path,name+<span class="string">"_weights.txt"</span>)</span><br><span class="line">    model_config = pickle.load(open(config_save_path, <span class="string">'rb'</span>))</span><br><span class="line">    model_weight = pickle.load(open(weight_save_path, <span class="string">'rb'</span>))</span><br><span class="line">    model = Model.from_config(model_config)</span><br><span class="line">    model.set_weights(model_weight)</span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line">model_save_path = <span class="string">r''</span></span><br><span class="line">save_model(autoencoder,<span class="string">'3-layer-autoencoder-for-mdd'</span>)</span><br><span class="line"><span class="comment">## 获取训练好的模型的参数作为新的卷积网络的卷积核</span></span><br><span class="line">autoencoder = load_model(<span class="string">'3-layer-autoencoder-for-mdd'</span>)</span><br><span class="line">weights = autoencoder.get_weights()[<span class="number">0</span>]</span><br><span class="line">list_kernel_weights = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(weights.shape[<span class="number">1</span>]):</span><br><span class="line">    list_kernel_weights.append(weights[:,i].reshape(kernel_size,kernel_size,kernel_size))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 使用autoencoder初始化卷积核已经成功，下面开始使用3D卷积为图像降维，最终生成一个降维之后的特征</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 卷积操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一幅图像一幅图像的卷积和池化</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convM</span><span class="params">(one_scan,kernels)</span>:</span></span><br><span class="line">    graph1 = tf.Graph()</span><br><span class="line">    <span class="keyword">with</span> graph1.as_default():</span><br><span class="line">        <span class="comment">#inputs = [batch, in_depth, in_height, in_width, in_channels]</span></span><br><span class="line">        <span class="comment">#filter =  [filter_depth, filter_height, filter_width, in_channels,</span></span><br><span class="line">        <span class="comment">#  out_channels]</span></span><br><span class="line">        <span class="comment"># reshape成需要的输入格式</span></span><br><span class="line">        f=tf.constant( one_scan.reshape(<span class="number">1</span>,<span class="number">64</span>,<span class="number">64</span>,<span class="number">36</span>,<span class="number">1</span>) )</span><br><span class="line">        g=tf.constant(  kernels.reshape(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">150</span>)   )</span><br><span class="line">        <span class="comment"># 3D 卷积操作</span></span><br><span class="line">        conv3=tf.nn.conv3d( f,g, strides=[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] , padding=<span class="string">"VALID"</span>,name=<span class="string">"conv1"</span>)</span><br><span class="line">        <span class="comment"># 池化操作</span></span><br><span class="line">        pooling3 = tf.nn.max_pool3d(conv3, ksize=[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], strides=[<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>], padding=<span class="string">'VALID'</span>, name=<span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">with</span> tf.Session(graph=graph1) <span class="keyword">as</span> sess:</span><br><span class="line">        sess.run(tf.global_variables_initializer())</span><br><span class="line">        result = (sess.run(pooling3))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">        sess.close()</span><br><span class="line"></span><br><span class="line">one_subject = subjects_data[<span class="number">0</span>].astype(np.float32)</span><br><span class="line">one_scan = one_subject[<span class="number">0</span>:,<span class="number">0</span>:,<span class="number">0</span>:,<span class="number">0</span>].astype(np.float32)</span><br><span class="line"><span class="comment">#   150 个 卷积核</span></span><br><span class="line">kernels = weights.reshape(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">150</span>).astype(np.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 使用循环处理每个被试和每个scan</span></span><br><span class="line">re_list_subjects=[]</span><br><span class="line"><span class="comment">#num_su = len(subjects_data)</span></span><br><span class="line"><span class="comment">#num_sc = su.shape[3]</span></span><br><span class="line"><span class="keyword">for</span> subject <span class="keyword">in</span> range( len(subjects_data) ):</span><br><span class="line">    su = subjects_data[i]</span><br><span class="line">    re_list_scan = []</span><br><span class="line">    <span class="keyword">for</span> scan <span class="keyword">in</span> range( su.shape[<span class="number">3</span>] ):</span><br><span class="line">        sc = su[<span class="number">0</span>:,<span class="number">0</span>:,<span class="number">0</span>:,scan].astype(np.float32)</span><br><span class="line">        re_sc = convM(sc,kernels)</span><br><span class="line">        re_list_scan.append(re_sc)</span><br><span class="line"></span><br><span class="line">    re_list_subjects.append(re_list_scan)</span><br><span class="line"></span><br><span class="line">feature_mat = np.asarray(re_list_subjects)</span><br><span class="line">os.chdir(<span class="string">r'D:\deeplearning'</span>)</span><br><span class="line">np.save(<span class="string">'3d_pool_feature_result'</span>,feature_mat)</span><br><span class="line"><span class="comment">###得到卷积和池化之后的特征，处理成以后分类要用到的数据格式，并保存下来</span></span><br><span class="line">re_feature=[]</span><br><span class="line"><span class="keyword">for</span> subject <span class="keyword">in</span> re_list_subjects:</span><br><span class="line">    <span class="keyword">for</span> scan <span class="keyword">in</span> subject:</span><br><span class="line">        re_feature.append(scan.reshape(<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">feature_2d = np.asarray(re_feature)</span><br><span class="line">np.save(<span class="string">'feature_2d_from_3d_pool'</span>,feature_mat)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 使用一种降维方法，使用svm完成分类</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 认知神经科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CNN </tag>
            
            <tag> feature extraction </tag>
            
            <tag> 特征提取 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_时间序列预测分析算法</title>
      <link href="/hexoblog/2017/05/11/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95/"/>
      <url>/hexoblog/2017/05/11/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>预测问题是机器学习中很重要的一个问题，它是根据过去已经存在的数据预测未来可能的情况。本文通过一个著名的波士顿抢劫案的数据集来说明预测问题的来龙去脉。</p><a id="more"></a><h2 id="ar自回归模型预测">AR自回归模型预测</h2><h3 id="数据集">数据集</h3><p><a href="https://datamarket.com/data/set/235k/daily-total-female-births-in-california-1959#!ds=235k&amp;display=line" target="_blank" rel="noopener">Daily Female Births Dataset</a></p><p>This dataset describes the number of daily female births in California in 1959.</p><p>它的结构很简单，每一行是一天的数据，每一行有两个数据，第一个是日期，第二个是人数。</p><h3 id="用python加载数据集">用Python加载数据集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot</span><br><span class="line">file_path = <span class="string">r'D:\deeplearning\Forecasting\daily-total-female-births-in-cal.csv'</span></span><br><span class="line">series = Series.from_csv(file_path, header=<span class="number">0</span>)</span><br><span class="line">print(series.head())</span><br><span class="line">series.plot()</span><br><span class="line">pyplot.show()</span><br></pre></td></tr></table></figure><p>series.plot()是pandas的Series自己提供的数据可视化方法。</p><h3 id="选择一种预测模型">选择一种预测模型</h3><p>这里我们先选择使用最广泛的自回归模型来看看。</p><h4 id="autoregressive-model">Autoregressive model</h4><p>自回归模型（英语：Autoregressive model，简称AR模型），是统计上一种处理时间序列的方法，用同一变数例如x的之前各期，亦即<span class="math inline">\(x_1\)</span>至 $ x_{t-1}$来预测本期 <span class="math inline">\(x_\)</span> 的表现，并假设它们为一线性关系。因为这是从回归分析中的线性回归发展而来，只是不用x预测y，而是用x预测x（自己）；所以叫做自回归。 自回归模型被广泛运用在经济学、信息学、自然现象的预测上.</p><p>自回归模型（Autoregressive Model）是用自身做回归变量的过程，即利用前期若干时刻的随机变量的线性组合来描述以后某时刻随机变量的线性回归模型，它是时间序列中的一种常见形式.</p><p>P阶自回归模型，记作AR(p),含义是序列中<span class="math inline">\(x_t\)</span>是前p个序列<span class="math inline">\((x_{t-6},x_{t-5},x_{t-4},x_{t-3},x_{t-2},x_{t-1})\)</span> 和误差项通过线性组合而成的。</p><p><strong>优点与限制</strong></p><ol style="list-style-type: decimal"><li>必须具有自相关，自相关系数（<span class="math inline">\(\varphi _{i}\)</span>）是关键。如果自相关系数(R)小于0.5，则不宜采用，否则预测结果极不准确。</li><li>自回归只能适用于预测与自身前期相关的经济现象，即受自身历史因素影响较大的经济现象，如矿的开采量，各种自然资源产量等；对于受社会因素影响较大的经济现象，不宜采用自回归，而应改采可纳入其他变数的向量自回归模型。</li></ol><h4 id="使用ar模型的训练和测试">使用AR模型的训练和测试</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面该选择用来预测的模型了，</span></span><br><span class="line"><span class="comment"># 这里我们随便选择一个 AR 模型</span></span><br><span class="line"><span class="keyword">from</span> statsmodels.tsa.ar_model <span class="keyword">import</span> AR</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"></span><br><span class="line"><span class="comment"># create a difference transform of the dataset</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">difference</span><span class="params">(dataset)</span>:</span></span><br><span class="line">diff = list()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dataset)):</span><br><span class="line">value = dataset[i] - dataset[i - <span class="number">1</span>]</span><br><span class="line">diff.append(value)</span><br><span class="line"><span class="keyword">return</span> numpy.array(diff)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make a prediction give regression coefficients and lag obs</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(coef, history)</span>:</span></span><br><span class="line">yhat = coef[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(coef)):</span><br><span class="line">yhat += coef[i] * history[-i]</span><br><span class="line"><span class="keyword">return</span> yhat</span><br><span class="line"></span><br><span class="line"><span class="comment"># split dataset</span></span><br><span class="line">X = difference(series.values)</span><br><span class="line">size = int(len(X) * <span class="number">0.66</span>)</span><br><span class="line">train, test = X[<span class="number">0</span>:size], X[size:]</span><br><span class="line"><span class="comment"># train autoregression</span></span><br><span class="line">model = AR(train)</span><br><span class="line">model_fit = model.fit(maxlag=<span class="number">6</span>, disp=<span class="literal">False</span>)</span><br><span class="line">window = model_fit.k_ar</span><br><span class="line">coef = model_fit.params</span><br><span class="line"><span class="comment"># walk forward over time steps in test</span></span><br><span class="line">history = [train[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(train))]</span><br><span class="line">predictions = list()</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(len(test)):</span><br><span class="line">yhat = predict(coef, history)</span><br><span class="line">obs = test[t]</span><br><span class="line">predictions.append(yhat)</span><br><span class="line">history.append(obs)</span><br><span class="line">error = mean_squared_error(test, predictions)</span><br><span class="line">print(<span class="string">'Test MSE: %.3f'</span> % error)</span><br><span class="line"><span class="comment"># plot</span></span><br><span class="line">pyplot.plot(test)</span><br><span class="line">pyplot.plot(predictions, color=<span class="string">'red'</span>)</span><br><span class="line">pyplot.show()</span><br></pre></td></tr></table></figure><p>上面我们使用的是AR(6)模型。就是用前6个数据去预测第七个数据。如此循环，不断调整参数，减小损失函数。</p><div class="figure"><img src="2017-05-11_172946.png"></div><p>保存训练好的模型，以便以后的使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># save model to file</span></span><br><span class="line">model_fit.save(<span class="string">'ar_model.pkl'</span>)</span><br><span class="line"><span class="comment"># save the differenced dataset</span></span><br><span class="line">numpy.save(<span class="string">'ar_data.npy'</span>, X)</span><br><span class="line"><span class="comment"># save the last ob</span></span><br><span class="line">numpy.save(<span class="string">'ar_obs.npy'</span>, [series.values[<span class="number">-1</span>]])</span><br></pre></td></tr></table></figure><p>与之对应的加载模型的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># load the AR model from file</span></span><br><span class="line"><span class="keyword">from</span> statsmodels.tsa.ar_model <span class="keyword">import</span> ARResults</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line">loaded = ARResults.load(<span class="string">'ar_model.pkl'</span>)</span><br><span class="line">print(loaded.params)</span><br><span class="line">data = numpy.load(<span class="string">'ar_data.npy'</span>)</span><br><span class="line">last_ob = numpy.load(<span class="string">'ar_obs.npy'</span>)</span><br><span class="line">print(last_ob)</span><br></pre></td></tr></table></figure><h2 id="线性回归预测">线性回归预测</h2><h2 id="使用神经网络实现简单的线性回归">使用神经网络实现简单的线性回归</h2><h3 id="数据集-1">数据集</h3><p>The problem that we will look at in this tutorial is the <a href="https://archive.ics.uci.edu/ml/machine-learning-databases/housing/housing.data" target="_blank" rel="noopener">Boston house price dataset</a>.</p><p>The dataset describes 13 numerical properties of houses in Boston suburbs and is concerned with modeling the price of houses in those suburbs in thousands of dollars. As such, this is a regression predictive modeling problem. Input attributes include things like crime rate, proportion of nonretail business acres, chemical concentrations and more.</p><p><a href="http://www.cs.toronto.edu/~delve/data/boston/bostonDetail.html" target="_blank" rel="noopener">数据集的详细说明</a></p><h3 id="使用keras用简单的神经网络模拟线性回归">使用keras用简单的神经网络模拟线性回归</h3><p>我们使用<a href="https://keras.io/" target="_blank" rel="noopener">Keras</a>构造一个简单的全连接的神经网络来模拟回归模型，做出预测。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Thu May 11 14:44:12 2017</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: FF120</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">import</span> pandas</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense</span><br><span class="line"><span class="keyword">from</span> keras.wrappers.scikit_learn <span class="keyword">import</span> KerasRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"></span><br><span class="line"><span class="comment"># load dataset</span></span><br><span class="line">data_file_path = <span class="string">r'D:\deeplearning\Boston house price dataset\housing.data.txt'</span></span><br><span class="line">dataframe = pandas.read_csv(data_file_path, delim_whitespace=<span class="literal">True</span>, header=<span class="literal">None</span>)</span><br><span class="line">dataset = dataframe.values</span><br><span class="line"><span class="comment"># split into input (X) and output (Y) variables</span></span><br><span class="line">X = dataset[:,<span class="number">0</span>:<span class="number">13</span>]</span><br><span class="line">Y = dataset[:,<span class="number">13</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># create model</span></span><br><span class="line">  <span class="comment"># 该模型一共有三层，第一层是输入，有13个神经元；第二层是也有13个神经元，激活函数是relu</span></span><br><span class="line">  <span class="comment"># 第三层只有一个神经元，是输出，没有激活函数</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(<span class="number">13</span>, input_dim=<span class="number">13</span>, kernel_initializer=<span class="string">'normal'</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(Dense(<span class="number">1</span>, kernel_initializer=<span class="string">'normal'</span>))</span><br><span class="line"><span class="comment"># Compile model</span></span><br><span class="line">model.compile(loss=<span class="string">'mean_squared_error'</span>, optimizer=<span class="string">'adam'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 划分训练集和测试集</span></span><br><span class="line">x_train = X[<span class="number">0</span>:<span class="number">400</span>,:]</span><br><span class="line">x_test = X[<span class="number">400</span>:,:]</span><br><span class="line">y_train = Y[<span class="number">0</span>:<span class="number">400</span>]</span><br><span class="line">y_test = Y[<span class="number">400</span>:]</span><br><span class="line">model.fit(x_train,y_train,epochs=<span class="number">1000</span>,batch_size=<span class="number">10</span>,shuffle=<span class="literal">True</span>,)</span><br><span class="line">predicted_y = model.predict(x_test)</span><br><span class="line">print(y_test)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot</span><br><span class="line">pyplot.plot(predicted_y)</span><br><span class="line">pyplot.plot(y_test, color=<span class="string">'red'</span>)</span><br><span class="line">pyplot.show()</span><br></pre></td></tr></table></figure><p>epochs = 1000 的时候的结果：</p><div class="figure"><img src="2017-05-11_191517.png"></div><p>epochs = 1500 的时候的结果：</p><div class="figure"><img src="2017-05-11_192035.png"></div><p>我们可以借助keara提供的scikit-learn API来和scikit-learn互动，这样我们可以更加方便的使用scikit-learn实现的交叉验证方式来测试我们的神经网络。</p><p>首先，我们把定义神经网络模型的代码写成函数的形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># define base model</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">baseline_model</span><span class="params">()</span>:</span></span><br><span class="line"><span class="comment"># create model</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(<span class="number">13</span>, input_dim=<span class="number">13</span>, kernel_initializer=<span class="string">'normal'</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(Dense(<span class="number">1</span>, kernel_initializer=<span class="string">'normal'</span>))</span><br><span class="line"><span class="comment"># Compile model</span></span><br><span class="line">model.compile(loss=<span class="string">'mean_squared_error'</span>, optimizer=<span class="string">'adam'</span>)</span><br><span class="line"><span class="keyword">return</span> mode</span><br></pre></td></tr></table></figure><p>我们使用KerasRegressor来打通和scikit-learn的连接。’nb_epoch=100, batch_size=5, verbose=0’这些参数都是kears模型fit的时候需要的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># evaluate model with standardized dataset</span></span><br><span class="line">estimator = KerasRegressor(build_fn=baseline_model, nb_epoch=<span class="number">100</span>, batch_size=<span class="number">5</span>, verbose=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>K折交叉验证和结果的评估：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kfold = KFold(n_splits=<span class="number">10</span>, random_state=seed)</span><br><span class="line">results = cross_val_score(estimator, X, Y, cv=kfold)</span><br><span class="line">print(<span class="string">"Results: %.2f (%.2f) MSE"</span> % (results.mean(), results.std()))</span><br></pre></td></tr></table></figure><p>为了方便理解和描述，我们这里只是介绍一下交叉验证的实现方法，并不使用。我们还是使用上面完整一段代码里用的手工划分训练集和测试集的方法。</p><h3 id="神经网络结构的调整和性能的比较">神经网络结构的调整和性能的比较</h3><p>我们改变一下上面定义的神经网络的结构，看结果是不是会发生变化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model.add(Dense(<span class="number">13</span>, input_dim=<span class="number">13</span>, kernel_initializer=<span class="string">'normal'</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(Dense(<span class="number">6</span>, kernel_initializer=<span class="string">'normal'</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(Dense(<span class="number">1</span>, kernel_initializer=<span class="string">'normal'</span>))</span><br></pre></td></tr></table></figure><p>原来的结构是<code>13 inputs -&gt;13 -&gt; 1</code>, 现在变成了<code>13 inputs -&gt; 13 -&gt; 6 -&gt; 1</code>. epochs = 1000 得到的结果是：</p><div class="figure"><img src="2017-05-11_193546.png"></div><p>可以看到并没有太大的提高。我们再尝试使用更多的隐层神经元试试。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(<span class="number">20</span>, input_dim=<span class="number">13</span>, kernel_initializer=<span class="string">'normal'</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(Dense(<span class="number">1</span>, kernel_initializer=<span class="string">'normal'</span>))</span><br></pre></td></tr></table></figure><div class="figure"><img src="2017-05-11_193854.png"></div><p>还是没有太大的提高，估计这种简单的模型也只能是这个水平了。</p><p>参考资料：<a href="http://machinelearningmastery.com/regression-tutorial-keras-deep-learning-library-python/" class="uri" target="_blank" rel="noopener">http://machinelearningmastery.com/regression-tutorial-keras-deep-learning-library-python/</a></p><p>参考文献：</p><ol style="list-style-type: decimal"><li><p><a href="http://machinelearningmastery.com/make-predictions-time-series-forecasting-python" class="uri" target="_blank" rel="noopener">http://machinelearningmastery.com/make-predictions-time-series-forecasting-python</a></p></li><li><p><a href="http://machinelearningmastery.com/time-series-prediction-lstm-recurrent-neural-networks-python-keras" class="uri" target="_blank" rel="noopener">http://machinelearningmastery.com/time-series-prediction-lstm-recurrent-neural-networks-python-keras</a></p></li><li><p><a href="http://machinelearningmastery.com/time-series-forecasting-long-short-term-memory-network-python" class="uri" target="_blank" rel="noopener">http://machinelearningmastery.com/time-series-forecasting-long-short-term-memory-network-python</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时间序列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法专题_计算几何</title>
      <link href="/hexoblog/2017/05/11/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
      <url>/hexoblog/2017/05/11/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/</url>
      
        <content type="html"><![CDATA[<p>算法题目当中经常涉及到一些几何题目。这类题目如果不事先了解一些知识，往往感觉很难有思路。本文总结算法中常见问题涉及到的主要知识。 <a id="more"></a></p><h2 id="线段">线段</h2><p><strong>点的凸组合</strong></p><p>点 <span class="math inline">\(p_1=(x_1,y_1)\)</span> 和 <span class="math inline">\(p_2=(x_2,y_2)\)</span> 的凸组合定义为：</p><p>满足如下条件的任意点 <span class="math inline">\(p_3\)</span></p><p><span class="math display">\[  x_3 = \alpha x_1 + (1-\alpha) x_2 \]</span> <span class="math display">\[  y_3 = \alpha y_1 + (1-\alpha) y_2 \]</span></p><p>其中，<span class="math inline">\(0 &lt;= \alpha &lt;= 1\)</span></p><p>含义，<span class="math inline">\(p_3\)</span> 位于点 <span class="math inline">\(p_1\)</span> 和 <span class="math inline">\(p_2\)</span> 组成的线段内，包含这两个端点。</p><p>我们用 <span class="math inline">\(p_1 p_2\)</span> 表示线段，用 <span class="math inline">\(p_1 \longrightarrow p_2\)</span> 表示向量或者叫做有向线段。</p><p>我们先来解决第一个问题：</p><h3 id="有向线段的旋转">有向线段的旋转</h3><p>给定两个有向线段 <span class="math inline">\(p_0 \longrightarrow p_1\)</span> 和 <span class="math inline">\(p_0 \longrightarrow p_2\)</span>，判断 <span class="math inline">\(p_0 \longrightarrow p_1\)</span> 是否在 <span class="math inline">\(p_0 \longrightarrow p_2\)</span> 的顺时针方向？</p><p><strong>叉积</strong></p><p>先来了解一个概念，两个点的叉积就是两个点的行列式的值：</p><p><span class="math display">\[p_1 \times p_2 = det[x_1 x_2 ; y_1 y_2] = x_1y_2-x_2y_1\]</span></p><p>叉积的几何意义是 由点(0,0),p1,p2,p1+p2组成的平行四边形的<em>有向</em>面积。</p><p><strong>结论</strong></p><p><span class="math display">\[  a = (p_1-p_0) \times (p_2-p_0)\]</span></p><p>如果a&gt;0,则 <span class="math inline">\(p_0 \longrightarrow p_1\)</span> 位于 <span class="math inline">\(p_0 \longrightarrow p_2\)</span> 的顺时针方向，如果a&lt;0,则位于逆时针方向。</p><h3 id="线段相交">线段相交</h3>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习_限制波尔茨曼向量机(RBM)</title>
      <link href="/hexoblog/2017/05/10/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_%E9%99%90%E5%88%B6%E6%B3%A2%E5%B0%94%E8%8C%A8%E6%9B%BC%E5%90%91%E9%87%8F%E6%9C%BA(RBM)/"/>
      <url>/hexoblog/2017/05/10/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_%E9%99%90%E5%88%B6%E6%B3%A2%E5%B0%94%E8%8C%A8%E6%9B%BC%E5%90%91%E9%87%8F%E6%9C%BA(RBM)/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍RBM相关的知识。包括能量函数，概率的观点，网络的结构等等。 <a id="more"></a> 先来看看没有限制的波尔茨曼机是什么样子的。</p><div class="figure"><img src="2017-05-10_123815.png"></div><p>原始的波尔茨曼机虽然有很多有趣的特性，但是由于连接过于复杂，很难实际应用（或者是有效的方法还没有被提出来，就像当年深度网络缺乏有效的训练方法一样）。一种限制连接形式的波尔茨曼机因为其简单的结构和有趣的性质得到了广泛的应用。看看它长什么样子。</p><div class="figure"><img src="2017-05-10_123931.png"></div><p>这就是RBM，很像一个两层的全连接的神经网络。 我们用<span class="math inline">\(v_i\)</span>来表示可视层的神经元,用<span class="math inline">\(h_j\)</span>来表示隐藏层的神经元,用 <span class="math inline">\(w_{ij}\)</span> 来表示两层之间的权重，用 <span class="math inline">\(a_i\)</span> 来表示可视层的偏置，用 <span class="math inline">\(b_j\)</span> 表示隐藏层的偏置,用 <span class="math inline">\((v,h)\)</span> 表示一个RBM，那么我们可以定义一些经常要使用到的量.</p><p>RBM的能量E定义为：</p><p><span class="math display">\[E(v,h)=-\sum_i{a_i v_i}-\sum_j{b_j h_j}-\sum_i\sum_j{h_j w_{ij} v_i}\]</span></p><p>在一般的玻尔兹曼机中，隐层和可见层之间的联合概率分布由能量函数给出:</p><p><span class="math display">\[P(v,h) = \dfrac 1 Z e^{-E(v,h)}\]</span></p><p>其中， <span class="math inline">\(Z\)</span> 为配分函数，定义为在节点的所有可能取值下$ e^{-E(v,h)} $的和（亦即使得概率分布和为1的归一化常数）. 类似地，可见层取值的边缘分布可通过对所有隐层配置求和得到: <span class="math display">\[P(v)=\dfrac 1 {Z} \sum_h{e^{-E(v,h)}}\]</span> 可见层的配置v对于隐层配置h的条件概率如下: <span class="math display">\[P(v|h)=\prod_{i=1}^m P(v_i|h)\]</span> h对于v的条件概率为: <span class="math display">\[P(h|v)=\prod_{j=1}^n P(h_j|v)\]</span></p><p>单个节点的激活概率为</p><p><span class="math display">\[P(h_j=1|v)=\sigma(b_j+\sum_{i=1}^m {w_{ij} v_i})\]</span></p><p><span class="math display">\[P(v_i=1|h)=\sigma(a_i+\sum_{j=1}^n w_{ij}h_j)\]</span></p><p>式中的<span class="math inline">\(\sigma\)</span>表示Logistic函数，： <span class="math display">\[P(t)= \dfrac 1 {1+e^{-t}}\]</span></p><p>受限玻尔兹曼机的<strong>训练目标</strong>是针对某一训练集 <span class="math inline">\({\displaystyle V}\)</span>，最大化概率的乘积。其中， ${V} $被视为一矩阵，每个行向量作为一个可见单元向量 <span class="math inline">\({\displaystyle v}\)</span>: <span class="math display">\[\arg\max_W \prod_{v \in V} P(v)\]</span></p><p>等价的，可以最大化它的对数函数： <span class="math display">\[\arg\max_W \mathbb{E} \left[\sum_{v \in V} \log P (v)\right]\]</span></p><p>训练受限玻尔兹曼机，即最优化权重矩阵 <span class="math inline">\({\displaystyle W}\)</span> .</p><p>波尔茨曼机也可以看作是 马尔科夫随机场的一种特殊情况。</p><p>RBM一个基本的训练方法叫做Contrastive Divergence，它的具体过程如下：</p><p>输入： 一个N行的矩阵<span class="math inline">\(x_0\)</span>，每一行对应一个可视的神经元; 隐层单元的个数m,学习率<span class="math inline">\(\epsilon\)</span>, 最大训练周期T。</p><p>输出：权重<span class="math inline">\(W\)</span>, 可视层的偏置<span class="math inline">\(a\)</span>, 隐藏层的偏置<span class="math inline">\(b\)</span></p><p>初始化： 权重<span class="math inline">\(W\)</span>,偏置<span class="math inline">\(a\)</span>,<span class="math inline">\(b\)</span>随机初始化为较小的数值,令可视层的第一个状态<span class="math inline">\(v_1 = x_0\)</span></p><p>参数更新规则：</p><p><span class="math inline">\(W = W + \epsilon*( P(h_1=1|v_1 )v_1^T - P(h_2=1|v_2)v_2^T))\)</span></p><p><span class="math inline">\(a = a +\epsilon*(v_1 - v_2)\)</span></p><p><span class="math inline">\(b = b + \epsilon*(P(h_1=1|v_1)-P(h_2=1|v_2))\)</span></p><p>下面用Python实现其中的计算步骤，这样能够对算法的每一步有一个比较详细的了解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RBM</span>:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_visible, num_hidden, learning_rate = <span class="number">0.1</span>)</span>:</span></span><br><span class="line">    self.num_hidden = num_hidden</span><br><span class="line">    self.num_visible = num_visible</span><br><span class="line">    self.learning_rate = learning_rate</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Initialize a weight matrix, of dimensions (num_visible x num_hidden), using</span></span><br><span class="line">    <span class="comment"># a Gaussian distribution with mean 0 and standard deviation 0.1.</span></span><br><span class="line">    self.weights = <span class="number">0.1</span> * np.random.randn(self.num_visible, self.num_hidden)</span><br><span class="line">    <span class="comment"># Insert weights for the bias units into the first row and first column.</span></span><br><span class="line">    self.weights = np.insert(self.weights, <span class="number">0</span>, <span class="number">0</span>, axis = <span class="number">0</span>)</span><br><span class="line">    self.weights = np.insert(self.weights, <span class="number">0</span>, <span class="number">0</span>, axis = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(self, data, max_epochs = <span class="number">1000</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Train the machine.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    data: A matrix where each row is a training example consisting of the states of visible units.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 也是可视层的神经元的数量</span></span><br><span class="line">    num_examples = data.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Insert bias units of 1 into the first column.</span></span><br><span class="line">    <span class="comment"># data的第一列用来表示偏置，这里全部设置成1</span></span><br><span class="line">    data = np.insert(data, <span class="number">0</span>, <span class="number">1</span>, axis = <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># max_epochs 就是最大的训练周期T</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(max_epochs):</span><br><span class="line">      <span class="comment"># Clamp to the data and sample from the hidden units.</span></span><br><span class="line">      <span class="comment"># (This is the "positive CD phase", aka the reality phase.)</span></span><br><span class="line">      pos_hidden_activations = np.dot(data, self.weights)</span><br><span class="line">      pos_hidden_probs = self._logistic(pos_hidden_activations)</span><br><span class="line">      pos_hidden_states = pos_hidden_probs &gt; np.random.rand(num_examples, self.num_hidden + <span class="number">1</span>)</span><br><span class="line">      <span class="comment"># Note that we're using the activation *probabilities* of the hidden states, not the hidden states</span></span><br><span class="line">      <span class="comment"># themselves, when computing associations. We could also use the states; see section 3 of Hinton's</span></span><br><span class="line">      <span class="comment"># "A Practical Guide to Training Restricted Boltzmann Machines" for more.</span></span><br><span class="line">      pos_associations = np.dot(data.T, pos_hidden_probs)</span><br><span class="line"></span><br><span class="line">      <span class="comment"># Reconstruct the visible units and sample again from the hidden units.</span></span><br><span class="line">      <span class="comment"># (This is the "negative CD phase", aka the daydreaming phase.)</span></span><br><span class="line">      neg_visible_activations = np.dot(pos_hidden_states, self.weights.T)</span><br><span class="line">      neg_visible_probs = self._logistic(neg_visible_activations)</span><br><span class="line">      neg_visible_probs[:,<span class="number">0</span>] = <span class="number">1</span> <span class="comment"># Fix the bias unit.</span></span><br><span class="line">      neg_hidden_activations = np.dot(neg_visible_probs, self.weights)</span><br><span class="line">      neg_hidden_probs = self._logistic(neg_hidden_activations)</span><br><span class="line">      <span class="comment"># Note, again, that we're using the activation *probabilities* when computing associations, not the states</span></span><br><span class="line">      <span class="comment"># themselves.</span></span><br><span class="line">      neg_associations = np.dot(neg_visible_probs.T, neg_hidden_probs)</span><br><span class="line"></span><br><span class="line">      <span class="comment"># Update weights.</span></span><br><span class="line">      self.weights += self.learning_rate * ((pos_associations - neg_associations) / num_examples)</span><br><span class="line"></span><br><span class="line">      error = np.sum((data - neg_visible_probs) ** <span class="number">2</span>)</span><br><span class="line">      print(<span class="string">"Epoch %s: error is %s"</span> % (epoch, error))</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run_visible</span><span class="params">(self, data)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Assuming the RBM has been trained (so that weights for the network have been learned),</span></span><br><span class="line"><span class="string">    run the network on a set of visible units, to get a sample of the hidden units.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    data: A matrix where each row consists of the states of the visible units.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    hidden_states: A matrix where each row consists of the hidden units activated from the visible</span></span><br><span class="line"><span class="string">    units in the data matrix passed in.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    num_examples = data.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create a matrix, where each row is to be the hidden units (plus a bias unit)</span></span><br><span class="line">    <span class="comment"># sampled from a training example.</span></span><br><span class="line">    hidden_states = np.ones((num_examples, self.num_hidden + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Insert bias units of 1 into the first column of data.</span></span><br><span class="line">    data = np.insert(data, <span class="number">0</span>, <span class="number">1</span>, axis = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Calculate the activations of the hidden units.</span></span><br><span class="line">    hidden_activations = np.dot(data, self.weights)</span><br><span class="line">    <span class="comment"># Calculate the probabilities of turning the hidden units on.</span></span><br><span class="line">    hidden_probs = self._logistic(hidden_activations)</span><br><span class="line">    <span class="comment"># Turn the hidden units on with their specified probabilities.</span></span><br><span class="line">    hidden_states[:,:] = hidden_probs &gt; np.random.rand(num_examples, self.num_hidden + <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># Always fix the bias unit to 1.</span></span><br><span class="line">    <span class="comment"># hidden_states[:,0] = 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Ignore the bias units.</span></span><br><span class="line">    hidden_states = hidden_states[:,<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">return</span> hidden_states</span><br><span class="line"></span><br><span class="line">  <span class="comment"># <span class="doctag">TODO:</span> Remove the code duplication between this method and `run_visible`?</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run_hidden</span><span class="params">(self, data)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Assuming the RBM has been trained (so that weights for the network have been learned),</span></span><br><span class="line"><span class="string">    run the network on a set of hidden units, to get a sample of the visible units.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    data: A matrix where each row consists of the states of the hidden units.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    visible_states: A matrix where each row consists of the visible units activated from the hidden</span></span><br><span class="line"><span class="string">    units in the data matrix passed in.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    num_examples = data.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create a matrix, where each row is to be the visible units (plus a bias unit)</span></span><br><span class="line">    <span class="comment"># sampled from a training example.</span></span><br><span class="line">    visible_states = np.ones((num_examples, self.num_visible + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Insert bias units of 1 into the first column of data.</span></span><br><span class="line">    data = np.insert(data, <span class="number">0</span>, <span class="number">1</span>, axis = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Calculate the activations of the visible units.</span></span><br><span class="line">    visible_activations = np.dot(data, self.weights.T)</span><br><span class="line">    <span class="comment"># Calculate the probabilities of turning the visible units on.</span></span><br><span class="line">    visible_probs = self._logistic(visible_activations)</span><br><span class="line">    <span class="comment"># Turn the visible units on with their specified probabilities.</span></span><br><span class="line">    visible_states[:,:] = visible_probs &gt; np.random.rand(num_examples, self.num_visible + <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># Always fix the bias unit to 1.</span></span><br><span class="line">    <span class="comment"># visible_states[:,0] = 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Ignore the bias units.</span></span><br><span class="line">    visible_states = visible_states[:,<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">return</span> visible_states</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">daydream</span><span class="params">(self, num_samples)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Randomly initialize the visible units once, and start running alternating Gibbs sampling steps</span></span><br><span class="line"><span class="string">    (where each step consists of updating all the hidden units, and then updating all of the visible units),</span></span><br><span class="line"><span class="string">    taking a sample of the visible units at each step.</span></span><br><span class="line"><span class="string">    Note that we only initialize the network *once*, so these samples are correlated.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    samples: A matrix, where each row is a sample of the visible units produced while the network was</span></span><br><span class="line"><span class="string">    daydreaming.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create a matrix, where each row is to be a sample of of the visible units</span></span><br><span class="line">    <span class="comment"># (with an extra bias unit), initialized to all ones.</span></span><br><span class="line">    samples = np.ones((num_samples, self.num_visible + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Take the first sample from a uniform distribution.</span></span><br><span class="line">    samples[<span class="number">0</span>,<span class="number">1</span>:] = np.random.rand(self.num_visible)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Start the alternating Gibbs sampling.</span></span><br><span class="line">    <span class="comment"># Note that we keep the hidden units binary states, but leave the</span></span><br><span class="line">    <span class="comment"># visible units as real probabilities. See section 3 of Hinton's</span></span><br><span class="line">    <span class="comment"># "A Practical Guide to Training Restricted Boltzmann Machines"</span></span><br><span class="line">    <span class="comment"># for more on why.</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, num_samples):</span><br><span class="line">      visible = samples[i<span class="number">-1</span>,:]</span><br><span class="line"></span><br><span class="line">      <span class="comment"># Calculate the activations of the hidden units.</span></span><br><span class="line">      hidden_activations = np.dot(visible, self.weights)</span><br><span class="line">      <span class="comment"># Calculate the probabilities of turning the hidden units on.</span></span><br><span class="line">      hidden_probs = self._logistic(hidden_activations)</span><br><span class="line">      <span class="comment"># Turn the hidden units on with their specified probabilities.</span></span><br><span class="line">      hidden_states = hidden_probs &gt; np.random.rand(self.num_hidden + <span class="number">1</span>)</span><br><span class="line">      <span class="comment"># Always fix the bias unit to 1.</span></span><br><span class="line">      hidden_states[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># Recalculate the probabilities that the visible units are on.</span></span><br><span class="line">      visible_activations = np.dot(hidden_states, self.weights.T)</span><br><span class="line">      visible_probs = self._logistic(visible_activations)</span><br><span class="line">      visible_states = visible_probs &gt; np.random.rand(self.num_visible + <span class="number">1</span>)</span><br><span class="line">      samples[i,:] = visible_states</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Ignore the bias units (the first column), since they're always set to 1.</span></span><br><span class="line">    <span class="keyword">return</span> samples[:,<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">_logistic</span><span class="params">(self, x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> / (<span class="number">1</span> + np.exp(-x))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  r = RBM(num_visible = <span class="number">6</span>, num_hidden = <span class="number">2</span>)</span><br><span class="line">  training_data = np.array([[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>], [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]])</span><br><span class="line">  r.train(training_data, max_epochs = <span class="number">50</span>)</span><br><span class="line">  print(r.weights)</span><br><span class="line">  user = np.array([[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]])</span><br><span class="line">  print(r.run_visible(user))</span><br></pre></td></tr></table></figure><p><strong>参考文献</strong></p><ol style="list-style-type: decimal"><li>介绍+Python源代码：<a href="http://blog.echen.me/2011/07/18/introduction-to-restricted-boltzmann-machines/" class="uri" target="_blank" rel="noopener">http://blog.echen.me/2011/07/18/introduction-to-restricted-boltzmann-machines/</a></li><li>介绍+Python源代码：<a href="http://imonad.com/rbm/restricted-boltzmann-machine/" class="uri" target="_blank" rel="noopener">http://imonad.com/rbm/restricted-boltzmann-machine/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RBM </tag>
            
            <tag> 限制波尔茨曼机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习_递归神经网络(RNN)</title>
      <link href="/hexoblog/2017/05/10/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_%E9%80%92%E5%BD%92%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C(RNN)/"/>
      <url>/hexoblog/2017/05/10/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_%E9%80%92%E5%BD%92%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C(RNN)/</url>
      
        <content type="html"><![CDATA[<p>递归神经网络，或者循环神经网络，英文名称Recurrent Neural Networks，是一种神经元上带环的神经网络。它的结构允许保留信息，传统的神经网络做不到这一点，这也许是传统的神经网络的主要缺点之一。递归神经网络主要的应用领域是<strong>语音识别</strong>，<strong>语言建模</strong>，<strong>翻译</strong>，<strong>图像字幕</strong>…</p><a id="more"></a><p>递归神经网络的神经元模型： <img src="2017-05-10_102612.png"> 神经元上的自传递(那个环)允许信息在网络训练的不同步骤之间保留信息。其实这个模型并不复杂，因为可以把它展开成一系列普通的神经元，如下图， <img src="2017-05-10_102844.png"> 上图中每一个神经元表示一个状态，从一个状态到下一个状态时，神经元保存的信息可以传递下去。</p><p>RNN的基本考量是可以利用之前的信息加强对现在的信息的理解，例如用一个完整视频的前几帧辅助识别后面几帧出现的内容，再比如，用一个电影的前半个小时的剧情预测后面的剧情。如果RNN能够实现这些，无疑会是非常有用的。</p><p>普通的RNN只能处理时间上接近的联系，比如用前一帧的信息预测后一帧，后两帧，但是无法处理时间上很长的联系，例如用一个小时之前的一帧预测现在的一帧。这是因为梯度随着层数的加深会很快消失，类似神经网络中遇到的那样。</p><p>有一种特殊结构的RNN网络可以克服上面的问题，使得长时间的联系可以实现，该网络的名字叫做LSTM(Long Short Term Memory networks)。</p><h2 id="lstm">LSTM</h2><p>Long Short Term Memory networks, 是一种特殊的RNN，</p><p>普通的RNN在神经元自己的环上从一个步骤到下一个步骤的时候，都会经过一个简单函数的处理，类似<span class="math inline">\(x2 = tanh(x1)\)</span>; <img src="2017-05-10_104948.png"> 而LSTM与之不同的是有一个更为复杂的处理，这是这个处理保证了它可以保留长期的信息。 <img src="2017-05-10_105051.png"> <img src="2017-05-10_105226.png"> 下面我们详细介绍这个复杂的处理过程。 <img src="QQ截图20170510112351.png"> 最上面的水平线保持了原来的数据的不变性（只经过了简单的线性变换），这个叫做cell state.</p><p><img src="2017-05-10_112918.png"> 这样的图标表示一个simoid神经元，输出范围是[0,1]. <img src="2017-05-10_113009.png"> <img src="2017-05-10_113224.png"> <img src="2017-05-10_113026.png"> <img src="2017-05-10_113334.png"> 上面的图展示了每一步的计算过程，其中*表示的是向量的乘法。</p><p>除了这种标准的结构，还有许多其他的变种，适用于不同的情况。</p><p><strong>参考文献</strong>：</p><p>http://colah.github.io/posts/2015-08-Understanding-LSTMs/</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RNN </tag>
            
            <tag> 递归神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法专题_素数问题</title>
      <link href="/hexoblog/2017/05/09/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E7%B4%A0%E6%95%B0%E9%97%AE%E9%A2%98/"/>
      <url>/hexoblog/2017/05/09/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E7%B4%A0%E6%95%B0%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>只有两个因子的数叫做素数，也叫质数。例如2，3，5，7，11….素数经常用在密码学中，所以涉及素数的运算也是会经常遇到的。</p><a id="more"></a><h2 id="素性测试">素性测试</h2><h3 id="测试一个数是否是素数">测试一个数是否是素数</h3><p>判断一个数是否是素数，我们就要找到它所有的因子，看是不是只有1和它本身。具体思路是从2开始，一直到$ n$, 如果都不能整除n，那么n就是素数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(n);i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="找出n以内的所有素数">找出n以内的所有素数</h3><p>如果是找出很多素数，如果从1开始一个一个做素性测试，那么开销就太高了，也没有必要，因为大多数都不是素数。 我们直到2是素数，那么所有2的倍数，4，6，8就都不是素数，因为其至少含有一个因子2. 同理，3的所有倍数也不是素数。 同理，5的所有倍数也不是素数。 这样考虑，每当我们确定一个素数的时候，就可以确定一大批数不是素数，这些肯定不是素数的数就不用再做素性测试了。 以这样的思路求n以内的素数的方法叫做<strong>埃氏筛法</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n 以内的素数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;prime)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// is_prime[0] 表示数字0 是不是素数</span></span><br><span class="line">    <span class="comment">// is_print[1] 表示数字1是不是素数</span></span><br><span class="line">    <span class="comment">// is_print[n] 表示数字n是不是素数</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; is_prime(n+<span class="number">1</span>,<span class="literal">true</span>);</span><br><span class="line">    is_prime[<span class="number">0</span>] = <span class="literal">false</span>;  <span class="comment">//0 不是素数，</span></span><br><span class="line">    is_prime[<span class="number">1</span>] = <span class="literal">false</span>; <span class="comment">//1 不是素数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">// 初始的时候，2是素数，is_prime[1]对应2</span></span><br><span class="line">        <span class="keyword">if</span>(is_prime[i])&#123;</span><br><span class="line">            prime.push_back(i);</span><br><span class="line">            p++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i*<span class="number">2</span>;j&lt;=n;j += i)&#123;</span><br><span class="line">                is_prime[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="找出区间ab内的所有素数">找出区间[a,b)内的所有素数</h3><p>直接利用上面的结论，可以找出b以内的所有素数，然后只取大于a的部分就可以了。 除此之外，我们还可以利用上面算法的思想，在区间[a,b)内使用埃氏筛法。 我们准备两个区间[2,<span class="math inline">\(\sqrt b\)</span>) 和 [a,b), 然后在区间[2,<span class="math inline">\(\sqrt b\)</span>)用埃氏筛法选择素数，同时在[a,b)删除相应的倍数，最后得到的就是[a,b)区间内的素数。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">segment_sieve</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;prime)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; is_prime;</span><br><span class="line">    <span class="comment">//is_prime 指示0...sqrt(b)内是否是素数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i*i &lt; b;i++)&#123;</span><br><span class="line">        is_prime.push_back(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// //is_prime_ab 指示[a,b])内是否是素数</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; is_prime_ab(b-a,<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;b;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(is_prime[i])&#123;</span><br><span class="line">            p++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>*i;j*j&lt;b;j += i)&#123;</span><br><span class="line">                is_prime[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=max(<span class="number">2</span>,(a+i<span class="number">-1</span>)/i)*i;j&lt;b;j += i)&#123;</span><br><span class="line">                is_prime_ab[j-a] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 素数 </tag>
            
            <tag> 质数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法专题_模运算</title>
      <link href="/hexoblog/2017/05/08/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E6%A8%A1%E8%BF%90%E7%AE%97/"/>
      <url>/hexoblog/2017/05/08/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E6%A8%A1%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>模运算是指对一个数求余数的过程。涉及到比较大的数字时，通常会涉及到取模运算。了解一些模运算的性质是有好处的。我们把a 和 b 除以 m 之后所得到的余数相等记作$ a b(mod m)$.</p><a id="more"></a><h2 id="基本的模运算定律">基本的模运算定律</h2><p>如果$ a b(mod m)$ 且 $ c d(mod m)$, 那么有 - $ {a+b}  $ - $ {a-b}  $ - $ {a b}  $</p><p>$ a b(mod m)$ 说明 <span class="math inline">\(a = km + b\)</span>, 另外：</p><ul><li><span class="math inline">\((a+b) \% c = (a\%c+b\%c)\%c\)</span></li><li><span class="math inline">\((a-b) \% c = (a\%c-b\%c)\%c\)</span></li><li><span class="math inline">\((a \times b) \% c = (a\%c \times b\%c)\%c\)</span></li><li><span class="math inline">\(a^b\space\%c = (a\%c)^b \space \% c\)</span></li></ul><p>最后一条规则在求大数的幂的模的时候非常有用。例如：</p><p><span class="math display">\[62^{65} \% 133    = 62 \times 62^{64} \% 133  = 62 \times (62^2)^{32} \% 133  = 62 \times 3844^{32} \% 133  = 62 \times (3844 \% 133)^{32} \% 133  = 62 \times 120^{32} \% 133  = 62 \times 36^{16} \% 133  = 62 \times 99^8 \% 133  = 62 \times 92^4 \% 133  = 62 \times 85^2 \% 133  = 62 \times 43 \% 133  = 2666 \% 133  = 6\]</span></p><h2 id="逆元">逆元</h2><p>考虑如何求解$ ax b(mod m)<span class="math inline">\(.中的\)</span>x<span class="math inline">\(,如果是等式，\)</span>ax=b<span class="math inline">\(,那么求解\)</span>x<span class="math inline">\(,非常容易，\)</span>x = a^{-1}*b<span class="math inline">\(,如果a是实数，那么\)</span>a^{-1} = 1 a$. 所以，求解x的关键是求出在取模运算意义下的a的倒数，这里称作<strong>逆元</strong>。</p><p>假设a的逆元是x，那么有<span class="math inline">\(ax \equiv 1(mod \space m)\)</span>, 就是<span class="math inline">\(ax=km+1\)</span>,转换一下就是求使得<span class="math inline">\(ax-km=1\)</span>成立的<span class="math inline">\(x\)</span>,其中a，m是一个已知数，k是正整数。 我们先来看一个更一般的问题的解法。a,b,x,y,都是整数，a,b,已知，求<span class="math inline">\(ax+by=1\)</span>成立的x,y.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">extgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d = a;</span><br><span class="line">    <span class="keyword">if</span>( b != <span class="number">0</span>)&#123;</span><br><span class="line">        d = extgcd(b,a%b,y,x);</span><br><span class="line">        y = y - (a/b)*x;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        x =<span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">4</span>,b=<span class="number">11</span>;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;extgcd(a,b,x,y)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样利用辗转相除法的扩展，可以解析的求解出x和y,比先确定一个数字再去求解另外一个数字要好。</p><p>下面来看求解逆元的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mod_inverse</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    extgcd(a,m,x,y);</span><br><span class="line">    <span class="keyword">return</span> (m+x%m)%m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;mod_inverse(<span class="number">3</span>,<span class="number">20</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面，我们直接求解得出了<span class="math inline">\(3(mod \space 20)\)</span>的逆元， 是7.</p><p>以上是利用扩展的辗转相除法求解逆元的过程。</p><p>求逆元还有其他的方法。</p><p><strong>费马小定理</strong></p><p>如果<span class="math inline">\(p\)</span>是素数，那么对于任意的整数<span class="math inline">\(x\)</span>,都有<span class="math inline">\(x^p \equiv x(mod \space p)\)</span>, 随便举几个例子，<span class="math inline">\(2^3 (mod\space3) \equiv 2\)</span>,<span class="math inline">\(8^5 (mod\space5) \equiv 8\)</span></p><p>如果x无法被p整除，还有一个规律成立，<span class="math inline">\(x^{p-1} \equiv 1(mod\space p)\)</span>,利用这条性质，也可以求一个数的逆元。等式两边都乘以<span class="math inline">\(x^{-1}\)</span>,得到<span class="math inline">\(x^{-1} = x^{p-2}(mod \space p)\)</span>, 所以在p是素数的时候（很多情况下都是如此），一个数的逆元，就等于这个数的p-2次方(mod p), 所以，使用快速幂运算就能求出逆元。</p><p>在p不是素数的时候，其实也有类似的定理可以使用，这里我们不做讨论了。因为程序设计题一般情况下给出的都会是素数。</p><h2 id="a的b次方模m">a的b次方模m</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Montgomery</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b,<span class="keyword">long</span> <span class="keyword">long</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> r=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    a %=m;</span><br><span class="line">    <span class="keyword">while</span>(b&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((b&amp;<span class="number">1</span>)!=<span class="number">0</span>)</span><br><span class="line">            r = (r*a)%m;</span><br><span class="line">        a = (a*a)%m;</span><br><span class="line">        b/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (r*a)%m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="nmod-p-和排列组合数模p">n!(mod p) 和排列组合数模P</h2><p>先来看一个具体的例子，求10！mod 4;</p><p>10! = 10x9x8x7x6x5x4x3x2x1 mod 4 = 2 x 1 x (2x4) x 3 x 2 x 1 x (1x4) x 3 x 2 x 1 mod p = 2x1x(3x2x1)x2 x (2x4)x(1x4) = 2x6x2 x (2x4)x(1x4) = 6x4x2x4x1x4 = 0</p><p>通过上面的计算过程我们可以发现，其实n!里面的所有数可以分成两个部分，一部分是能够被p整除的，这类要单独拿出来，另外一类是不能被p整除的，这类mod p之后就会呈现出周期性，最终形成<span class="math inline">\(a^b\)</span>这种形式。</p><p>下面具体看一下n! mod p的代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mod_fact</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> p,<span class="keyword">int</span> &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//e 的含义是n!能够迭代整除p的次数。</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fact(p,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nfact(p,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//计算i的阶乘</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;p;i++)&#123;</span><br><span class="line">        nfact[i] *= nfact[i<span class="number">-1</span>]*i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;p;i++)&#123;</span><br><span class="line">        fact[i] = nfact[i] % p;</span><br><span class="line">    &#125;</span><br><span class="line">    e = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = mod_fact(n/p,p,e);</span><br><span class="line">    e += n/p;</span><br><span class="line">    <span class="keyword">if</span>(n/p % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res*(p-fact[n%p])%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res*(fact[n%p])%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;mod_fact(<span class="number">5</span>,<span class="number">7</span>,e)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;e&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知道了如何计算阶乘的模，计算排列和组合结果的模也就不成问题了。 求<span class="math inline">\(C^k_n = \dfrac{n!}{k!(n-k)!} (mod\space p)\)</span></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mod_comb</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span> || k&lt;<span class="number">0</span>|| n&lt;k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> e1,e2,e3;</span><br><span class="line">    <span class="keyword">int</span> a1 = mod_fact(n,p,e1);</span><br><span class="line">    <span class="keyword">int</span> a2 = mod_fact(k,p,e2);</span><br><span class="line">    <span class="keyword">int</span> a3 = mod_fact(n-k,p,e3);</span><br><span class="line">    <span class="keyword">if</span>(e1 &gt; e2+e3) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a1* mod_inverse(a2*a3%p,p)%p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mod </tag>
            
            <tag> 模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kickstart Round B 2017</title>
      <link href="/hexoblog/2017/05/07/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/Kickstart-Round-B-2017/"/>
      <url>/hexoblog/2017/05/07/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/Kickstart-Round-B-2017/</url>
      
        <content type="html"><![CDATA[<p>谷歌codejam:https://codejam.withgoogle.com/codejam/contest/11304486/dashboard.</p><a id="more"></a><h2 id="problem-a">problem A</h2><p><img src="2017-05-07_162055.png"> 小规模测试文件：https://drive.google.com/open?id=0B2aHWGYn_JL-WFhaWVMxaXpxWVk 大规模测试文件：https://drive.google.com/open?id=0B2aHWGYn_JL-X1BoUlUzZFptQzQ</p><p>因为给出的序列是有序的，我们用i表示开始的元素，用j表示结束的元素，比如对于例子[3,6,7,9]来说，i=0,j=2表示以3开始，以7结束的属于[3,6,7,9]的子集的数量，所有这样的子集都有相同的差值7-3=4,所以差值乘以数量就是结果。</p><p>现在问题的关键就是以i开头的，j结尾的子集的数量的确定。 先来 看[3,6]，只有[3,6], 1个 看[3,7]，有[3,7],[3,6,7]; 2个 看[3,9], 有[3,9],[3,6,9],[3,7,9],[3,6,7,9]； 4个 看[6,7],有[6,7]; 1个 看[6,9],有[6,7],[6,7,9]; 2个。</p><p>我们发现，子集的数量只与i和j的距离有关系。此关系是<span class="math inline">\(2^{j-i-1}\)</span></p><p>利用这个规律，我们可以简单的编写一下程序计算结果：假设一个实例数据存储在v[]中。num是v的长度。sum=0; <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;num;j++)&#123;</span><br><span class="line">        sum = (sum + ( (v[i]-v[j]) * <span class="number">2</span>^[j-i<span class="number">-1</span>] ) % mod ) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><p>仔细观察上面的代码，我们发现每次都要计算<span class="math inline">\(2^i\)</span>,这是一个耗时的操作，尤其是当i很大的时候。我们可以事先计算出所有需要的值存储在一个数组中，这样只需要计算一次就可以了。那么我们需要计算到2的多少次方呢？我们查看最大的那组的数据规模，发现N最大是10000，所以只要稍微大于10000就可以了。这里设置maxn = 10005;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10005</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> p[maxn];</span><br><span class="line">p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;maxn; i++)&#123;</span><br><span class="line">    p[i]=p[i<span class="number">-1</span>]*<span class="number">2</span> % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对比一下优化前后的运行时间： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">two_n</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ret = (ret * <span class="number">2</span> ) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> p[maxn];</span><br><span class="line">    <span class="keyword">auto</span> start_time = clock();</span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;maxn; i++)&#123;</span><br><span class="line">        p[i]=p[i<span class="number">-1</span>]*<span class="number">2</span> % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> end_time = clock();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;end_time - start_time &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> q[maxn];</span><br><span class="line">    <span class="keyword">auto</span> s = clock();</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> two = <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxn;i++)&#123;</span><br><span class="line">        q[i] = two_n(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> e = clock();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; e - s &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><p>在maxn=10005的情况下，输出是0，363. 单位是毫秒。 可以看到，这个差距还是相当大的，maxn越大，越明显。</p><p>这样的时间复杂度其实已经可以解决这个问题了。 完整的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10005</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>  p[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num ;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;num;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(num,<span class="number">0</span>);</span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;maxn; i++)&#123;</span><br><span class="line">        p[i]=p[i<span class="number">-1</span>]*<span class="number">2</span> % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=num<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完成读取数据</span></span><br><span class="line">    <span class="comment">//遍历组合</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;num;j++)&#123;</span><br><span class="line">            sum = (sum + ( (v[i]-v[j]) * p[j-i<span class="number">-1</span>] ) % mod ) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"d:/A-large-practice.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"d:/A-large-practice.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> T,cas=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span> (T--)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;++cas&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">        run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还有另外一个版本的代码，貌似效率更高一些，但是还不是很明白原理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f(x, y, z) for(int x = (y); x &lt;= (z); ++x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> g(x, y, z) for(int x = (y); x &lt; (z); ++x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> h(x, y, z) for(int x = (y); x &gt;= (z); --x)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pow2[<span class="number">10007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pow2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">f(i, <span class="number">1</span>, <span class="number">10003</span>) pow2[i] = pow2[i - <span class="number">1</span>] * <span class="number">2</span> % MOD;</span><br><span class="line"><span class="keyword">int</span> T; <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">f(_, <span class="number">1</span>, T)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> n, ans = <span class="number">0</span>; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">f(i, <span class="number">1</span>, n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x; <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">ans = ((ll) pow2[i - <span class="number">1</span>] * x + ans) % MOD;</span><br><span class="line">ans = (((ll) -pow2[n - i] * x + ans) % MOD + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case #%d: %d\n"</span>, _, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="problem-b">problem B</h2><div class="figure"><img src="2017-05-08_150406.png"></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MODULO = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">double</span> x[MAXN], y[MAXN], w[MAXN];</span><br><span class="line"><span class="keyword">double</span> a[MAXN];</span><br><span class="line"><span class="keyword">int</span> Order[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x, <span class="keyword">const</span> <span class="keyword">int</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[x] &lt; a[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">GetMin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> leftw = <span class="number">0</span>, rightw = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        cur += (a[Order[i]] - a[Order[<span class="number">0</span>]]) * w[Order[i]];</span><br><span class="line">        rightw += w[Order[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> ans = cur;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        leftw += w[Order[i - <span class="number">1</span>]];</span><br><span class="line">        rightw -= w[Order[i - <span class="number">1</span>]];</span><br><span class="line">        cur += leftw * (a[Order[i]] - a[Order[i - <span class="number">1</span>]]);</span><br><span class="line">        cur -= rightw * (a[Order[i]] - a[Order[i - <span class="number">1</span>]]);</span><br><span class="line">        <span class="keyword">if</span> (cur &lt; ans)</span><br><span class="line">            ans = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf"</span>, &amp;x[i], &amp;y[i], &amp;w[i]);</span><br><span class="line">        Order[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> Ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">        a[i] = (x[i] + y[i]) * <span class="number">0.5</span>;</span><br><span class="line">    sort(Order, Order + N, Cmp);</span><br><span class="line">    Ans += GetMin();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">        a[i] = (x[i] - y[i]) * <span class="number">0.5</span>;</span><br><span class="line">    sort(Order, Order + N, Cmp);</span><br><span class="line">    Ans += GetMin();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.8lf\n"</span>, Ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"d:/B-small_test.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="comment">//freopen("d:/B-large.out", "w", stdout);</span></span><br><span class="line">    <span class="keyword">int</span> Cases;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Cases);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> Case = <span class="number">1</span>; Case &lt;= Cases; Case ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: "</span>, Case);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Case #%d: \n"</span>, Case);</span><br><span class="line">        Work();</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法专题_霍夫曼编码(哈夫曼编码)</title>
      <link href="/hexoblog/2017/05/06/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/"/>
      <url>/hexoblog/2017/05/06/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>霍夫曼编码是一种无损编码方法，它是无损编码方案中最优的，基本思想是给出现频率高的字符以较短的编码，给出现频率低的字符以长的编码。本文将介绍霍夫曼编码的算法步骤和具体实现。</p><a id="more"></a><h2 id="二叉霍夫曼编码">二叉霍夫曼编码</h2><p><strong>前缀码</strong>： 没有任何一个编码是其他编码的前缀，这样的一套编码体系叫做前缀码。例如a的编码是010，那么不会存在编码是0，01，0101，0100，010**的字符。前缀码确保了解码时的唯一性。</p><p>霍夫曼编码的算法步骤： 1. 统计每个字符出现的频率，按照频率从大到小排序。 2. 找到出现频率最小的两个字符，把这两个字符作为左右孩子，添加一个节点作为它们共同的父亲节点，父亲节点的值是这两个字符频率的和。 3. 重复步骤2直到总概率为1为之。 4. 以上步骤构造了一颗二叉树，二叉树根的概率是1.从根开始，递归的标记每个节点，左孩子标记为0，右孩子标记为1，直到到达叶节点。 5. 从跟出发到每个叶节点经过的0–1路径就是该字符的编码。</p><p>下面看一个具体的例子： 假设一个文件中只包含a,b,c,d,e,f六种字符，它们的出现频率如下表所示：</p><table><thead><tr class="header"><th></th><th>a</th><th>b</th><th>c</th><th>d</th><th>e</th><th>f</th></tr></thead><tbody><tr class="odd"><td>出现次数</td><td>45</td><td>13</td><td>12</td><td>16</td><td>9</td><td>5</td></tr><tr class="even"><td>出现频率</td><td>0.45</td><td>0.13</td><td>0.12</td><td>0.16</td><td>0.09</td><td>0.05</td></tr></tbody></table><p>第一步，找到频率最小的两个，应该是e,f,我们把e和f的根记作ef，这个时候构造了一个二叉树，二叉树的根是ef,频率是(9+5)/100 = 0.14. <img src="2017-05-06_230648.png"> 第二步，用ef代替e和f之后，继续寻找最小的两个节点，这个时候是b,c,我们把b和c的根记作bc,这个bc的频率是(12+13)/100 = 0.25. <img src="2017-05-06_230917.png"> 第三步，继续寻找频率最低的节点，这个时候是d和ef. 我们把d和ef的根记作def,它的频率是(16+14)/100 = 0.3. <img src="2017-05-06_231330.png"> 第四步，继续寻找频率最小的两个值合并，这个时候是bc和def,我们记作bcdef,它的频率是0.55. <img src="2017-05-06_231549.png"> 第五步，继续寻找频率最小的两个值合并，这个时候只剩下两个值了，就是a和bcde,它们和的频率是1. <img src="2017-05-06_231913.png"> 可以看到，我们最终形成了一颗二叉树，调整一下位置，使之更好看一些。编号之后的情况是这个样子： <img src="2017-05-06_232520.png"> 从中可以得到每个字符的编码：</p><table><thead><tr class="header"><th>a</th><th>b</th><th>c</th><th>d</th><th>e</th><th>f</th></tr></thead><tbody><tr class="odd"><td>00</td><td>0100</td><td>0101</td><td>0111</td><td>01100</td><td>01101</td></tr></tbody></table><p>这就是整个霍夫曼编码过程。除了使用二进制编码，其实还可以使用多种不同的进制编码，只要扩展分支的数目就可以了。</p><h2 id="n叉霍夫曼编码">N叉霍夫曼编码</h2><p>举例来说，还是上面的例子，如果编码的数字允许使用0，1，2三个数字。那么霍夫曼编码的步骤变为：</p><ol style="list-style-type: decimal"><li>设字符数量为K，则第一次选择num = <code>K-2*[(K-1)/2]</code>,[]代表下取整的意思。这里K=6，所以第一次寻找2个频率最低的字符，e,f.如果num=0,取2，如果num=1,取3.</li><li>把找出来的字符的概率合并作为新的一项加入到队列中，原来的删掉，继续用1中的方法寻找直到最后剩下三个为止。</li></ol><p>具体到这个问题，具体的过程为： <img src="2017-05-06_235322.png"> <img src="2017-05-06_235547.png"> <img src="2017-05-06_235729.png"> <img src="2017-05-07_000144.png"> 这个时候，得到的最优编码是：</p><table><thead><tr class="header"><th align="right">a</th><th align="right">d</th><th align="right">c</th><th align="right">b</th><th align="right">e</th><th align="right">f</th></tr></thead><tbody><tr class="odd"><td align="right">0</td><td align="right">2</td><td align="right">10</td><td align="right">12</td><td align="right">110</td><td align="right">111</td></tr></tbody></table><p>于此，我们可以很容易的推广到N叉霍夫曼编码，思想是一样的，都是贪心法和前缀码。</p><h2 id="二叉哈夫曼编码的实现">二叉哈夫曼编码的实现</h2><p>下面给出二叉霍夫曼编码的C++实现的版本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> label; <span class="comment">// 节点的编码， 0 或者 1</span></span><br><span class="line">    <span class="keyword">char</span> c; <span class="comment">// 节点表示的字符</span></span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">    Node() : label(<span class="number">-1</span>),left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    Node(<span class="keyword">char</span> cc) : label(<span class="number">-1</span>), c(cc),left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    Node(<span class="keyword">int</span> la) : label(la),left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出字符的编码</span></span><br><span class="line"><span class="comment"> * @param root </span></span><br><span class="line"><span class="comment"> * @param s </span></span><br><span class="line"><span class="comment"> * @param re </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node* root,<span class="built_in">string</span> &amp;s,<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt; &amp;re)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;</span><br><span class="line">        re[root-&gt;c] = s + to_string(root-&gt;label);</span><br><span class="line">        s.clear();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        s += to_string( root-&gt;label );</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) dfs(root-&gt;left,s1,re);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) dfs(root-&gt;right,s2,re);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈夫曼编码</span></span><br><span class="line"><span class="comment"> * @param source 每个字符出现的频率</span></span><br><span class="line"><span class="comment"> * @return  每个字符对应的二进制编码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt; huff(<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">double</span>&gt; &amp;source)&#123;</span><br><span class="line">    <span class="comment">// 1. 初始化数据结构</span></span><br><span class="line">    <span class="built_in">multimap</span>&lt;<span class="keyword">double</span>,Node*&gt; tree;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter : source)&#123;</span><br><span class="line">        Node *newNode = <span class="keyword">new</span> Node(iter.first);</span><br><span class="line">        tree.insert(make_pair(iter.second,newNode));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 构建哈夫曼树</span></span><br><span class="line">    Node* newNode;</span><br><span class="line">    <span class="keyword">while</span>( tree.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">auto</span> ff = tree.begin();</span><br><span class="line">        <span class="keyword">auto</span> ss = ++(tree.begin());</span><br><span class="line">        newNode = <span class="keyword">new</span> Node();</span><br><span class="line">        newNode-&gt;left = ff-&gt;second;</span><br><span class="line">        ff-&gt;second-&gt;label = <span class="number">0</span>; <span class="comment">// 左子树编码为0</span></span><br><span class="line">        newNode-&gt;right = ss-&gt;second;</span><br><span class="line">        ss-&gt;second-&gt;label = <span class="number">1</span>; <span class="comment">// 右子树编码为1</span></span><br><span class="line">        tree.insert(make_pair(ff-&gt;first+ss-&gt;first,newNode));</span><br><span class="line">        tree.erase(ff);</span><br><span class="line">        tree.erase(ss);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;label = <span class="number">0</span>; <span class="comment">// 根节点编码为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 输出每个叶子节点的编码</span></span><br><span class="line">    Node* root = newNode;</span><br><span class="line">    <span class="built_in">string</span> tmp = <span class="string">""</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt; re;</span><br><span class="line">    dfs(root,tmp,re);</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 霍夫曼编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法专题_最小生成树</title>
      <link href="/hexoblog/2017/05/06/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/hexoblog/2017/05/06/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><strong>生成树</strong>，是指图的一个最小连通的子图，该子图少一条边，就会不连通，多一条边，就会有环。</p><p><strong>最小生成树</strong>，是指边有权值的情况下，找到权值的总和最小的那个连通子图。</p><a id="more"></a><p><img src="2017-05-06_205228.png"> 如图，边上的数值如果代表距离的话，求最小生成树，就是求一个用最短的距离把所有点连接起来的方案。 我们通过仔细观察实验可以得出，最小的生成树是这样的。 <img src="2017-05-06_205542.png"></p><p>上面是一个最小生成树的实例，那么我们依照怎样的规则得出来的最小生成树呢，总不能靠看吧？</p><p>其实，这个问题用贪心法就可以解决。</p><h2 id="kruskal算法">Kruskal算法</h2><p>对于给定的无向有权图$ G=(V,E)<span class="math inline">\(，Kruskal算法描述如下： &gt; 1. 构造空集合A，并将图G中所有点加入集合A，此时A为有|V|棵树的森林。 &gt; 2. 将图\)</span>G<span class="math inline">\(中所有边按照权重进行排序，形成有序集合\)</span>B$。 &gt; 3. 对于步骤2中排序后集合B中权重最小的边（u，v），尝试将（u，v）以及点u、v加入到集合A中。 &gt; 4. 如果步骤3中尝试加入的点和边，对于图A而言，不形成回路，则添加点u、v及边（u，v），否则不添加。 &gt; 5. 将步骤3处理的边（u，v）从集合B中删除。 &gt; 6. 判断此时作为图的集合A，是否满足边的数量等于|V|-1（也即满足最小生成树的要求），如果是，则找到最小生成树，如果不是，则转至步骤3。</p><p>上面给出的例子，如果按照Kruskal算法，过程是下面这个样子的。 初始化的时候，A集合包含所有的顶点，B集合包含按照权值从小到达排序好的边。 <img src="2017-05-06_213033.png"> 第一次，添加1–&gt;2, 得到 <img src="2017-05-06_213448.png"> 第二次，添加1–&gt;3,得到 <img src="2017-05-06_213627.png"> 第三次，添加4–&gt;6，得到 <img src="2017-05-06_213729.png"> 第四次，添加5–&gt;6,得到 <img src="2017-05-06_213957.png"> 第五次，应该添加2–&gt;3,但是如果添加了2–&gt;3就形成的回路，所以该次不添加，从集合B中删除2–&gt;3,继续看下一个。 <img src="2017-05-06_214218.png"> 第六次，应该添加4–&gt;5,但是如果添加了，就形成了回路，所以也应该跳过。 <img src="2017-05-06_214327.png"> 第七次，应该添加3–&gt;4,得到 <img src="2017-05-06_214435.png"> 此时，所有的点都已经连通，所以算法结束。最小生成树找出来了。</p><p>分析整个过程，判断连通与否 和 判断算法是否结束 是每一步操作都要检查的，所以必须要有高效的方法。 判断算法是否结束可以用A的边的数目是否达到了顶点的数目-1， 判断联通性就要用到<strong>并查集</strong>了。并查集是一种多个树组成的数据结构，可以方便的查出同组不同组的问题。</p><p>使用并查集实现的Kruskal算法如下： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="prime算法">prime算法</h2><p>对于图G=（V，E），Prim算法描述如下： &gt; 1. 给定空集合A，以及任何一点v0属于{V}，将v0加入集合A中，此时A={v0}。 &gt; 2. 对于集合A中的任意一点u，以及V-A中任意一点w，找到权重最小的边（u，w），常识将（u，w）加入集合A。 &gt; 3. 判断步骤2中的边（u，w）是否使图A形成回路，如果形成回路，则不加入A，否则将点w和边（u，w）加入A。 &gt; 4. 判断此时图G中所有点{V}是否已经全部加入到集合A中，如果是，则最小生成树已经找到，退出；否则，转步骤2。</p><p>上面的例子用prime算法来做的过程是： 初始化的时候，A是空的，V包含了所有的点。 <img src="2017-05-06_215824.png"> 第一步，从V中任意找一个点加入集合A中； <img src="2017-05-06_215906.png"> 第二步，找到4和其余的顶点之间权重最小的边，是4–6, <img src="2017-05-06_220107.png"> 第三步，找到4，6和其余的顶点之间权重最小的边，5–6， <img src="2017-05-06_220243.png"> 第四步，找到4，5，6和其余的顶点之间权重最小的边，4–3 <img src="2017-05-06_220357.png"> 第五步，找到3，4，5，6和其余的顶点之间权重最小的边，1–3 <img src="2017-05-06_221817.png"> 第六步，找到1，3，4，5，6和2之间权重最小的边，1–2， <img src="2017-05-06_222318.png"> 此时，所有的顶点都加入了集合A，算法结束。 可以看到，结果和上面的Kruskal算法算法是一致的。一个是从边来考虑，一个是从顶点来考虑，二者实际上都是贪心法的思路。</p><p>prime算法的核心是找到两个集合之间权重最小的边，这个可以用堆实现。 prime算法的一种实现： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法专题_图之最短路径</title>
      <link href="/hexoblog/2017/05/06/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E5%9B%BE%E4%B9%8B%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
      <url>/hexoblog/2017/05/06/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E5%9B%BE%E4%B9%8B%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<p>最短路径问题是图论中的一种重要的问题。关于这个问题的详细描述，可以参考一本书《迷茫的旅行商》，书中介绍了各式各样的路径规划问题，还有各种可能的解法，和整个问题的发展历史。看完能对该问题有一个很好的理解，也能够明白，计算机算法是如何在尚不直到该问题的解决方法的时候，一步一步扩展解题的规模，从而使得现在大部分的问题都可以在能够接受的时间复杂度内解决。这里，我们只介绍几个简单的求最短路径的算法，是在算法题目中经常出现的。</p><a id="more"></a><h2 id="多源最短路径问题">多源最短路径问题</h2><p>在一个图中，找到任意两个点之间的最短路径问题，叫做多源最短路径。 如下图，1，2，3，4表示4个城市，线上的数字表示该路程的距离，求任意两个城市的最短路径是多少。 <img src="2017-05-07_190826.png"></p><p>先来考虑如何才能确定两点之间的最短路径。比如求从城市1到城市3的最短路径，我们可以使用深度优先搜索或者广度优先搜索的方式，从节点1出发，搜索到节点3未知，然后记录所有路径中的最小值，就是1到3的最短路径。</p><h3 id="floyd-warshall-算法">floyd-Warshall 算法</h3><p>使用宽度优先或者深度优先的方式求两个顶点之间的最短路径还可以，时间复杂度上可以接受，但是求多源最短路问题就显得太复杂了。那么有没有更好的方法呢？ 设想一下，从a到b的路程是l,如何缩短这个路程呢？只能试试能不能找到其他的路从a到b，看其他的所有路程中有没有比当前这条路短的。 这就是floyd-Warshall算法的思想。</p><p>我们把上面的图存储成下面这种形式：称为e. <img src="2017-05-07_191839.png"> floyd-Warshall 算法可以表述为： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(e[i][j]&gt;e[i][k]+e[k][j])&#123;</span><br><span class="line">         e[i][j] = e[i][k]+e[k][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体到这个例子，我们看一下这个算法是如何工作的。 开始的时候，k=1,i=1,j=1,2,3,4; 循环里面比较的是： e[1][1] &gt; e[1][1] + e[1][1] e[1][2] &gt; e[1][1] + e[1][2] e[1][3] &gt; e[1][1] + e[1][3] e[1][4] &gt; e[1][1] + e[1][4] 然后，k=1,i=2,j=1,2,3,4; 循环里面比较的是： e[2][1] &gt; e[2][1] + e[1][1] e[2][2] &gt; e[2][1] + e[1][2] e[2][3] &gt; e[2][1] + e[1][3] e[2][4] &gt; e[2][1] + e[1][4] 然后，k=1,i=3,j=1,2,3,4;循环里面的比较是： e[3][1] &gt; e[3][1] + e[1][1] e[3][2] &gt; e[3][1] + e[1][2] e[3][3] &gt; e[3][1] + e[1][3] e[3][4] &gt; e[3][1] + e[1][4] 然后，k=1,i=4,j=1,2,3,4;循环里面的比较是： e[4][1] &gt; e[4][1] + e[1][1] e[4][2] &gt; e[4][1] + e[1][2] e[4][3] &gt; e[4][1] + e[1][3] e[4][4] &gt; e[4][1] + e[1][4]</p><p>可以看到，当k=1的时候，遍历了每个节点到每个节点的连接，把通过节点1中转的情况全部尝试了一遍，看有没有任何两个节点之间通过节点1中转之后路程会变短。如果会，就把路程更新成这个更短的路程。 K=1执行完之后矩阵的更新情况： <img src="2017-05-07_195431.png"> K=2的时候就好理解了。就是尝试经过节点2进行中转。 因为已经是经过节点1中转过后的数据了。所以相当于原始数据经过节点1和节点2中转之后获得的最短的距离。 K=2执行完之后矩阵的更新情况： <img src="2017-05-07_195547.png"> k=3的时候同样的道理，经过节点3中转，k=4的时候经过节点4中转。这样最后获得的更新之后的矩阵e就存储了任意两个节点之间的最短路径。 K=3执行完之后矩阵的更新情况： <img src="2017-05-07_195632.png"> K=4执行完之后矩阵的更新情况： <img src="2017-05-07_195750.png"></p><p>这就是floyd-Warshall 算法，其实非常简单，就是逐个尝试使用节点中转是否可以较少距离，然后更新距离。</p><h2 id="单源最短路径问题">单源最短路径问题</h2><p>上面求的是任意两个点的最短距离，如果求某一个点到其余各个点的最短距离，还有效率更高的方法。 求一个特定的点到其他点的最短路径，就是单源最短路问题。</p><h3 id="dijkstr-算法">Dijkstr 算法</h3><p>算法的基本思想： 每次找到离源点最近的一个点，以这个点为顶点进行扩展，最终得到源点到其余各点的最短路径。具体的步骤是： 1. 初始化：将所有的顶点分为两部分，已知最短路径的顶点集合P和未知最短路径的顶点集合Q。开始的时候，P中只有源点，因为开始的时候只能直到源点到源点的距离最近，是0. 其余所有的点属于集合Q。 2. 设置源点到自己的距离为0.设置源点能够直接到达（不经过别的节点）的顶点的距离为e源点到该点的距离。把所有源点不能直接到达的节点的值设置为无穷大。 3. 在集合Q中选择一个离源点距离最近的点加入到P，同时从Q中删除该节点，假设这个节点是u,考察u能到达的所有节点，看是否从源点通过u到达这些节点比原来的距离近，如果近，就更新这个值。 4. 重复第三步直到Q为空。</p><p>我们举例说明该算法的具体过程： <img src="2017-05-07_204118.png"></p><p>初始化，P集合中只有源点1，Q集合中是剩下的所有节点。distance数据初始化成图中的样子。 <img src="2017-05-07_204912.png"> 找到结合Q中距离源点最近的节点，是2，加入到P中，2可以到达3和4.此时到3的距离distance中是12，到4的距离distance中是无穷大，如果通过节点2中转，可以得到到3的距离等于10，小于原来的12，到4的距离是4，小于原来的无穷大，所以更新这两个距离。 <img src="2017-05-07_205423.png"> 从集合Q中找一个到集合P最近的节点，是4，把4加入P，同时从Q中删除4，4能够到达的节点是3，5，6，考察通过4能够减少原来distance中的距离。从源点通过4达到3距离是8，比原来的10小，更新；从源点通过4到达5，距离是17，比原来的无穷大小，更新；从源点通过4到达6，距离是19，比原来的无穷大小，更新； <img src="2017-05-07_205855.png"> 从集合Q中选出距离源点最近的节点，是3，把3加入结合P，同时从集合Q中删除3.看通过3能够使得distance中的各个距离缩小。3只能到达5，从源点通过3到达5的距离是13，小于原来的17，更新； <img src="2017-05-07_210348.png"> 从集合Q中继续选择距离源点最近的点，是5，加入P，从Q中删除；5只能到达6，通过5到达6距离变成了17，小于原来的19，更新； <img src="2017-05-07_210717.png"> 集合Q中只剩下一个节点，将它加入P集合，通过它不能达到任何节点，所以算法结束。 此时的distance存储的就是最终的结果。 <img src="2017-05-07_210822.png"></p><p>注意，该算法的时间复杂度是O(N^2)，如果使用邻接表来存储图，时间复杂度可以是O(M),M是边的数量，可以看到，该算法非常高效，但是不能解决带负权边的问题，如果要解的问题权重有负值，可以考虑使用下面提到的方法。</p><h3 id="bellman-ford-算法">Bellman-Ford 算法</h3><p>该算法核心代码： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n<span class="number">-1</span>;k++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>( distance[[v[i]]] &gt; distance[u[i]] + w[i] )&#123;</span><br><span class="line">        distance[[v[i]]] = distance[u[i]] + w[i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码当中，n是节点的个数，m是边的个数，distance是记录源点到各个点的最短距离的数组，u,v,w是三个数组，用来存储边的信息，对于边i来说，u[i]是这变的起点，v[i]是这条边的终点，w[i]是这条边的权重。所以， <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( distance[[v[i]]] &gt; distance[u[i]] + w[i] )&#123;</span><br><span class="line">    distance[[v[i]]] = distance[u[i]] + w[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码的含义就是：如果从源点到节点v[i]的距离 大于 经过节点u[i]再到v[i]的距离，就更新源点到节点v[i]的距离为 distance[u[i]] + w[i]. 这里的操作和dijstra算法是一样的含义。通俗的理解就是，如果通过第i条边能使距离变短，就更新。</p><p>那么，所有的边都松弛一边之后会是什么样子呢。为什么最外层还有一个n-1次的循环呢？ 让我们通过具体的实例看一下具体情况。 <img src="2017-05-07_213921.png"> 空心小圆圈上的数字是边的编号，distance数组被初始化了。我们用上面的代码进行一轮运算：K=1， i= 1…m 这里m等于5，因为只有5条边。 i = 1, u[1]=2, v[1]=3, distance[v[1]]无穷大，distance[u[1]]+w[1]还是无穷大，所以本次不更新distance数组。 i = 2, distance[v[2]]=无穷，而distance[u[2]]+w[2]=-3,所以distance[v[2]]=-3 <img src="2017-05-07_214613.png"> i = 3, distance[v[3]]=无穷，而distance[u[3]]+w[3]=5,所以distance[3]=5, <img src="2017-05-07_214822.png"> i = 4, distance[v[4]]=5，而distance[u[4]]+w[4]=无穷,所以本次不更新。 <img src="2017-05-07_214939.png"> i = 5, distance[v[5]]=无穷，而distance[u[5]]+w[5]=无穷，所以本次不更新。 <img src="2017-05-07_215503.png"></p><p>从上面可以看出，所有的边都松弛了一边，但是并没有得到答案，目前为止，我们只得到了源点到2的最短距离，源点到3目前还不是最短距离。所以可以假定，每次遍历一边所有的边，至少能够确定一个顶点的最短距离，所以最多循环顶点的个数减1次就可以了。需要注意的是，并不一定每次遍历一遍边只能确定一个顶点的最短距离，所以n-1次只是上限，如果超过了n-1次，distance数组还在发生变化，那么说明图中存在负权回路，存在负权回路的图是没有最短路径的，因为每绕一圈路径都会缩短。</p><p>K=2 完成之后的情况： <img src="2017-05-07_220125.png"></p><p>k=3 完成之后的情况： <img src="2017-05-07_220303.png"></p><p>k=4 完成之后的情况： <img src="2017-05-07_220418.png"></p><p>可以看到，此时已经没有变化了，算法在与上一次相比，distance没有变化之后其实就可以提前结束了。</p><p><strong>参考文献</strong>：</p><ol style="list-style-type: decimal"><li>带权最短路：http://www.renfei.org/blog/weighted-shortest-path.html</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
            <tag> 最短路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VISIO的使用01-基础入门</title>
      <link href="/hexoblog/2017/05/05/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/Visio/VISIO%E7%9A%84%E4%BD%BF%E7%94%A801-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
      <url>/hexoblog/2017/05/05/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/Visio/VISIO%E7%9A%84%E4%BD%BF%E7%94%A801-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>visio是一个适用于绘制各种流程图，示意图的工具，提供了大量的元件和模版，比直接使用word或者画图绘制图形要方便许多。 <a id="more"></a> <img src="无标题.png"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工具 </category>
          
          <category> Visio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> visio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法专题_图之网络流</title>
      <link href="/hexoblog/2017/05/05/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E5%9B%BE%E4%B9%8B%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
      <url>/hexoblog/2017/05/05/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E5%9B%BE%E4%B9%8B%E7%BD%91%E7%BB%9C%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<p>有一个自来水管道运输系统，起点是s，终点是t，途中经过的管道都有一个最大的容量。求从s到t的最大水流量是多少？</p><p>网络最大流问题是网络的另一个基本问题。许多系统包含了流量问题。例如交通系统有车流量，金融系统有现金流，控制系统有信息流等。许多流问题主要是确定这类系统网络所能承受的最大流量以及如何达到这个最大流量。</p><a id="more"></a><p>先介绍最大流问题额一般模型。 <img src="2017-05-05_162502.png"> 如图，要求从s到t的最大流是多少。我们可以很容易的看出该网络的最大流是4，s–&gt;1 == 2 并且 s–&gt;2 = 2. 线段上的数据表示线段上的最大容量，s表示起点，术语叫做源点(source),t是终点，术语叫做汇点(sink),边的容量记作<span class="math inline">\(c\)</span>,实际边上流过的具体的值记作<span class="math inline">\(f\)</span>. 最大流问题就是最大化从s出发的流量。</p><p><strong>流网络的值</strong></p><p>有时候，我们会提到流网络的大小，这个时候是指所有从源点出发的流之和。</p><h2 id="ford-fulkerson">Ford-Fulkerson</h2><p>网络最大流问题比较常见的是Ford-Fulkerson解法。该方法依赖于三种重要思想：残留网络，增广路径和割。</p><h3 id="增广路径">增广路径</h3><p>增广路径可以看做是从源点s到汇点t之间的一条路径，沿该路径可以压入更多的流，从而增加流的值。 举个例子来说明下，如图所示，每条红线就代表了一条增广路径，当前s到t的流量为3。 <img src="2017-05-05_172645.png"> 当然这并不是该网络的最大流，根据寻找增广路径的算法我们其实还可以继续寻找增广路径，最终的最大流网络如下图所示，最大流为4。 <img src="2017-05-05_172712.png"></p><h3 id="残留网络residual-graph">残留网络(Residual Graph)</h3><p>给定一个具体的流，除了这个流之外，网络上还能容纳的流叫做这个流对应的残留网络。可以简单的把残留网络理解为整个网络减去当前的流网络。</p><p>残留网络的具体计算方法： 给定一个流网络G和一个流，流的残留网<span class="math inline">\(G_f\)</span>拥有与原网相同的顶点。原流网络中每条边将对应残留网中一条或者两条边，对于原流网络中的任意边(u, v)，流量为f(u, v)，容量为c(u, v)： - 如果f(u, v) &gt; 0，则在残留网中包含一条容量为f(u, v)的边(v, u); - 如果f(u, v) &lt; c(u, v)，则在残留网中包含一条容量为c(u, v) - f(u, v)的边(u, v)。 <img src="2017-05-05_163526.png"> 如上图所示，开始的时候，所有的流都为0，此时满足第二条，f(u,v) = 0 &lt; c(u,v).所以残留网络与原来的网络相同。 <img src="2017-05-05_164453.png"> 在当前的残留网络（与原网络相同）随意确定一条增广路径，假设是<code>0--&gt;1--&gt;3--&gt;5</code>，该路径的最大流量是2. f(0,1)&gt;0, 残留网络中有一条边(1,0) = 2, f(0,1) = c(0,1), 所以没有从0到1的边。 c(1,3)&gt;f(1,3)&gt;0, 所以残留网络中有两条边,(1,3)=3-2=1, (3,1)=f(1,3)=2. c(3,5) = f(3,5)&gt;0, 所以残留网络中有一条边，(5,2) = 2. 整个残留网络的变化如有图所示。 <img src="2017-05-05_165150.png"> 再从残留网络中找一条增广路径，这次我们找<code>0--&gt;2--&gt;4--&gt;5</code>,最大流量是1. 按照残留网络的规则，计算之后的残留网络如右图所示。 <img src="2017-05-05_165642.png"> 继续从残留网络中找增广路径，可以寻找到一条<code>0--&gt;2--&gt;3--&gt;1--&gt;4--&gt;5</code>的路径，注意<code>3--&gt;1</code>就是原来的<code>1--&gt;3</code>减去1，最大的流量是1. 根据上面的规则调整残留网络，如右图所示。 此时，残留网络中再也找不到任何一条从0到5的增广路径，所以过程结束，这个时候，我们发现，我们已经找到了最大流。上图左边所示的就是该网络的最大流，和我们最初的直观印象是一样的。</p><h3 id="割">割</h3><p>设整个图的顶点集合是V。所谓图的割，指的是边的集合，指的是对于某个顶点集合<span class="math inline">\(S \subseteq V\)</span> ,从S出发指向S外部的那些边的集合，记为割(S,V). 所以割是指一些边的集合。 这些边上的容量之和被称为割的容量。</p><p><strong>最小割问题</strong></p><p>对于给定的网络，为了保证没有从s到t的路径，需要删去的边的总容量最小是多少。其中<span class="math inline">\(s \in S\)</span> 且 <span class="math inline">\(t \in {V/S}\)</span>.</p><p><strong>最大流最小割定理</strong></p><p>一个网中所有流中的最大值等于所有割中的最小容量。 其实这个定理很容易从道理上想明白，一旦超出最小割，便总有边超出了边的容量，也就不存在可行的流了。</p><p>用上面用过的图来说明一下割的相关概念： <img src="2017-05-05_175417.png"> 如图，流网络的一个割为s:{0,1,2},t:{3,4,5}, 通过割的流量定义为从s到t的所有流量之和(从t到s的流量记作负值)，所以这个割的流量是：2+1=3 割的容量记作所有从s到t的边的容量之和，所以是3+1+1+1 = 6.</p><p>从上面的定义可以简单的得到一点，任何一个割的流量都小于等于割的容量。 将上面的割的图形增加一个虚拟的节点s’，绘制成下面的形式：f1是流入S的流量，f2是从S到T的流量，f3是从T到S的流量。一个节点的流入流量等于流出的流量，所以有f2 = f1 + f3.</p><p><img src="2017-05-05_183244.png"> 从这个图可以清晰的看出，流网络的值等于f1, 而割的流量等于f2-f3. 所以有流网络的值等于割的流量值。 最大流最小割定理定理的证明：http://www.cnblogs.com/luweiseu/archive/2012/07/14/2591573.html <img src="2017-05-05_185210.png"></p><h3 id="ford-fulkerson算法的实现">Ford-Fulkerson算法的实现</h3><p>上面介绍残留网络的时候已经将的很清楚了，Ford-Fulkerson算法就是不断更新残留网络，从中找出可行的流，直到无法从残留网络中找出可行的流为止。 所以，简单的算法步骤可以表述为： &gt; 1. 初始化流flow = 0; &gt; 2. while(condition){ &gt; flow += path-flow &gt; } &gt; 此处的condition为 存在从s到t的增广路径，path-flow为该增广路径的值。 &gt; 3. 输出flow.</p><p>可以看出，算法的主要部分在寻找增广路径上面。 参考文章：http://www.geeksforgeeks.org/ford-fulkerson-algorithm-for-maximum-flow-problem/</p><p>程序以这个实例作为输入： <img src="2017-05-05_191021.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ program for implementation of Ford Fulkerson algorithm</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Number of vertices in given graph</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> V 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns true if there is a path from source 's' to sink 't' in</span></span><br><span class="line"><span class="comment">  residual graph. Also fills parent[] to store the path */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  使用宽度优先搜索搜索残留网络之中是否有增广路径</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> rGraph[V][V], <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> parent[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Create a visited array and mark all vertices as not visited</span></span><br><span class="line">    <span class="keyword">bool</span> visited[V];</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="keyword">sizeof</span>(visited));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a queue, enqueue source vertex and mark source vertex</span></span><br><span class="line">    <span class="comment">// as visited</span></span><br><span class="line">    <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    parent[s] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Standard BFS Loop   宽度优先搜索</span></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v=<span class="number">0</span>; v&lt;V; v++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[v]==<span class="literal">false</span> &amp;&amp; rGraph[u][v] &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(v);</span><br><span class="line">                parent[v] = u;</span><br><span class="line">                visited[v] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we reached sink in BFS starting from source, then return</span></span><br><span class="line">    <span class="comment">// true, else false</span></span><br><span class="line">    <span class="keyword">return</span> (visited[t] == <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns the maximum flow from s to t in the given graph</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fordFulkerson</span><span class="params">(<span class="keyword">int</span> graph[V][V], <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a residual graph and fill the residual graph with</span></span><br><span class="line">    <span class="comment">// given capacities in the original graph as residual capacities</span></span><br><span class="line">    <span class="comment">// in residual graph</span></span><br><span class="line">    <span class="keyword">int</span> rGraph[V][V]; <span class="comment">// Residual graph where rGraph[i][j] indicates</span></span><br><span class="line">    <span class="comment">// residual capacity of edge from i to j (if there</span></span><br><span class="line">    <span class="comment">// is an edge. If rGraph[i][j] is 0, then there is not)</span></span><br><span class="line">    <span class="comment">// 初始化残留网络，刚开始的时候，残留网络和初始网络一致，见上面的讲解</span></span><br><span class="line">    <span class="keyword">for</span> (u = <span class="number">0</span>; u &lt; V; u++)</span><br><span class="line">        <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; V; v++)</span><br><span class="line">            rGraph[u][v] = graph[u][v];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> parent[V];  <span class="comment">// This array is filled by BFS and to store path</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max_flow = <span class="number">0</span>;  <span class="comment">// There is no flow initially</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Augment the flow while tere is path from source to sink</span></span><br><span class="line">    <span class="comment">//bfs(rGraph, s, t, parent) 实现了判断残留网络中是否存在增广路径</span></span><br><span class="line">    <span class="keyword">while</span> (bfs(rGraph, s, t, parent))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Find minimum residual capacity of the edges along the</span></span><br><span class="line">        <span class="comment">// path filled by BFS. Or we can say find the maximum flow</span></span><br><span class="line">        <span class="comment">// through the path found.</span></span><br><span class="line">        <span class="keyword">int</span> path_flow = INT_MAX;</span><br><span class="line">        <span class="comment">//找到path_flow的值，path_flow的值等于增广路径中最小的边的容量。</span></span><br><span class="line">        <span class="keyword">for</span> (v=t; v!=s; v=parent[v])</span><br><span class="line">        &#123;</span><br><span class="line">            u = parent[v];</span><br><span class="line">            path_flow = min(path_flow, rGraph[u][v]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// update residual capacities of the edges and reverse edges</span></span><br><span class="line">        <span class="comment">// along the path</span></span><br><span class="line">        <span class="comment">//更新残留网络</span></span><br><span class="line">        <span class="keyword">for</span> (v=t; v != s; v=parent[v])</span><br><span class="line">        &#123;</span><br><span class="line">            u = parent[v];</span><br><span class="line">            rGraph[u][v] -= path_flow;</span><br><span class="line">            rGraph[v][u] += path_flow;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add path flow to overall flow</span></span><br><span class="line">        max_flow += path_flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the overall flow</span></span><br><span class="line">    <span class="keyword">return</span> max_flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Driver program to test above functions</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Let us create a graph shown in the above example</span></span><br><span class="line">    <span class="keyword">int</span> graph[V][V] = &#123; &#123;<span class="number">0</span>, <span class="number">16</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">14</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">20</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">4</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The maximum possible flow is "</span> &lt;&lt; fordFulkerson(graph, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码搜索增广路径使用的BFS，实际上还可以使用DFS，PFS等方法，参考文章： http://www.cnblogs.com/luweiseu/archive/2012/07/14/2591573.html</p><p><strong>参考文献</strong></p><p>http://www.cnblogs.com/luweiseu/archive/2012/07/14/2591573.html http://www.acmerblog.com/ford-fulkerson-6135.html http://blog.csdn.net/smartxxyx/article/details/9293805 http://www.geeksforgeeks.org/ford-fulkerson-algorithm-for-maximum-flow-problem/</p><h2 id="dinic算法">Dinic算法</h2><p>Dinic是一种比Ford-Fulkerson效率更高的算法，当数据较大的时候，可以考虑使用Dinic算法。</p><h3 id="顶点的层次">顶点的层次</h3><p>在残留网络中，把顶点距离源点的距离定义为节点的层次，源点的层次为0，和源点直接相连的节点的层次是1. <strong>分层</strong>： 将残留网络中所有节点的层次标记出来的过程。（注意不是所有的网络都可以分层） <strong>层次网络</strong>：对残留网络进行分层后，删去比汇点Vt层次更高的顶点和与汇点Vt同层的顶点(保留Vt)，并删去这些顶点相关联的弧，再删去从某层顶点指向同层顶点和低层顶点的弧，所剩余的各条弧的容量与残留网络中的容量相同，这样得到的网络就是残留网络的子网络，称为层次网络，记为G’‘(V’‘,E’’)。</p><p>根据层次网络定义，层次网络中任意的一条弧<u,v>，有满足level(u)+1 == level(v)，这条弧也叫允许弧。直观的说，层次网络是建立在残留网络基础之上的一张“最短路径图”。从源点开始，在层次网络中沿着边不管怎么走，到达一个终点之后，经过的路径一定是终点在残留网络中的最短路径。</u,v></p><h3 id="dinic算法的思想">Dinic算法的思想</h3><p>Dinic算法的思想也是分阶段地在层次网络中增广。它与最短增广路算法不同之处是：最短增广路每个阶段执行完一次BFS增广后，要重新启动BFS从源点Vs开始寻找另一条增广路;而在Dinic算法中，只需一次DFS过程就可以实现多次增广，这是Dinic算法的巧妙之处。Dinic算法具体步骤如下:</p><p>（1）初始化容量网络和网络流。</p><p>（2）构造残留网络和层次网络，若汇点不再层次网络中，则算法结束。</p><p>（3）在层次网络中用一次DFS过程进行增广，DFS执行完毕，该阶段的增广也执行完毕。</p><p>（4）转步骤（2）。</p><p>在Dinic的算法步骤中，只有第（3）步与最短增广路相同。在下面实例中，将会发现DFS过程将会使算法的效率有非常大的提高。 DFS增广过程示意： <img src="2017-05-05_201259.png"></p><h3 id="dinic算法实现">Dinic算法实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">210</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">210</span>*<span class="number">210</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, f;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;edge[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> first[MAXN], level[MAXN];</span><br><span class="line"><span class="keyword">int</span> q[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(first, <span class="number">-1</span>, <span class="keyword">sizeof</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_graph</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].v = v, edge[cnt].f = f;</span><br><span class="line">    edge[cnt].next = first[u], first[u] = cnt++;</span><br><span class="line">    edge[cnt].v = u, edge[cnt].f = <span class="number">0</span>;  <span class="comment">//增加一条反向弧，容量为0</span></span><br><span class="line">    edge[cnt].next = first[v], first[v] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> <span class="comment">//构建层次网络</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(level, <span class="number">0</span>, <span class="keyword">sizeof</span>(level));</span><br><span class="line">    level[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">0</span>, rear = <span class="number">1</span>;</span><br><span class="line">    q[front] = s;</span><br><span class="line">    <span class="keyword">while</span>(front &lt; rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q[front++];</span><br><span class="line">        <span class="keyword">if</span>(x == t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e = first[x]; e != <span class="number">-1</span>; e = edge[e].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[e].v, f = edge[e].f;</span><br><span class="line">            <span class="keyword">if</span>(!level[v] &amp;&amp; f)</span><br><span class="line">            &#123;</span><br><span class="line">                level[v] = level[x] + <span class="number">1</span>;</span><br><span class="line">                q[rear++] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> maxf, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == t) <span class="keyword">return</span> maxf;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> e = first[u]; e != <span class="number">-1</span>; e = edge[e].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[e].v, f = edge[e].f;</span><br><span class="line">        <span class="keyword">if</span>(level[u] + <span class="number">1</span> == level[v] &amp;&amp; f)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> Min = min(maxf-ret, f);</span><br><span class="line">            f = dfs(v, Min, t);</span><br><span class="line">            edge[e].f -= f;</span><br><span class="line">            edge[e^<span class="number">1</span>].f += f;</span><br><span class="line">            ret += f;</span><br><span class="line">            <span class="keyword">if</span>(ret == maxf) <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> <span class="comment">//Dinic</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs(s, t)) ans += dfs(s, INF, t);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考文献</strong></p><p>https://comzyh.com/blog/archives/568/ http://blog.csdn.net/wall_f/article/details/8207595 http://www.cnblogs.com/y-clever/p/6308820.html http://blog.csdn.net/u012914220/article/details/23865829 http://blog.csdn.net/pi9nc/article/details/23339111 http://www.nocow.cn/index.php/Dinic#.E7.AE.97.E6.B3.95.E6.B5.81.E7.A8.8B</p><p>2017ISAP 算法 ：http://www.renfei.org/blog/isap.html</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片处理02-一寸照片</title>
      <link href="/hexoblog/2017/05/05/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%8602-%E4%B8%80%E5%AF%B8%E7%85%A7%E7%89%87/"/>
      <url>/hexoblog/2017/05/05/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%8602-%E4%B8%80%E5%AF%B8%E7%85%A7%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>学会一些对照片的简单处理方法是每个人都应该掌握的技能。比如，修改图片的尺寸，修改图片占用的空间的大小，修改图片的底色。制作标准的一寸照片，二寸照片等等。这些在很多需要个人简历的地方都用的到。 <a id="more"></a> 图像处理软件有很多，最专业的要属photoshop了。但是，如果只是简单的处理数据，没有必要使用这么庞大和复杂的软件。美图秀秀就能满足要求。软件不到30M，安装也很快。</p><h2 id="美图秀秀制作一寸照片">美图秀秀制作一寸照片</h2><h3 id="下载安装美图秀秀">下载安装美图秀秀</h3><p>下载地址：http://xiuxiu.meitu.com/ <img src="2017-05-05_115122.png"></p><h3 id="更换照片的背景">更换照片的背景</h3><ol style="list-style-type: decimal"><li>打开美化图片，选择一张图片进来。 <img src="2017-05-05_115244.png"></li><li>选择抠图笔–自动抠图，在人像上画线，软件会自动找到边缘，把人像抠出来。 <img src="2017-05-05_115544.png"> 单击完成抠图，会出现下面这样的界面： <img src="2017-05-05_120107.png"> 选择背景颜色： <img src="2017-05-05_120738.png"> 制作好的照片： <img src="2017-05-05_121353.png"> 最后一张是使用图案作为背景的。</li></ol><h3 id="更改照片的格式和kb大小">更改照片的格式和KB大小</h3><p>很多网站上传图片的时候都有文件格式的限制和文件大小的限制。我们手里的图片很可能不满足要求。使用美图秀秀可以方便的更改文件的格式和大小。 <img src="2017-05-05_123555.png"></p><p>除此之外，还有一种更简单的把图像KB大小变小的方法，就是打开图像，用QQ截图截取，然后保存，一般情况下图像都能降到十几KB。</p><h2 id="photoshop制作一寸照片">photoshop制作一寸照片</h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工具 </category>
          
          <category> 图片处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美图秀秀 </tag>
            
            <tag> 一寸照片 </tag>
            
            <tag> 换背景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo的使用03-迁移</title>
      <link href="/hexoblog/2017/05/05/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/Hexo/Hexo%E7%9A%84%E4%BD%BF%E7%94%A803-%E8%BF%81%E7%A7%BB/"/>
      <url>/hexoblog/2017/05/05/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/Hexo/Hexo%E7%9A%84%E4%BD%BF%E7%94%A803-%E8%BF%81%E7%A7%BB/</url>
      
        <content type="html"><![CDATA[<p>hexo目前还没有全自动的一键迁移功能，所以要移动位置的时候需要重新执行一边流程。把这个流程记录下来，便于以后再次迁移的时候使用。</p><a id="more"></a><h2 id="建站">建站</h2><ol style="list-style-type: decimal"><li>找一个目录，命令行切换到该目录下。</li><li><code>npm install -g hexo-cli</code>, 安装主程序。</li><li><code>hexo version</code>, 查看安装的版本 <img src="QQ截图20170505001427.png"></li><li><code>hexo init .</code>, 在当前目录下建立站点，该过程会安装许多相关的文件。 <img src="QQ截图20170505001745.png"></li><li><code>hexo s</code>，打开hexo的服务器，然后在浏览器输入<code>http://localhost:4000/</code>,查看效果。 <img src="QQ截图20170505002008.png"></li></ol><h2 id="安装需要的插件">安装需要的插件</h2><p><code>npm install hexo-deployer-git --save</code> <code>npm install hexo-generator-feed --save</code> <code>npm install hexo-generator-search --save</code></p><h2 id="更新成以前的配置">更新成以前的配置</h2><p>主配置文件和整个主题文件夹全部拷贝过来，覆盖原来的文件。</p><h2 id="拷贝博客数据">拷贝博客数据</h2><p>把source文件加整个复制过来覆盖。</p><h2 id="完成">完成</h2><p>此时本地的环境就搭建好了，只是还没有和远程的仓库连接起来。 <code>hexo g</code>生成public目录。 将public部署到远程。</p><h2 id="解决hexo和latex的冲突问题">解决hexo和latex的冲突问题</h2><p>https://github.com/hexojs/hexo/issues/524</p><p>使用pandoc会出现其他的问题，因为markdown语法会有少许的不同，这个是最令人头疼的事情。 http://shomy.top/2016/10/22/hexo-markdown-mathjax/</p><p>适用了N中方法，最后发现，还是修改源码的方法最靠谱，不会有格式上的太大的变化。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工具 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_Matlab使用技巧</title>
      <link href="/hexoblog/2017/05/04/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_Matlab%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/hexoblog/2017/05/04/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_Matlab%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>记录一些Matlab常用的操作，以便日后查阅。</p><a id="more"></a><h2 id="发出声音">发出声音</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sp=actxserver(<span class="string">'SAPI.SpVoice'</span>);</span><br><span class="line">sp.Speak(<span class="string">'第一个被试处理完了！'</span>)</span><br></pre></td></tr></table></figure><h2 id="计时">计时</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tic; <span class="comment">% 开始计时</span></span><br><span class="line">....</span><br><span class="line">toc <span class="comment">% 停止计时</span></span><br></pre></td></tr></table></figure><h2 id="输出重定向到文件">输出重定向到文件</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">diary 文件路径   <span class="comment">% 输出重定向到文件</span></span><br><span class="line">...</span><br><span class="line">diary off; <span class="comment">% 从diary 到diary off 之间的输出都重定向到文件中去了。</span></span><br></pre></td></tr></table></figure><h2 id="颜色控制">颜色控制</h2><p><strong>生成颜色</strong></p><p>Matlab中可以很方便的生成各种不同的颜色，在Matlab中叫做颜色映像。 <img src="QQ截图20170504215111.png"> 例如想要获得 从 蓝色 到 红色 渐变的 100 中颜色，可以输入： <code>a = jet(100)</code>, a会是一个100 * 3的矩阵， 值都在0 – 1 之间，0表示黑色，1表示白色。 3 个列分别表示R， G ， B 三个通道的取值。</p><p>不同的颜色映像： <img src="2017-05-04_222428.png"> 生成的代码：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">color_num = <span class="number">64</span>;</span><br><span class="line">M = hsv(color_num);</span><br><span class="line">colormap(M);</span><br><span class="line">colorbar();</span><br><span class="line"><span class="comment">%pcolor(M);</span></span><br><span class="line"></span><br><span class="line">M = hot(color_num);</span><br><span class="line">colormap(M);</span><br><span class="line">colorbar();</span><br><span class="line"></span><br><span class="line">M = cool(color_num);</span><br><span class="line">colormap(M);</span><br><span class="line">colorbar();</span><br><span class="line"></span><br><span class="line">M = pink(color_num);</span><br><span class="line">colormap(M);</span><br><span class="line">colorbar();</span><br><span class="line"></span><br><span class="line">M = bone(color_num);</span><br><span class="line">colormap(M);</span><br><span class="line">colorbar();</span><br><span class="line"></span><br><span class="line">M = jet(color_num);</span><br><span class="line">colormap(M);</span><br><span class="line">colorbar();</span><br><span class="line"></span><br><span class="line">M = copper(color_num);</span><br><span class="line">colormap(M);</span><br><span class="line">colorbar();</span><br><span class="line"></span><br><span class="line">M = prism(color_num);</span><br><span class="line">colormap(M);</span><br><span class="line">colorbar();</span><br><span class="line"></span><br><span class="line">M = flag(color_num);</span><br><span class="line">colormap(M);</span><br><span class="line">colorbar();</span><br><span class="line"></span><br><span class="line">M = gray(color_num);</span><br><span class="line">colormap(M);</span><br><span class="line">colorbar();</span><br></pre></td></tr></table></figure><p><strong>设置颜色</strong></p><p>使用<code>colormap(M)</code>指定画图的时候使用的颜色映像，<code>M</code>是上面生成的n*3的矩阵。</p><p><strong>显示colorbar</strong></p><p>函数<code>colorbar();</code>可以显示当前的colorbar.</p><p>不同的jet(n)得到的颜色：</p><div class="figure"><img src="2017-05-04_220731.png"></div><p>不同的HSV(n)得到的颜色：</p><div class="figure"><img src="2017-05-04_221208.png"></div><p><strong>颜色矩阵</strong></p><p>函数<code>pcolor(A)</code>,可以把矩阵A以用颜色代表数值大小的方式显示出来。该函数默认情况下不使用最后一行和最后一列，所以要完整的打印出整个矩阵的颜色，在使用之前要增加一行，增加一列。 <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 准备数据</span></span><br><span class="line">map=<span class="number">2</span>*(<span class="built_in">rand</span>(<span class="number">4</span>)<span class="number">-0.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 增加一行和一列</span></span><br><span class="line">clear add_cow;</span><br><span class="line">clear add_col;</span><br><span class="line">maxV = <span class="built_in">max</span>(<span class="built_in">max</span>(map));</span><br><span class="line">minV = <span class="built_in">min</span>(<span class="built_in">min</span>(map));</span><br><span class="line">va = (maxV + minV) /2;</span><br><span class="line">add_cow(<span class="number">1</span>,[<span class="number">1</span>:<span class="built_in">size</span>(map,<span class="number">2</span>)]) = va;</span><br><span class="line">map = [map;add_cow];</span><br><span class="line">add_col([<span class="number">1</span>:(<span class="built_in">size</span>(map,<span class="number">1</span>))],<span class="number">1</span>) = va;</span><br><span class="line">map = [map,add_col];</span><br><span class="line"><span class="comment">% 打印</span></span><br><span class="line">M = jet(color_num);</span><br><span class="line">colormap(M);</span><br><span class="line">pcolor(map);</span><br></pre></td></tr></table></figure></p><p>不同的颜色映象打印出来的矩阵： <img src="2017-05-04_230147.png"></p><h2 id="读写文件">读写文件</h2><p><strong>读取Excel</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="string">'D:\FMRI_ROOT\YIYU\features_dcm_origin.xls'</span></span><br><span class="line">data = xlsread(file,<span class="string">'Sheet1'</span>);</span><br></pre></td></tr></table></figure><p><strong>写入Excel</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xlswrite(file,data,<span class="string">'Sheet2'</span>);</span><br></pre></td></tr></table></figure><p>写入的时候需要确保文件不被其他资源占用，否则可能出现写入失败的情况。</p><p><strong>写文本文件</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fid=fopen(<span class="string">'D:\colors.txt'</span>,<span class="string">'w+'</span>);</span><br><span class="line">fprintf(fid,<span class="string">'写入的内容'</span>);</span><br><span class="line">fclose(fid);</span><br></pre></td></tr></table></figure><h2 id="随机生成数字">随机生成数字</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rand</span>(n)  <span class="comment">% n*n的矩阵</span></span><br><span class="line"><span class="built_in">rand</span>(m,n)  <span class="comment">% m*n的矩阵</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GIT的使用01-基本功能</title>
      <link href="/hexoblog/2017/05/04/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/Git/GIT%E7%9A%84%E4%BD%BF%E7%94%A801-%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/"/>
      <url>/hexoblog/2017/05/04/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/Git/GIT%E7%9A%84%E4%BD%BF%E7%94%A801-%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>版本控制工具主要有SVN和git, 目前git已经全面超越了SVN, 成为最优秀的版本管理工具。一切文本文档都可以用git来管理，使用git能够以最小的存储代价，追踪记录每一次对文件的修改，并且能够在需要的时候，恢复到任意一个版本。 除此之外，多人协作也是git的一个重要应用，它可以方便的完成分支和合并，提高团队合作的效率。</p><a id="more"></a><p>目前基于git的开放源代码托管平台国内主要是(coding.net)[coding.net],免费提供私有仓库。国外主要是<a href="github.com">github</a>,两者的功能基本一样，都提供代码管理和Page服务，所以两者都可以用来托管静态博客。</p><p>目前应用git较多的领域是一个是编程领域，包括代码版本的管理，文档的管理；另一个就是图书出版领域，有很多写书的人就是利用git管理自己的内容的。有不少工具提供了将文本格式格式化成书籍的工具，最常见的一种是<code>markdown</code>.PREVIEW</p><h2 id="安装">安装</h2><p><a href="https://git-scm.com/" target="_blank" rel="noopener">git</a>提供了Windows的安装包，所以直接下载安装就可以了。初学git,最好使用命令，放弃图形界面，这样能更深入的理解内部的原理，这对以后复杂的版本管理，分支合并等内容有好处。</p><h2 id="使用">使用</h2><h3 id="克隆别人的仓库">克隆别人的仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 仓库地址</span><br></pre></td></tr></table></figure><p>如果是公开仓库，直接克隆成功，如果是私有仓库，按照提示输入用户名和密码。</p><h3 id="修改之后提交到远程">修改之后提交到远程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add -A  <span class="comment">#添加所有新添加的文件</span></span><br><span class="line">git commit -a -m <span class="string">"提交说明"</span>  <span class="comment">#提交修改到本地git仓库</span></span><br><span class="line">git push origin master <span class="comment"># 提交本地仓库到远程的master分支</span></span><br></pre></td></tr></table></figure><h3 id="保持和远程仓库一致">保持和远程仓库一致</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>pull之后可能会出现冲突的情况，这个时候git会提示你有哪些文件冲突了，你需要子集修改冲突的文件，然后重新提交。</p><h3 id="记住密码">记住密码</h3><p>修改.git目录中的config将其中的<code>[remote &quot;origin&quot;]</code>修改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url = https://[username]:[password]@github.com/...</span><br></pre></td></tr></table></figure><!-- more --><div class="figure"><img src="remember_password.png" alt="example for rememner git password"><p class="caption">example for rememner git password</p></div><h3 id="进一步学习">进一步学习</h3><p>git的几个简单的命令足够日常使用，如果项进一步学习，可以参考一下资料： <a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="noopener">git简明指南</a> <a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">ProGit</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JetBrainsCLion的使用01-入门</title>
      <link href="/hexoblog/2017/05/04/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8BIDE/JetBrainsCLion/JetBrainsCLion%E7%9A%84%E4%BD%BF%E7%94%A801-%E5%85%A5%E9%97%A8/"/>
      <url>/hexoblog/2017/05/04/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8BIDE/JetBrainsCLion/JetBrainsCLion%E7%9A%84%E4%BD%BF%E7%94%A801-%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>c++的IDE有很多，微软的Visual Studio, 跨平台的codeblocks, 全能的eclipse, 还有就是jetbrains的Clion。 这些我都用过，感觉用着最自然的，花费学习时间最少的就是Clion了，他的调试功能也是非常好用，变量的显示很直观。</p><a id="more"></a><div class="figure"><img src="2017-05-04_181337.png"></div><h2 id="安装clion">安装CLion</h2><p>这个软件不是免费的，但是破解方法已经出了，所以可以从官方网站上下载，适用30天，到期再破解就可以了。下载地址：https://www.jetbrains.com/clion/</p><h2 id="配置编译器">配置编译器</h2><p><code>file-&gt;setting-&gt;Build,Execution,Deployment</code>选择<code>Toolchains</code>,可以看到右侧支持两种C++编译器，<code>MinGW</code>和<code>Cygwin</code>, 如果你的电脑上已经安装了任何一种，直接指定该软件的根目录就可以了，软件会自动探测相应的编译器，在线面给出版本。 <img src="QQ截图20170504181921.png"></p><p><strong>安装<code>MinGW</code></strong></p><p>Windows平台下建议安装<a href="http://tdm-gcc.tdragon.net/download" target="_blank" rel="noopener">TDM-GCC</a>,提供Windows下的安装包，安装完成之后直接就能使用，而且他提供了管理工具，以后安装和卸载相关的软件包也比较方便，安装的时候选择最简单的包含C++的编译器就可以。</p><p>安装完成后把安装的目录填在上面配置的位置就可以了。</p><p><strong>安装<code>cygwin</code></strong></p><p>下载<a href="https://cygwin.com/install.html" target="_blank" rel="noopener">cygwin</a>按照指示安装即可。</p><h2 id="字体和外观的调整">字体和外观的调整</h2><p><code>jetbrains</code>系列的软件都不支持使用<code>Ctrl+鼠标滚轮</code>的方式调整字体的大小，这点不太方便。默认的字体和背景可能不太舒服，调整字体和外观的选项都在<code>file-&gt;setting-&gt;Editor</code>中。</p><h2 id="调试">调试</h2><p>调试非常方便，只要在左侧单击，出现红色的小圆点，代表断点，然后不要点RUN,而是点DEBUG，就进入了调试模式，程序会运行到断点处等待用户的操作。 <img src="QQ截图20170504183933.png"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工具 </category>
          
          <category> 编程IDE </category>
          
          <category> JetBrainsCLion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cLion </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fMRI中常用的工具包</title>
      <link href="/hexoblog/2017/05/02/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/fMRI%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E5%8C%85/"/>
      <url>/hexoblog/2017/05/02/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/fMRI%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>fMRI分析的各个阶段用到的工具包和画图工具。 <a id="more"></a></p><h2 id="实验设计">实验设计</h2><h3 id="psychopy"><a href="http://www.psychopy.org/" target="_blank" rel="noopener">psychopy</a></h3><p>PsychoPy is an open-source application allowing you run a wide range of neuroscience, psychology and psychophysics experiments. It’s a free, powerful alternative to Presentation™ or e-Prime™, written in Python (a free alternative to Matlab™ ).</p><p>PsychoPy is unique in giving you a choice of interface: use the Builder interface to build rich, flexible experiments easily or use the Coder interface to write extremely powerful experiments in the widely-used Python programming language. The best of both worlds!</p><p>一个用于刺激呈现的工具包，可以保住设计实验，处理图像和声音的呈现方式，有基于matlab的版本。</p><h2 id="数据预处理和统计分析">数据预处理和统计分析</h2><h3 id="spm"><a href="http://www.fil.ion.ucl.ac.uk/spm/" target="_blank" rel="noopener">SPM</a></h3><div class="figure"><img src="2017-05-02_120405.png" alt="SPM"><p class="caption">SPM</p></div><p>基于matlab的工具包，可以完成fMRI原始数据格式的转换，时间层校正，头动校正，配准，分割，平滑等预处理操作。可以进行个体水平和组水平的统计分析。可以做DCM。除此之外，还能提供一些图像之间运算的小工具，例如图像之间的加减乘除。</p><h3 id="afni"><a href="https://afni.nimh.nih.gov/" target="_blank" rel="noopener">AFNI</a></h3><p>AFNI (Analysis of Functional NeuroImages) is a set of C programs for processing, analyzing, and displaying functional MRI (FMRI) data - a technique for mapping human brain activity. It runs on Unix+X11+Motif systems, including SGI, Solaris, Linux, and Mac OS X. It is available free (in C source code format, and some precompiled binaries) for research purposes.</p><h3 id="fsl"><a href="https://fsl.fmrib.ox.ac.uk/fsl/fslwiki" target="_blank" rel="noopener">FSL</a></h3><p>FSL is a comprehensive library of analysis tools for FMRI, MRI and DTI brain imaging data. It runs on Apple and PCs (both Linux, and Windows via a Virtual Machine), and is very easy to install. Most of the tools can be run both from the command line and as GUIs (“point-and-click” graphical user interfaces)</p><h3 id="neurodebian"><a href="http://neuro.debian.net/index.html" target="_blank" rel="noopener">NeuroDebian</a></h3><p>一个集成了大部分神经科学领域Linux系统下的工具的虚拟机镜像。里面包含的软件的列表可以参考：http://neuro.debian.net/pkgs.html</p><h3 id="dpabi"><a href="http://rfmri.org/dpabi" target="_blank" rel="noopener">DPABI</a></h3><p>a toolbox for Data Processing &amp; Analysis for Brain Imaging. 静息态脑网络的相关数据和工具：http://rfmri.org/。</p><h3 id="nibabel"><a href="http://nipy.org/nibabel/" target="_blank" rel="noopener">NiBabel</a></h3><p>提供读写神经影像数据格式的接口，基于python.</p><h3 id="section"></h3><h2 id="roi和mask制作和查看">ROI和Mask制作和查看</h2><h3 id="freeroi"><a href="http://freeroi.brainactivityatlas.org/" target="_blank" rel="noopener">freeroi</a></h3><p>FreeROI is a versatile image processing software developed for neuroimaging data. Its goal is to provide a user-friendly interface for neuroimaging researchers to visualize and analyze their data, especially in defining region of interest (ROI) for ROI analysis.</p><h3 id="xjview"><a href="http://www.alivelearn.net/xjview/" target="_blank" rel="noopener">xjview</a></h3><p>一个基于Matlab和SPM的用于查看激活的工具，可以Load不同的大脑地图从而实现显示激活的脑区的名称。还可以根据激活保存成Mask.</p><h3 id="wfu_pickatlas"><a href="https://www.nitrc.org/projects/wfu_pickatlas/" target="_blank" rel="noopener">WFU_PickAtlas</a></h3><p>基于Matlab和SPM的ROI制作工具。支持导入不同的大脑地图制作各个脑区的Mask。也支持以某个MNI坐标为中心，制作球形，方形的mask. <img src="2017-05-02_111209.png"></p><h2 id="功能连接">功能连接</h2><h3 id="conn"><a href="https://www.nitrc.org/projects/conn/" target="_blank" rel="noopener">CONN</a></h3><p>一个用来做静息态和任务态功能核磁成像数据的功能连接(functional connectivity)的工具包，包括去噪，first_level,second_level分析，支持region-to-region, seed-to-region, voxel-to-voxel等水平的功能连接分析，结果的展示也很漂亮。 ### <a href="https://www.nitrc.org/projects/rest/" target="_blank" rel="noopener">REST</a> 主要功能是用来做静息态数据的功能连接，也提供了图像计算的一些方法，可以用来计算图像乘以激活之后的Mask。还提供了可视化图像的界面，可以用来查看图像。 ### <a href="http://fcp-indi.github.io/docs/user/index.html" target="_blank" rel="noopener">C-PAC</a> The Configurable Pipeline for the Analysis of Connectomes (C-PAC) is a configurable, open-source, Nipype-based, automated processing pipeline for resting state functional MRI (R-fMRI) data, for use by both novice and expert users ### wiki上处理功能连接的工具包的列表</p><p>&lt;https://en.wikipedia.org/wiki/List_of_functional_connectivity_software &gt;</p><h2 id="mvpa">MVPA</h2><h3 id="mvpa-1"><a href="https://github.com/PrincetonUniversity/princeton-mvpa-toolbox" target="_blank" rel="noopener">MVPA</a></h3><p>The MVPA Toolbox is a set of Matlab tools to facilitate multi-voxel pattern analysis of fMRI neuroimaging data. The aim is to create a set of open source functions in a widely-used language to facilitate exploration of multi-voxel pattern analysis techniques and to reduce the ‘startup costs’ for knowledgeable users eager to apply pattern classification algorithms to their imaging data. By developing the toolbox in the Matlab environment, users are able to take advantage of the vast array of existing functions. The data structures used and generated by the toolbox are designed to facilitate exploration and further script development.</p><h3 id="pymvpa"><a href="http://www.pymvpa.org/" target="_blank" rel="noopener">pyMVPA</a></h3><p>PyMVPA is a Python package intended to ease statistical learning analyses of large datasets. It offers an extensible framework with a high-level interface to a broad range of algorithms for classification, regression, feature selection, data import and export. It is designed to integrate well with related software packages, such as scikit-learn, shogun, MDP, etc. While it is not limited to the neuroimaging domain, it is eminently suited for such datasets. PyMVPA is free software and requires nothing but free-software to run.</p><p>pyMVPA windows 安装包的地址：<a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/" class="uri" target="_blank" rel="noopener">http://www.lfd.uci.edu/~gohlke/pythonlibs/</a></p><h3 id="cosmomvpa"><a href="http://cosmomvpa.org/index.html" target="_blank" rel="noopener">CoSMoMVPA</a></h3><p>A multi-modal, multi-variate pattern analysis (MVPA) toolbox in Matlab / GNU Octave for cognitive neuroscientists.</p><h2 id="signalchange">SignalChange</h2><h3 id="marsbar"><a href="http://marsbar.sourceforge.net/index.html" target="_blank" rel="noopener">marsbar</a></h3><div class="figure"><img src="2017-05-02_125514.png"></div><p>marsbar是基于Matlab的一个计算SignalChange的工具。里面定义了一种.mat的ROI格式，可以和.nii的ROI格式之间进行转换。里面提供了将一个多标签Mask分割成多个单独的mask的方法，当然，反过来也可以实现。</p><h2 id="group-ica-分析">group ICA 分析</h2><h3 id="gift"><a href="http://mialab.mrn.org/software/gift/" target="_blank" rel="noopener">gift</a></h3><p>一个使用很广泛的用来做组水平的ICA的工具。</p><h2 id="dcm">DCM</h2><h3 id="tapas"><a href="https://www.tnu.ethz.ch/de/software/tapas.html" target="_blank" rel="noopener">TAPAS</a></h3><p>大量平行DCM的计算。</p><h2 id="绘图">绘图</h2><h3 id="origin"><a href="http://www.originlab.com" target="_blank" rel="noopener">Origin</a></h3><p>Origin是由OriginLab公司开发的一个科学绘图、数据分析软件，支持在Microsoft Windows下运行。Origin支持各种各样的2D/3D图形。Origin中的数据分析功能包括统计，信号处理，曲线拟合以及峰值分析。Origin中的曲线拟合是采用基于Levernberg-Marquardt算法（LMA）的非线性最小二乘法拟合。Origin强大的数据导入功能，支持多种格式的数据，包括ASCII , Excel, NI TDM, DIADem, NetCDF, SPC，等等。图形输出格式多样，例如JPEG，GIF，EPS，TIFF等。内置的查询工具可通过ADO访问数据库数据。 <img src="2017-05-02_130248.png"></p><h3 id="excel">EXCEL</h3><p>各种条形图，柱状图，扇形图都可以用EXCEL来画。</p><h3 id="matlab">Matlab</h3><p>Matlab可以绘制各种2D，3D图形。很多基于Matlab的工具包画出的图形都是基于Matlab的画图功能。但是想用Matlab画出好看的图需要直接编写代码。</p><h3 id="matplotlib"><a href="https://matplotlib.org/index.html" target="_blank" rel="noopener">Matplotlib</a></h3><p>Matplotlib is a Python 2D plotting library which produces publication quality figures in a variety of hardcopy formats and interactive environments across platforms. Matplotlib can be used in Python scripts, the Python and IPython shell, the jupyter notebook, web application servers, and four graphical user interface toolkits.</p><div class="figure"><img src="2017-05-02_130835.png"></div><p>以上几个都是通用的绘图工具，适用于绘制各种图形。在认知神经科学的绘图中，经常需要以大脑为背景绘制图像。下面介绍几个实现了在大脑皮层或者大脑的展开层绘制图像的工具。</p><h3 id="brat"><a href="https://www.nitrc.org/projects/brat/" target="_blank" rel="noopener">BRAT</a></h3><p>Brainnetome fMRI toolkit (brat) refers to the construction and assessment of brain network used to evaluated brain network architecture about fMRI imaging data. These ideas have been instantiated in software that is called Brainnetome fRMI toolkit(brat). The brat package has been designed for the analysis of brain network based on spm (http://www.fil.ion.ucl.ac.uk/spm/). The images can from different cohorts, or time-series from the same subject. The current release is designed for the analysis of fMRI, EEG. It includes the proprecessing steps, functional connectivity analysis, network analysis and network view etc.</p><p>使用它可以很方便的绘制出类似下面这样的图：</p><div class="figure"><img src="1.png"></div><div class="figure"><img src="2.png"></div><h3 id="brainnet-viewer"><a href="https://www.nitrc.org/projects/bnv/" target="_blank" rel="noopener">BrainNet Viewer</a></h3><p>BrainNet Viewer is a brain network visualization tool, which can help researchers to visualize structural and functional connectivity patterns from different levels in a quick, easy, and flexible way. 一个类似上面的那样可以绘制脑区位置和大脑功能连接的工具，比上面的工具好用，选项多一些，配置更方便。</p><h3 id="pycortex"><a href="https://github.com/gallantlab/pycortex" target="_blank" rel="noopener">pycortex</a></h3><p>一个基于python的绘制大脑展开皮层的工具。绘制的图形类似下面这样：</p><div class="figure"><img src="QQ截图20170502132207.png"></div><h3 id="freesurfer"><a href="https://surfer.nmr.mgh.harvard.edu/fswiki/FreeSurferWiki" target="_blank" rel="noopener">FreeSurfer</a></h3><p>一个绘制皮层图像的工具，包含一些分析的方法。是由麻省总医院（Massachusetts General Hospital）的Bruce Fischl和同事开发的处理MRI解剖图像的软件包。虽然它实际上不是fMRI分析工具，但是因为它可以很容易地自动生成皮层表面模型和解剖分割图，因此近几年也越来越流行。这些模型可以用来进行基于皮层表面的被试间配准，这通常比常规的被试间的三维大脑配准更精确(见第4章)。它也可以导入FSL或者SPM处理过的统计结果，将它们投射在重建的皮层表面，这样可以进行基于皮层表面的组分析.产生的图像类似下面这样：</p><div class="figure"><img src="5.png"></div><div class="figure"><img src="lh_aparc.jpeg"></div><div class="figure"><img src="encode.png"></div><div class="figure"><img src="8.png"></div><h3 id="caret"><a href="http://brainvis.wustl.edu/wiki/index.php/Caret:Download" target="_blank" rel="noopener">caret</a></h3><p>类似freesurfer，可以绘制类似下面的图形，可以看到，这个更好看一些。</p><div class="figure"><img src="caret.png"></div><h3 id="circos"><a href="http://circos.ca/" target="_blank" rel="noopener">circos</a></h3><p>一个常用来可视化基因组的工具包，可以用来画各种环状图形。</p><div class="figure"><img src="QQ截图20170502133729.png"></div><h3 id="brainbrowser"><a href="https://brainbrowser.cbrain.mcgill.ca" target="_blank" rel="noopener">BrainBrowser</a></h3><p>一个大脑的浏览器，各种视角看大脑。</p><h3 id="cbrain"><a href="http://mcin-cnim.ca/neuroimagingtechnologies/cbrain/" target="_blank" rel="noopener">cbrain</a></h3><p>一个基于浏览器的脑影像分析工具集合。</p><h3 id="pysurfer"><a href="https://pysurfer.github.io/" target="_blank" rel="noopener">pysurfer</a></h3><p>PySurfer is a Python library for visualizing cortical surface representations of neuroimaging data. The package is primarily intended for use with Freesurfer, but it can plot data that are drawn from a variety of sources. PySurfer extends Mayavi’s powerful rendering engine with a high-level interface for working with MRI and MEG data.</p><div class="figure"><img src="QQ截图20170514155026.png"></div><h3 id="纤维束绘制工具">纤维束绘制工具</h3><p><a href="http://www.med.unc.edu/psych/research/niral/download" class="uri" target="_blank" rel="noopener">http://www.med.unc.edu/psych/research/niral/download</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 认知神经科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fMRI </tag>
            
            <tag> toolboxhexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法专题_一维数组</title>
      <link href="/hexoblog/2017/05/02/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84/"/>
      <url>/hexoblog/2017/05/02/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>算法题型中经常涉及到一个序列的问题，可能是一个整数数组，也可能是一个字符串。这类问题涵盖的面非常广,可以考察的知识点也非常多，但是总有一些处理的思想和技巧是不变的。这里，我把遇到的这类问题总结在一起，一遍能够从中发现规律，灵活掌握解题的技巧。</p><a id="more"></a><h2 id="跳跃游戏">跳跃游戏</h2><div class="figure"><img src="2017-03-21_103300.png" alt="2017-03-21_103300.png"><p class="caption">2017-03-21_103300.png</p></div><p><strong>思路</strong> 如果采用遍历的方法，复杂度与数组的长度和数组元素的大小相关，数组中元素的大小会在很大程度上影响时间复杂度，例如数组元素都是1，代表每次都只能向后一步，那么结果就是n,如果数组的第一个元素就是n,那么一步就可以到达数组的结尾。所以这显然不是一个好的办法.考虑数组<code>array</code>的一个区间<code>[0,i]</code>,截止到<code>i</code>位置的时候，能够到达的最远的位置是<code>next</code>.考虑如何求解<code>next</code>的值.初始的时候,<code>next=0</code>,<code>i=0</code>的时候，能够到达的最远位置是<code>i+array[i]</code>,这个时候<code>next=i+array[i]</code>.当<code>i=1</code>的时候，能够到达的最远位置可能是<code>i+array[i]</code>,也可能是<code>next</code>,所以我们要取这两个元素的最大值作为<code>next</code>的值.这样只需要遍历一遍数组,我们就得到了每个元素可以达到的最远的位置.最后需要得到的结果是跳跃的次数,那么什么时候需要跳跃呢?设置一个变量<code>current</code>表示当前所在的位置,当<code>current</code>小于<code>i</code>的时候,说明我们已经遍历到了大于<code>current</code>的位置，这个时候就需要跳跃,<code>jump++</code>,然后更新<code>current = next</code>指向最新的位置. 具体实现如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跳跃游戏</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> jump = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(current &lt; i)&#123;</span><br><span class="line">            ++jump;</span><br><span class="line">            current = next;</span><br><span class="line">            <span class="comment">// 判断数组中有小于等于0的时候的情况</span></span><br><span class="line">            <span class="keyword">if</span>(v[current] &lt;= <span class="number">0</span> &amp;&amp; current &lt; v.size()<span class="number">-1</span> &amp;&amp; current &lt; i)&#123;</span><br><span class="line">                <span class="comment">// 遇到0，跳不过去，返回-1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        next = max(next,i+v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jump;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> re = getMin(v);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;re&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子数组的最大累加和">子数组的最大累加和</h2><p><img src="2017-03-21_134743.png" alt="2017-03-21_134743.png"> <img src="2017-03-21_135757.png" alt="2017-03-21_135757.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子数组的最大累加和问题</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.empty())&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">//遍历到v[i]的累加和</span></span><br><span class="line">    <span class="keyword">int</span> maxValue = <span class="number">-10000</span>; <span class="comment">// 遍历到v[i]时最大的累加和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();i++)&#123;</span><br><span class="line">        sum += v[i];</span><br><span class="line">        <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxValue = max(maxValue,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">-2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">-2</span>,<span class="number">6</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;getMaxSum(v)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子数组的最大累加和动态规划">子数组的最大累加和(动态规划)</h2><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:<code>{6,-3,-2,7,-15,1,2,2}</code>,连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1).</p><p>本题使用简单的动态规划算法，时间复杂度O(N)即可达到题目的要求。</p><p><strong>思路</strong> 首先想最一般的方法。对于一个<code>n</code>个元素的数组，它的所有的连续子数组有 <span class="math inline">\(N=\dfrac {n(n+1)} 2\)</span>. 如果用暴力的方法，需要循环N次。每次循环的操作是求解一个区间内元素的和。每次都求和有点浪费时间，这个过程可以优化成预先求解出前<code>k</code>个数的和的数组存储在<code>sum</code>中，这样，假如某次循环我们要求解<code>[i,j]</code>区间的和，直接计算<code>sum[j]-sum[i-1]</code>即可。这样算下来，暴力求解的时间复杂度是<code>O(N)+O(n)=O(N)</code>.</p><p>仔细考虑这个问题，其实可以拆解成一个小规模的问题和一个递推的规则。假设我们已经知道以第<code>k</code>个元素结尾的子数组的最大和是<code>sumk</code>,那么以第<code>k+1</code>个元素结尾的子数组的最大和就只有两种情况：只有第<code>k+1</code>个元素和<code>sumk+array[k+1]</code>. 只需要比较这两个数字的大小就可以确定第<code>k+1</code>个元素结尾的子数组的最大和了。需要注意的是，之所以能用这样的策略，是题目中限定了必须是连续的子数组，所以以<code>k</code>结尾的数组和以<code>k+1</code>结尾的数组是有关联的。下面是用该动态规划的方法解题的代码，时间复杂度是<code>O(n)</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">array</span>.size() == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//用动态规划，可以在O(n)的时间内获得答案</span></span><br><span class="line">    <span class="comment">//设dp[i]表示以i结尾的所有序列的最大的那个和</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(<span class="built_in">array</span>.size(),<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 以第一个元素结尾的所有序列只有array[0]一种，所以无论它是正数，负数，还是零，最大的结果都是array[0]</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> maxSum = <span class="number">-1000000</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">array</span>.size();i++)&#123;</span><br><span class="line">        dp[i] = max(<span class="built_in">array</span>[i],dp[i<span class="number">-1</span>]+<span class="built_in">array</span>[i]);</span><br><span class="line">        maxSum = maxSum &lt; dp[i] ? dp[i] : maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="滑动窗口子数组最大值"><span id="s01">滑动窗口子数组最大值</span></h2><div class="figure"><img src="2017-03-21_090951.png" alt="2017-03-21_090951.png"><p class="caption">2017-03-21_090951.png</p></div><p><strong>思路</strong> 首先容易想到的是暴力的方法,对于长度是<code>n</code>窗口宽度是<code>w</code>的题目来说，需要<code>O(n-m+1)*O(m)</code>的时间复杂度。仔细分析暴力的方法就会发现，窗口每次移动一个位置，有一个元素退出窗口，一个元素进来，如果这两个元素都不是最大值，那么遍历整个窗口内的元素寻找最大值的操作就不是必要的。所以，改进的方式是记录窗口的最大值和最小值。每次滑动窗口的时候，维护这个最大值和最小值即可。这样时间复杂度可以降低到<code>O(n)</code>.窗口最大值和最小值的维护方案：维护一个宽度是<code>w</code>的滑动窗口的双端队列结构。始终在队列的尾部保存最大值的下标，始终在队尾保存最小值的下标。从头到位扫描数组，每扫描一个数，就按照相应的规则更新双端队列，把超出范围的下标出队，找到当前的最大值保存下来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getMaxs(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v,<span class="keyword">int</span> w)&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">int</span>(v.size());++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v.empty())&#123;</span><br><span class="line">            v.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(v[i]&lt;=v[q.back()])&#123;</span><br><span class="line">            v.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            v.pop_back();</span><br><span class="line">            <span class="keyword">if</span>(v.empty())&#123;</span><br><span class="line">                v.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(v[q.back()]&lt;=v[i])&#123;</span><br><span class="line">                    q.pop_back();</span><br><span class="line">                    <span class="keyword">if</span>(q.empty())&#123;</span><br><span class="line">                        q.push_back(i);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                q.push_back(i);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i-w == q.front())&#123;</span><br><span class="line">            q.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=w<span class="number">-1</span>)&#123;</span><br><span class="line">            result.insert(result.end(),v[q.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求滑动窗口做最大值,改进的分支逻辑，减少了if判断</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> * @param w</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getMaxes2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v, <span class="keyword">int</span> w)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;  <span class="comment">// store result</span></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d; <span class="comment">//store index of the array</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!d.empty() &amp;&amp; v[d.back()]&lt;=v[i])&#123;</span><br><span class="line">            <span class="keyword">while</span>(v[d.back()&lt;=v[i]] &amp;&amp; !d.empty())&#123;</span><br><span class="line">                d.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            d.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            d.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i-w == d.front())&#123;</span><br><span class="line">            d.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录结果</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;=w<span class="number">-1</span>)&#123;</span><br><span class="line">            result.insert(result.end(),v[d.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求滑动窗口最小值</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> * @param w</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getMines(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v,<span class="keyword">int</span> w)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; min;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!min.empty() &amp;&amp; v[min.back()]&gt;=v[i])&#123;</span><br><span class="line">            <span class="keyword">while</span>(!min.empty() &amp;&amp; v[min.back()]&gt;=v[i])&#123;</span><br><span class="line">                min.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            min.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            min.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i-w ==min.front())&#123;</span><br><span class="line">            min.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录结果</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;=w<span class="number">-1</span>)&#123;</span><br><span class="line">            result.insert(result.end(),v[min.front()]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, World!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要求滑动窗口的最小值，只需要在判断大小的时候改变一下即可。</p><h2 id="快速求数组连续子数组的最大值和最小值的差">快速求数组连续子数组的最大值和最小值的差</h2><div class="figure"><img src="2017-03-21_091927.png" alt="2017-03-21_091927.png"><p class="caption">2017-03-21_091927.png</p></div><p><strong>思路</strong> 使用两个队列维护区间<code>[i,j]</code>的最大值和最小值。这样根据<a href="#s01">滑动窗口子数组最大值</a>中提到的方法,我们可以高效的计算出区间内最大值和最小值。但是长度为<code>n</code>的数组子数组有<code>N</code>个，不能在<code>O(n)</code>的时间内解决。注意到这里其实有隐含的规律在，如果发现这个规律，可以避免很多不必要的计算，如果有区间<code>[i,j]</code>不满足条件<code>max-min&lt;=somevalue</code>，那么所有包含这个区间的子数组都不可能满足这个条件,因为更大的区间的最大值肯定大于等于<code>max</code>,最小值肯定小于等于<code>min</code>. 应用这个规则，就可以在<code>O(n)</code>的时间内解决问题了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求一个数组的子数组最大值和最小值的差</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; max;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; min;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;v.size())&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 维护max</span></span><br><span class="line">            <span class="keyword">if</span>(!max.empty() &amp;&amp; v[max.front()]&lt;=v[j])&#123;</span><br><span class="line">                <span class="keyword">while</span>(!max.empty() &amp;&amp; v[max.front()&lt;=v[j]])&#123;</span><br><span class="line">                    max.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">                max.push_back(j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                max.push_back(j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//维护min</span></span><br><span class="line">            <span class="keyword">if</span>(!min.empty() &amp;&amp; v[min.front()]&gt;=v[j])&#123;</span><br><span class="line">                <span class="keyword">while</span>(!min.empty() &amp;&amp; v[min.front()&gt;=v[j]])&#123;</span><br><span class="line">                    min.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">                min.push_back(j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                min.push_back(j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断当前数组是否满足条件，如果该数组不满足条件，那么所有包含该数组的将全部不满足条件</span></span><br><span class="line">            <span class="keyword">if</span>(v[max.front()]-v[min.front()]&gt;num)&#123;</span><br><span class="line">                count+=j-i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j==v.size()<span class="number">-1</span>)&#123;</span><br><span class="line">                count+=j-i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        while(!max.empty())&#123;</span></span><br><span class="line"><span class="comment">//            max.pop_back();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        while(!min.empty())&#123;</span></span><br><span class="line"><span class="comment">//            min.pop_back();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;count&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长递增子序列">最长递增子序列</h2><div class="figure"><img src="2017-03-21_092428.png" alt="2017-03-21_092428.png"><p class="caption">2017-03-21_092428.png</p></div><p><strong>思路</strong> 长度为<code>n</code>的数组的所有的子序列的个数是<span class="math inline">\(2^n-1\)</span>, 所以暴力的方法是不用考虑的，除非<code>n</code>特别小的情况下。考虑递增子序列的生成过程，只有新的数字比原来递增子序列的最后一个值大的时候，递增子序列才可以增长1，我们用<code>dp[i]</code>表示在以<code>i</code>结尾的时候，最长的递增子序列长度是<code>leni</code>,那么以<code>i+1</code>结尾的最长递增子序列就很容易求得：如果<code>array[i+1]</code>大于递增子序列的末尾元素，就+1，否则就是原来的<code>leni</code>.</p><script src="https://gist.github.com/FF120/913731d335c7973e4569181d1acf0c7f.js"></script><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最长递增子序列</span></span><br><span class="line"><span class="comment"> * 给定数组arr,返回arr的最长递增子序列。</span></span><br><span class="line"><span class="comment"> * e.g. arr = [2,1,5,3,6,4,8,9,7]  返回 1,3,4,8,9 或 2，3，4，8，9</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getIncrease(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(v.size(),<span class="number">1</span>);<span class="comment">//dp的第一个元素为1，表示以第一个元素结果时，最长递增子序列的长度是1，只包括自己</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;v.size();++i)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j)&#123;</span><br><span class="line">           dp[i] = <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">if</span>(v[j]&lt;v[i])&#123;</span><br><span class="line">               dp[i] = max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();++i)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dp[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    getIncrease(v);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排成一条线的纸牌博弈问题">排成一条线的纸牌博弈问题</h2><div class="figure"><img src="2017-03-21_102624.png" alt="2017-03-21_102624.png"><p class="caption">2017-03-21_102624.png</p></div><p>时间复杂度O(N^2), 空间复杂度O(N^2) 生成两个大小N*N的矩阵 N1的dp[i][j]表示arr[i…j]这个排列上如果A先拿，最终能得到什么分数。 N2的dp[i][j]表示arr[i…j]这个排列上如果B后拿，最终能得到什么分数。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="数组中的最长连续序列">数组中的最长连续序列</h2><div class="figure"><img src="2017-03-21_104858.png" alt="2017-03-21_104858.png"><p class="caption">2017-03-21_104858.png</p></div><p><strong>思路</strong> 容易想到，先排序在遍历一遍，就可以知道最长的连续序列有多长，但是最快速的排序算法也要<code>O(nlogn)</code>的时间复杂度，显然不满足要求。所以，本题不可能是使用排序的方法解决。如果要在<code>O(n)</code>的时间内解决，必须遍历数组常数次。考虑遍历到每个数组元素的时候的操作,比如我们处理的某个数组元素是<code>a</code>，这个时候要判断的是a-1,a-2,…a+1,a+2,…是否在这个数组中，直到有不在数组中的时候，停止计数，这就是所有包含该数字的连续序列的最长的长度。然后处理下一个数字。假设能够在<code>O(1)</code>的时间内判断一个数字是否存在数组中(使用哈希表存储)，O(n)的时间内就能解决这个问题。具体实现参考下面的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组中最长连续序列</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxSeries</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; hs;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : v)&#123;</span><br><span class="line">        hs.insert(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left=v[i]<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(hs.erase(left))&#123;</span><br><span class="line">            count++;</span><br><span class="line">            left--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right=v[i]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(hs.erase(right))&#123;</span><br><span class="line">            count++;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = max(sum,count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算数组的小和">计算数组的小和</h2><div class="figure"><img src="2017-03-21_133320.png" alt="2017-03-21_133320.png"><p class="caption">2017-03-21_133320.png</p></div><p><strong>思路</strong> 采用一个数组<code>sum[i]</code>记录数组<code>array[i]</code>对应的小和，当<code>array[i+1]&gt;array[i]</code>的时候，<code>sum[i+1]=sum[i]+array[i]</code>,当<code>array[i+1]&lt;array[i]</code>的时候，需要回溯到第一个小于array[i+1]的位置，假设是j,sum[i+1]=sum[j]+array[j]. 使用这种方法，时间复杂度最坏不会超过O(n^2).</p><p>使用一种归并排序的思想，时间复杂度可以控制在O（N*logN）,但是不如上面的方法简单直接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMinSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span></span>&#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum(v.size(),<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">int</span> minSum = <span class="number">0</span>;</span><br><span class="line">  sum[<span class="number">0</span>]=v[<span class="number">0</span>];</span><br><span class="line">  minSum += sum[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;v.size();i++)&#123;</span><br><span class="line">     <span class="keyword">if</span>(v[i]&gt;v[i<span class="number">-1</span>])&#123;</span><br><span class="line">       sum[i] = v[i<span class="number">-1</span>]+sum[i<span class="number">-1</span>];</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(v[j]&gt;v[i])&#123;</span><br><span class="line">          j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">           sum[i] = v[j] + sum[j];</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     minSum += sum[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> minSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在数组中找到一个局部最小的位置二分法的应用">在数组中找到一个局部最小的位置(二分法的应用)</h2><div class="figure"><img src="2017-03-21_141706.png" alt="2017-03-21_141706.png"><p class="caption">2017-03-21_141706.png</p></div><p>最容易想到的解法：从头开始遍历数组，一旦遇到<code>a[i-1]&gt;a[i] &amp;&amp; a[i]&lt;a[i+1]</code>的位置,终止遍历,输出i. 最坏的情况下时间复杂度是<code>O(N)</code>.</p><p><em>当一个问题在二分之后，可以明确的知道要求解的结果必定在某一侧时，就可以利用二分法来降低算法的时间复杂度</em>.具体到这个问题,<code>array[0]&lt;array[1]</code>时,<code>array[0]</code>就是局部小,<code>array[n-2]&gt;array[n-1]</code>,<code>array[n-1]</code>就是局部小. 我们讨论区间[1,n-2]的情况. 找到这个区间的中间元素<code>mid=(left+right)/2</code>,如果<code>array[mid]&gt;array[mid-1]</code>，那么局部极小值肯定在mid的左侧,领<code>left=mid-1</code>,继续二分查找.同理,如果<code>array[mid]&gt;array[mid]+1</code>,那么局部极小值一定出现在<code>mid</code>的右侧.为什么呢? 假设我们已经得到了一个左侧的区间<code>[0,mid]</code>,其中0是数组的第一个元素，mid是中间元素，得到array[mid]&gt;array[mid-1],且有a[0]&gt;a[1].可知,两头元素大，中间元素小，局部最小值一定在这个区间,接下来继续使用二分法,直到找出这个元素即可。因为本体要求的是找出任意一个局部极小值，所以可以使用这样的方法来加快速度,如果是要找出所有的局部极小值，二分的方法就没有优势了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 找到任意一个局部最小的位置并返回索引</span></span><br><span class="line"><span class="comment"> * 从左边开始，如果第二个数比第一个数小，第二个数是局部最小</span></span><br><span class="line"><span class="comment"> * 从右边开始，如果第二个数比第一个数小，第二个数是局部最小</span></span><br><span class="line"><span class="comment"> * 如果数组是空 ，没有局部最小</span></span><br><span class="line"><span class="comment"> * 如果数组只有一个数，这个数就是局部最小</span></span><br><span class="line"><span class="comment"> * else  局部最小就是两边挨着的数都比它大</span></span><br><span class="line"><span class="comment"> * 这里规定这个数组任意相邻的数都不相等</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMinPart</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v.size() == <span class="number">1</span>) <span class="keyword">return</span> v[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(v[<span class="number">0</span>]&gt;v[<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v[v.size()<span class="number">-1</span>]&lt;v[v.size()<span class="number">-2</span>]) <span class="keyword">return</span> v.size()<span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=v.size()<span class="number">-2</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i<span class="number">-1</span>]&gt;v[i] &amp;&amp; v[i] &lt; v[i+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 如果没有局部最小值，返回-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;getMinPart2(v)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组中子数组的最大累乘积">数组中子数组的最大累乘积</h2><div class="figure"><img src="2017-03-21_150344.png" alt="2017-03-21_150344.png"><p class="caption">2017-03-21_150344.png</p></div><p>解法： 分别求以v[i]结尾的子数组的最大累成积，dp[i], dp[i]可以由dp[i-1]求出来，所以整体的时间复杂度是O（N） 因为最后的结果是求做大累乘积，而dp[i]只和dp[i-1]有关系，所以可以不用维护动态规划表， 空间复杂度可以降低到O（1）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求数组的最大子数组累乘积</span></span><br><span class="line"><span class="comment"> * 暴力的方法，就是枚举所有的子数组，计算子数组的累乘，然后取最大值</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getMaxC</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.empty())  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> maxC = <span class="number">-1000</span>;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();++i)&#123;</span><br><span class="line">        sum  = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;v.size();++j)&#123;</span><br><span class="line">            sum = sum * v[j];</span><br><span class="line">            maxC = max(maxC,sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxC;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 暴力的方法需要的时间复杂度是2重循环，是O(N**2)</span></span><br><span class="line"><span class="comment"> * 下面用记录最大累乘和最小累乘值的方法做，时间复杂度是O(N)</span></span><br><span class="line"><span class="comment"> * 1. 所有的子数组必然以v[i]结尾，首先计算v[0]结尾的最大值和最小值，都是v[0]</span></span><br><span class="line"><span class="comment"> * 2. 以v[i]结尾的数组的最大值的情况有这样几种；</span></span><br><span class="line"><span class="comment"> * max*v[i] ; min*v[i], v[i] 分别对应 v[i]正，负 和dp[i-1]是0的情况</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getMaxC2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> maxValue = v[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">double</span> minValue = v[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">double</span> dpi = v[<span class="number">0</span>]; <span class="comment">// 存放前一个的结果</span></span><br><span class="line">    <span class="keyword">double</span> maxEnd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> minEnd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;v.size();++i)&#123;</span><br><span class="line">        maxEnd = maxValue * v[i];</span><br><span class="line">        minEnd = minValue * v[i];</span><br><span class="line">        maxValue = max(max(maxEnd,minEnd),v[i]);</span><br><span class="line">        minValue = min(min(maxEnd,minEnd),v[i]);</span><br><span class="line">        dpi = max(dpi,maxValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dpi;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; v=&#123;<span class="number">-2.5</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0.5</span>,<span class="number">-8</span>,<span class="number">8</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;getMaxC(v)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;getMaxC2(v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不包含本位置位的累乘数组">不包含本位置位的累乘数组</h2><div class="figure"><img src="2017-03-21_161557.png" alt="2017-03-21_161407.png"><p class="caption">2017-03-21_161407.png</p></div><p>如果可以使用除法，那么问题很简单，先求累乘，再除以v[i]. (不包含0的情况) 如果数组中有一个0，则0位置上是累乘，其他位置是0 如果数组中有两个及以上的0， 则所有位置都是0；</p><p>如果不能使用除法运算，可以考虑除去自己的乘积，就是从左边乘到v[i-1] 再从右边乘到v[i+1];</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不包含本位置位的累乘数组,可以使用除法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getC(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : v)&#123;</span><br><span class="line">        sum *= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;v.size();++i)&#123;</span><br><span class="line">        v[i] = sum / v[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVecor</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : v)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不使用除法的版本</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getC2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lr;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rl;</span><br><span class="line">    <span class="keyword">int</span> lrsum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> rlsum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();i++)&#123;</span><br><span class="line">        lrsum *= v[i];</span><br><span class="line">        lr.push_back(lrsum);</span><br><span class="line">        rlsum *= v[v.size()<span class="number">-1</span>-i];</span><br><span class="line">        rl.push_back(rlsum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rl2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=v.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        rl2.push_back(rl[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    v[<span class="number">0</span>] = rl2[<span class="number">1</span>];</span><br><span class="line">    v[v.size()<span class="number">-1</span>] = lr[v.size()<span class="number">-2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;v.size()<span class="number">-1</span>;++i)&#123;</span><br><span class="line">        v[i] = lr[i<span class="number">-1</span>] * rl2[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 减少空间复杂度的版本</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getC3(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re(v);</span><br><span class="line">    re[<span class="number">0</span>] = v[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;v.size()<span class="number">-1</span>;++i)&#123;</span><br><span class="line">        re[i] = re[i<span class="number">-1</span>] * v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=v.size()<span class="number">-1</span>;i&gt;<span class="number">0</span>;--i)&#123;</span><br><span class="line">        re[i] = re[i<span class="number">-1</span>] * tmp ;</span><br><span class="line">        tmp *= v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    re[<span class="number">0</span>] = tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> result = getC(v);</span><br><span class="line">    <span class="keyword">auto</span> result2 = getC2(v);</span><br><span class="line">    <span class="keyword">auto</span>  result3 = getC3(v);</span><br><span class="line">    printVecor(result);</span><br><span class="line">    printVecor(result2);</span><br><span class="line">    printVecor(result3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组的partition调整">数组的partition调整</h2><p><img src="2017-03-21_200734.png" alt="2017-03-21_200734.png"> 都用到了用下标指示不同的分区的思想。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setV</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;v.size();++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i]&gt;v[u])&#123;</span><br><span class="line">            swap(v[i],v[u+<span class="number">1</span>]);</span><br><span class="line">            u++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortV</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.empty()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = v.size();</span><br><span class="line">    <span class="keyword">while</span>(index &lt; right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[index] == <span class="number">0</span>)&#123;</span><br><span class="line">            swap(v[++left],v[index++]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(v[index] == <span class="number">2</span>)&#123;</span><br><span class="line">            swap(v[index],v[--right]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> a: v)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    setV(v);</span><br><span class="line">    print(v);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2 = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    sortV(v2);</span><br><span class="line">    print(v2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="数组中未出现的最小正整数">数组中未出现的最小正整数</h2><p><img src="2017-03-21_213108.png" alt="2017-03-21_213108.png"> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个无序的整形数组，找到数组中未出现的最小正整数。</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">missNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = v.size();</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[l] == l+<span class="number">1</span>)&#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(v[l] &lt;= l || v[l] &gt; r || v[v[l]-l] == v[l])&#123;</span><br><span class="line">            v[l] = v[--r];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            swap(v[l],v[v[l]-l]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1 = &#123;<span class="number">-1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;missNum(v1)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;missNum(v2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="数组排序之后相邻数字的最大差值">数组排序之后相邻数字的最大差值</h2><div class="figure"><img src="2017-03-21_213346.png" alt="2017-03-21_213346.png"><p class="caption">2017-03-21_213346.png</p></div><p><img src="2017-03-21_213648.png" alt="2017-03-21_213648.png"> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// 计算数num应该放入哪个桶里面</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bucket</span><span class="params">(<span class="keyword">long</span> num,<span class="keyword">long</span> len,<span class="keyword">long</span> min,<span class="keyword">long</span> max)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) ( (num-min)*len/(max-min) );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxGap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.empty() || v.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = v.size();</span><br><span class="line">    <span class="keyword">int</span> minValue = INT32_MAX;</span><br><span class="line">    <span class="keyword">int</span> maxValue = INT32_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">        minValue = min(minValue,v[i]);</span><br><span class="line">        maxValue = max(maxValue,v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(minValue == maxValue)  <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果数组的最大值==最小值，说明只有一种元素，那间隔为0</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; hasNum(len+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxes(len+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mines(len+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> bid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">        bid = bucket(v[i],len,minValue,maxValue);</span><br><span class="line">        mines[bid] = hasNum[bid] ? min(mines[bid],v[i]) : v[i];</span><br><span class="line">        maxes[bid] = hasNum[bid] ? max(maxes[bid],v[i]) : v[i];</span><br><span class="line">        hasNum[bid] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lastMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=len)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hasNum[i++])&#123;</span><br><span class="line">            lastMax = maxes[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hasNum[i])&#123;</span><br><span class="line">            res = max(res,mines[i]-lastMax);</span><br><span class="line">            lastMax = maxes[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> a:v)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;maxGap(v)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="找到出现50以上的数字">找到出现50%以上的数字</h2><p>思路就是每次删除两个不同的数字，那么最后一定会剩下那个出现次数大于一半的数字。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 选出数组中出现次数大于一半的数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cand = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">                cand = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == cand) count++;</span><br><span class="line">            <span class="keyword">else</span> count--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == cand)&#123;</span><br><span class="line">                times ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(times &gt; len /<span class="number">2</span>)&#123;<span class="keyword">return</span> cand;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="找到出现次数在nk次以上的数字">找到出现次数在N/K次以上的数字</h2><p>每次删除数组中K个不同的数字。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每次删除数组中K个不同的数字，返回剩下的数字</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; deleteK(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v,<span class="keyword">int</span> k)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; record; <span class="comment">// key : cands  value: times</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(record.find(v[i]) != record.end())&#123;</span><br><span class="line">            record[v[i]] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(record.size() == k<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">//所有候选减1，并把是0的删除</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> aa : record)&#123;</span><br><span class="line">                aa.second--;</span><br><span class="line">                <span class="keyword">if</span>(aa.second == <span class="number">0</span>)&#123;</span><br><span class="line">                    record.erase(aa.first);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            record[v[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ss : record)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ss.first&lt;&lt;<span class="string">" "</span>&lt;&lt;ss.second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="求直方图的最大连续面积">求直方图的最大连续面积</h2><p>题目：给定一个正整数数组arr,把每个数字看作直方图的高，宽度都是1，返回连续的最大面积。 例如，arr = [2,3,4,2,7,8,4] 返回 17 ，7和8组成的面积是14，最大。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直方图求面积的题</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v=&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.empty()||v[s.top()]&lt;v[i])&#123;</span><br><span class="line">            s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>( !s.empty() &amp;&amp;v[s.top()]&gt;=v[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> j = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="keyword">int</span> k = s.empty()?<span class="number">-1</span>:s.top();</span><br><span class="line">                <span class="keyword">int</span> area = (i-k<span class="number">-1</span>)*v[j];</span><br><span class="line">                result.insert(result.end(),area);</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:result)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> a=max(result.begin(),result.end());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Largest Rectangle in Histogram</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRetangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;height)</span></span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        height.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;height.size();)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.empty() || height[i]&gt;height[s.top()])&#123;</span><br><span class="line">                s.push(i++);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                result = max(result,height[tmp]*(s.empty()?i:<span class="number">1</span> -s.top()<span class="number">-1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    Solution s;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s.largestRetangleArea(a)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Largest Rectangle in Histogram</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRetangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;height)</span></span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        height.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;height.size();)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.empty() || height[i]&gt;height[s.top()])&#123;</span><br><span class="line">                s.push(i++);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                result = max(result,height[tmp]*(s.empty()?i:<span class="number">1</span> -s.top()<span class="number">-1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    Solution s;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s.largestRetangleArea(a)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="换钱的最少货币数量">换钱的最少货币数量</h2><p><img src="2017-03-22_102806.png" alt="2017-03-22_102806.png"> <img src="2017-03-22_102836.png" alt="2017-03-22_102836.png"> 原问题和补充问题都可以用动态规划做。 原问题的dp[i][j]表示 在可以任意使用arr[0…i]货币的情况下，做成面值j需要 的最小货币数量</p><p>补充问题的dp[i][j]表示，在可以任意使用arr[0…i]的情况下，组成面值j所需要的 最小张数，注意这里的每个数字仅代表一张，不能重复使用。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *给定数组arr, 整数aim arr中的整数不重复，每个数字代表一种面值的货币，求组成aim的最少张数</span></span><br><span class="line"><span class="comment"> * e.g. arr=[5,2,3] aim = 20  输出 4</span></span><br><span class="line"><span class="comment"> * arr=[3,5] aim=2  找不开的情况输出-1</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> * @param aim</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v, <span class="keyword">int</span> aim)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(v.size(),<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(aim+<span class="number">1</span>));</span><br><span class="line">    <span class="comment">//初始化第一列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();++i)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化第一行,不能找开的情况设置为1000,只要这个数是整数并且足够大就可以。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=aim;++j)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = j%v[<span class="number">0</span>]==<span class="number">0</span> ? j / v[<span class="number">0</span>] : <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;v.size();++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=aim;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j-v[i]]&lt;<span class="number">0</span> &amp;&amp; dp[i<span class="number">-1</span>][j])&#123;</span><br><span class="line">                dp[i][j] = <span class="number">1000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dp[i][j-v[i]]&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i][j - v[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出动态规划表格</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dp.size();++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;dp[<span class="number">0</span>].size();++j)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;dp[i][j]&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[v.size()<span class="number">-1</span>][aim];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> aim = <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;getMin(v,aim)&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定整数数组arr 和 整数aim arr中的数字可以重复，每个数字代表一张相应面额的货币，</span></span><br><span class="line"><span class="comment"> * 求组成aim的最少张数</span></span><br><span class="line"><span class="comment"> * e.g. arr=[5,2,3] aim=20 无法组成</span></span><br><span class="line"><span class="comment"> * arr = [5,2,5,3] aim = 10 输出2</span></span><br><span class="line"><span class="comment"> * arr = [5,2,5,3] aim = 0  输出0</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> * @param aim</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v,<span class="keyword">int</span> aim)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(v.size(),<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(aim+<span class="number">1</span>));</span><br><span class="line">    <span class="comment">//初始化第一列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();++i)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//组成0需要任何货币0张就够了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化第一行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=aim;++j)&#123;</span><br><span class="line">        <span class="comment">// 除了能组成和v[0]一样面值的货币，其他的都无法组成，因为v[0]只有一张</span></span><br><span class="line">        dp[<span class="number">0</span>][j] = j == v[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">10000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;v.size();++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=aim;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j-v[i]]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = min(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-v[i]]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印动态规划表格</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dp.size();++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;dp[<span class="number">0</span>].size();++j)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;dp[i][j]&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[v.size()<span class="number">-1</span>][aim];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> aim = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; getMin(v,aim)&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="换钱的方法数">换钱的方法数</h2><p><img src="2017-03-22_105837.png" alt="2017-03-22_105837.png"> 使用动态规划的方法，dp[i][j]表示在使用arr[0…i]货币的情况下，组成j有多少中情况。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v,<span class="keyword">int</span> aim)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(v.size(),<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(aim+<span class="number">1</span>));</span><br><span class="line">    <span class="comment">//初始化第一列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();++i)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化第一行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=aim;j++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = j%v[<span class="number">0</span>]==<span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;v.size();++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=aim;++j)&#123;</span><br><span class="line">            dp[i][j] = j-v[i]&gt;=<span class="number">0</span> ? dp[i<span class="number">-1</span>][j]+dp[i][j-v[i]] : dp[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印动态规划表格</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dp.size();++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;dp[<span class="number">0</span>].size();++j)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;dp[i][j]&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[v.size()<span class="number">-1</span>][aim];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> aim = <span class="number">7</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; getNum(v,aim) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="判断字符数组中是否所有的字符都只出现一次">判断字符数组中是否所有的字符都只出现一次</h2><div class="figure"><img src="2017-03-22_111143.png" alt="2017-03-22_111143.png"><p class="caption">2017-03-22_111143.png</p></div><ul><li>使用哈希表统计字符个数即可</li><li>第二个要求，使用非递归的方式实现堆排序，然后统计相邻的字符是否重复就可以了。</li></ul><h2 id="数组中两个字符串的最小距离">数组中两个字符串的最小距离</h2><p><img src="2017-03-22_112158.png" alt="2017-03-22_112158.png"> <img src="2017-03-22_112307.png" alt="2017-03-22_112307.png"> <img src="2017-03-22_134025.png" alt="2017-03-22_134025.png"></p><h2 id="找到最长回文子串">找到最长回文子串</h2><p><img src="2017-03-22_141453.png" alt="2017-03-22_141453.png"> <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="450" src="//music.163.com/outchain/player?type=0&id=631401164&auto=1&height=430"></iframe></p><h2 id="统计数组中每个数字前面比自己小的数字有多少个">统计数组中每个数字前面比自己小的数字有多少个</h2><p>保证都是正整数，没有重复的数字，例如输入 [2,7,4,6,5,3,1] 输出：[0,1,1,2,2,1,0] <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node(<span class="keyword">int</span> _start, <span class="keyword">int</span> _end) :</span><br><span class="line">            start(_start), end(_end), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>),</span><br><span class="line">            cnt(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start, end;</span><br><span class="line">    Node *left, *right;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * @param A: An integer array</span></span><br><span class="line"><span class="comment">      * @return: Count the number of element before this element 'ai' is</span></span><br><span class="line"><span class="comment">      *          smaller than it and return count number array</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countOfSmallerNumberII(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A) &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        Node *root = build(<span class="number">0</span>, <span class="number">20000</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = query(root, <span class="number">0</span>, A[i] - <span class="number">1</span>);</span><br><span class="line">            res.push_back(cnt);</span><br><span class="line">            <span class="comment">// 更新计数下标是i的计数</span></span><br><span class="line">            modify(root, A[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">Node *<span class="title">build</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (start == end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(start, end);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Node *root = <span class="keyword">new</span> Node(start, end);</span><br><span class="line">        root-&gt;left = build(start, mid);</span><br><span class="line">        root-&gt;right = build(mid + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(Node *root, <span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;start == root-&gt;end &amp;&amp; root-&gt;start == idx)</span><br><span class="line">        &#123;</span><br><span class="line">            ++(root-&gt;cnt);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = root-&gt;start + ((root-&gt;end - root-&gt;start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (mid &gt;= idx)</span><br><span class="line">        &#123;</span><br><span class="line">            modify(root-&gt;left, idx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            modify(root-&gt;right, idx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root-&gt;cnt = root-&gt;left-&gt;cnt + (root-&gt;right ? root-&gt;right-&gt;cnt : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(Node *root, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;end &lt; start || root-&gt;start &gt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;start &gt;= start &amp;&amp; root-&gt;end &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;cnt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = root-&gt;start + ((root-&gt;end - root-&gt;start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (mid &gt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> query(root-&gt;left, start, end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mid &lt; start)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> query(root-&gt;right, start, end);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftRes = query(root-&gt;left, start, mid);</span><br><span class="line">        <span class="keyword">int</span> rightRes = query(root-&gt;right, mid + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leftRes + rightRes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    Solution s;</span><br><span class="line">    <span class="keyword">auto</span> re = s.countOfSmallerNumberII(v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="统计数组中每个数字后面比自己小的数字有多少个">统计数组中每个数字后面比自己小的数字有多少个</h2><p>保证都是正整数，没有重复的数字，例如输入 [2,7,4,6,5,3,1] 输出：[1,5,2,3,2,1,0]</p><p>这个可以调用上面的函数实现 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countOfSmallerNumberBack(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)&#123;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(A);</span><br><span class="line">       <span class="keyword">int</span> len = A.size();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">           tmp[i] = A[len<span class="number">-1</span>-i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re = countOfSmallerNumberII(tmp);</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result(re);</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">           result[i] = re[len<span class="number">-1</span>-i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h2 id="一个有重复数字的整数数组求包含所有的数字的最短的连续序列的长度">一个有重复数字的整数数组，求包含所有的数字的最短的连续序列的长度</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMinUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = v.size();</span><br><span class="line">    <span class="comment">//统计独立的数字的个数</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; se;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();i++)&#123;</span><br><span class="line">        se.insert(v[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ulen = se.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; count;</span><br><span class="line">    <span class="keyword">int</span> res = len; <span class="comment">// 存放结果，最坏的情况下是数组的长度，结果肯定不会大于这个值</span></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="keyword">while</span>(t&lt;len &amp;&amp; num &lt;ulen)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count[v[t++]]++ == <span class="number">0</span>)&#123;</span><br><span class="line">                num ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; ulen) <span class="keyword">break</span>;</span><br><span class="line">        res = min(res,t-s);</span><br><span class="line">        <span class="keyword">if</span>(--count[v[s++]] == <span class="number">0</span>)&#123;</span><br><span class="line">            num--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="连续整数和">连续整数和</h2><p>每一个正整数 N 都能表示成若干个连续正整数的和，例如10可以表示成1+2+3+4，15可以表示成4+5+6，8可以表示成8本身。我们称这种表示方法为SCI(Sum of Consecutive Integers)表示法。</p><p>小Hi发现一个整数可能有很多种SCI表示，例如15可以表示成1+2+3+4+5，4+5+6，7+8以及15本身。小Hi想知道N的所有SCI表示中，最多能包含多少个连续正整数。例如1+2+3+4+5是15包含正整数最多的表示。</p><p><a href="http://hihocoder.com/problemset/problem/1543?sid=1145912" target="_blank" rel="noopener">hihocoder 1453</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回整数n的所有SCI表示法</span></span><br><span class="line"><span class="comment"> * 就是连续整数和等于n</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 思路是利用等差数列的求和公式</span></span><br><span class="line"><span class="comment"> * @param n</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SCI</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> maxn = <span class="built_in">sqrt</span>(<span class="number">2</span>*num);</span><br><span class="line">    <span class="keyword">int</span> max_n = (<span class="keyword">int</span>)(maxn + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// i个连续的数字的和是num,求首元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = max_n; i&gt;=<span class="number">2</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span>*num % i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> a02 = <span class="number">2</span>*num / i + <span class="number">1</span> - i;</span><br><span class="line">            <span class="keyword">if</span>(a02 &lt; <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(a02 % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> a0 = a02 / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T,num;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">        <span class="keyword">int</span> re = SCI(num);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;re&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集合的子集问题">集合的子集问题</h2><p>给定一个包含N个整数的集合S={A1, A2, … AN}，以及一个给定的整数K，请计算有多少个S的子集满足其中的最大值与最小值的和小于等于K。</p><p>例如对于S={4, 2, 5, 8}以及K=7,满足的条件的子集有以下4个:{2}, {2, 4}, {2, 5}, {2, 4, 5}。</p><p><a href="http://hihocoder.com/problemset/problem/1546" target="_blank" rel="noopener">hihocoder 1546</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Montgomery</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b,<span class="keyword">long</span> <span class="keyword">long</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(b &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> r=<span class="number">1</span>;</span><br><span class="line">    a %=m;</span><br><span class="line">    <span class="keyword">while</span>(b&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((b&amp;<span class="number">1</span>)!=<span class="number">0</span>)</span><br><span class="line">            r = (r*a)%m;</span><br><span class="line">        a = (a*a)%m;</span><br><span class="line">        b/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (r*a)%m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">min_max</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    sort(v.begin(),v.end());</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = v.size() - <span class="number">1</span>, m = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[l] + v[r] &lt;= k)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> sum = Montgomery(<span class="number">2</span>,(r-l),m);</span><br><span class="line">            res = (res + sum ) % m;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n&gt;&gt; k;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(n,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> re = min_max(v,k);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;re&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习_使用autoencoder自动提取特征</title>
      <link href="/hexoblog/2017/04/27/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_%E4%BD%BF%E7%94%A8autoencoder%E8%87%AA%E5%8A%A8%E6%8F%90%E5%8F%96%E7%89%B9%E5%BE%81/"/>
      <url>/hexoblog/2017/04/27/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_%E4%BD%BF%E7%94%A8autoencoder%E8%87%AA%E5%8A%A8%E6%8F%90%E5%8F%96%E7%89%B9%E5%BE%81/</url>
      
        <content type="html"><![CDATA[<p>autoencoder自动提取特征的原理是使用输入数据作为输出标签训练数据，中间层的神经元的数目小于特征数目，使用中间层的神经元的输出作为特征，这样就达成一个特征空间变换和降维的目的。本质上它是通过一种非线性的变换函数在转换特征空间。 <a id="more"></a></p><h2 id="实现一个最简单的自动特征提取器">实现一个最简单的自动特征提取器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 准备数据</span></span><br><span class="line">X_root = <span class="string">r'd:/X.npy'</span></span><br><span class="line">X = np.load(X_root)</span><br><span class="line">root = <span class="string">r'D:\FMRI_ROOT\YIYU\CONN\conn_project04\meresult'</span><span class="comment">#####################</span></span><br><span class="line">y_path = <span class="string">r'y.npy'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据转成python格式</span></span><br><span class="line">data_root = os.path.join(root,<span class="string">'data'</span>)</span><br><span class="line">y = np.load(os.path.join(data_root,y_path))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> cross_validation</span><br><span class="line">test_size = <span class="number">0.3</span></span><br><span class="line">X_train, X_test, y_train, y_test = cross_validation.train_test_split(X,y,test_size=test_size, random_state=<span class="number">0</span>)</span><br><span class="line">print(X_train.shape, y_train.shape)</span><br><span class="line">print(X_test.shape, y_test.shape)</span><br><span class="line"><span class="comment">###############################################################################</span></span><br><span class="line"><span class="comment">###############################################################################</span></span><br><span class="line"><span class="comment"># 定义神经网络的结构</span></span><br><span class="line">encoding_dim = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># this is our input placeholder</span></span><br><span class="line">input_img = Input(shape=(<span class="number">4298</span>,))</span><br><span class="line"></span><br><span class="line">encoded = Dense(<span class="number">1000</span>, activation=<span class="string">'relu'</span>)(input_img)</span><br><span class="line">encoded = Dense(<span class="number">100</span>, activation=<span class="string">'relu'</span>)(encoded)</span><br><span class="line">encoded = Dense(encoding_dim, activation=<span class="string">'relu'</span>)(encoded)</span><br><span class="line"></span><br><span class="line">decoded = Dense(<span class="number">100</span>, activation=<span class="string">'relu'</span>)(encoded)</span><br><span class="line">decoded = Dense(<span class="number">1000</span>, activation=<span class="string">'relu'</span>)(decoded)</span><br><span class="line">decoded = Dense(<span class="number">4298</span>, activation=<span class="string">'sigmoid'</span>)(decoded)</span><br><span class="line"></span><br><span class="line">autoencoder = Model(input_img, decoded)</span><br><span class="line"></span><br><span class="line">encoder = Model(input_img, encoded)</span><br><span class="line"></span><br><span class="line">encoded_input = Input(shape=(encoding_dim,))</span><br><span class="line">decoder_layer1 = autoencoder.layers[<span class="number">-3</span>](encoded_input)</span><br><span class="line">decoder_layer2 = autoencoder.layers[<span class="number">-2</span>](decoder_layer1)</span><br><span class="line">decoder_layer3 = autoencoder.layers[<span class="number">-1</span>](decoder_layer2)</span><br><span class="line">decoder = Model(encoded_input, decoder_layer3)</span><br><span class="line"></span><br><span class="line">autoencoder.compile(optimizer=<span class="string">'adadelta'</span>, loss=<span class="string">'binary_crossentropy'</span>)</span><br><span class="line"></span><br><span class="line">autoencoder.fit(X_train, X_train,</span><br><span class="line">                epochs=<span class="number">100</span>,</span><br><span class="line">                batch_size=<span class="number">256</span>,</span><br><span class="line">                shuffle=<span class="literal">True</span>,</span><br><span class="line">                validation_data=(X_test, X_test))</span><br><span class="line"></span><br><span class="line">save_model(autoencoder,<span class="string">'autoencoder'</span>)</span><br><span class="line">save_model(encoder,<span class="string">'encoder'</span>)</span><br><span class="line">save_model(decoder,<span class="string">'decoder'</span>)</span><br><span class="line"><span class="comment">## 加载保存的模型</span></span><br><span class="line">autoencoder = load_model(<span class="string">"autoencoder"</span>)</span><br><span class="line">encoder = load_model(<span class="string">"encoder"</span>)</span><br><span class="line">decoder = load_model(<span class="string">"decoder"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 使用训练好的模型</span></span><br><span class="line">encoded_imgs = encoder.predict(X_test)</span><br><span class="line">decoded_imgs = decoder.predict(encoded_imgs)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 使用分类器分类</span></span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line">svc_linear =  SVC(C=<span class="number">1</span>,kernel=<span class="string">"linear"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> KFold</span><br><span class="line">cv = KFold(y_test.shape[<span class="number">0</span>], n_folds=<span class="number">10</span>)</span><br><span class="line">score_linear_svc = []</span><br><span class="line"><span class="keyword">for</span> train,test <span class="keyword">in</span> cv:</span><br><span class="line">        <span class="comment"># ----------------------------------------------------------</span></span><br><span class="line">        svc_linear.fit(encoded_imgs[train],y_test[train])</span><br><span class="line">        score_linear_svc.append( svc_linear.score(encoded_imgs[test],y_test[test]) )</span><br><span class="line"></span><br><span class="line">print(np.mean(score_linear_svc))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> autoencoder </tag>
            
            <tag> fmri </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习_卷积神经网络</title>
      <link href="/hexoblog/2017/04/20/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>/hexoblog/2017/04/20/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<p>卷积神经网络不同于前面介绍的反向传播算法中介绍的神经网络，那样的神经网络是全连接的，层与层之间每两个节点之间都有连接。这样的网络层数多了之后，参数就会指数级增长，变得难以训练。 卷积神经网络是以一定的规则规定了层与层之间的连接，只有满足特定要求的连接才存在，不满足的不存在。卷积神经网络比较擅长处理输入是图像的数据。 <a id="more"></a></p><h2 id="卷积">卷积</h2><p>参考内容：https://arxiv.org/pdf/1603.07285.pdf</p><p>卷积网络中的概念： http://www.datakit.cn/blog/2016/03/23/bp_cnn.html</p><p>简单卷积的计算：</p><p>卷积核：</p><div class="figure"><img src="2017-04-20_202354.png"></div><p>计算过程：</p><div class="figure"><img src="2017-04-20_202310.png"></div><p>上面示例的卷积叫做<code>2-D convolution</code>,通过这个例子，我们也可以很容易明白<code>3-D convolution</code>甚至<code>N-D convolution</code>的含义。</p><p>下面介绍几个符号的含义：</p><ul><li><code>input feature map</code> : 上图中亮蓝色所示的数据。</li><li><code>output feature maps</code> : 上图中输出的3*3的矩阵</li><li><span class="math inline">\(n\)</span> : number of output feature maps;</li><li><span class="math inline">\(m\)</span> : number of input feature maps;</li><li><span class="math inline">\(k_j\)</span> : kernel size along axis j:</li><li><span class="math inline">\(i_j\)</span> : input size along axis j,</li><li><span class="math inline">\(s_j\)</span> : stride (distance between two consecutive positions of the kernel) along axis j,</li><li><span class="math inline">\(p_j\)</span> : zero padding (number of zeros concatenated at the beginning and at the end of an axis) along axis j.</li></ul><p>下面看一个具体的例子：</p><p><span class="math inline">\(N = 2, i_1 = i_2 = 5, k_1 = k_2 = 3, s_1 = s_2 = 2, p_1 = p_2 = 1\)</span></p><p>解析上面参数的含义：</p><ul><li><span class="math inline">\(i_1 = i_2 = 5\)</span> ： 说明input feature maps是一个5*5的矩阵。</li><li><span class="math inline">\(k_1 = k_2 = 3\)</span> : 说明kernel是一个3*3的矩阵</li><li><span class="math inline">\(s_1 = s_2 = 2\)</span> : 说明在水平方向和在竖直方向上，kernel每次移动2个单元的距离。</li><li><span class="math inline">\(p_1 = p_2 = 1\)</span> : 说明在水平方向和竖直方向上各有一个单位的padding.</li><li><span class="math inline">\(N = 2\)</span> : 说明有2个output feature maps</li></ul><p>具体的实例和计算的过程可以看下图：</p><div class="figure"><img src="2017-04-20_204237.png"></div><h3 id="pooling">pooling</h3><p>除了卷积之外，cnn还有一个核心的概念，子抽样(subsampling)，一般用pooling来表示。pooling的种类有很多种，主要是用一个特征来表达一个局部特征，这样使得参数大为减少。常见的有max pooling和mean pooling，L2 pooling。max pooling就是用局部特征的最大值来表达这个区域的特征。</p><div class="figure"><img src="2017-04-21_092850.png"></div><div class="figure"><img src="2017-04-21_092917.png"></div><h3 id="各种类型的卷积的计算">各种类型的卷积的计算</h3><p><strong>一维卷积</strong></p><div class="figure"><img src="2017-04-21_094638.png"></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算1D卷积</span></span><br><span class="line"><span class="comment"># a array_like, (m,)</span></span><br><span class="line"><span class="comment"># b array_like, (n,)</span></span><br><span class="line"><span class="comment"># stride 步长</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv1D</span><span class="params">(a,b,stride=<span class="number">1</span>)</span>:</span></span><br><span class="line">    klen = kernel_a.shape[<span class="number">0</span>]</span><br><span class="line">    result=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,a.shape[<span class="number">0</span>]-klen+<span class="number">1</span>,stride):</span><br><span class="line">        result.append(sum(a[i:(i+klen)]*kernel_a))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">0</span>])</span><br><span class="line">b = np.array([<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>])</span><br><span class="line">resultl = conv1D(a,b,stride=<span class="number">1</span>)</span><br><span class="line">resultr = conv1D(a,b,stride=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><strong>二维卷积</strong></p><p>一个最简单的例子：</p><div class="figure"><img src="2017-04-21_093356.png"></div><p>步长是2的一个例子：</p><div class="figure"><img src="2017-04-21_093927.png"></div><p><strong>三维卷积</strong></p><div class="figure"><img src="2017-04-21_094749.png"></div>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习_使用keras实现autoencoder</title>
      <link href="/hexoblog/2017/04/20/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_%E4%BD%BF%E7%94%A8keras%E5%AE%9E%E7%8E%B0autoencoder/"/>
      <url>/hexoblog/2017/04/20/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_%E4%BD%BF%E7%94%A8keras%E5%AE%9E%E7%8E%B0autoencoder/</url>
      
        <content type="html"><![CDATA[<p>autoencoder是利用神经网络来自动提取有意义的特征的一种方法，它的基本思想是这样的： 输入和输出层拥有一样的神经元的数目，都等于数据的输入维数。中间拥有若干个隐含层，隐含层的神经元的数目要小于输入维数。使用输入作为输出训练整个神经网络，最后会得到一个<span class="math inline">\(f(x)=x\)</span>的等式。观察训练好的神经网络，最后的输出是经过比输入的数据的维数更少的数据得到的，所以，中间隐含层的数据表示就是原来输入数据的某种抽象，因为压缩了数据的维数，所以是一种降维的方法。当然，也可以使输入输出的维数远远小于中间隐含层的维数，这样会得到低维数据的高维表示。 <a id="more"></a> 参考资料：https://blog.keras.io/building-autoencoders-in-keras.html</p><p>keras是一个抽象层次较高的深度学习框架，它以theano和tensorflow作为后端实现，使用她可以很方便的实现多种不同的autoencoder. ## 最简单的单层编码解码机 我们使用手写数字识别的数据构造一个简单的自动编码机。目的是给数据降维。我们构造一个三层的神经网络，输入层包含<code>28*28 = 784</code> 个神经元，中间的隐含层包含<code>4*4 = 16</code> 个神经元,输出层包含<code>28*28 = 784</code> 个神经元。然后把手写数字识别的数据去掉标签，后者说是把标签设置为自己的输入，然后训练该神经网络，就会得到一个把<code>28*28</code>的灰度图像映射到<code>4*4</code>的灰度图像的映射，通过后面两层神经网络，我们可以根据<code>4*4</code>的数据恢复原来的<code>28*28</code>的图像，如果恢复的图像的质量还不错，就能够说明神经网络自动学习到的压缩方法确实是很不错的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Input, Dense</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Model</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> regularizers</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_model</span><span class="params">(model,name)</span>:</span></span><br><span class="line">    <span class="comment">## fit完成之后，保存整个模型的配置</span></span><br><span class="line">    root_path = <span class="string">r'd:\deeplearning'</span></span><br><span class="line">    model_config = model.get_config()</span><br><span class="line">    model_weight = model.get_weights()</span><br><span class="line"></span><br><span class="line">    config_save_path = os.path.join(root_path,name+<span class="string">"_config.txt"</span>)</span><br><span class="line">    weight_save_path = os.path.join(root_path,name+<span class="string">"_weights.txt"</span>)</span><br><span class="line">    pickle.dump(model_config, open(config_save_path, <span class="string">'wb'</span>))</span><br><span class="line">    pickle.dump(model_weight, open(weight_save_path, <span class="string">'wb'</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_model</span><span class="params">(name)</span>:</span></span><br><span class="line">    root_path = <span class="string">r'd:\deeplearning'</span></span><br><span class="line">    config_save_path = os.path.join(root_path,name+<span class="string">"_config.txt"</span>)</span><br><span class="line">    weight_save_path = os.path.join(root_path,name+<span class="string">"_weights.txt"</span>)</span><br><span class="line">    model_config = pickle.load(open(config_save_path, <span class="string">'rb'</span>))</span><br><span class="line">    model_weight = pickle.load(open(weight_save_path, <span class="string">'rb'</span>))</span><br><span class="line">    model = Model.from_config(model_config)</span><br><span class="line">    model.set_weights(model_weight)</span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 加载数据</span></span><br><span class="line">(x_train, _), (x_test, _) = mnist.load_data()</span><br><span class="line"><span class="comment"># 把数据缩放到 0 -- 1</span></span><br><span class="line">x_train = x_train.astype(<span class="string">'float32'</span>) / <span class="number">255.</span></span><br><span class="line">x_test = x_test.astype(<span class="string">'float32'</span>) / <span class="number">255.</span></span><br><span class="line">x_train = x_train.reshape((len(x_train), np.prod(x_train.shape[<span class="number">1</span>:])))</span><br><span class="line">x_test = x_test.reshape((len(x_test), np.prod(x_test.shape[<span class="number">1</span>:])))</span><br><span class="line">print(x_train.shape)</span><br><span class="line">print(x_test.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment">###############################################################################</span></span><br><span class="line"><span class="comment">###############################################################################</span></span><br><span class="line"><span class="comment"># this is the size of our encoded representations</span></span><br><span class="line"><span class="comment"># 将784维的数据压缩到32维</span></span><br><span class="line">encoding_dim = <span class="number">16</span>  <span class="comment"># 32 floats -&gt; compression of factor 24.5, assuming the input is 784 floats</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># this is our input placeholder</span></span><br><span class="line">input_img = Input(shape=(<span class="number">784</span>,))</span><br><span class="line"><span class="comment"># "encoded" is the encoded representation of the input</span></span><br><span class="line"><span class="comment"># 新建了一个32个网络节点，激活函数使用relu的层，注意在此层前面应该是输入层，拥有784个神经元的节点。</span></span><br><span class="line"><span class="comment">#encoded = Dense(encoding_dim, activation='relu')(input_img)</span></span><br><span class="line"><span class="comment"># 在压缩层添加稀疏的限制。在没有任何限制，只用节点的数目限制的时候，结果和PCA的结果十分类似</span></span><br><span class="line"><span class="comment"># 但是当加入稀疏优化之后，就不一样了</span></span><br><span class="line">encoded = Dense(encoding_dim, activation=<span class="string">'relu'</span>,activity_regularizer=regularizers.l1(<span class="number">10e-5</span>))(input_img)</span><br><span class="line"><span class="comment"># "decoded" is the lossy reconstruction of the input</span></span><br><span class="line"><span class="comment"># 在encoded的后面，新建了一个拥有784个节点的神经网络层，作为解码层。</span></span><br><span class="line">decoded = Dense(<span class="number">784</span>, activation=<span class="string">'sigmoid'</span>)(encoded)</span><br><span class="line"></span><br><span class="line"><span class="comment"># this model maps an input to its reconstruction</span></span><br><span class="line">autoencoder = Model(input_img, decoded)</span><br><span class="line"><span class="comment"># 现在autoencoder是这样的一个神经网络，输入包含784个节点，紧接着是32个节点的第一个隐含层，然后是784个节点的输出层。</span></span><br><span class="line"></span><br><span class="line">encoder = Model(input_img, encoded)</span><br><span class="line"><span class="comment"># encoder 以784个节点作为输入层，以32个节点作为输出层，没有中间的隐含层，这就是一个最简单的感知机的模型。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create a placeholder for an encoded (32-dimensional) input</span></span><br><span class="line">encoded_input = Input(shape=(encoding_dim,))</span><br><span class="line"><span class="comment"># retrieve the last layer of the autoencoder model</span></span><br><span class="line"><span class="comment"># 找到上面创建的神经网络的最后一层，也就是输出层。</span></span><br><span class="line">decoder_layer = autoencoder.layers[<span class="number">-1</span>]</span><br><span class="line"><span class="comment"># create the decoder model</span></span><br><span class="line">decoder = Model(encoded_input, decoder_layer(encoded_input))</span><br><span class="line"><span class="comment"># 现在decoder 是以32个维度输入，以784个维度输出的简单的神经网络，需要注意的是，encoder和decorder都是上面定义的autoencoder神经网络的</span></span><br><span class="line"><span class="comment"># 的一部分，只是用了新的变量名称把其中的一部分网络提取出来了。所以，对应的网络参数是一样的，因为本来指代的就是同一个网络的不同部分。</span></span><br><span class="line"></span><br><span class="line">autoencoder.compile(optimizer=<span class="string">'adadelta'</span>, loss=<span class="string">'binary_crossentropy'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">##x训练过程，注意到这里并不是没有标签，而是把子集的输入作为了输出，所以这不是无监督学习。而是有监督学习</span></span><br><span class="line"><span class="comment">## 这里通常叫做自监督学习。</span></span><br><span class="line">autoencoder.fit(x_train, x_train,</span><br><span class="line">                epochs=<span class="number">50</span>,</span><br><span class="line">                batch_size=<span class="number">256</span>,</span><br><span class="line">                shuffle=<span class="literal">True</span>,</span><br><span class="line">                validation_data=(x_test, x_test))</span><br><span class="line"></span><br><span class="line">save_model(autoencoder,<span class="string">'autoencoder'</span>)</span><br><span class="line">save_model(encoder,<span class="string">'encoder'</span>)</span><br><span class="line">save_model(decoder,<span class="string">'decoder'</span>)</span><br><span class="line"><span class="comment">## 加载保存的模型</span></span><br><span class="line">autoencoder = load_model(<span class="string">"autoencoder"</span>)</span><br><span class="line">encoder = load_model(<span class="string">"encoder"</span>)</span><br><span class="line">decoder = load_model(<span class="string">"decoder"</span>)</span><br><span class="line"><span class="comment">## 这样，保存的模型包括结构和参数就都回来了。</span></span><br><span class="line"><span class="comment"># encode and decode some digits</span></span><br><span class="line"><span class="comment"># note that we take them from the *test* set</span></span><br><span class="line">encoded_imgs = encoder.predict(x_test) <span class="comment"># 会利用上面训练好的网络，输出32维的数据</span></span><br><span class="line">decoded_imgs = decoder.predict(encoded_imgs) <span class="comment"># 会利用训练好的网络，输出784维的数据。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># use Matplotlib (don't ask)</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 设置显示前多少个数据</span></span><br><span class="line">n = <span class="number">12</span>  <span class="comment"># how many digits we will display</span></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>, <span class="number">4</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="comment"># display original</span></span><br><span class="line">    ax = plt.subplot(<span class="number">2</span>, n, i + <span class="number">1</span>)</span><br><span class="line">    plt.imshow(x_test[i].reshape(<span class="number">28</span>, <span class="number">28</span>))</span><br><span class="line">    plt.gray()</span><br><span class="line">    ax.get_xaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.get_yaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># display reconstruction</span></span><br><span class="line">    ax = plt.subplot(<span class="number">2</span>, n, i + <span class="number">1</span> + n)</span><br><span class="line">    plt.imshow(decoded_imgs[i].reshape(<span class="number">28</span>, <span class="number">28</span>))</span><br><span class="line">    plt.gray()</span><br><span class="line">    ax.get_xaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.get_yaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="多层的编码解码机">多层的编码解码机</h2><p>单层神经网络的处理能力是有限的，无论编码还是解码，我们都可以使用多个层来提高映射，或者说数据表征空间转换的能力。下面我们建立一个多层的神经网络，让每层的神经元的数量逐渐减少再逐渐增大，这样可以实现一个分层的数据压缩，数据降维。 我们建立的神经网络的形式是这样的(<code>784--&gt;128--&gt;64--&gt;32--&gt;64--&gt;128--&gt;784</code>),包含输入层，输出层在内，一共有7层。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Thu Apr 20 11:30:40 2017</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: FF120</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Input, Dense</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Model</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> regularizers</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_model</span><span class="params">(model,name)</span>:</span></span><br><span class="line">    <span class="comment">## fit完成之后，保存整个模型的配置</span></span><br><span class="line">    root_path = <span class="string">r'd:\deeplearning'</span></span><br><span class="line">    model_config = model.get_config()</span><br><span class="line">    model_weight = model.get_weights()</span><br><span class="line"></span><br><span class="line">    config_save_path = os.path.join(root_path,name+<span class="string">"_config.txt"</span>)</span><br><span class="line">    weight_save_path = os.path.join(root_path,name+<span class="string">"_weights.txt"</span>)</span><br><span class="line">    pickle.dump(model_config, open(config_save_path, <span class="string">'wb'</span>))</span><br><span class="line">    pickle.dump(model_weight, open(weight_save_path, <span class="string">'wb'</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_model</span><span class="params">(name)</span>:</span></span><br><span class="line">    root_path = <span class="string">r'd:\deeplearning'</span></span><br><span class="line">    config_save_path = os.path.join(root_path,name+<span class="string">"_config.txt"</span>)</span><br><span class="line">    weight_save_path = os.path.join(root_path,name+<span class="string">"_weights.txt"</span>)</span><br><span class="line">    model_config = pickle.load(open(config_save_path, <span class="string">'rb'</span>))</span><br><span class="line">    model_weight = pickle.load(open(weight_save_path, <span class="string">'rb'</span>))</span><br><span class="line">    model = Model.from_config(model_config)</span><br><span class="line">    model.set_weights(model_weight)</span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 加载数据</span></span><br><span class="line">(x_train, _), (x_test, _) = mnist.load_data()</span><br><span class="line"><span class="comment"># 把数据缩放到 0 -- 1</span></span><br><span class="line">x_train = x_train.astype(<span class="string">'float32'</span>) / <span class="number">255.</span></span><br><span class="line">x_test = x_test.astype(<span class="string">'float32'</span>) / <span class="number">255.</span></span><br><span class="line">x_train = x_train.reshape((len(x_train), np.prod(x_train.shape[<span class="number">1</span>:])))</span><br><span class="line">x_test = x_test.reshape((len(x_test), np.prod(x_test.shape[<span class="number">1</span>:])))</span><br><span class="line">print(x_train.shape)</span><br><span class="line">print(x_test.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment">###############################################################################</span></span><br><span class="line"><span class="comment">###############################################################################</span></span><br><span class="line">encoding_dim = <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># this is our input placeholder</span></span><br><span class="line">input_img = Input(shape=(<span class="number">784</span>,))</span><br><span class="line"></span><br><span class="line">encoded = Dense(<span class="number">128</span>, activation=<span class="string">'relu'</span>)(input_img)</span><br><span class="line">encoded = Dense(<span class="number">64</span>, activation=<span class="string">'relu'</span>)(encoded)</span><br><span class="line">encoded = Dense(encoding_dim, activation=<span class="string">'relu'</span>)(encoded)</span><br><span class="line"></span><br><span class="line">decoded = Dense(<span class="number">64</span>, activation=<span class="string">'relu'</span>)(encoded)</span><br><span class="line">decoded = Dense(<span class="number">128</span>, activation=<span class="string">'relu'</span>)(decoded)</span><br><span class="line">decoded = Dense(<span class="number">784</span>, activation=<span class="string">'sigmoid'</span>)(decoded)</span><br><span class="line"></span><br><span class="line">autoencoder = Model(input_img, decoded)</span><br><span class="line"></span><br><span class="line">encoder = Model(input_img, encoded)</span><br><span class="line"></span><br><span class="line">encoded_input = Input(shape=(<span class="number">32</span>,))</span><br><span class="line">decoder_layer1 = autoencoder.layers[<span class="number">-3</span>](encoded_input)</span><br><span class="line">decoder_layer2 = autoencoder.layers[<span class="number">-2</span>](decoder_layer1)</span><br><span class="line">decoder_layer3 = autoencoder.layers[<span class="number">-1</span>](decoder_layer2)</span><br><span class="line">decoder = Model(encoded_input, decoder_layer3)</span><br><span class="line"></span><br><span class="line">autoencoder.compile(optimizer=<span class="string">'adadelta'</span>, loss=<span class="string">'binary_crossentropy'</span>)</span><br><span class="line"></span><br><span class="line">autoencoder.fit(x_train, x_train,</span><br><span class="line">                epochs=<span class="number">50</span>,</span><br><span class="line">                batch_size=<span class="number">256</span>,</span><br><span class="line">                shuffle=<span class="literal">True</span>,</span><br><span class="line">                validation_data=(x_test, x_test))</span><br><span class="line"></span><br><span class="line">save_model(autoencoder,<span class="string">'autoencoder'</span>)</span><br><span class="line">save_model(encoder,<span class="string">'encoder'</span>)</span><br><span class="line">save_model(decoder,<span class="string">'decoder'</span>)</span><br><span class="line"><span class="comment">## 加载保存的模型</span></span><br><span class="line">autoencoder = load_model(<span class="string">"autoencoder"</span>)</span><br><span class="line">encoder = load_model(<span class="string">"encoder"</span>)</span><br><span class="line">decoder = load_model(<span class="string">"decoder"</span>)</span><br><span class="line">encoded_imgs = encoder.predict(x_test)</span><br><span class="line">decoded_imgs = decoder.predict(encoded_imgs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">n = <span class="number">10</span>  <span class="comment"># how many digits we will display</span></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>, <span class="number">4</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="comment"># display original</span></span><br><span class="line">    ax = plt.subplot(<span class="number">2</span>, n, i + <span class="number">1</span>)</span><br><span class="line">    plt.imshow(x_test[i].reshape(<span class="number">28</span>, <span class="number">28</span>))</span><br><span class="line">    plt.gray()</span><br><span class="line">    ax.get_xaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.get_yaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># display reconstruction</span></span><br><span class="line">    ax = plt.subplot(<span class="number">2</span>, n, i + <span class="number">1</span> + n)</span><br><span class="line">    plt.imshow(decoded_imgs[i].reshape(<span class="number">28</span>, <span class="number">28</span>))</span><br><span class="line">    plt.gray()</span><br><span class="line">    ax.get_xaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.get_yaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p>上面的代码以中间神经元数目最少的作为分割，前面的作为编码机，后面的作为解码机，前后正好是对称的。当然，这并不是必须的，你也可以让中间的任何一层作为分割，前面作为编码机，后面的作为解码机。这样会实现不同的压缩表示层级。</p><p>我们把中间层向前推进一层，再看结果： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">input_img = Input(shape=(<span class="number">784</span>,))</span><br><span class="line"></span><br><span class="line">encoded = Dense(<span class="number">128</span>, activation=<span class="string">'relu'</span>)(input_img)</span><br><span class="line">encoded = Dense(<span class="number">64</span>, activation=<span class="string">'relu'</span>)(encoded)</span><br><span class="line"></span><br><span class="line">decoded = Dense(<span class="number">32</span>, activation=<span class="string">'relu'</span>)(encoded)</span><br><span class="line">decoded = Dense(<span class="number">64</span>, activation=<span class="string">'relu'</span>)(decoded)</span><br><span class="line">decoded = Dense(<span class="number">128</span>, activation=<span class="string">'relu'</span>)(decoded)</span><br><span class="line">decoded = Dense(<span class="number">784</span>, activation=<span class="string">'sigmoid'</span>)(decoded)</span><br><span class="line"></span><br><span class="line">autoencoder = Model(input_img, decoded)</span><br><span class="line"></span><br><span class="line">encoder = Model(input_img, encoded)</span><br><span class="line"></span><br><span class="line">encoded_input = Input(shape=(<span class="number">64</span>,))</span><br><span class="line">decoder_layer0 = autoencoder.layers[<span class="number">-4</span>](encoded_input)</span><br><span class="line">decoder_layer1 = autoencoder.layers[<span class="number">-3</span>](decoder_layer0)</span><br><span class="line">decoder_layer2 = autoencoder.layers[<span class="number">-2</span>](decoder_layer1)</span><br><span class="line">decoder_layer3 = autoencoder.layers[<span class="number">-1</span>](decoder_layer2)</span><br><span class="line">decoder = Model(encoded_input, decoder_layer3)</span><br></pre></td></tr></table></figure></p><h2 id="卷积神经网络的autoencoder">卷积神经网络的autoencoder</h2><p>处理图像的时候，使用卷积神经网络通常可以有更好的效果。所以，我们尝试使用卷积神经网络做autoencoder,看看数据压缩的效果如何。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Input, Dense, Conv2D, MaxPooling2D, UpSampling2D</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Model</span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> backend <span class="keyword">as</span> K</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> keras.callbacks <span class="keyword">import</span> TensorBoard</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">(x_train, _), (x_test, _) = mnist.load_data()</span><br><span class="line"></span><br><span class="line">x_train = x_train.astype(<span class="string">'float32'</span>) / <span class="number">255.</span></span><br><span class="line">x_test = x_test.astype(<span class="string">'float32'</span>) / <span class="number">255.</span></span><br><span class="line">x_train = np.reshape(x_train, (len(x_train), <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>))  <span class="comment"># adapt this if using `channels_first` image data format</span></span><br><span class="line">x_test = np.reshape(x_test, (len(x_test), <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>))  <span class="comment"># adapt this if using `channels_first` image data format</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 28*28的图像，只有1个通道，黑白图像</span></span><br><span class="line">input_img = Input(shape=(<span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>))  <span class="comment"># adapt this if using `channels_first` image data format</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个卷积核是3*3的层</span></span><br><span class="line">x = Conv2D(<span class="number">16</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>)(input_img)</span><br><span class="line"><span class="comment"># 定义一个pooling层，取2*2区域内的最大值</span></span><br><span class="line">x = MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>), padding=<span class="string">'same'</span>)(x)</span><br><span class="line"><span class="comment"># 定义一个3*3的核</span></span><br><span class="line">x = Conv2D(<span class="number">8</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>)(x)</span><br><span class="line">x = MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>), padding=<span class="string">'same'</span>)(x)</span><br><span class="line"><span class="comment"># 定义一个pooling层，取2*2区域内的最大值</span></span><br><span class="line">x = Conv2D(<span class="number">8</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>)(x)</span><br><span class="line"></span><br><span class="line">encoded = MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>), padding=<span class="string">'same'</span>)(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># at this point the representation is (4, 4, 8) i.e. 128-dimensional</span></span><br><span class="line"></span><br><span class="line">x = Conv2D(<span class="number">8</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>)(encoded)</span><br><span class="line">x = UpSampling2D((<span class="number">2</span>, <span class="number">2</span>))(x)</span><br><span class="line">x = Conv2D(<span class="number">8</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>)(x)</span><br><span class="line">x = UpSampling2D((<span class="number">2</span>, <span class="number">2</span>))(x)</span><br><span class="line">x = Conv2D(<span class="number">16</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">'relu'</span>)(x)</span><br><span class="line">x = UpSampling2D((<span class="number">2</span>, <span class="number">2</span>))(x)</span><br><span class="line">decoded = Conv2D(<span class="number">1</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">'sigmoid'</span>, padding=<span class="string">'same'</span>)(x)</span><br><span class="line"></span><br><span class="line">autoencoder = Model(input_img, decoded)</span><br><span class="line">autoencoder.compile(optimizer=<span class="string">'adadelta'</span>, loss=<span class="string">'binary_crossentropy'</span>)</span><br><span class="line"></span><br><span class="line">autoencoder.fit(x_train, x_train,</span><br><span class="line">                epochs=<span class="number">1</span>,</span><br><span class="line">                batch_size=<span class="number">128</span>,</span><br><span class="line">                shuffle=<span class="literal">True</span>,</span><br><span class="line">                validation_data=(x_test, x_test),</span><br><span class="line">                callbacks=[TensorBoard(log_dir=<span class="string">'d:/log'</span>)])</span><br><span class="line"></span><br><span class="line">decoded_imgs = autoencoder.predict(x_test)</span><br><span class="line"></span><br><span class="line">n = <span class="number">10</span></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>, <span class="number">4</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="comment"># display original</span></span><br><span class="line">    ax = plt.subplot(<span class="number">2</span>, n, i)</span><br><span class="line">    plt.imshow(x_test[i].reshape(<span class="number">28</span>, <span class="number">28</span>))</span><br><span class="line">    plt.gray()</span><br><span class="line">    ax.get_xaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.get_yaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># display reconstruction</span></span><br><span class="line">    ax = plt.subplot(<span class="number">2</span>, n, i + n)</span><br><span class="line">    plt.imshow(decoded_imgs[i].reshape(<span class="number">28</span>, <span class="number">28</span>))</span><br><span class="line">    plt.gray()</span><br><span class="line">    ax.get_xaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.get_yaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> plot_model</span><br><span class="line">plot_model(autoencoder, to_file=<span class="string">'model.png'</span>)</span><br></pre></td></tr></table></figure><p>上面的代码建立了一个这样的模型： <code>input--&gt;Conv2D--&gt;MaxPooling2D--&gt;Conv2D--&gt;MaxPooling2D--&gt;Conv2D--&gt;MaxPooling2D(encoded)--&gt;Conv2D--&gt;UpSampling2D--&gt;Conv2D--&gt;UpSampling2D--&gt;Conv2D--&gt;UpSampling2D--&gt;Conv2D(decoded)</code> 一共有14层网络。使用下面的语句可以打印出这些结构： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> plot_model</span><br><span class="line">plot_model(autoencoder, to_file=<span class="string">'model.png'</span>)</span><br></pre></td></tr></table></figure></p><p>1<a href="model.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> keras </tag>
            
            <tag> autoencoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习_Keras使用技巧</title>
      <link href="/hexoblog/2017/04/19/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_Keras%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/hexoblog/2017/04/19/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_Keras%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>keras是一个构建在更高水平上的深度学习框架，类似scikit-learn,他提供了高级的抽象的接口，使得你在不了解具体细节的基础上，就可以定义和使用各种神经网络算法完成某个具体的工作。 <a id="more"></a> ## 模型的可视化 http://blog.csdn.net/u014749291/article/details/54891087 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line"></span><br><span class="line">  File <span class="string">"&lt;ipython-input-7-779239671584&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    SVG(model_to_dot(model).create(prog=<span class="string">'dot'</span>, format=<span class="string">'svg'</span>))</span><br><span class="line"></span><br><span class="line">  File <span class="string">"C:\ProgramData\Anaconda3\envs\python35\lib\site-packages\keras-2.0.3-py3.5.egg\keras\utils\vis_utils.py"</span>, line <span class="number">35</span>, <span class="keyword">in</span> model_to_dot</span><br><span class="line">    _check_pydot()</span><br><span class="line"></span><br><span class="line">  File <span class="string">"C:\ProgramData\Anaconda3\envs\python35\lib\site-packages\keras-2.0.3-py3.5.egg\keras\utils\vis_utils.py"</span>, line <span class="number">17</span>, <span class="keyword">in</span> _check_pydot</span><br><span class="line">    <span class="keyword">raise</span> ImportError(<span class="string">'Failed to import pydot. You must install pydot'</span></span><br><span class="line"></span><br><span class="line">ImportError: Failed to <span class="keyword">import</span> pydot. You must install pydot <span class="keyword">and</span> graphviz <span class="keyword">for</span> `pydotprint` to work.</span><br></pre></td></tr></table></figure></p><p>如果是在Windows平台测试，很容易出现上述问题，下载相应的<a href="http://www.graphviz.org/pub/graphviz/stable/windows/graphviz-2.38.msi" target="_blank" rel="noopener">软件</a>安装，再设置环境变量就可以了。</p><ul><li>显示模型的信息： <code>model.summary()</code>;</li><li>获得模型训练好的参数信息: <code>model.get_weights()</code></li><li>保存模型的图片到本地： <code>from keras.utils import plot_model plot_model(model, to_file='model.png')</code></li><li><code>model.layers</code> is a flattened list of the layers comprising the model graph.</li><li><code>model.inputs</code> is the list of input tensors.</li><li><code>model.outputs</code> is the list of output tensors.</li></ul><h2 id="利用tensorboard-实现模型的和计算过程的可视化">利用TensorBoard 实现模型的和计算过程的可视化</h2><p>如果keras使用的是tensorflow作为后端的框架，我们可以借助TensorBoard实现高级一些的可视化。keras实现的可视化功能有限，不能满足深入研究和调试代码的要求。 <a href="https://www.tensorflow.org/get_started/summaries_and_tensorboard" target="_blank" rel="noopener">官方教程</a></p><ol style="list-style-type: decimal"><li>打开TensorBoard :</li></ol><p>打开<code>cmd</code>,执行<code>activate python35</code>激活安装了tensorflow的环境，然后执行<code>tensorboard --logdir=path/to/logs</code>,在本地浏览器打开<code>http://localhost:6006/</code>可以看到下面的界面： <img src="2017-04-21_103727.png"> ## 模型持久化 模型的存储和模型的加载在编程中经常会用到，毕竟训练出一个模型常常需要很长的时间。模型的关键信息其实就两个方面，结构和参数。结构可以用一些结构化的字符串来表示，参数直接用numpy的结构就可以。keras分别提供了保存结构和保存参数的方法。</p><p>获得模型结构的方法： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保存成json格式字符串</span></span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> model_from_json</span><br><span class="line">json_string = model.to_json()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存成 yaml格式的字符串</span></span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> model_from_yaml</span><br><span class="line">yaml_string = model.to_yaml()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用变量的形式返回结构的信息，可以自己使用其他工具序列化为字符串。</span></span><br><span class="line">model.get_config()</span><br></pre></td></tr></table></figure></p><p>获得模型的参数的方法： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只保存模型的参数，不保存模型的结构</span></span><br><span class="line">model.save_weights(filepath)</span><br></pre></td></tr></table></figure></p><p>从已经保存的结构恢复模型的方法： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> model_from_json</span><br><span class="line">model = model_from_json(json_string)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> model_from_yaml</span><br><span class="line">model = model_from_yaml(yaml_string)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从配置信息恢复模型</span></span><br><span class="line">model = Model.from_config(config)</span><br><span class="line"><span class="comment"># or, for Sequential:</span></span><br><span class="line">model = Sequential.from_config(config)</span><br></pre></td></tr></table></figure></p><p>为模型设置参数的方法： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里的model要和加载的权重保存的时候的模型结构一致。</span></span><br><span class="line">model.load_weights(filepath, by_name=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></p><p>我习惯使用的方法是： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Model</span><br><span class="line"><span class="comment"># 保存模型</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_model</span><span class="params">(model,name)</span>:</span></span><br><span class="line">    <span class="comment">## fit完成之后，保存整个模型的配置</span></span><br><span class="line">    root_path = <span class="string">r'd:\deeplearning'</span></span><br><span class="line">    model_config = model.get_config()</span><br><span class="line">    model_weight = model.get_weights()</span><br><span class="line">    <span class="keyword">import</span> pickle</span><br><span class="line">    <span class="keyword">import</span> os</span><br><span class="line">    config_save_path = os.path.join(root_path,name+<span class="string">"_config.txt"</span>)</span><br><span class="line">    weight_save_path = os.path.join(root_path,name+<span class="string">"_weights.txt"</span>)</span><br><span class="line">    pickle.dump(model_config, open(config_save_path, <span class="string">'wb'</span>))</span><br><span class="line">    pickle.dump(model_weight, open(weight_save_path, <span class="string">'wb'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载模型</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_model</span><span class="params">(name)</span>:</span></span><br><span class="line">    root_path = <span class="string">r'd:\deeplearning'</span></span><br><span class="line">    <span class="keyword">import</span> pickle</span><br><span class="line">    <span class="keyword">import</span> os</span><br><span class="line">    config_save_path = os.path.join(root_path,name+<span class="string">"_config.txt"</span>)</span><br><span class="line">    weight_save_path = os.path.join(root_path,name+<span class="string">"_weights.txt"</span>)</span><br><span class="line">    model_config = pickle.load(open(config_save_path, <span class="string">'rb'</span>))</span><br><span class="line">    model_weight = pickle.load(open(weight_save_path, <span class="string">'rb'</span>))</span><br><span class="line">    model = Model.from_config(model_config)</span><br><span class="line">    model.set_weights(model_weight)</span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> keras </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习_反向传播算法及简单实例</title>
      <link href="/hexoblog/2017/04/19/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/"/>
      <url>/hexoblog/2017/04/19/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>反向传播算法入门资源索引：</p><p><a href="http://www.52nlp.cn/tag/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95python%E4%BB%A3%E7%A0%81" target="_blank" rel="noopener">http://www.52nlp.cn/tag/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95python%E4%BB%A3%E7%A0%81</a></p><a id="more"></a><p>一个简单的三层网络：</p><div class="figure"><img src="2017-04-19_191339.png"></div><p>下面我们以上面的简单的三层的神经网络说明BP算法的计算过程。</p><p>初始的输入参数是：</p><table><thead><tr class="header"><th align="center"><span class="math inline">\(x_1\)</span></th><th align="center"><span class="math inline">\(x_2\)</span></th><th align="center"><span class="math inline">\(x_3\)</span></th><th align="center"><span class="math inline">\(w_{14}\)</span></th><th align="center"><span class="math inline">\(w_{15}\)</span></th><th align="center"><span class="math inline">\(w_{24}\)</span></th><th align="center"><span class="math inline">\(w_25\)</span></th><th align="center"><span class="math inline">\(w_{34}\)</span></th><th align="center"><span class="math inline">\(w_{35}\)</span></th><th align="center"><span class="math inline">\(w_{46}\)</span></th><th align="center"><span class="math inline">\(w_{56}\)</span></th><th align="center"><span class="math inline">\(b_4\)</span></th><th align="center"><span class="math inline">\(b_5\)</span></th><th align="center"><span class="math inline">\(b_6\)</span></th></tr></thead><tbody><tr class="odd"><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0.2</td><td align="center">-0.3</td><td align="center">0.4</td><td align="center">0.1</td><td align="center">-0.5</td><td align="center">0.2</td><td align="center">-0.3</td><td align="center">-0.2</td><td align="center">-0.4</td><td align="center">0.2</td><td align="center">0.1</td></tr></tbody></table><p>该神经网络接受一个三维的向量作为输入[x1,x2,x3],输出只有一个数字，这里设置为不是0，就是1.示例给出的数据[1,0,1]对应的类别是1.</p><p>定义好了网络的结构，给出了初始的网络参数的值( <span class="math inline">\(w_{14}\)</span>|<span class="math inline">\(w_{15}\)</span>|<span class="math inline">\(w_{24}\)</span>|<span class="math inline">\(w_25\)</span>|<span class="math inline">\(w_{34}\)</span>|<span class="math inline">\(w_{35}\)</span>|<span class="math inline">\(w_{46}\)</span>|<span class="math inline">\(w_{56}\)</span>|<span class="math inline">\(b_4\)</span>|<span class="math inline">\(b_5\)</span>|<span class="math inline">\(b_6\)</span>| ),都是该神经网络的参数。现在的目标是使得该神经网络在输入是[1,0,1]时，输出是1,或者至少是十分接近1.</p><p>首先计算一下在初始化参数的情况下，神经网络的输出是什么。 神经元输出的计算过程。</p><div class="figure"><img src="2017-04-19_102750.png"></div><p>在这里，激活函数我们使用sigmiod函数：</p><p><span class="math display">\[f(x) =  \dfrac 1 {1+e^{-x}}\]</span></p><p>我们将第i个神经元在激活函数作用之前的输出记作的输出记作 <span class="math inline">\(I_i\)</span> ,在激活函数作用之后的值记 <span class="math inline">\(O_i\)</span> 计算过程如下： <span class="math display">\[I_4 = x_1*w_{14}+x_2*w_{24}+x_3*w_{34}+b_4 = 1*0.2+0*0.4+1*(-0.5)+(-0.4) = -0.7\]</span></p><p><span class="math display">\[I_5 = x_1*w_{15}+x_2*w_{25}+x_3*w_{35}+b_5 = 1*(-0.3)+0*0.1+1*0.2+0.2 = 0.1\]</span></p><p><span class="math display">\[I_6 = O_4*w_{46}+O_5*w_{56}+b_6 = 0.331812*(-0.3)+0.524979*(-0.2)+0.1 = -0.104539\]</span></p><p><span class="math display">\[O_4 = f(I_4) = \dfrac 1 {1+e^{-(-0.7)}} = 0.331812\]</span></p><p><span class="math display">\[O_5 = f(I_5) = \dfrac 1 {1+e^{-0.1}} = 0.524979\]</span></p><p><span class="math display">\[O_6 = f(I_6) = \dfrac 1 {1+e^{-(-0.104539)}} = 0.473889\]</span></p><p>可以看到，初始化的参数对[1,0,1]的输出是0.473899，而我们期望的输出是1。 所以，必须使用某种办法调整参数，才可以达到我们的期望。</p><p>我们定义误差如下：</p><p><span class="math display">\[E = \frac12 (target - O_6)^2\]</span></p><p>用平方误差来度量输出和期望的输出之间的差距。那么接下来我们希望调整神经网络的参数，使得E尽快的缩小，这样我们就可以使神经网络尽快的达到我们期望的输出。首先考虑如何改变<span class="math inline">\(w_{46}\)</span>才能使得误差减小。这里我求 $ $ , 导数对应的方向函数上升下降的速度是最快的，我们使用偏导数找到最快的下降方向，按照这样的方式更新神经网络的权重参数和偏置参数。</p><p><span class="math display">\[\frac {\partial E} {\partial w_{46}} = \frac {\partial E} {\partial O_6} * \frac {\partial O_6} {\partial I_6} * \frac {\partial I_6} {\partial w_{46}}\]</span></p><p>上面应用了求导的链式法则，将对<span class="math inline">\(w_{46}\)</span>的偏导数表示成了已知的数据。下面我们一步一步求出这个偏导数的表达式并得出参数的更新规则。</p><p><span class="math display">\[E = \frac12 (target - O_6)^2\]</span></p><p><span class="math display">\[\frac {\partial E} {\partial O_6} = -\frac12*2(target-O_6) = O_6 - target = 0.473889 - 1 = -0.526111\]</span></p><p><span class="math display">\[O_6 = f(I_6) = \frac {1} {1+e^{-I_6}}\]</span> <span class="math display">\[\frac {\partial O_6} {\partial I_6} {} = e^{-I_6}*(\frac {1} {1+e^{-I_6}})^{2} = O_6 * (1-O_6) = 0.473889 * (1-0.473889) = 0.249318\]</span></p><p><span class="math display">\[I_6 = O_4*w_{46}+O_5*w_{56}+b_6\]</span></p><p><span class="math display">\[\frac {\partial I_6} {\partial w_{46}} = O_4 = 0.331812\]</span></p><p>综合上面的所有公式，可以推导出最终的参数更新公式是： <span class="math display">\[\frac {\partial E} {\partial w_{46}} = (O_6 - target) * (O_6*(1-O_6))*O_4=(-0.526111)*0.249318*0.331812= -0.043523\]</span></p><p>我们定义一个学习率<span class="math inline">\(l\)</span>,表示参数更新的速度，这里设定为0.9；然后定义参数按照下面的方式更新： <span class="math display">\[w^+_{46} = w_{46} - l * \frac {\partial E} {\partial w_{46}} = -0.3 - 0.9*(-0.043523) =  -0.260829\]</span></p><p>下面总结一下上面提到的公式，需要注意的是，我这里举例的神经网络只有一个输出，所有偏导数和导数是一样的。但是通常的神经网络都有多个输出。在有多个输出的时候，我们定义E等于多个输出节点的E的和。这样，多个节点的输出就和单个节点的输出不太一样。我们定义输出节点的错误率为： <span class="math display">\[E_i = O_i*(1-O_i)*(target-O_i)\]</span></p><p>我们定义隐藏层的节点的错误率为： <span class="math display">\[E_i = O_i*(1-O_i)*( \sum E_k*w_{jk})\]</span></p><p>这样，每次参数的更新就可以写成下面的形式： <span class="math display">\[\Delta w_{ij} = l * E_j * O_i\]</span> 偏置的更新定义如下： <span class="math display">\[\Delta b_j = l * E_j\]</span></p><p>不断的应用以上的公式更新权重参数和偏置，直到错误率到达一个很小的水平，停止训练。这个时候，神经网络对输入[1,0,1]的输出已经非常接近正确答案1了。</p><p>第一轮权重和偏置的更新是： <img src="2017-04-19_213636.png"></p><p>了解了反向传播算法，就掌握了神经网络参数学习的方法，我们就可以写出自己的神经网络了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 全连接层实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FullConnectedLayer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_size, output_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                 activator)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        构造函数</span></span><br><span class="line"><span class="string">        input_size: 本层输入向量的维度</span></span><br><span class="line"><span class="string">        output_size: 本层输出向量的维度</span></span><br><span class="line"><span class="string">        activator: 激活函数</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.input_size = input_size</span><br><span class="line">        self.output_size = output_size</span><br><span class="line">        self.activator = activator</span><br><span class="line">        <span class="comment"># 权重数组W</span></span><br><span class="line">        self.W = np.random.uniform(<span class="number">-0.1</span>, <span class="number">0.1</span>,</span><br><span class="line">            (output_size, input_size))</span><br><span class="line">        <span class="comment"># 偏置项b</span></span><br><span class="line">        self.b = np.zeros((output_size, <span class="number">1</span>))</span><br><span class="line">        <span class="comment"># 输出向量</span></span><br><span class="line">        self.output = np.zeros((output_size, <span class="number">1</span>))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, input_array)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        前向计算</span></span><br><span class="line"><span class="string">        input_array: 输入向量，维度必须等于input_size</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="comment"># 式2</span></span><br><span class="line">        self.input = input_array</span><br><span class="line">        self.output = self.activator.forward(</span><br><span class="line">            np.dot(self.W, input_array) + self.b)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span><span class="params">(self, delta_array)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        反向计算W和b的梯度</span></span><br><span class="line"><span class="string">        delta_array: 从上一层传递过来的误差项</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="comment"># 式8</span></span><br><span class="line">        self.delta = self.activator.backward(self.input) * np.dot(</span><br><span class="line">            self.W.T, delta_array)</span><br><span class="line">        self.W_grad = np.dot(delta_array, self.input.T)</span><br><span class="line">        self.b_grad = delta_array</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, learning_rate)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        使用梯度下降算法更新权重</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.W += learning_rate * self.W_grad</span><br><span class="line">        self.b += learning_rate * self.b_grad</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sigmoid激活函数类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SigmoidActivator</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, weighted_input)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span> / (<span class="number">1.0</span> + np.exp(-weighted_input))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span><span class="params">(self, output)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> output * (<span class="number">1</span> - output)</span><br><span class="line"><span class="comment"># 神经网络类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Network</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, layers)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        构造函数</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.layers = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(layers) - <span class="number">1</span>):</span><br><span class="line">            self.layers.append(</span><br><span class="line">                FullConnectedLayer(</span><br><span class="line">                    layers[i], layers[i+<span class="number">1</span>],</span><br><span class="line">                    SigmoidActivator()</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, sample)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        使用神经网络实现预测</span></span><br><span class="line"><span class="string">        sample: 输入样本</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        output = sample</span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> self.layers:</span><br><span class="line">            layer.forward(output)</span><br><span class="line">            output = layer.output</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(self, labels, data_set, rate, epoch)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        训练函数</span></span><br><span class="line"><span class="string">        labels: 样本标签</span></span><br><span class="line"><span class="string">        data_set: 输入样本</span></span><br><span class="line"><span class="string">        rate: 学习速率</span></span><br><span class="line"><span class="string">        epoch: 训练轮数</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(epoch):</span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> range(len(data_set)):</span><br><span class="line">                self.train_one_sample(labels[d],</span><br><span class="line">                    data_set[d], rate)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train_one_sample</span><span class="params">(self, label, sample, rate)</span>:</span></span><br><span class="line">        self.predict(sample)</span><br><span class="line">        self.calc_gradient(label)</span><br><span class="line">        self.update_weight(rate)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calc_gradient</span><span class="params">(self, label)</span>:</span></span><br><span class="line">        delta = self.layers[<span class="number">-1</span>].activator.backward(</span><br><span class="line">            self.layers[<span class="number">-1</span>].output</span><br><span class="line">        ) * (label - self.layers[<span class="number">-1</span>].output)</span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> self.layers[::<span class="number">-1</span>]:</span><br><span class="line">            layer.backward(delta)</span><br><span class="line">            delta = layer.delta</span><br><span class="line">        <span class="keyword">return</span> delta</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_weight</span><span class="params">(self, rate)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> self.layers:</span><br><span class="line">            layer.update(rate)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_and_evaluate</span><span class="params">()</span>:</span></span><br><span class="line">    last_error_ratio = <span class="number">1.0</span></span><br><span class="line">    epoch = <span class="number">0</span></span><br><span class="line">    train_data_set, train_labels = get_training_data_set()</span><br><span class="line">    test_data_set, test_labels = get_test_data_set()</span><br><span class="line">    network = Network([<span class="number">784</span>, <span class="number">300</span>, <span class="number">10</span>])</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        epoch += <span class="number">1</span></span><br><span class="line">        network.train(train_labels, train_data_set, <span class="number">0.3</span>, <span class="number">1</span>)</span><br><span class="line">        print(<span class="string">'%s epoch %d finished'</span> % (now(), epoch) )</span><br><span class="line">        <span class="keyword">if</span> epoch % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            error_ratio = evaluate(network, test_data_set, test_labels)</span><br><span class="line">            print(<span class="string">'%s after epoch %d, error ratio is %f'</span> % (now(), epoch, error_ratio) )</span><br><span class="line">            <span class="keyword">if</span> error_ratio &gt; last_error_ratio:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                last_error_ratio = error_ratio</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    train_and_evaluate()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Anaconda的使用01-基础</title>
      <link href="/hexoblog/2017/04/18/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8BIDE/Anaconda/Anaconda%E7%9A%84%E4%BD%BF%E7%94%A801-%E5%9F%BA%E7%A1%80/"/>
      <url>/hexoblog/2017/04/18/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8BIDE/Anaconda/Anaconda%E7%9A%84%E4%BD%BF%E7%94%A801-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.continuum.io/downloads" target="_blank" rel="noopener">anaconda</a>是一个python的集成环境，自带了许多常用的python包，所以安装它是学习python最简便的方法。anaconda提供conda命令，可以创建多个相互隔离的不同的python工作环境，十分方便。 <a id="more"></a> ## 安装 下载python3.6版本的安装包，直接双击安装即可，所有选项选择默认就行。软件安装好之后，Windows的命令窗口应该可以直接执行<code>python</code>,<code>ipython</code>,<code>conda</code>,<code>pip</code>等命令。</p><h2 id="conda">conda</h2><ul><li>查看当前安装的环境 <code>conda info -e</code></li><li>创建一个名称为<code>python35</code>的环境： <code>conda create --name python35 python=3.5</code></li><li>删除这个环境： <code>conda remove -n python35 --all</code></li><li>激活某个环境： <code>activate python35</code></li><li>退出某个环境：<code>deactivate</code></li><li>复制某个环境：<code>conda create -n python35_copy --clone python35</code></li><li>查看conda的版本:<code>conda --version</code></li><li>更新conda： <code>conda update conda</code></li><li>查看当前环境中安装的包和版本号： <code>conda list</code></li><li>一次安装anaconda集成包：<code>conda install anaconda</code></li><li>更新anaconda的版本： <code>conda update anaconda</code></li><li>更改conda的镜像： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加Anaconda的TUNA镜像</span></span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line"><span class="meta">#</span><span class="bash"> TUNA的<span class="built_in">help</span>中镜像地址加有引号，需要去掉</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置搜索时显示通道地址</span></span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure></li></ul><h2 id="配置python2.7-和python-3.5两个工作环境">配置python2.7 和python 3.5两个工作环境</h2><ol style="list-style-type: decimal"><li><code>conda create --name python35 python=3.5</code></li><li><code>activate python35</code></li><li><code>conda install anaconda</code></li><li><code>spyder</code></li></ol><p>这样就打开了python3.5的spyder工作环境。<code>conda install anaconda</code>是安装anaconda所有的包，如果用不到这么多，可以不必执行这一步，因为安装太多的包比较耗时。</p><ol style="list-style-type: decimal"><li><code>conda create --name python27 python=2.7</code></li><li><code>activate python27</code></li><li><code>conda install anaconda</code></li><li><code>spyder</code></li></ol><p>这样就打开了python3.5的spyder工作环境。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工具 </category>
          
          <category> 编程IDE </category>
          
          <category> Anaconda </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> anaconda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习__利用神经网络识别手写数字</title>
      <link href="/hexoblog/2017/04/18/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_%E5%88%A9%E7%94%A8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AF%86%E5%88%AB%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97/"/>
      <url>/hexoblog/2017/04/18/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_%E5%88%A9%E7%94%A8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AF%86%E5%88%AB%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p>文章翻译自英文文章。学习神经网络的入门教程。</p><a id="more"></a><p>人类视觉系统是大自然的一大奇迹。 考虑下面的手写数字序列： <img src="2017-04-18_193648.png"> 大部分人能够毫不费力的识别出这些数字是 504192。这种简单性只是一个幻觉。在我们大脑各半球，有一个主要的视觉皮层，即V1，它包含1.4亿个神经元以及数以百亿的神经元连接。而且人类不只是有V1，还有一系列的视觉皮层——V2,V3,V4和V5，它们能够执行更加复杂的图像处理。我们可以将大脑想象成一台超级计算机，在几亿年的进化中不断改进，最终非常适合理解这个视觉世界。要识别手写数字不是一件非常容易的事。然而，我们人类却能非常惊人的通过我们的眼睛理解所看到的一切，但是几乎所有的工作都是在不知不觉中完成的，以至于我们不会赞叹我们的视觉系统解决的问题有多么艰难。</p><p>神经网络用不同的方法来处理这个问题。它的思想就是利用大量的手写数字（训练样本），然后开发出一套从训练样本中进行学习的系统。换句话说，神经网络使用样本来自动推理出识别手写数字的规则。此外，通过增加训练样本规模，神经网络能学到手写体的更多规则从而提升它的识别精度。因此在我们像上面一样只有100张训练数字同时，有可能我们能通过成千上万更多的训练样本来构建更好的手写识别算法。 <img src="2017-04-18_193737.png"></p><p>本章我们将编写一段计算机程序来实现一个能识别手写数字的神经网络。这个程序大概有74行，而且没有使用其他特别的神经网络库，但是这段程序能够具有96%的数字识别精度，而且没有人工干预。此外，在后面的章节中我们将改进算法达到99%以上的精度。实际上，最好的商业神经网络已经很好的应用在银行支票处理以及邮局识别地址等。</p><p>我们专注在手写体识别是因为它是一个很好的学习神经网络的原型问题。做为一个原型，它刚好合适：识别手写数字是一个挑战，不是那么容易，而它也不需要一个极其复杂的方案或者巨大的计算能力。此外，它也是开发更多高级技术的好方法，比如深度学习。因此整本书我们将不断重复回到手写识别这个问题。这本书的后面，我们将讨论这些算法思想如何应用到计算机视觉的其他问题，还包括语言识别、自然语言处理和其他领域。</p><p>当然，如果本章只是写一个识别手写数字的计算机程序，那么将非常短小！在编写过程中，我们将介绍很多神经网络的关键思想，包括人工神经网络的两大类别（感知器和sigmoid神经元）以及神经网络标准学习算法，即随机梯度下降。整个过程我们将关注在阐述为什么这样处理是有效的，从而让你构建起神经网络直觉。这比只陈述基础的机制更加冗长，但这对更深入理解所学到的内容是值得的。在这些收获上，本章结束你将明白深度学习是什么，且它为什么这么重要。</p><h2 id="感知器perceptrons">感知器(Perceptrons)</h2><p>什么是神经网络？在开始之前，我将介绍一种人工的神经元，即感知器(perceptron)。感知器是由Frank Rosenblatt 在上世纪50到60年代发明的 , 灵感来源于 Warren McCulloch 和 Walter Pitts 的早期工作。今天人工神经网络使用更加通用的其他模型，本书以及许多现代的神经网络工作中，主要的神经网络模型是sigmoid神经元。 我们将很快讨论sigmoid神经元，但是为了更好了解它的原理，我们首先要理解感知器。</p><p>那么感知器如何工作呢？一个感知器获取几个二进制输入<span class="math inline">\(x_1, x_2, \ldots\)</span>，并且产生一个二进制数出： <img src="2017-04-18_193925.png"> 在这个例子中，感知器具有三个输入<span class="math inline">\(x_1, x_2, x_3\)</span>。通常它会具有更多或更少的输入。Rosenblatt 提出了一个简单规则来计算最后数出。他引入了权重(weights) <span class="math inline">\(w_1,w_2,\ldots\)</span>，这些实数表示各个输入对输出的重要性。这个神经元输出(output) <span class="math inline">\(0\)</span> 或者 <span class="math inline">\(1\)</span> 是由这些输入的加权求和 <span class="math inline">\(\sum_j w_j x_j\)</span> 是否大于或者小于某一个阈值(threshold)。不像这些权重，阈值是这个神经元的实数参数。将它们放入更加精确的代数术语中： <img src="2017-04-18_194211.png"> 这就是一个感知器如何工作的全部内容！</p><p>这是一个基础的数学模型。你可以这么理解感知器，它是一个通过加权凭据来进行决策的设备。让我们来看这个例子，可能它不是一个真实的例子，但是非常好理解，后面我们将很快进入真实的例子。假设周末到了，你听说在你所在的城市将有一个奶酪节，你很喜欢吃奶酪，并且正决定是否要去参加这个节日，你可能会通过以下三个方面来权衡你的决定:</p><ol style="list-style-type: decimal"><li>天气好吗？</li><li>你的男(女)朋友是否愿意陪你去？</li><li>是否这个活动距离公共交通很近？（你自己没车）</li></ol><p>我们将这三个因素用对应的二进制变量<span class="math inline">\(x_1, x_2\)</span>和<span class="math inline">\(x_3\)</span>表示。比如，当天气还不错时，我们有<span class="math inline">\(x_1 = 1\)</span> ，天气不好时<span class="math inline">\(x_1 = 0\)</span>；相似的，如果男或女朋友愿意去，<span class="math inline">\(x_2 = 1\)</span>，否则<span class="math inline">\(x_2 = 0\)</span>；对于公共交通<span class="math inline">\(x_3\)</span>同理赋值。</p><p>现在假设奶酪是你的最爱，以致于即便你的男或女朋友不感兴趣而且去那里也不太方便，你仍然非常想去参加这个节日活动。但是也许你真的讨厌坏天气，而且如果天气很糟，你也没办法去。你能使用感知器来模拟这类决策。一种决策方式是，让天气权重 <span class="math inline">\(w_1 = 6\)</span>，其他条件权重分别为<span class="math inline">\(w_2 = 2\)</span>，<span class="math inline">\(w_3 = 2\)</span>。权重<span class="math inline">\(w_1\)</span>值越大表示天气影响最大，比起男或女朋友加入或者交通距离的影响都大。最后，假设你选择5做为感知器阈值，按照这种选择，这个感知器就能实现这个决策模型：当天气好时候输出<span class="math inline">\(1\)</span>，天气不好时候输出<span class="math inline">\(0\)</span>，无论你男或女朋友是否愿意去，或者交通是否比较近。</p><p>通过更改权重和阈值，我们能得到不同的决策模型。例如，我们将阈值设为<span class="math inline">\(3\)</span>，那么感知器会在以下条件满足时决定去参加活动：如果天气很好、或者男(女)朋友愿意去并且交通很近。换句话说，它将是决策的不同模型，阈值越低，表明你越想去参加这个节日活动。</p><p>显然，这个感知器不是人类决策的完整模型！但是这个例子说明了一个感知器如何能将各种凭据进行加权和来制定决策，而且一个复杂的感知器网络能做出非常微妙的决策： <img src="2017-04-18_194623.png"> 在这个网络中，第一列感知器（我们称其为第一层感知器）通过加权输入凭据来做出三个非常简单的决策。那第二列感知器是什么呢？其中每一个感知器都是通过将第一列的决策结果进行加权和来做出自己的决策。通过这种方式，第二层感知器能够比第一层感知器做出更加复杂和抽象层的决策。第三层感知器能做出更加复杂的决策，以此类推，更多层感知器能够进行更加复杂的决策。在这个网络中，第一列感知器（我们称其为第一层感知器）通过加权输入凭据来做出三个非常简单的决策。那第二列感知器是什么呢？其中每一个感知器都是通过将第一列的决策结果进行加权和来做出自己的决策。通过这种方式，第二层感知器能够比第一层感知器做出更加复杂和抽象层的决策。第三层感知器能做出更加复杂的决策，以此类推，更多层感知器能够进行更加复杂的决策。</p><p>顺便说一句，当我们定义感知器时，它们都只有一个输出。但上面的网络中，这些感知器看上去有多个输出。实际上，它们也仍然只有一个输出，只不过为了更好的表明这些感知器输出被其他感知器所使用，因此采用了多个输出的箭头线表示，这比起绘制一条输出线然后分裂开更好一些。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deep_learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习_基本概念</title>
      <link href="/hexoblog/2017/04/18/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/hexoblog/2017/04/18/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>深度学习应该了解的内容。</p><a id="more"></a><h2 id="深度学习的应用领域">深度学习的应用领域</h2><p>深度学习得到越来越快的发展，这是因为深度学习是最有希望解决一些普通算法难以解决的问题，让我们来看一看都有哪些问题是目前还没有解决，但是有望可以借助深度学习方法的进步解决的。</p><h3 id="黑白图像的自动着色">黑白图像的自动着色</h3><p>我们都知道，把彩色图像变成黑白图像很容易，但是要把黑白图像变成彩色图像就不那么容易了（颜色信息从那里来？），这个问题以前都是靠<a href="https://en.wikipedia.org/wiki/Hand-colouring_of_photographs" target="_blank" rel="noopener">手工着色</a>的方式解决的，但是这样的方法费时费力还需要专业的人才。 目前使用ImageNet训练的多层的卷积神经网络可以达到的水平如下图： <img src="2017-05-11_102343.png"></p><h3 id="自动为电影添加声音">自动为电影添加声音</h3><p>为无声电影添加配音应该是一个更加困难的问题，但是深度学习的方法已经做出了一些有益的尝试。现在能够做到的是一些简单的动作的配音，例如视频中出现一个敲击的动作，可以配上一个敲击的声音，当然，这需要大量的训练样本去学习什么样的场景对应什么样的声音。这个方面主要是<strong>CNN</strong>和<strong>LSTM</strong>.</p><h3 id="自动机器翻译">自动机器翻译</h3><p><strong>自动翻译文字</strong></p><p>从一种语言翻译到另外一种语言，这样的软件早就有，而且有了很多年了。但是翻译的水平始终无法与人工翻译相提并论。深度学习技术的发展有希望改变这一点，自动机器翻译的水平不断提高，直逼人工翻译的水平。这个领域使用的神经网络是<strong>Stacked networks of large LSTM recurrent neural networks</strong>.</p><p><strong>翻译图像中的文字</strong></p><p>识别图像中的文字一直以来都是一个比较实际的问题，在各种场合下都有应用。最常见的比如车牌的识别，名片的识别，信用卡号码的识别。以前用图像处理的算法解决这个问题的时候，大多是局限在某一个具体的场景，例如车牌识别，图像大小基本固定，背景颜色基本固定，文字只有很有限的几个，这种情况下普通的算法也能得到很好的效果。但是实际应用的时候往往情况比这个复杂的多，这个领域使用的神经网络主要是<strong>CNN</strong>.</p><div class="figure"><img src="2017-05-11_104215.png"></div><h3 id="物体分类和检测">物体分类和检测</h3><p>识别一个图像中的物体的类别，或者各个物体的类别也是意见很困难的事情。因为类别往往有无穷多种。</p><p><strong>Object Classification</strong></p><p>比如判断一副图像属于1000个类别中的哪一类。目前ImageNet上已经能够做到很高的准确率。</p><p><strong>Object Detection</strong></p><p>识别图像中的各个对象并标记出来。</p><div class="figure"><img src="2017-05-11_104735.png"></div><h3 id="手写笔迹的自动生成">手写笔迹的自动生成</h3><p>我们知道，一个人的签名可以证明身份，这是因为假设了一个前提：每个人的笔迹都有唯一性，并且可以鉴别出来。这个任务就是要打破这个前提，让电脑可以根据一个人的笔迹风格，生成出具有相同风格的笔迹。到那个时候，签名估计就没什么用了。 当然，目前这方面还很弱。</p><h3 id="文本的自动生成">文本的自动生成</h3><p>这是一个更加令人兴奋的领域。可以借助机器自动句子，段落，甚至论文。主要使用的神经网络是<strong>Large recurrent neural networks</strong>. 当然，这个目前还没有什么突破，具体的成果可以参考<a href="http://karpathy.github.io/" class="uri" target="_blank" rel="noopener">http://karpathy.github.io/</a></p><h3 id="图像理解">图像理解</h3><p>该任务是自动生成一段对图像的描述性文字，类似我们小时候玩的那种<em>看图说话</em>。这个领域已经取得了一些令人惊叹的成果，目前的水平如下图：</p><div class="figure"><img src="2017-05-11_105852.png"></div><h3 id="automatic-game-playing">Automatic Game Playing</h3><p>This is a task where a model learns how to play a computer game based only on the pixels on the screen.</p><p>This very difficult task is the domain of deep reinforcement models and is the breakthrough that DeepMind (now part of google) is renown for achieving.</p><h2 id="深度学习中的概念">深度学习中的概念</h2><p><img src="2017-04-18_111733.png"> 神经网络中的一个函数： <img src="2017-04-18_111848.png"> 将负无穷到正无穷的范围压缩到0–1的函数： <img src="2017-04-18_112030.png"> 下图中的神经网络使用上面的激活函数。 <img src="2017-04-18_122122.png"></p><p>神经网络的结构一旦定义，就定义了一组函数。神经网络的参数一旦确定，就确定了一个函数，对于特定的输入，产生特定的输出。 <img src="2017-04-18_122501.png"> 输出层的处理，归一化0–1的范围。 <img src="2017-04-18_123014.png"></p><h3 id="张量tensor">张量(tensor)</h3><p>张量，或tensor，是本文档会经常出现的一个词汇，在此稍作解释。</p><p>使用这个词汇的目的是为了表述统一，张量可以看作是向量、矩阵的自然推广，我们用张量来表示广泛的数据类型。</p><p>规模最小的张量是0阶张量，即标量，也就是一个数。</p><p>当我们把一些数有序的排列起来，就形成了1阶张量，也就是一个向量</p><p>如果我们继续把一组向量有序的排列起来，就形成了2阶张量，也就是一个矩阵</p><p>把矩阵摞起来，就是3阶张量，我们可以称为一个立方体，具有3个颜色通道的彩色图片就是一个这样的立方体</p><p>把立方体摞起来，好吧这次我们真的没有给它起别名了，就叫4阶张量了，不要去试图想像4阶张量是什么样子，它就是个数学上的概念。</p><p>张量的阶数有时候也称为维度，或者轴，轴这个词翻译自英文axis。譬如一个矩阵[[1,2],[3,4]]，是一个2阶张量，有两个维度或轴，沿着第0个轴（为了与python的计数方式一致，本文档维度和轴从0算起）你看到的是[1,2]，[3,4]两个向量，沿着第1个轴你看到的是[1,3]，[2,4]两个向量。</p><p>要理解沿着某个轴的意思，可以运行如下的代码： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">sum0 = np.sum(a, axis=<span class="number">0</span>)</span><br><span class="line">sum1 = np.sum(a, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> sum0</span><br><span class="line"><span class="keyword">print</span> sum1</span><br></pre></td></tr></table></figure></p><h3 id="平方误差和交叉熵">平方误差和交叉熵</h3><div class="figure"><img src="2017-04-18_182534.png"></div><h3 id="激活函数">激活函数</h3><p>作用在神经元上，对神经元上的数据进行处理的函数。在神经网络发展的早期，神经元上的数据没有经过任何处理，或者只经过线性的处理，可以认为这个时候的激活函数是<span class="math inline">\(y=x\)</span>,或者(-1|1),(0|1)等阶跃函数。 #### sigmod激活函数 <img src="2017-04-19_090342.png"> <span class="math display">\[f(x) =  \dfrac 1 {1 + e^x}\]</span></p><p>它的作用是把 <span class="math inline">\(-\infty\)</span> 到 <span class="math inline">\(+\infty\)</span> 映射到[0,1]范围内.函数主要在[-4,4]之间，两侧接近0和1.由于Sigmoid函数所具有的性质, 它常和单位阶跃函数用于构造人工神经网络; 另外心理学中的学习曲线的形状也和Sigmoid函数比较类似.</p><p>主要用于隐层神经元输出。</p><h4 id="tanh-激活函数">tanh 激活函数</h4><p><span class="math display">\[tanh(x) = 2sigmoid(2x)-1\]</span></p><p>实际应用中，tanh 会比 sigmoid 更好.</p><h4 id="softmax-激活函数">Softmax 激活函数</h4><p>主要用于多分类神经网络输出。 <img src="2017-04-19_092053.png"></p><p>Softmax适合多分类的情况。 #### ReLu(Rectified Linear Units)激活函数 深度学习中，我们一般使用ReLU作为中间隐层神经元的激活函数，AlexNet中提出用ReLU来替代传统的激活函数是深度学习的一大进步。 2001年，神经科学家Dayan、Abott从生物学角度，模拟出了脑神经元接受信号更精确的激活模型，该模型如下图所示： <img src="2017-04-19_092904.png"></p><p><strong>Softplus</strong></p><p>Softplus函数，Softplus函数是Logistic-Sigmoid函数原函数</p><p><span class="math display">\[softplus(x) = log(1+e^x)\]</span></p><p><strong>Rectifier</strong></p><p><span class="math display">\[f(x) = max(0,x)\]</span></p><p><img src="2017-04-19_093237.png"> 综合速率和效率，DL中大部分激活函数应该选择ReLu. ## 深度学习工具 ### keras <a href="https://keras-cn.readthedocs.io/en/latest/" target="_blank" rel="noopener">keras中文文档</a></p><p><a href="https://keras.io/" target="_blank" rel="noopener">keras官方文档</a></p><p><a href="https://github.com/fchollet/keras" target="_blank" rel="noopener">github开源代码</a></p><h4 id="安装">安装</h4><ol style="list-style-type: decimal"><li>下载源代码</li><li>解压缩</li><li>切换到解压缩之后的目录，包含文件<code>setup.py</code>的路径，执行安装命令<code>python setup.py install</code>.</li><li>打开python环境，输入<code>import keras</code>,如果没有报错，证明安装成功。</li></ol><p>如果以上步骤出现问题，很可能是缺少需要的软件包。keras后端使用tensorflow或者theano，所以二者必须使用安装其中之一。如果没有安装<code>tensorfolw</code>,则会有下面的报错信息： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Using TensorFlow backend.</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"C:\Anaconda2\lib\site-packages\keras-2.0.3-py2.7.egg\keras\__init__.py"</span>,</span><br><span class="line"> line <span class="number">3</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> . <span class="keyword">import</span> activations</span><br><span class="line">  File <span class="string">"C:\Anaconda2\lib\site-packages\keras-2.0.3-py2.7.egg\keras\activations.p</span></span><br><span class="line"><span class="string">y"</span>, line <span class="number">3</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> . <span class="keyword">import</span> backend <span class="keyword">as</span> K</span><br><span class="line">  File <span class="string">"C:\Anaconda2\lib\site-packages\keras-2.0.3-py2.7.egg\keras\backend\__ini</span></span><br><span class="line"><span class="string">t__.py"</span>, line <span class="number">73</span>, <span class="keyword">in</span> &lt;module&gt;</span><br></pre></td></tr></table></figure></p><p>如果已经安装了<code>theano</code>,可以切换keras的后端。</p><h4 id="在tensorflow和theano之间切换">在TensorFlow和theano之间切换</h4><p><a href="https://keras.io/backend/" target="_blank" rel="noopener">官方文档</a></p><ol style="list-style-type: decimal"><li><p>找到配置文件<code>$HOME/.keras/keras.json</code>,如果还没有，创建该文件。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"epsilon"</span>: <span class="number">1e-07</span>,</span><br><span class="line">    <span class="string">"floatx"</span>: <span class="string">"float32"</span>,</span><br><span class="line">    <span class="string">"image_data_format"</span>: <span class="string">"channels_last"</span>,</span><br><span class="line">    <span class="string">"backend"</span>: <span class="string">"tensorflow"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>backend指定了使用哪一个，可使用的关键字是<code>tensorflow</code>和<code>theano</code>,修改保存即可。</p></li></ol><h4 id="安装tensorflow">安装tensorflow</h4><p>如果之前两个软件包都没有安装，那么必须要安装一个才能继续使用keras. <a href="https://www.tensorflow.org/install/" target="_blank" rel="noopener">官方安装教程</a></p><p>我们只是用来学习，所以先安装一个不支持GPU的版本，这个版本需要的条件少，容易安装成功。关于完整的安装教程，可以参照官方文档。</p><ol style="list-style-type: decimal"><li>下载安装<a href="https://www.continuum.io/downloads" target="_blank" rel="noopener">Anaconda</a></li><li><p>创建一个tensorflow环境：<code>conda create -n tensorflow</code>; <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Fetching package metadata ...........</span><br><span class="line">Solving package specifications:</span><br><span class="line">Package plan for installation in environment C:\Anaconda2\envs\tensorflow:</span><br></pre></td></tr></table></figure></p></li><li>激活该环境：<code>activate tensorflow</code></li><li><p>安装<code>cpu-only</code>版本的tensorflow: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/windows/cpu/tensorflow<span class="number">-1.0</span><span class="number">.1</span>-cp35-cp35m-win_amd64.whl</span><br></pre></td></tr></table></figure></p></li></ol><p>如果出现下面的错误： <code>tensorflow-1.0.1-cp35-cp35m-win_amd64.whl is not a supported wheel on this platf orm.</code>;可能是因为你的python环境不是3.5，目前tensorflow在windows上只支持python 3.5.</p><ol start="5" style="list-style-type: decimal"><li>anaconda创建一个python 3.5的环境：<code>&gt;conda create --name tensorflow35 python=3.5</code>,然后激活该环境<code>activate tensorflow35</code>.然后再执行第四步的安装语句。</li><li>成功安装之后会有<code>successful</code>的字样。<code>Successfully installed appdirs-1.4.3 numpy-1.12.1 packaging-16.8 protobuf-3.2.0 pyparsing-2.2.0 setuptools-35.0.0 six-1.10.0 tensorflow-1.0.1 wheel-0.29.0</code>.</li><li>测试安装是否成功：进入python环境执行<code>import tensorflow as tf</code>，没有报错证明安装成功。</li></ol><p>安装完<code>tensorflow</code>之后，重新执行上面的安装keras的所有步骤，即可成功安装keras. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> keras</span><br><span class="line">Using TensorFlow backend.</span><br></pre></td></tr></table></figure></p><p>出现上面的提示，没有任何的报错信息，证明安装成功。</p><h4 id="安装theano">安装theano</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda install mingw libpython</span><br><span class="line">pip insall theano</span><br></pre></td></tr></table></figure><h4 id="keras配置文件">keras配置文件</h4><p>位置： <code>C:\Users\FF120\.keras\keras.json</code>; 内容： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"epsilon"</span>: <span class="number">1e-07</span>,</span><br><span class="line">    <span class="string">"floatx"</span>: <span class="string">"float32"</span>,</span><br><span class="line">    <span class="string">"image_data_format"</span>: <span class="string">"channels_last"</span>,</span><br><span class="line">    <span class="string">"backend"</span>: <span class="string">"tensorflow"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>backend : 用来指定keras使用的后端实现，可选的关键字是<code>tensorflow</code>,<code>theano</code>;</p><p>image_data_format: 用来指定图像输入参数的格式，可选的关键字是<code>channels_first</code>,<code>channels_last</code>,详细的叙述参看下面。 &gt; 在如何表示一组彩色图片的问题上，Theano和TensorFlow发生了分歧，’th’模式，也即Theano模式会把100张RGB三通道的16×32（高为16宽为32）彩色图表示为下面这种形式（100,3,16,32），Caffe采取的也是这种方式。第0个维度是样本维，代表样本的数目，第1个维度是通道维，代表颜色通道数。后面两个就是高和宽了。这种theano风格的数据组织方法，称为“channels_first”，即通道维靠前。 &gt; 而TensorFlow，的表达形式是（100,16,32,3），即把通道维放在了最后，这种数据组织方式称为“channels_last”。</p><h4 id="keras模型">keras模型</h4><p>接受张量作为输入然后输出张量的实体都叫做模型，keras中有两种模型。一种是最简单的<code>Sequential</code>,它是单输入单输出，一条路通到底，层与层之间只有相邻关系，跨层连接统统没有。这种模型编译速度快，操作上也比较简单。</p><p>还有一种是<code>functional model API</code>,这个模型支持多输入多输出，层与层之间想怎么连怎么连，但是编译速度慢。</p><h4 id="keras编程概念">keras编程概念</h4><p><strong>batch_size</strong> 深度学习的优化算法，说白了就是梯度下降。每次的参数更新有两种方式。</p><p>第一种，遍历全部数据集算一次损失函数，然后算函数对各个参数的梯度，更新梯度。这种方法每更新一次参数都要把数据集里的所有样本都看一遍，计算量开销大，计算速度慢，不支持在线学习，这称为Batch gradient descent，批梯度下降。</p><p>另一种，每看一个数据就算一下损失函数，然后求梯度更新参数，这个称为随机梯度下降，stochastic gradient descent。这个方法速度比较快，但是收敛性能不太好，可能在最优点附近晃来晃去，hit不到最优点。两次参数的更新也有可能互相抵消掉，造成目标函数震荡的比较剧烈。</p><p>为了克服两种方法的缺点，现在一般采用的是一种折中手段，mini-batch gradient decent，小批的梯度下降，这种方法把数据分为若干个批，按批来更新参数，这样，一个批中的一组数据共同决定了本次梯度的方向，下降起来就不容易跑偏，减少了随机性。另一方面因为批的样本数与整个数据集相比小了很多，计算量也不是很大。</p><p>基本上现在的梯度下降都是基于mini-batch的，所以Keras的模块中经常会出现batch_size，就是指这个。</p><p>顺便说一句，Keras中用的优化器SGD是stochastic gradient descent的缩写，但不代表是一个样本就更新一回，还是基于mini-batch的。</p><h5 id="layers">layers</h5><p><strong>Dense</strong> 普通的全连接的神经网络层。</p><p><strong>Dropout</strong> 一个简单的避免神经网络的训练过程中过拟合的方法，具体的还不是太懂，参考论文：<a href="http://www.cs.toronto.edu/~rsalakhu/papers/srivastava14a.pdf" target="_blank" rel="noopener">Dropout: A Simple Way to Prevent Neural Networks from Overfitting</a></p><h2 id="深度学习资料">深度学习资料</h2><p>https://ljalphabeta.gitbooks.io/neural-networks-and-deep-learning-notes/content/chapter6.html</p><p>http://www.tensorfly.cn/home/?p=80</p><p>http://neuralnetworksanddeeplearning.com/chap2.html</p><p>http://ufldl.stanford.edu/wiki/index.php/UFLDL_Tutorial</p><p>http://www.pyimagesearch.com/2014/09/22/getting-started-deep-learning-python</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deep_learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法专题_算法总结</title>
      <link href="/hexoblog/2017/04/17/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/hexoblog/2017/04/17/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>从宏观上总结都有哪些算法，每种算法各自适用解决什么样的问题。 <a id="more"></a> - 分治法 - 随机化方法 - 递归技术 - 动态规划 - 贪心算法 - 摊还分析</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法专题_排序算法</title>
      <link href="/hexoblog/2017/04/16/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/hexoblog/2017/04/16/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>排序算法，是将无序数据变为有序的一种算法。通常分为内部排序和外部排序。内部排序是指所有待排序的数据都在内存中，都可以直接访问得到。 外部排序是指数据存储在外部，通常都涉及大量的数据的排序问题，这里我们先不讨论。本文主要介绍主要的内部排序算法。 <a id="more"></a> 内部排序按照算法思想的不同，可以分为以下几种类型：</p><blockquote><ul><li>插入排序</li><li>选择排序</li><li>交换排序</li><li>归并排序</li><li>基数排序</li></ul></blockquote><h2 id="比较排序">比较排序</h2><p>如果排序算法中元素的顺序的确定依赖元素之间的比较，那么这类排序算法称作比较排序。</p><p>插入排序</p><p>插入排序的思想是将一个元素插入到一个已经排序好的序列中，在插入的时候逐个比较带插入元素和有序的序列，找到新插入元素的合适位置，插入到序列中。</p><h3 id="直接插入排序">直接插入排序</h3><p>最简单的插入排序，直接使用插入排序的思想而没有经过任何的优化过程。 <img src="2017-04-16_193954.png"> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> a : v)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count == i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">" : "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; SimpleInsertSort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.size();</span><br><span class="line">    <span class="comment">// 每次循环，都假设i前面的数字已经排序好了，i是要插入到已排序序列的数字，i之后的数字都是未排序的。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="comment">// 打印当前的状态</span></span><br><span class="line">        print(a,i);</span><br><span class="line">        <span class="comment">// 找到当前数字i应当插入的位置</span></span><br><span class="line">        <span class="keyword">int</span> curValue = a[i];</span><br><span class="line">        <span class="keyword">int</span> ii = i;</span><br><span class="line">        <span class="keyword">if</span>(a[ii]&lt;a[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="comment">//应当插入首位</span></span><br><span class="line">            <span class="keyword">while</span>(ii<span class="number">-1</span>&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                a[ii] = a[ii<span class="number">-1</span>];</span><br><span class="line">                ii--;</span><br><span class="line">            &#125;</span><br><span class="line">            a[<span class="number">0</span>] = curValue;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[ii]&gt;=a[ii<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="comment">//应当插入末尾</span></span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">//如果应该插入的位置是有序列表的末尾，则什么都不用做。</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;ii<span class="number">-1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[ii]&gt;=a[j] &amp;&amp; a[ii]&lt;a[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="comment">//应当插入j之后</span></span><br><span class="line">                    <span class="keyword">while</span>(ii<span class="number">-1</span>&gt;j)&#123;</span><br><span class="line">                        a[ii] = a[ii<span class="number">-1</span>];</span><br><span class="line">                        ii--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    a[ii] = curValue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print(a,a.size());</span><br><span class="line">    <span class="keyword">return</span>  a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>,<span class="number">13</span>,<span class="number">27</span>,<span class="number">49</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> re = SimpleInsertSort(v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">49</span>  : <span class="number">38</span> <span class="number">65</span> <span class="number">97</span> <span class="number">76</span> <span class="number">13</span> <span class="number">27</span> <span class="number">49</span></span><br><span class="line"><span class="number">38</span> <span class="number">49</span>  : <span class="number">65</span> <span class="number">97</span> <span class="number">76</span> <span class="number">13</span> <span class="number">27</span> <span class="number">49</span></span><br><span class="line"><span class="number">38</span> <span class="number">49</span> <span class="number">65</span>  : <span class="number">97</span> <span class="number">76</span> <span class="number">13</span> <span class="number">27</span> <span class="number">49</span></span><br><span class="line"><span class="number">38</span> <span class="number">49</span> <span class="number">65</span> <span class="number">97</span>  : <span class="number">76</span> <span class="number">13</span> <span class="number">27</span> <span class="number">49</span></span><br><span class="line"><span class="number">38</span> <span class="number">49</span> <span class="number">65</span> <span class="number">76</span> <span class="number">97</span>  : <span class="number">13</span> <span class="number">27</span> <span class="number">49</span></span><br><span class="line"><span class="number">13</span> <span class="number">38</span> <span class="number">49</span> <span class="number">65</span> <span class="number">76</span> <span class="number">97</span>  : <span class="number">27</span> <span class="number">49</span></span><br><span class="line"><span class="number">13</span> <span class="number">27</span> <span class="number">38</span> <span class="number">49</span> <span class="number">65</span> <span class="number">76</span> <span class="number">97</span>  : <span class="number">49</span></span><br><span class="line"><span class="number">13</span> <span class="number">27</span> <span class="number">38</span> <span class="number">49</span> <span class="number">49</span> <span class="number">65</span> <span class="number">76</span> <span class="number">97</span></span><br></pre></td></tr></table></figure></p><p>简单插入排序的时间复杂度是<code>o(n^2)</code>;</p><h3 id="折半插入排序二分插入排序">折半插入排序(二分插入排序)</h3><p>简单插入排序没有经过任何的过程优化，我们仔细分析简单插入排序的过程，寻找元素应该插入的位置这一过程是可以优化的。因为是在有序序列中查找，所以可以使用二分查找方法缩短查找的时间。该方法被叫做二分插入排序。 STL中<code>lower_bound(a.begin(),a.end()+ii,a[i]);</code>实现了二分查找算法，我们直接使用它替换原来的循环语句查找出插入位置即可。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用二分查找方法搜索应该插入的位置，此方法叫做二分插入排序</span></span><br><span class="line"><span class="comment">//            for(int j=0;j&lt;ii-1;j++)&#123;</span></span><br><span class="line"><span class="comment">//                if(a[ii]&gt;=a[j] &amp;&amp; a[ii]&lt;a[j+1])&#123;</span></span><br><span class="line"><span class="comment">//                    //应当插入j之后</span></span><br><span class="line"><span class="comment">//                    while(ii-1&gt;j)&#123;</span></span><br><span class="line"><span class="comment">//                        a[ii] = a[ii-1];</span></span><br><span class="line"><span class="comment">//                        ii--;</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//                    a[ii] = curValue;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="keyword">auto</span> index = lower_bound(a.begin(),a.begin()+ii,a[ii]);</span><br><span class="line"><span class="comment">//应当插入j之后的位置</span></span><br><span class="line"><span class="keyword">int</span> j = distance(a.begin(),index)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(ii<span class="number">-1</span>&gt;j)&#123;</span><br><span class="line">        a[ii] = a[ii<span class="number">-1</span>];</span><br><span class="line">        ii--;</span><br><span class="line">&#125;</span><br><span class="line">a[ii] = curValue;</span><br></pre></td></tr></table></figure></p><h3 id="二路插入排序">二路插入排序</h3><h3 id="缩小增量排序希尔排序">缩小增量排序（希尔排序）</h3><h3 id="简单选择排序">简单选择排序</h3><p>在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。</p><h3 id="二元选择排序">二元选择排序</h3><p>简单选择排序，每趟循环只能确定一个元素排序后的定位。我们可以考虑改进为每趟循环确定两个元素（当前趟最大和最小记录）的位置,从而减少排序所需的循环次数。改进后对n个数据进行排序，最多只需进行[n/2]趟循环即可。</p><h3 id="堆排序">堆排序</h3><p>堆排序就是使用堆维护数据的有序结构，主要的问题是的建堆的操作和堆调整的操作。</p><p>交换排序</p><h3 id="冒泡排序">冒泡排序</h3><p>冒泡排序总是交换相邻的两个值。</p><p>在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> a : v)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count == i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">" | "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sortTop(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=v.size()<span class="number">-1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">        print(v,j+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;j;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i+<span class="number">1</span>] &lt; v[i])&#123;</span><br><span class="line">                tmp = v[i];</span><br><span class="line">                v[i] = v[i+<span class="number">1</span>];</span><br><span class="line">                v[i+<span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>,<span class="number">13</span>,<span class="number">27</span>,<span class="number">12</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> a = sortTop(v);</span><br><span class="line">    print(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">49</span> <span class="number">38</span> <span class="number">65</span> <span class="number">97</span> <span class="number">76</span> <span class="number">13</span> <span class="number">27</span> <span class="number">12</span></span><br><span class="line"><span class="number">38</span> <span class="number">49</span> <span class="number">65</span> <span class="number">76</span> <span class="number">13</span> <span class="number">27</span> <span class="number">12</span>  | <span class="number">97</span></span><br><span class="line"><span class="number">38</span> <span class="number">49</span> <span class="number">65</span> <span class="number">13</span> <span class="number">27</span> <span class="number">12</span>  | <span class="number">76</span> <span class="number">97</span></span><br><span class="line"><span class="number">38</span> <span class="number">49</span> <span class="number">13</span> <span class="number">27</span> <span class="number">12</span>  | <span class="number">65</span> <span class="number">76</span> <span class="number">97</span></span><br><span class="line"><span class="number">38</span> <span class="number">13</span> <span class="number">27</span> <span class="number">12</span>  | <span class="number">49</span> <span class="number">65</span> <span class="number">76</span> <span class="number">97</span></span><br><span class="line"><span class="number">13</span> <span class="number">27</span> <span class="number">12</span>  | <span class="number">38</span> <span class="number">49</span> <span class="number">65</span> <span class="number">76</span> <span class="number">97</span></span><br><span class="line"><span class="number">13</span> <span class="number">12</span>  | <span class="number">27</span> <span class="number">38</span> <span class="number">49</span> <span class="number">65</span> <span class="number">76</span> <span class="number">97</span></span><br><span class="line"><span class="number">12</span> <span class="number">13</span> <span class="number">27</span> <span class="number">38</span> <span class="number">49</span> <span class="number">65</span> <span class="number">76</span> <span class="number">97</span>  |</span><br></pre></td></tr></table></figure></p><h2 id="线性时间排序">线性时间排序</h2><p>比较排序依赖元素之间的比较，所以最优的算法的时间复杂度也不会低于<code>O(n*logn)</code>;归并排序，堆排序和快速排序都可以达到这一水平。还有一些不依赖元素之间的比较确定元素顺序的排序算法可以达到更低的时间复杂度。例如：计数排序，基数排序和桶排序。</p><h3 id="计数排序">计数排序</h3><p>计数排序的基本思想是： 开辟一个与最大数的值大小一样的数组，然后把每个数字放到对应的数组中，自然而然就有序了。例如对<code>[9,23,2,100,34,398,5]</code>排序，开辟一个a[399]的数组，然后<code>令a[9] = 1;a[23] = 1;a[2]=1;a[100] = 1; a[34] = 1;a[398] = 1;a[5] = 1</code>;然后从头开始把有值的元素取出来就自然有了顺序。如果有元素的值相等，例如有2个100，只需要让a[100] = 2就行了。下面看看如何取出排序好的数据。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计数排序</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countSort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)&#123;</span><br><span class="line">    <span class="comment">//1.找到最大值，开辟数组</span></span><br><span class="line">    <span class="keyword">if</span>(v.empty()) <span class="keyword">return</span> v;</span><br><span class="line">    <span class="keyword">int</span> maxValue = v[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;v.size();i++)&#123;</span><br><span class="line">        maxValue = v[i] &gt; maxValue ? v[i] : maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 开辟对应的数组并计数</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b(maxValue + <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();i++)&#123;</span><br><span class="line">        b[v[i]] = b[v[i]] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 取出结果</span></span><br><span class="line">    v.clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b.size();i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(b[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            v.push_back(i);</span><br><span class="line">            b[i] = b[i] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码只能处理非负数的情况。需要注意的是，计数排序当处理有大量重复数字，而数据的范围不大的时候很有用。 ### 基数排序(桶排序) 桶排序是一种时间复杂度可以达到O(n)的排序算法，但是它使用的空间较多，也有较大的限制条件，不适用于所有情况下的排序，只适用特定的情况下的排序。</p><p>一种更一般的算法思想是分桶法。它的思想是把元素按照一定的范围分别放在对应的桶中，然后再做相应的处理。分组后处理的复杂度就会降低很多，然后再想办法把每个桶中的结果合并起来。</p><p>基数排序专门针对的是整数的排序，（因为字符串也是整数表示的，所以字符串的排序也可以使用桶排序）。这里固定的把桶定为10个，分别对应数字0–9.首先按照个位数字入桶，然后按照十位数字，然后按照百位数字，…直到最高位数字，然后按照顺序取出来就是了。下面以<code>[521 310 72 373 15 546 385 856 187 147]</code>为例子说明具体的过程。 <img src="2017-04-17_200445.png"> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回a的第i位数字，</span></span><br><span class="line"><span class="comment">// i = 0 个位</span></span><br><span class="line"><span class="comment">// i = 1 十位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gg</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> re;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        re = a % <span class="number">10</span>;</span><br><span class="line">        a = a / <span class="number">10</span>;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; baseSort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.empty()) <span class="keyword">return</span> v;</span><br><span class="line">    <span class="keyword">int</span> maxValue = v[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//找到最大值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();i++)&#123;</span><br><span class="line">        maxValue = v[i] &gt; maxValue ? v[i] : maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> high = <span class="number">0</span>;  <span class="comment">// 获得最高位，需要循环这么多次</span></span><br><span class="line">    <span class="keyword">while</span>(maxValue)&#123;</span><br><span class="line">        maxValue /= <span class="number">10</span>;</span><br><span class="line">        high ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// i = 0 按照个位入桶，收集</span></span><br><span class="line">    <span class="comment">// i = 1 按照十位入桶，收集</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;high;i++)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; t(<span class="number">10</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 入桶操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;v.size();j++)&#123;</span><br><span class="line">            t[ gg(v[j],i) ].push_back(v[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从0号桶开始按照顺序收集</span></span><br><span class="line">        v.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> a : t)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> b : a)&#123;</span><br><span class="line">                v.push_back(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="后记">后记</h2><p>说明：</p><p>当原表有序或基本有序时，直接插入排序和冒泡排序将大大减少比较次数和移动记录的次数，时间复杂度可降至O（n）；</p><p>而快速排序则相反，当原表基本有序时，将蜕化为冒泡排序，时间复杂度提高为O（n2）；</p><p>原表是否有序，对简单选择排序、堆排序、归并排序和基数排序的时间复杂度影响不大。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPM中函数的修改和使用</title>
      <link href="/hexoblog/2017/04/14/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/SPM%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/hexoblog/2017/04/14/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/SPM%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>SPM是处理脑成像数据的一个综合性软件，基于matlab实现，里面有大量的函数都可以抽取出来单独使用完成某一个功能。使用其中的函数工作可以大大提高分析处理数据的便捷性，便于实现批量处理和大规模数据处理。 <a id="more"></a> ### 获得窗口的句柄保存下窗口正在显示的图像 <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Fgraph = spm_figure(<span class="string">'GetWin'</span>,<span class="string">'Graphics'</span>);</span><br><span class="line">h1 = <span class="built_in">figure</span>(Fgraph);</span><br><span class="line">print(h1,Input_VOINames,<span class="string">'-dpng'</span>);<span class="comment">% 打印出PNG图片，还可以输出其他的格式，参考Matlab的print函数。</span></span><br></pre></td></tr></table></figure></p><h3 id="打印spm头信息包括时间和日期以及执行的函数名称">打印SPM头信息，包括时间和日期以及执行的函数名称</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spm(<span class="string">'FnBanner'</span>,mfilename,SVNid);</span><br><span class="line"><span class="comment">% SPM8: spm_imcalc_extend (v3691)                    22:17:00 - 16/11/2016</span></span><br><span class="line"><span class="comment">% ========================================================================</span></span><br></pre></td></tr></table></figure><h3 id="获得文件p的头信息">获得文件P的头信息</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P = &#123;<span class="string">'D:\FMRI_ROOT\YANTAI\ANALYSIS\pre_processing\20160911002\ep2d_bold_moco_p2_rest_0006\af20160911002-182750-00006-00006-1.img'</span>,</span><br><span class="line">    <span class="string">'D:\FMRI_ROOT\YANTAI\ANALYSIS\pre_processing\20160911002\ep2d_bold_moco_p2_rest_0006\af20160911002-182750-00006-00006-1.img'</span>&#125;;</span><br><span class="line">header = spm_vol(P);</span><br></pre></td></tr></table></figure><h3 id="获得图像某个坐标的值">获得图像某个坐标的值</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">V = &#123;<span class="string">'D:\FMRI_ROOT\YANTAI\ANALYSIS\first_level\20160911002\beta_0001.img'</span>&#125;;</span><br><span class="line">XYZ = [<span class="number">13</span>;<span class="number">48</span>;<span class="number">2</span>];</span><br><span class="line">Y = spm_get_data(V,XYZ);</span><br></pre></td></tr></table></figure><h3 id="roi的定义">ROI的定义</h3><p>SPM中Region of Interest(ROI)的定义使用的是函数<code>spm_ROI.m</code>,在SPM工具包中查找该名称即可找到它。 SPM中的函数默认都是通过交互的方式获得需要的参数的，类似这样的形式，<code>spm_input('VOI definition...','!+1','b',def,[],1);</code>，当我们需要批量处理的时候，只需要找到相关的参数，注释掉<code>spm_input...</code>，以传入参数替代即可。例如，假如我们想要修改<code>spm_ROI.m</code>使它能够根据输入的MNI坐标定义一个球形的ROI,可以这样修改： 1. 找到下面这段代码： <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ~isfield(xY,<span class="string">'def'</span>)</span><br><span class="line">    def        = &#123;<span class="string">'sphere'</span>,<span class="string">'box'</span>,<span class="string">'cluster'</span>,<span class="string">'mask'</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> isfield(xY,<span class="string">'rej'</span>)</span><br><span class="line">        <span class="keyword">if</span> ~isfield(xY,<span class="string">'M'</span>)</span><br><span class="line">            xY.rej = &#123;xY.rej&#123;:&#125; <span class="string">'cluster'</span>&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> isfield(xY,<span class="string">'M'</span>)</span><br><span class="line">            xY.rej = &#123;&#125;;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            xY.rej = &#123;<span class="string">'cluster'</span>&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    [q, <span class="built_in">i</span>] = setdiff(def,xY.rej);</span><br><span class="line">    def    = def(<span class="built_in">sort</span>(<span class="built_in">i</span>));</span><br><span class="line">    xY.def = spm_input(<span class="string">'VOI definition...'</span>,<span class="string">'!+1'</span>,<span class="string">'b'</span>,def,[],<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>其中最后一条语句<code>xY.def = spm_input('VOI definition...','!+1','b',def,[],1);</code>是定义需要什么类型的ROI的，原来的代码里面需要用户输入，这里我们把这句话注视掉，用<code>xY.def = input_xyz;</code>代替；这里需要注意的是，input_xyz是3行1列的列向量，表示MNI坐标。当不知道数据的格式的时候，最好在matlab命令窗口执行修改之前的<code>spm_input()</code>,查看返回的是什么类型的数据。 2. 然后找到下面的代码： <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'sphere'</span></span><br><span class="line">   <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">   <span class="keyword">if</span> ~isfield(xY,<span class="string">'xyz'</span>) || <span class="built_in">isempty</span>(xY.xyz)</span><br><span class="line">       xY.xyz = spm_input(<span class="string">'sphere centre [x y z] &#123;mm&#125;'</span>,...</span><br><span class="line">           <span class="string">'!+0'</span>,<span class="string">'r'</span>,<span class="string">'0 0 0'</span>,<span class="number">3</span>);</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">if</span> ~isfield(xY,<span class="string">'spec'</span>)</span><br><span class="line">       xY.spec = spm_input(<span class="string">'sphere radius (mm)'</span>,<span class="string">'!+0'</span>,<span class="string">'r'</span>,<span class="number">0</span>,<span class="number">1</span>,[<span class="number">0</span>,Inf]);</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   xY.str = sprintf(<span class="string">'%0.1fmm sphere'</span>,xY.spec);</span><br></pre></td></tr></table></figure></p><p>这段代码是当上面定义了要使用球形的ROI时，球形ROI需要的一些参数。可以揽到，这里也是用交互的方式输入的参数，这里我们修改成传入参数的形式。 <code>xY.xyz = input_xyz;</code> <code>xY.spec = input_radius;</code></p><p>该函数原来的调用方式是<code>[xY, XYZmm, j] = spm_ROI(xY, XYZmm)</code>,由于我们新加入了传入参数，所以我们修改原来的函数为下面这样的形式：<code>[xY, XYZmm, j] = spm_ROI_extend(xY, XYZmm,input_def,input_xyz,input_radius)</code>, 最后，最好把新加入的参数的含义写在下面的注释中，这样就可以使用<code>help spm_ROI</code>查看到该函数的使用方法。另外，自己改写的函数最好换一个名字。 一个完整的例子： <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[xY, XYZmm, j]</span> = <span class="title">spm_ROI_extend</span><span class="params">(xY, XYZmm,input_def,input_xyz,input_radius)</span></span></span><br><span class="line"><span class="comment">% Region of Interest specification</span></span><br><span class="line"><span class="comment">% input_def : one of &#123;'sphere','box','cluster','mask'&#125;;e.g. sphere</span></span><br><span class="line"><span class="comment">% input_xyz : MNI_cor, e.g. [2;2;2]</span></span><br><span class="line"><span class="comment">% input_radius : r of sphere, e.g.  12</span></span><br><span class="line"><span class="comment">% FORMAT xY = spm_ROI(xY)</span></span><br><span class="line"><span class="comment">% xY     - VOI structure</span></span><br><span class="line"><span class="comment">%    xY.def      - VOI definition [sphere, box, mask, cluster, all]</span></span><br><span class="line"><span class="comment">%    xY.rej      - cell array of disabled VOI definition options</span></span><br><span class="line"><span class="comment">%    xY.xyz      - centre of VOI &#123;mm&#125;</span></span><br><span class="line"><span class="comment">%    xY.spec     - VOI definition parameters</span></span><br><span class="line"><span class="comment">%    xY.str      - description of the VOI</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% FORMAT [xY, XYZmm, j] = spm_ROI(xY, XYZmm)</span></span><br><span class="line"><span class="comment">% XYZmm  - [3xm] locations of voxels &#123;mm&#125;</span></span><br><span class="line"><span class="comment">%          If an image filename, an spm_vol structure or a NIfTI object is</span></span><br><span class="line"><span class="comment">%          given instead, XYZmm will be initialised to all voxels within</span></span><br><span class="line"><span class="comment">%          the field of view of that image.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% XYZmm  - [3xn] filtered locations of voxels &#123;mm&#125; (m&gt;=n) within VOI xY</span></span><br><span class="line"><span class="comment">% j      - [1xn] indices of input locations XYZmm within VOI xY</span></span><br><span class="line"><span class="comment">%__________________________________________________________________________</span></span><br><span class="line"><span class="comment">% Copyright (C) 2008-2014 Wellcome Trust Centre for Neuroimaging</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Karl Friston, Guillaume Flandin</span></span><br><span class="line"><span class="comment">% $Id: spm_ROI.m 6079 2014-06-30 18:25:37Z spm $</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> nargin &lt; <span class="number">2</span> &amp;&amp; nargout &gt; <span class="number">1</span></span><br><span class="line">    error(<span class="string">'Too many output arguments.'</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>, xY; <span class="keyword">catch</span>, xY = []; <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Specify ROI</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="keyword">if</span> ~isfield(xY,<span class="string">'def'</span>)</span><br><span class="line">    def        = &#123;<span class="string">'sphere'</span>,<span class="string">'box'</span>,<span class="string">'cluster'</span>,<span class="string">'mask'</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> isfield(xY,<span class="string">'rej'</span>)</span><br><span class="line">        <span class="keyword">if</span> ~isfield(xY,<span class="string">'M'</span>)</span><br><span class="line">            xY.rej = &#123;xY.rej&#123;:&#125; <span class="string">'cluster'</span>&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> isfield(xY,<span class="string">'M'</span>)</span><br><span class="line">            xY.rej = &#123;&#125;;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            xY.rej = &#123;<span class="string">'cluster'</span>&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    [q, <span class="built_in">i</span>] = setdiff(def,xY.rej);</span><br><span class="line">    def    = def(<span class="built_in">sort</span>(<span class="built_in">i</span>));</span><br><span class="line">    <span class="comment">%xY.def = spm_input('VOI definition...','!+1','b',def,[],1);</span></span><br><span class="line">    xY.def = input_def; <span class="comment">%========&#123;'sphere','box','cluster','mask'&#125;;==============================================</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-ROI parameters</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">switch</span> lower(xY.def)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'sphere'</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> ~isfield(xY,<span class="string">'xyz'</span>) || <span class="built_in">isempty</span>(xY.xyz)</span><br><span class="line">        <span class="comment">%xY.xyz = spm_input('sphere centre [x y z] &#123;mm&#125;',...</span></span><br><span class="line">        <span class="comment">%    '!+0','r','0 0 0',3);</span></span><br><span class="line">        xY.xyz = input_xyz; <span class="comment">%=========[2;2;2]=============================================</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> ~isfield(xY,<span class="string">'spec'</span>)</span><br><span class="line">        <span class="comment">%xY.spec = spm_input('sphere radius (mm)','!+0','r',0,1,[0,Inf]);</span></span><br><span class="line">        xY.spec = input_radius; <span class="comment">% ============12======================================</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    xY.str = sprintf(<span class="string">'%0.1fmm sphere'</span>,xY.spec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'box'</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> ~isfield(xY,<span class="string">'xyz'</span>) || <span class="built_in">isempty</span>(xY.xyz)</span><br><span class="line">        xY.xyz = spm_input(<span class="string">'box centre [x y z] &#123;mm&#125;'</span>,...</span><br><span class="line">            <span class="string">'!+0'</span>,<span class="string">'r'</span>,<span class="string">'0 0 0'</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> ~isfield(xY,<span class="string">'spec'</span>)</span><br><span class="line">        xY.spec = spm_input(<span class="string">'box dimensions [x y z] &#123;mm&#125;'</span>,...</span><br><span class="line">            <span class="string">'!+0'</span>,<span class="string">'r'</span>,<span class="string">'0 0 0'</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">length</span>(xY.spec) &lt; <span class="number">3</span></span><br><span class="line">        xY.spec = xY.spec(<span class="number">1</span>)*[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    xY.str = sprintf(<span class="string">'%0.1f x %0.1f x %0.1f mm box'</span>,xY.spec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mask'</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> ~isfield(xY,<span class="string">'spec'</span>)</span><br><span class="line">        xY.spec = spm_vol(spm_select(<span class="number">1</span>,<span class="string">'image'</span>,<span class="string">'Specify Mask'</span>));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> ~isstruct(xY.spec)</span><br><span class="line">            xY.spec = spm_vol(xY.spec);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    str    = spm_file(xY.spec.fname,<span class="string">'short30'</span>);</span><br><span class="line">    str    = regexprep(str, &#123;<span class="string">'\\'</span> <span class="string">'\^'</span> <span class="string">'_'</span> <span class="string">'&#123;'</span> <span class="string">'&#125;'</span>&#125;, ...</span><br><span class="line">        &#123;<span class="string">'\\\\'</span> <span class="string">'\\^'</span> <span class="string">'\\_'</span> <span class="string">'\\&#123;'</span> <span class="string">'\\&#125;'</span>&#125;); <span class="comment">% Escape TeX special characters</span></span><br><span class="line">    xY.str = sprintf(<span class="string">'image mask: %s'</span>,str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'cluster'</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> ~isfield(xY,<span class="string">'xyz'</span>) || <span class="built_in">isempty</span>(xY.xyz)</span><br><span class="line">        xY.xyz = spm_input(<span class="string">'seed voxel [x y z] &#123;mm&#125;'</span>,...</span><br><span class="line">            <span class="string">'!+0'</span>,<span class="string">'r'</span>,<span class="string">'0 0 0'</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> ~isfield(xY,<span class="string">'M'</span>)</span><br><span class="line">        xY.M = spm_input(<span class="string">'affine transformation matrix'</span>,...</span><br><span class="line">            <span class="string">'!+0'</span>,<span class="string">'r'</span>,<span class="string">'0 0 0'</span>,[<span class="number">4</span> <span class="number">4</span>]);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    xY.spec = [];</span><br><span class="line">    xY.str  = sprintf(<span class="string">'cluster (seed voxel: %0.1f %0.1f %0.1f)'</span>,xY.xyz);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'all'</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    xY.str  = <span class="string">'all'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">otherwise</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    error(<span class="string">'Unknown VOI type.'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> nargin &lt; <span class="number">2</span>, <span class="keyword">return</span>; <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-'Estimate' ROI</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Argument check</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> ischar(XYZmm) &amp;&amp; <span class="built_in">isempty</span>(XYZmm)</span><br><span class="line">    XYZmm = spm_select(<span class="number">1</span>,<span class="string">'image'</span>,<span class="string">'Specify Image'</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> ischar(XYZmm), XYZmm = spm_vol(XYZmm); <span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> isa(XYZmm,<span class="string">'nifti'</span>)</span><br><span class="line">    XYZmm    = struct(<span class="string">'dim'</span>,<span class="built_in">size</span>(XYZmm.dat), <span class="string">'mat'</span>,XYZmm.mat);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> isstruct(XYZmm) <span class="comment">% spm_vol</span></span><br><span class="line">    [R,C,P]  = <span class="built_in">ndgrid</span>(<span class="number">1</span>:XYZmm.dim(<span class="number">1</span>),<span class="number">1</span>:XYZmm.dim(<span class="number">2</span>),<span class="number">1</span>:XYZmm.dim(<span class="number">3</span>));</span><br><span class="line">    RCP      = [R(:)';C(:)';P(:)';<span class="built_in">ones</span>(<span class="number">1</span>,<span class="built_in">numel</span>(R))];</span><br><span class="line">    XYZmm    = XYZmm.mat(<span class="number">1</span>:<span class="number">3</span>,:)*RCP;</span><br><span class="line">    clear R C P RCP</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isempty</span>(XYZmm), XYZmm = <span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">0</span>); <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Filter location of voxels</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">Q          = <span class="built_in">ones</span>(<span class="number">1</span>,<span class="built_in">size</span>(XYZmm,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> lower(xY.def)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'sphere'</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="built_in">j</span>      = <span class="built_in">find</span>(sum((XYZmm - xY.xyz*Q).^<span class="number">2</span>) &lt;= xY.spec^<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'box'</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="built_in">j</span>      = <span class="built_in">find</span>(all(<span class="built_in">abs</span>(XYZmm - xY.xyz*Q) &lt;= xY.spec(:)*Q/<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mask'</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    XYZ    = xY.spec.mat \ [XYZmm; Q];</span><br><span class="line">    <span class="built_in">j</span>      = <span class="built_in">find</span>(spm_sample_vol(xY.spec, XYZ(<span class="number">1</span>,:), XYZ(<span class="number">2</span>,:), XYZ(<span class="number">3</span>,:),<span class="number">0</span>) &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'cluster'</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    [x, <span class="built_in">i</span>] = spm_XYZreg(<span class="string">'NearestXYZ'</span>,xY.xyz,XYZmm);</span><br><span class="line">    XYZ    = <span class="built_in">round</span>(xY.M \ [XYZmm; Q]);</span><br><span class="line">    A      = spm_clusters(XYZ);</span><br><span class="line">    <span class="built_in">j</span>      = <span class="built_in">find</span>(A == A(<span class="built_in">i</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'all'</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="built_in">j</span>      = <span class="number">1</span>:<span class="built_in">size</span>(XYZmm,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">otherwise</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    error(<span class="string">'Unknown VOI type.'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">XYZmm      = XYZmm(:,<span class="built_in">j</span>);</span><br><span class="line"><span class="keyword">if</span> strcmpi(xY.def,<span class="string">'mask'</span>) &amp;&amp; ~<span class="built_in">isempty</span>(XYZmm), xY.xyz = <span class="built_in">mean</span>(XYZmm,<span class="number">2</span>); <span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h3 id="根据spm.mat获得spmxspm等结构数据">根据SPM.mat获得SPM，xSPM等结构数据</h3><p>Compute a specified and thresholded SPM following estimation <img src="2017-04-14_184550.png"> <img src="2017-04-14_184633.png"> <img src="QQ截图20170414184700.png"> <img src="2017-04-14_184737.png"> 实现上面图形界面所定义的操作，选择一个Contrast, 定义一个P值的大小，得到相关的图像结构信息，SPM中的函数是<code>spm_getSPM</code>, 函数调用的原型是<code>[SPM,xSPM] = spm_getSPM(varargin)</code>, 它的主要作用是通过SPM.mat文件获得SPM,xSPM等结构，这两种结构在后在许多方法中作为输入参数。</p><h3 id="spm中result面板中对应的函数">SPM中Result面板中对应的函数</h3><p><img src="2017-04-14_185253.png"> 想实现这个面板中的一些操作功能，可以查看对应的函数<code>spm_result_ui</code>; <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% FORMAT [hreg,xSPM,SPM] = spm_results_ui('Setup',xSPM)</span></span><br><span class="line"><span class="comment">% Query SPM and setup GUI using a xSPM input structure. This allows to run</span></span><br><span class="line"><span class="comment">% results setup without user interaction. See spm_getSPM for details of</span></span><br><span class="line"><span class="comment">% allowed fields.</span></span><br></pre></td></tr></table></figure></p><h3 id="抽取时间序列函数">抽取时间序列函数</h3><p>在结果面板中抽取时间序列的操作主要涉及到两个函数，<code>spm_regions</code>和<code>spm_ROI</code>;最核心的定义ROI的代码在<code>spm_ROI</code>中。 附上一个可以根据输入的坐标抽取球形VOI的修改版代码： <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[Y,xY]</span> = <span class="title">spm_regions_extend</span><span class="params">(xSPM,SPM,hReg,xY,Input_VOINames,Input_is,input_def,input_xyz,input_radius)</span></span></span><br><span class="line"><span class="comment">% VOI time-series extraction of adjusted data (&amp; local eigenimage analysis)</span></span><br><span class="line"><span class="comment">% FORMAT [Y xY] = spm_regions(xSPM,SPM,hReg,[xY]);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% FORMAT [Y xY] = spm_regions(xSPM,SPM,hReg,[xY],Input_VOIName,Input_i)</span></span><br><span class="line"><span class="comment">% Input_VOIName : 抽取的VOI的名称</span></span><br><span class="line"><span class="comment">% Input_i : adjust_contrst 这里选择那个F-All的,整数，1 是dont adjust, 2 是F-All.</span></span><br><span class="line"><span class="comment">% Input_VOI_path : 抽取VOI所使用的Mask的路径;</span></span><br><span class="line"><span class="comment">% Input_is : Input_i</span></span><br><span class="line"><span class="comment">% input_def :  ROI类型的定义,sphere</span></span><br><span class="line"><span class="comment">% input_xyz :  MNI 坐标</span></span><br><span class="line"><span class="comment">% input_radius :  半径</span></span><br><span class="line"><span class="keyword">if</span> nargin &lt; <span class="number">4</span>, xY = []; <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> nargin &gt; <span class="number">5</span></span><br><span class="line">    Input_VOIName = Input_VOINames;</span><br><span class="line">    Input_i =Input_is;</span><br><span class="line">    xY = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%-Get figure handles</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">Finter = spm_figure(<span class="string">'FindWin'</span>,<span class="string">'Interactive'</span>);</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isempty</span>(Finter), noGraph = <span class="number">1</span>; <span class="keyword">else</span> noGraph = <span class="number">0</span>; <span class="keyword">end</span></span><br><span class="line">header = get(Finter,<span class="string">'Name'</span>);</span><br><span class="line">set(Finter,<span class="string">'Name'</span>,<span class="string">'VOI time-series extraction'</span>);</span><br><span class="line"><span class="keyword">if</span> ~noGraph, Fgraph = spm_figure(<span class="string">'GetWin'</span>,<span class="string">'Graphics'</span>); <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Find nearest voxel [Euclidean distance] in point list</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">% if isempty(xSPM.XYZmm)</span></span><br><span class="line"><span class="comment">%     spm('alert!','No suprathreshold voxels!',mfilename,0);</span></span><br><span class="line"><span class="comment">%     Y = []; xY = [];</span></span><br><span class="line"><span class="comment">%     return</span></span><br><span class="line"><span class="comment">% end</span></span><br><span class="line"><span class="comment">% try</span></span><br><span class="line"><span class="comment">%     xyz    = xY.xyz;</span></span><br><span class="line"><span class="comment">% catch</span></span><br><span class="line"><span class="comment">%     xyz    = spm_XYZreg('NearestXYZ',...</span></span><br><span class="line"><span class="comment">%              spm_XYZreg('GetCoords',hReg),xSPM.XYZmm);</span></span><br><span class="line"><span class="comment">%     xY.xyz = xyz;</span></span><br><span class="line"><span class="comment">% end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% and update GUI location</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">%spm_XYZreg('SetCoords',xyz,hReg);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Get adjustment options and VOI name</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">% if ~noGraph</span></span><br><span class="line"><span class="comment">%     if ~isempty(xY.xyz)</span></span><br><span class="line"><span class="comment">%         posstr = sprintf('at [%3.0f %3.0f %3.0f]',xY.xyz);</span></span><br><span class="line"><span class="comment">%     else</span></span><br><span class="line"><span class="comment">%         posstr = '';</span></span><br><span class="line"><span class="comment">%     end</span></span><br><span class="line"><span class="comment">%     spm_input(posstr,1,'d','VOI time-series extraction');</span></span><br><span class="line"><span class="comment">% end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ~isfield(xY,<span class="string">'name'</span>)</span><br><span class="line">    xY.name    = Input_VOIName; <span class="comment">%name of region char字符串类型 ========================================================================</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ~isfield(xY,<span class="string">'Ic'</span>)</span><br><span class="line">    q     = <span class="number">0</span>;</span><br><span class="line">    Con   = &#123;<span class="string">'&lt;don''t adjust&gt;'</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(SPM.xCon)</span><br><span class="line">        <span class="keyword">if</span> strcmp(SPM.xCon(<span class="built_in">i</span>).STAT,<span class="string">'F'</span>)</span><br><span class="line">            q(<span class="keyword">end</span> + <span class="number">1</span>) = <span class="built_in">i</span>;</span><br><span class="line">            Con&#123;<span class="keyword">end</span> + <span class="number">1</span>&#125; = SPM.xCon(<span class="built_in">i</span>).name;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">i</span>     = Input_i; <span class="comment">% adjust_contrst 这里选择那个F-All的,整数，1 是dont adjust, 2 是F-All. =====================================================================</span></span><br><span class="line">    xY.Ic = q(<span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-If fMRI data then ask user to select session</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> isfield(SPM,<span class="string">'Sess'</span>) &amp;&amp; ~isfield(xY,<span class="string">'Sess'</span>)</span><br><span class="line">    s       = <span class="built_in">length</span>(SPM.Sess);</span><br><span class="line">    <span class="keyword">if</span> s &gt; <span class="number">1</span></span><br><span class="line">        s   = spm_input(<span class="string">'which session'</span>,<span class="string">'!+1'</span>,<span class="string">'n1'</span>,s,s);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    xY.Sess = s;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Specify VOI</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">xY.M = xSPM.M;</span><br><span class="line">[xY, xY.XYZmm, Q] = spm_ROI_extend(xY, xSPM.XYZmm,input_def,input_xyz,input_radius);<span class="comment">%--------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">try</span>, xY = rmfield(xY,<span class="string">'M'</span>); <span class="keyword">end</span></span><br><span class="line"><span class="keyword">try</span>, xY = rmfield(xY,<span class="string">'rej'</span>); <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isempty</span>(xY.XYZmm)</span><br><span class="line">    warning(<span class="string">'Empty region.'</span>);</span><br><span class="line">    Y = [];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Extract required data from results files</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line">spm(<span class="string">'Pointer'</span>,<span class="string">'Watch'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%-Get raw data, whiten and filter</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">y        = spm_get_data(SPM.xY.VY,xSPM.XYZ(:,Q));</span><br><span class="line">y        = spm_filter(SPM.xX.K,SPM.xX.W*y);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Computation</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Remove null space of contrast</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> xY.Ic</span><br><span class="line"></span><br><span class="line">    <span class="comment">%-Parameter estimates: beta = xX.pKX*xX.K*y</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="built_in">beta</span>  = spm_get_data(SPM.Vbeta,xSPM.XYZ(:,Q));</span><br><span class="line"></span><br><span class="line">    <span class="comment">%-subtract Y0 = XO*beta,  Y = Yc + Y0 + e</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    y     = y - spm_FcUtil(<span class="string">'Y0'</span>,SPM.xCon(xY.Ic),SPM.xX.xKXs,<span class="built_in">beta</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Confounds</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">xY.X0     = SPM.xX.xKXs.X(:,[SPM.xX.iB SPM.xX.iG]);</span><br><span class="line"></span><br><span class="line"><span class="comment">%-Extract session-specific rows from data and confounds</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">    <span class="built_in">i</span>     = SPM.Sess(xY.Sess).row;</span><br><span class="line">    y     = y(<span class="built_in">i</span>,:);</span><br><span class="line">    xY.X0 = xY.X0(<span class="built_in">i</span>,:);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% and add session-specific filter confounds</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">    xY.X0 = [xY.X0 SPM.xX.K(xY.Sess).X0];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">    xY.X0 = [xY.X0 SPM.xX.K(xY.Sess).KH]; <span class="comment">% Compatibility check</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Remove null space of X0</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">xY.X0     = xY.X0(:,any(xY.X0));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Compute regional response in terms of first eigenvariate</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">[m n]   = <span class="built_in">size</span>(y);</span><br><span class="line"><span class="keyword">if</span> m &gt; n</span><br><span class="line">    [v s v] = svd(y'*y);</span><br><span class="line">    s       = <span class="built_in">diag</span>(s);</span><br><span class="line">    v       = v(:,<span class="number">1</span>);</span><br><span class="line">    u       = y*v/<span class="built_in">sqrt</span>(s(<span class="number">1</span>));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    [u s u] = svd(y*y');</span><br><span class="line">    s       = <span class="built_in">diag</span>(s);</span><br><span class="line">    u       = u(:,<span class="number">1</span>);</span><br><span class="line">    v       = y'*u/<span class="built_in">sqrt</span>(s(<span class="number">1</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">d       = <span class="built_in">sign</span>(sum(v));</span><br><span class="line">u       = u*d;</span><br><span class="line">v       = v*d;</span><br><span class="line">Y       = u*<span class="built_in">sqrt</span>(s(<span class="number">1</span>)/n);</span><br><span class="line"></span><br><span class="line"><span class="comment">%-Set in structure</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">xY.y    = y;</span><br><span class="line">xY.u    = Y;</span><br><span class="line">xY.v    = v;</span><br><span class="line">xY.s    = s;</span><br><span class="line"></span><br><span class="line"><span class="comment">%-Display VOI weighting and eigenvariate</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="keyword">if</span> ~noGraph</span><br><span class="line"></span><br><span class="line">    <span class="comment">% show position</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    spm_results_ui(<span class="string">'Clear'</span>,Fgraph);</span><br><span class="line">    h1 = <span class="built_in">figure</span>(Fgraph);</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    spm_dcm_display(xY)</span><br><span class="line"></span><br><span class="line">    <span class="comment">% show dynamics</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">        <span class="built_in">plot</span>(SPM.xY.RT*[<span class="number">1</span>:<span class="built_in">length</span>(xY.u)],Y)</span><br><span class="line">        str = <span class="string">'time (seconds&#125;'</span>;</span><br><span class="line">    <span class="keyword">catch</span></span><br><span class="line">        <span class="built_in">plot</span>(Y)</span><br><span class="line">        str = <span class="string">'scan'</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    title([<span class="string">'1st eigenvariate: '</span> xY.name],<span class="string">'FontSize'</span>,<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">if</span> strcmpi(xY.def,<span class="string">'mask'</span>)</span><br><span class="line">        [p,n,e] = fileparts(xY.spec.fname);</span><br><span class="line">        posstr  = sprintf(<span class="string">'from mask %s'</span>, [n e]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        posstr  = sprintf(<span class="string">'at [%3.0f %3.0f %3.0f]'</span>,xY.xyz);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    str = &#123; str;<span class="string">' '</span>;...</span><br><span class="line">        sprintf(<span class="string">'%d voxels in VOI %s'</span>,<span class="built_in">length</span>(Q),posstr);...</span><br><span class="line">        sprintf(<span class="string">'Variance: %0.2f%%'</span>,s(<span class="number">1</span>)*<span class="number">100</span>/sum(s))&#125;;</span><br><span class="line">    xlabel(str)</span><br><span class="line">    axis tight square</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Save</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line">str = [<span class="string">'VOI_'</span> xY.name <span class="string">'.mat'</span>];</span><br><span class="line"><span class="keyword">if</span> isfield(xY,<span class="string">'Sess'</span>) &amp;&amp; isfield(SPM,<span class="string">'Sess'</span>)</span><br><span class="line">    str = sprintf(<span class="string">'VOI_%s_%i.mat'</span>,xY.name,xY.Sess);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> spm_check_version(<span class="string">'matlab'</span>,<span class="string">'7'</span>) &gt;= <span class="number">0</span></span><br><span class="line">    save(fullfile(SPM.swd,str),<span class="string">'-V6'</span>,<span class="string">'Y'</span>,<span class="string">'xY'</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    save(fullfile(SPM.swd,str),<span class="string">'Y'</span>,<span class="string">'xY'</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">fprintf(<span class="string">'   VOI saved as %s\n'</span>,spm_str_manip(fullfile(SPM.swd,str),<span class="string">'k55'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">%-Reset title</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">set(Finter,<span class="string">'Name'</span>,header);</span><br><span class="line">spm(<span class="string">'Pointer'</span>,<span class="string">'Arrow'</span>)</span><br><span class="line">print(h1,Input_VOINames,<span class="string">'-dpng'</span>);<span class="comment">% 打印出PNG图片，还可以输出其他的格式，参考Matlab的print函数。</span></span><br></pre></td></tr></table></figure></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[xY, XYZmm, j]</span> = <span class="title">spm_ROI_extend</span><span class="params">(xY, XYZmm,input_def,input_xyz,input_radius)</span></span></span><br><span class="line"><span class="comment">% Region of Interest specification</span></span><br><span class="line"><span class="comment">% input_def : one of &#123;'sphere','box','cluster','mask'&#125;;e.g. sphere</span></span><br><span class="line"><span class="comment">% input_xyz : MNI_cor, e.g. [2;2;2]</span></span><br><span class="line"><span class="comment">% input_radius : r of sphere, e.g.  12</span></span><br><span class="line"><span class="comment">% FORMAT xY = spm_ROI(xY)</span></span><br><span class="line"><span class="comment">% xY     - VOI structure</span></span><br><span class="line"><span class="comment">%    xY.def      - VOI definition [sphere, box, mask, cluster, all]</span></span><br><span class="line"><span class="comment">%    xY.rej      - cell array of disabled VOI definition options</span></span><br><span class="line"><span class="comment">%    xY.xyz      - centre of VOI &#123;mm&#125;</span></span><br><span class="line"><span class="comment">%    xY.spec     - VOI definition parameters</span></span><br><span class="line"><span class="comment">%    xY.str      - description of the VOI</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% FORMAT [xY, XYZmm, j] = spm_ROI(xY, XYZmm)</span></span><br><span class="line"><span class="comment">% XYZmm  - [3xm] locations of voxels &#123;mm&#125;</span></span><br><span class="line"><span class="comment">%          If an image filename, an spm_vol structure or a NIfTI object is</span></span><br><span class="line"><span class="comment">%          given instead, XYZmm will be initialised to all voxels within</span></span><br><span class="line"><span class="comment">%          the field of view of that image.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% XYZmm  - [3xn] filtered locations of voxels &#123;mm&#125; (m&gt;=n) within VOI xY</span></span><br><span class="line"><span class="comment">% j      - [1xn] indices of input locations XYZmm within VOI xY</span></span><br><span class="line"><span class="comment">%__________________________________________________________________________</span></span><br><span class="line"><span class="comment">% Copyright (C) 2008-2014 Wellcome Trust Centre for Neuroimaging</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Karl Friston, Guillaume Flandin</span></span><br><span class="line"><span class="comment">% $Id: spm_ROI.m 6079 2014-06-30 18:25:37Z spm $</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> nargin &lt; <span class="number">2</span> &amp;&amp; nargout &gt; <span class="number">1</span></span><br><span class="line">    error(<span class="string">'Too many output arguments.'</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>, xY; <span class="keyword">catch</span>, xY = []; <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Specify ROI</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="keyword">if</span> ~isfield(xY,<span class="string">'def'</span>)</span><br><span class="line">    def        = &#123;<span class="string">'sphere'</span>,<span class="string">'box'</span>,<span class="string">'cluster'</span>,<span class="string">'mask'</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> isfield(xY,<span class="string">'rej'</span>)</span><br><span class="line">        <span class="keyword">if</span> ~isfield(xY,<span class="string">'M'</span>)</span><br><span class="line">            xY.rej = &#123;xY.rej&#123;:&#125; <span class="string">'cluster'</span>&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> isfield(xY,<span class="string">'M'</span>)</span><br><span class="line">            xY.rej = &#123;&#125;;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            xY.rej = &#123;<span class="string">'cluster'</span>&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    [q, <span class="built_in">i</span>] = setdiff(def,xY.rej);</span><br><span class="line">    def    = def(<span class="built_in">sort</span>(<span class="built_in">i</span>));</span><br><span class="line">    <span class="comment">%xY.def = spm_input('VOI definition...','!+1','b',def,[],1);</span></span><br><span class="line">    xY.def = input_def; <span class="comment">%========&#123;'sphere','box','cluster','mask'&#125;;==============================================</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-ROI parameters</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">switch</span> lower(xY.def)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'sphere'</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> ~isfield(xY,<span class="string">'xyz'</span>) || <span class="built_in">isempty</span>(xY.xyz)</span><br><span class="line">        <span class="comment">%xY.xyz = spm_input('sphere centre [x y z] &#123;mm&#125;',...</span></span><br><span class="line">        <span class="comment">%    '!+0','r','0 0 0',3);</span></span><br><span class="line">        xY.xyz = input_xyz; <span class="comment">%=========[2;2;2]=============================================</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> ~isfield(xY,<span class="string">'spec'</span>)</span><br><span class="line">        <span class="comment">%xY.spec = spm_input('sphere radius (mm)','!+0','r',0,1,[0,Inf]);</span></span><br><span class="line">        xY.spec = input_radius; <span class="comment">% ============12======================================</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    xY.str = sprintf(<span class="string">'%0.1fmm sphere'</span>,xY.spec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'box'</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> ~isfield(xY,<span class="string">'xyz'</span>) || <span class="built_in">isempty</span>(xY.xyz)</span><br><span class="line">        xY.xyz = spm_input(<span class="string">'box centre [x y z] &#123;mm&#125;'</span>,...</span><br><span class="line">            <span class="string">'!+0'</span>,<span class="string">'r'</span>,<span class="string">'0 0 0'</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> ~isfield(xY,<span class="string">'spec'</span>)</span><br><span class="line">        xY.spec = spm_input(<span class="string">'box dimensions [x y z] &#123;mm&#125;'</span>,...</span><br><span class="line">            <span class="string">'!+0'</span>,<span class="string">'r'</span>,<span class="string">'0 0 0'</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">length</span>(xY.spec) &lt; <span class="number">3</span></span><br><span class="line">        xY.spec = xY.spec(<span class="number">1</span>)*[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    xY.str = sprintf(<span class="string">'%0.1f x %0.1f x %0.1f mm box'</span>,xY.spec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mask'</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> ~isfield(xY,<span class="string">'spec'</span>)</span><br><span class="line">        xY.spec = spm_vol(spm_select(<span class="number">1</span>,<span class="string">'image'</span>,<span class="string">'Specify Mask'</span>));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> ~isstruct(xY.spec)</span><br><span class="line">            xY.spec = spm_vol(xY.spec);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    str    = spm_file(xY.spec.fname,<span class="string">'short30'</span>);</span><br><span class="line">    str    = regexprep(str, &#123;<span class="string">'\\'</span> <span class="string">'\^'</span> <span class="string">'_'</span> <span class="string">'&#123;'</span> <span class="string">'&#125;'</span>&#125;, ...</span><br><span class="line">        &#123;<span class="string">'\\\\'</span> <span class="string">'\\^'</span> <span class="string">'\\_'</span> <span class="string">'\\&#123;'</span> <span class="string">'\\&#125;'</span>&#125;); <span class="comment">% Escape TeX special characters</span></span><br><span class="line">    xY.str = sprintf(<span class="string">'image mask: %s'</span>,str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'cluster'</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> ~isfield(xY,<span class="string">'xyz'</span>) || <span class="built_in">isempty</span>(xY.xyz)</span><br><span class="line">        xY.xyz = spm_input(<span class="string">'seed voxel [x y z] &#123;mm&#125;'</span>,...</span><br><span class="line">            <span class="string">'!+0'</span>,<span class="string">'r'</span>,<span class="string">'0 0 0'</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> ~isfield(xY,<span class="string">'M'</span>)</span><br><span class="line">        xY.M = spm_input(<span class="string">'affine transformation matrix'</span>,...</span><br><span class="line">            <span class="string">'!+0'</span>,<span class="string">'r'</span>,<span class="string">'0 0 0'</span>,[<span class="number">4</span> <span class="number">4</span>]);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    xY.spec = [];</span><br><span class="line">    xY.str  = sprintf(<span class="string">'cluster (seed voxel: %0.1f %0.1f %0.1f)'</span>,xY.xyz);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'all'</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    xY.str  = <span class="string">'all'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">otherwise</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    error(<span class="string">'Unknown VOI type.'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> nargin &lt; <span class="number">2</span>, <span class="keyword">return</span>; <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-'Estimate' ROI</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Argument check</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> ischar(XYZmm) &amp;&amp; <span class="built_in">isempty</span>(XYZmm)</span><br><span class="line">    XYZmm = spm_select(<span class="number">1</span>,<span class="string">'image'</span>,<span class="string">'Specify Image'</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> ischar(XYZmm), XYZmm = spm_vol(XYZmm); <span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> isa(XYZmm,<span class="string">'nifti'</span>)</span><br><span class="line">    XYZmm    = struct(<span class="string">'dim'</span>,<span class="built_in">size</span>(XYZmm.dat), <span class="string">'mat'</span>,XYZmm.mat);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> isstruct(XYZmm) <span class="comment">% spm_vol</span></span><br><span class="line">    [R,C,P]  = <span class="built_in">ndgrid</span>(<span class="number">1</span>:XYZmm.dim(<span class="number">1</span>),<span class="number">1</span>:XYZmm.dim(<span class="number">2</span>),<span class="number">1</span>:XYZmm.dim(<span class="number">3</span>));</span><br><span class="line">    RCP      = [R(:)';C(:)';P(:)';<span class="built_in">ones</span>(<span class="number">1</span>,<span class="built_in">numel</span>(R))];</span><br><span class="line">    XYZmm    = XYZmm.mat(<span class="number">1</span>:<span class="number">3</span>,:)*RCP;</span><br><span class="line">    clear R C P RCP</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isempty</span>(XYZmm), XYZmm = <span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">0</span>); <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Filter location of voxels</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">Q          = <span class="built_in">ones</span>(<span class="number">1</span>,<span class="built_in">size</span>(XYZmm,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> lower(xY.def)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'sphere'</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="built_in">j</span>      = <span class="built_in">find</span>(sum((XYZmm - xY.xyz*Q).^<span class="number">2</span>) &lt;= xY.spec^<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'box'</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="built_in">j</span>      = <span class="built_in">find</span>(all(<span class="built_in">abs</span>(XYZmm - xY.xyz*Q) &lt;= xY.spec(:)*Q/<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mask'</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    XYZ    = xY.spec.mat \ [XYZmm; Q];</span><br><span class="line">    <span class="built_in">j</span>      = <span class="built_in">find</span>(spm_sample_vol(xY.spec, XYZ(<span class="number">1</span>,:), XYZ(<span class="number">2</span>,:), XYZ(<span class="number">3</span>,:),<span class="number">0</span>) &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'cluster'</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    [x, <span class="built_in">i</span>] = spm_XYZreg(<span class="string">'NearestXYZ'</span>,xY.xyz,XYZmm);</span><br><span class="line">    XYZ    = <span class="built_in">round</span>(xY.M \ [XYZmm; Q]);</span><br><span class="line">    A      = spm_clusters(XYZ);</span><br><span class="line">    <span class="built_in">j</span>      = <span class="built_in">find</span>(A == A(<span class="built_in">i</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'all'</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="built_in">j</span>      = <span class="number">1</span>:<span class="built_in">size</span>(XYZmm,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">otherwise</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    error(<span class="string">'Unknown VOI type.'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">XYZmm      = XYZmm(:,<span class="built_in">j</span>);</span><br><span class="line"><span class="keyword">if</span> strcmpi(xY.def,<span class="string">'mask'</span>) &amp;&amp; ~<span class="built_in">isempty</span>(XYZmm), xY.xyz = <span class="built_in">mean</span>(XYZmm,<span class="number">2</span>); <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>调用上面两个函数的实现创建VOI的功能： <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createVOI</span><span class="params">(spmT_filepath,spm_mat_path)</span></span></span><br><span class="line"><span class="comment">% 功能： 使用特定的Mask抽取VOI。</span></span><br><span class="line"><span class="comment">% spm_mat_path : SPM.mat的完整路径，需要是做完FirstLevel之后的SPM.mat;</span></span><br><span class="line"><span class="comment">% Input_u : 抽取时间序列时使用的P值，一般默认是0.001，当抽取失败的时候，，适当调大可以确保成功；</span></span><br><span class="line"><span class="comment">% -----------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">% 配置信息：</span></span><br><span class="line"><span class="comment">% contrast_name ： First_Level时候设置的contrast,这里的顺序很重要，因为程序中使用数字表示每个contrast的；</span></span><br><span class="line"><span class="comment">% InputMask ： appying mask : 0 none ; 1 contrast ; 2 image ;默认是整数 0</span></span><br><span class="line"><span class="comment">% InputthresDesc : p value adjustment to control: 'FWE' or 'none'</span></span><br><span class="line"><span class="comment">% Input_k : extend threshold &#123;voxel&#125;  0 ; 默认是0</span></span><br><span class="line"><span class="comment">% xx_mask_path : 抽取的VOI使用的mask的绝对路径</span></span><br><span class="line"><span class="comment">% VOI_Mask ：抽取的VOI使用的mask的绝对路径</span></span><br><span class="line"><span class="comment">% Input_is ： adjust_contrst 这里选择那个F-All的,整数，1 是dont adjust, 2 是F-All，3个数字分别对应三个Mask的adjust_contrst。</span></span><br><span class="line"><span class="comment">%spmT_filepath = 'D:\FMRI_ROOT\YANTAI2\ANALYSIS\first_level_dcm_4class\HC\20160911002\spmF_0001.nii';</span></span><br><span class="line"><span class="comment">%spm_mat_path = 'D:\FMRI_ROOT\YANTAI2\ANALYSIS\first_level_dcm_4class\HC\20160911002\SPM.mat';</span></span><br><span class="line"><span class="comment">%xjview(spmT_filepath);</span></span><br><span class="line">input_xyz_LMGN = [<span class="number">-12</span>;<span class="number">-24</span>;<span class="number">-8</span>];</span><br><span class="line">input_xyz_LA1 = [<span class="number">-54</span>;<span class="number">-14</span>;<span class="number">2</span>];</span><br><span class="line">input_xyz_LV1 = [<span class="number">-6</span>;<span class="number">-74</span>;<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xyz_LMGN = find_peak_co(spmT_filepath,input_xyz_LMGN);</span><br><span class="line">xyz_LA1 = find_peak_co(spmT_filepath,input_xyz_LA1);</span><br><span class="line">xyz_LV1 = find_peak_co(spmT_filepath,input_xyz_LV1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Ic = <span class="number">1</span>; <span class="comment">% 要使用的contrast的编号，这里1是第一个contrast,这里是F contrast</span></span><br><span class="line">InputMask = <span class="number">0</span>;  <span class="comment">% 不使用mask</span></span><br><span class="line">InputthresDesc = <span class="string">'none'</span>;</span><br><span class="line">Input_u = <span class="number">0.05</span>;  <span class="comment">% 抽取VOI时使用的P值</span></span><br><span class="line">Input_k = <span class="number">0</span>;</span><br><span class="line">empty_bit=<span class="string">''</span>;</span><br><span class="line">Input_is = <span class="number">2</span>;</span><br><span class="line">input_def = <span class="string">'sphere'</span>;</span><br><span class="line">input_radius = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">VOI_name = <span class="string">'LMGN'</span>; <span class="comment">%生成的VOI的名称</span></span><br><span class="line">input_xyz = xyz_LMGN;</span><br><span class="line">[SPM,xSPM] = spm_getSPM_extend(spm_mat_path,Ic,InputMask,InputthresDesc,Input_u,Input_k);</span><br><span class="line">[hReg,xSPM,SPM] = spm_result_ui_extend(<span class="string">'Setup'</span>,xSPM);</span><br><span class="line">[Y xY] = spm_regions_extend(xSPM,SPM,hReg,empty_bit,VOI_name,Input_is,input_def,input_xyz,input_radius);</span><br><span class="line"></span><br><span class="line">VOI_name = <span class="string">'LA1'</span>; <span class="comment">%生成的VOI的名称</span></span><br><span class="line">input_xyz = xyz_LA1;</span><br><span class="line">[SPM,xSPM] = spm_getSPM_extend(spm_mat_path,Ic,InputMask,InputthresDesc,Input_u,Input_k);</span><br><span class="line">[hReg,xSPM,SPM] = spm_result_ui_extend(<span class="string">'Setup'</span>,xSPM);</span><br><span class="line">[Y xY] = spm_regions_extend(xSPM,SPM,hReg,empty_bit,VOI_name,Input_is,input_def,input_xyz,input_radius);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">VOI_name = <span class="string">'LV1'</span>; <span class="comment">%生成的VOI的名称</span></span><br><span class="line">input_xyz = xyz_LV1;</span><br><span class="line">[SPM,xSPM] = spm_getSPM_extend(spm_mat_path,Ic,InputMask,InputthresDesc,Input_u,Input_k);</span><br><span class="line">[hReg,xSPM,SPM] = spm_result_ui_extend(<span class="string">'Setup'</span>,xSPM);</span><br><span class="line">[Y xY] = spm_regions_extend(xSPM,SPM,hReg,empty_bit,VOI_name,Input_is,input_def,input_xyz,input_radius);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 认知神经科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SPM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XJVIEW的使用技巧</title>
      <link href="/hexoblog/2017/04/14/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/XJVIEW%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/hexoblog/2017/04/14/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/XJVIEW%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>xjview是用来查看大脑激活图像的比较好用的软件，它基于matlab和SPM开发而成。如果需要批量处理一些数据，可能设计到提取里面的代码。下面介绍一些xjview的命令用法。 <a id="more"></a> ### 显示激活图像 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spmT_filepath = 'D:\spmF_0001.nii';</span><br><span class="line">xjview(spmT_filepath); %显示一幅激活图像，显示多幅可以用逗号隔开</span><br></pre></td></tr></table></figure></p><h3 id="找到激活最大值">找到激活最大值</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">h = spm_mip_ui('FindMIPax');</span><br><span class="line">% loc     - String defining jump: 'dntmv' - don't move</span><br><span class="line">%                                 'nrvox' - nearest suprathreshold voxel</span><br><span class="line">%                                 'nrmax' - nearest local maxima</span><br><span class="line">%                                 'glmax' - global maxima</span><br><span class="line">loc = 'glmax';</span><br><span class="line">xyz = spm_mip_ui('Jump',h,loc); % 更换loc参数，实现不同的找到最大值的方法。</span><br></pre></td></tr></table></figure><h3 id="根据某个坐标找到局部激活最大值">根据某个坐标找到局部激活最大值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">h = spm_mip_ui('FindMIPax');</span><br><span class="line">hC = <span class="number">0</span>;</span><br><span class="line">[xyz,d] = spm_mip_ui('SetCoords',[-14,-26,-6],h,hC);</span><br><span class="line">% xyz是找出来的坐标，d是移动的距离</span><br></pre></td></tr></table></figure><h3 id="查看某个坐标在图像中的位置">查看某个坐标在图像中的位置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xjview([<span class="number">20</span> <span class="number">10</span> <span class="number">1</span>],[<span class="number">10</span>]); % 后面的[<span class="number">10</span>]是赋值给该点的激活强度，为了颜色的显示。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 认知神经科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XJVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DCM模型的定义和估计</title>
      <link href="/hexoblog/2017/04/13/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/DCM%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BC%B0%E8%AE%A1/"/>
      <url>/hexoblog/2017/04/13/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/DCM%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BC%B0%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>DCM，中文名称动态因果模型，是一种用来研究脑区之间因果关系的一种模型。它从神经元水平建模，一般使用双线性模型表达神经元的响应。可以用来验证哪个模型与实验的数据最匹配。 <a id="more"></a> ## VOI抽取 DCM模型的定义需要得到感兴趣脑区的VOI，所以VOI的抽取是DCM模型定义的第一步。</p><h2 id="dcm模型的定义">DCM模型的定义</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DCM</span> = <span class="title">create_dcm</span><span class="params">(subject_path,VOIs,Input_a,Input_b,Input_c,name)</span></span></span><br><span class="line"><span class="comment">%功能： 定义DCM模型，需要先做完抽取VOI，在FirstLevel文件夹下面VOI_开头的文件；</span></span><br><span class="line"><span class="comment">%subject_path : First_Level 被试目录， eg.D:\FMRI_ROOT\YANTAI\ANALYSIS\first_level_dcm_w_whole\20160716002\</span></span><br><span class="line"><span class="comment">%condition_name : SPM.mat 设计矩阵中定义的条件，这里用来给生成的DCM命名。</span></span><br><span class="line"><span class="comment">%---------------------------------------------------------------</span></span><br><span class="line"><span class="comment">%-配置----------------------------------------------------------</span></span><br><span class="line"><span class="comment">%Input_a : DCM模型矩阵，需要更改模型的时候，修改这个矩阵</span></span><br><span class="line"><span class="comment">%Input_b : 调节输入</span></span><br><span class="line"><span class="comment">%Input_c : 外界输入</span></span><br><span class="line"><span class="comment">%-配置结束------------------------------------------------------</span></span><br><span class="line"><span class="comment">%subject_path = 'D:\FMRI_ROOT\YANTAI2\ANALYSIS\first_level_dcm_4class\CB\20161215002\';</span></span><br><span class="line">cd(subject_path);</span><br><span class="line">spmmatfile = [subject_path,<span class="string">'SPM.mat'</span>];</span><br><span class="line"><span class="comment">%name ='FULL'; % 生成的DCM模型的名称；</span></span><br><span class="line">condition_mask = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>];</span><br><span class="line">TE = <span class="number">0.04</span>; <span class="comment">%  TE</span></span><br><span class="line"><span class="comment">%Input_a = [1,1,1;1,1,1;1,1,1]; % 定义DCM模型的连接矩阵</span></span><br><span class="line"><span class="comment">%Input_b = [0,0,0;0,0,0;0,0,0]; % 定义调节参数</span></span><br><span class="line"><span class="comment">%Input_c = [1,1,1,1;0,0,0,0;0,0,0,0]; % 定义输入参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 获得VOI</span></span><br><span class="line"><span class="comment">%------------------------------------------------</span></span><br><span class="line"><span class="comment">%VOIs=&#123;'D:\FMRI_ROOT\YANTAI2\ANALYSIS\first_level_dcm_4class\CB\20161215002\VOI_LMGN_1.mat';</span></span><br><span class="line"> <span class="comment">%   'D:\FMRI_ROOT\YANTAI2\ANALYSIS\first_level_dcm_4class\CB\20161215002\VOI_LA1_1.mat';</span></span><br><span class="line">  <span class="comment">%  'D:\FMRI_ROOT\YANTAI2\ANALYSIS\first_level_dcm_4class\CB\20161215002\VOI_LV1_1.mat'&#125;;</span></span><br><span class="line"><span class="comment">%-------------------------------------------------</span></span><br><span class="line">DCM = spm_dcm_specify_extend(spmmatfile,name,VOIs,condition_mask,TE,Input_a,Input_b,Input_c);</span><br><span class="line">clear name;</span><br><span class="line">clear VOIs;</span><br><span class="line">clear condition_mask;</span><br><span class="line"><span class="comment">%spm_dcm_estimate(DCM);</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DCM</span> = <span class="title">spm_dcm_specify_extend</span><span class="params">(spmmatfile,name,VOIs,condition_mask,TE,Input_a,Input_b,Input_c)</span></span></span><br><span class="line"><span class="comment">% Specify inputs of a DCM</span></span><br><span class="line"><span class="comment">% FORMAT [DCM] = spm_dcm_specify</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% DCM  - the DCM structure (see spm_dcm_ui)</span></span><br><span class="line"><span class="comment">%__________________________________________________________________________</span></span><br><span class="line"><span class="comment">% Copyright (C) 2008 Wellcome Trust Centre for Neuroimaging</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Karl Friston</span></span><br><span class="line"><span class="comment">% $Id: spm_dcm_specify.m 4185 2011-02-01 18:46:18Z guillaume $</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Interactive window</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">Finter = spm_figure(<span class="string">'GetWin'</span>,<span class="string">'Interactive'</span>);</span><br><span class="line">bcolor = get(Finter,<span class="string">'color'</span>);</span><br><span class="line">WS     = spm(<span class="string">'WinScale'</span>);</span><br><span class="line">dx     = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">spm_input(<span class="string">'Specify DCM:...  '</span>,<span class="number">1</span>,<span class="string">'d'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="comment">% Get design and directory</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="comment">%[spmmatfile, sts] = spm_select(1,'^SPM\.mat$','Select SPM.mat');</span></span><br><span class="line"><span class="comment">%spmmatfile = 'D:\FMRI_ROOT\YANTAI\ANALYSIS\first_level_dcm_w_whole\20160716002\SPM.mat';</span></span><br><span class="line">sts = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> ~sts, DCM = []; <span class="keyword">return</span>; <span class="keyword">end</span></span><br><span class="line">swd = spm_str_manip(spmmatfile,<span class="string">'H'</span>);</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">    load(fullfile(swd,<span class="string">'SPM.mat'</span>))</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">    error([<span class="string">'Cannot read '</span> fullfile(swd,<span class="string">'SPM.mat'</span>)]);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="comment">% Name</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="comment">%name  = spm_input('name for DCM_???.mat','+1','s');</span></span><br><span class="line"><span class="comment">%name = 'HG_DCM';</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="comment">% Outputs</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Get cell array of region structures</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">% VOI1_path = 'd:\fmri_root\yantai\aNALYSIS\first_level_dcm_w_whole\20160716002\VOI_HG_DW_1.mat';</span></span><br><span class="line"><span class="comment">% VOI2_path = 'd:\fmri_root\yantai\aNALYSIS\first_level_dcm_w_whole\20160716002\VOI_MFG_DW_1.mat';</span></span><br><span class="line"><span class="comment">% VOI3_path = 'd:\fmri_root\yantai\aNALYSIS\first_level_dcm_w_whole\20160716002\VOI_STG_DW_1.mat';</span></span><br><span class="line"><span class="comment">% VOIs = &#123;VOI1_path;VOI2_path;VOI3_path&#125;;</span></span><br><span class="line"><span class="comment">%P     = cellstr(spm_select([1 8],'^VOI.*\.mat$',&#123;'select VOIs'&#125;,'',swd));</span></span><br><span class="line">P = VOIs;</span><br><span class="line">m     = <span class="built_in">numel</span>(P);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:m</span><br><span class="line">    p     = load(P&#123;<span class="built_in">i</span>&#125;,<span class="string">'xY'</span>);</span><br><span class="line">    xY(<span class="built_in">i</span>) = p.xY;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="comment">% Inputs</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Get (nc) 'causes' or inputs U</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">spm_input(<span class="string">'Input specification:...  '</span>,<span class="number">1</span>,<span class="string">'d'</span>);</span><br><span class="line">Sess   = SPM.Sess(xY(<span class="number">1</span>).Sess);</span><br><span class="line"><span class="comment">%condition_mask = [1,0,0,0]; % 閰嶇疆鍖呭惈鍝釜鏉′欢锛屼笉鍖呭惈鍝釜鏉′欢锛?</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isempty</span>(Sess.U)</span><br><span class="line">    <span class="comment">% spontaneous activity, i.e. no stimuli</span></span><br><span class="line">    nc = <span class="number">0</span>;</span><br><span class="line">    U = [];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">% with stimuli</span></span><br><span class="line">    U.dt   = Sess.U(<span class="number">1</span>).dt;</span><br><span class="line">    u      = <span class="built_in">length</span>(Sess.U);</span><br><span class="line">    U.name = &#123;&#125;;</span><br><span class="line">    U.u    = [];</span><br><span class="line">    <span class="keyword">for</span>  <span class="built_in">i</span> = <span class="number">1</span>:u  <span class="comment">%i 鏄潯浠剁殑缂栧彿  1锛?JX锛? 2锛?DW   3锛?RL 4锛?ZR</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">length</span>(Sess.U(<span class="built_in">i</span>).name)</span><br><span class="line">            str = [<span class="string">'include '</span> Sess.U(<span class="built_in">i</span>).name&#123;<span class="built_in">j</span>&#125; <span class="string">'?'</span>];  <span class="comment">% include JX</span></span><br><span class="line">            <span class="keyword">if</span> condition_mask(<span class="built_in">i</span>)<span class="comment">%spm_input(str,'+1','y/n',[1 0],1)   include JX20 ,yes 1 ; no 0;</span></span><br><span class="line">                U.u             = [U.u Sess.U(<span class="built_in">i</span>).u(<span class="number">33</span>:<span class="keyword">end</span>,<span class="built_in">j</span>)];</span><br><span class="line">                U.name&#123;<span class="keyword">end</span> + <span class="number">1</span>&#125; = Sess.U(<span class="built_in">i</span>).name&#123;<span class="built_in">j</span>&#125;;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    nc     = <span class="built_in">size</span>(U.u,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="comment">% Timings</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"></span><br><span class="line">spm_input(<span class="string">'Timing information:...  '</span>,<span class="number">-1</span>,<span class="string">'d'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%-Slice timings</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">RT     = SPM.xY.RT;</span><br><span class="line"><span class="comment">%delays = spm_input('Slice timings [s]','+1','r', repmat(RT,1,m),m,[0 RT]);</span></span><br><span class="line">delays = <span class="built_in">repmat</span>(RT,<span class="number">1</span>,m)';</span><br><span class="line"><span class="comment">%-Echo time (TE) of data acquisition</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">%TE    = 0.04;  %==================================================================鑷繁杈撳叆TE鐨勫?====================</span></span><br><span class="line">TE_ok = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ~TE_ok</span><br><span class="line">    <span class="comment">%TE = spm_input('Echo time, TE [s]', '+1', 'r', TE);</span></span><br><span class="line">    <span class="keyword">if</span> ~TE || (TE &lt; <span class="number">0</span>) || (TE &gt; <span class="number">0.1</span>)</span><br><span class="line">        str = &#123; <span class="string">'Extreme value for TE or TE undefined.'</span>,...</span><br><span class="line">            <span class="string">'Please re-enter TE (in seconds!)'</span>&#125;;</span><br><span class="line">        spm_input(str,<span class="string">'+1'</span>,<span class="string">'bd'</span>,<span class="string">'OK'</span>,[<span class="number">1</span>],<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        TE_ok = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="comment">% Model options</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="keyword">if</span> nc                                                     <span class="comment">% there are inputs</span></span><br><span class="line">    spm_input(<span class="string">'Model options:...  '</span>,<span class="number">-1</span>,<span class="string">'d'</span>);</span><br><span class="line">    <span class="comment">%options.nonlinear  = spm_input('modulatory effects','+1','b',&#123;'bilinear','nonlinear'&#125;,[0 1],1);</span></span><br><span class="line">    options.nonlinear = <span class="number">0</span>; <span class="comment">%modulatory effects :  0: bilinear  , 1: nonlinear</span></span><br><span class="line"><span class="comment">%options.two_state  = spm_input('states per region', '+1','b',&#123;'one','two'&#125;,[0 1],1);</span></span><br><span class="line">options.two_state = <span class="number">0</span> ; <span class="comment">% states per region ; 0: one  ; 1 : two</span></span><br><span class="line">    <span class="comment">%options.stochastic = spm_input('stochastic effects','+1','b',&#123;'no','yes'&#125;,[0 1],1);</span></span><br><span class="line">options.stochastic = <span class="number">0</span> ; <span class="comment">%stochastic effects; 0 : no ; 1 : yes,</span></span><br><span class="line">    <span class="comment">%options.centre     = spm_input('centre input',      '+1','b',&#123;'no','yes'&#125;,[0 1],1);</span></span><br><span class="line">options.centre = <span class="number">0</span> ; <span class="comment">% centre input ; 0 : no 1: yes;</span></span><br><span class="line">    options.endogenous = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    options.nonlinear  = <span class="number">0</span>;</span><br><span class="line">    options.two_state  = <span class="number">0</span>;</span><br><span class="line">    options.stochastic = <span class="number">1</span>;</span><br><span class="line">    options.centre     = <span class="number">1</span>;</span><br><span class="line">    options.endogenous = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="comment">% Graph connections</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line">a     = <span class="built_in">zeros</span>(m,m);</span><br><span class="line"><span class="keyword">if</span> options.endogenous</span><br><span class="line">    b     = <span class="built_in">zeros</span>(m,m,<span class="number">1</span>);</span><br><span class="line">    c     = <span class="built_in">zeros</span>(m,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    b     = <span class="built_in">zeros</span>(m,m,nc);</span><br><span class="line">    c     = <span class="built_in">zeros</span>(m,nc);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">d     = <span class="built_in">zeros</span>(m,m,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%-Intrinsic connections (A matrix)</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Buttons and labels</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">spm_input(<span class="string">'Specify intrinsic connections from'</span>,<span class="number">1</span>,<span class="string">'d'</span>)</span><br><span class="line">spm_input(<span class="string">'to'</span>,<span class="number">3</span>,<span class="string">'d'</span>)</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:m</span><br><span class="line">    str    = sprintf(<span class="string">'%s %i'</span>,xY(<span class="built_in">i</span>).name,<span class="built_in">i</span>);</span><br><span class="line">    h1(<span class="built_in">i</span>)  = uicontrol(Finter,<span class="string">'String'</span>,str,...</span><br><span class="line">        <span class="string">'Style'</span>,<span class="string">'text'</span>,...</span><br><span class="line">        <span class="string">'FontSize'</span>,<span class="number">10</span>,...</span><br><span class="line">        <span class="string">'BackgroundColor'</span>,bcolor,...</span><br><span class="line">        <span class="string">'HorizontalAlignment'</span>,<span class="string">'right'</span>,...</span><br><span class="line">        <span class="string">'Position'</span>,[<span class="number">080</span> <span class="number">350</span>-dx*<span class="built_in">i</span> <span class="number">080</span> <span class="number">020</span>].*WS);</span><br><span class="line">    h2(<span class="built_in">i</span>)  = uicontrol(Finter,<span class="string">'String'</span>,sprintf(<span class="string">'%i'</span>,<span class="built_in">i</span>),...</span><br><span class="line">        <span class="string">'Style'</span>,<span class="string">'text'</span>,...</span><br><span class="line">        <span class="string">'FontSize'</span>,<span class="number">10</span>,...</span><br><span class="line">        <span class="string">'BackgroundColor'</span>,bcolor,...</span><br><span class="line">        <span class="string">'Position'</span>,[<span class="number">180</span>+dx*<span class="built_in">i</span> <span class="number">350</span> <span class="number">010</span> <span class="number">020</span>].*WS);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:m</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:m</span><br><span class="line">        h3(<span class="built_in">i</span>,<span class="built_in">j</span>) = uicontrol(Finter,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">180</span>+dx*<span class="built_in">j</span> <span class="number">350</span>-dx*<span class="built_in">i</span> <span class="number">020</span> <span class="number">020</span>].*WS,...</span><br><span class="line">            <span class="string">'BackgroundColor'</span>,bcolor,...</span><br><span class="line">            <span class="string">'Style'</span>,<span class="string">'radiobutton'</span>);</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">i</span> == <span class="built_in">j</span></span><br><span class="line">            set(h3(<span class="built_in">i</span>,<span class="built_in">j</span>),<span class="string">'Value'</span>,<span class="number">1</span>,...</span><br><span class="line">                <span class="string">'enable'</span>,<span class="string">'off'</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            set(h3(<span class="built_in">i</span>,<span class="built_in">j</span>),<span class="string">'enable'</span>,<span class="string">'on'</span>,<span class="string">'TooltipString'</span>, ...</span><br><span class="line">                sprintf(<span class="string">'from %s to %s'</span>,xY(<span class="built_in">j</span>).name,xY(<span class="built_in">i</span>).name));</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> nc &amp;&amp; <span class="built_in">i</span>~=<span class="built_in">j</span></span><br><span class="line">            set(h3(<span class="built_in">i</span>,<span class="built_in">j</span>),<span class="string">'Value'</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            set(h3(<span class="built_in">i</span>,<span class="built_in">j</span>),<span class="string">'Value'</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">uicontrol(Finter,<span class="string">'String'</span>,<span class="string">'done'</span>,<span class="string">'Position'</span>, [<span class="number">300</span> <span class="number">100</span> <span class="number">060</span> <span class="number">020</span>].*WS,...</span><br><span class="line">    <span class="string">'Callback'</span>, <span class="string">'uiresume(gcbf)'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%uiwait(Finter);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Get a  a 灏辨槸DCM妯″瀷鐨勮繛鎺ョ煩闃?</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">%for i = 1:m</span></span><br><span class="line"><span class="comment">%    for j = 1:m</span></span><br><span class="line"><span class="comment">%       a(i,j) = get(h3(i,j),'Value');</span></span><br><span class="line"><span class="comment">%   end</span></span><br><span class="line"><span class="comment">%end</span></span><br><span class="line"><span class="comment">%a = [1,1,1;1,1,1;1,1,1];  %=========================================================瀹氫箟鐨凞CM妯″瀷锛屾澶勬湁涓変釜鑺傜偣锛屾墍浠ユ槸3*3鐨勭煩闃碉紱</span></span><br><span class="line">a = Input_a;</span><br><span class="line">delete(findobj(get(Finter,<span class="string">'Children'</span>),<span class="string">'flat'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">%-Effects of causes (B and C matrices)</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line">uicontrol(Finter,<span class="string">'String'</span>,<span class="string">'done'</span>,<span class="string">'Position'</span>, [<span class="number">300</span> <span class="number">100</span> <span class="number">060</span> <span class="number">020</span>].*WS,...</span><br><span class="line">    <span class="string">'Callback'</span>, <span class="string">'uiresume(gcbf)'</span>);</span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:nc</span><br><span class="line"></span><br><span class="line">    <span class="comment">%-Buttons and labels</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    str   = sprintf(...</span><br><span class="line">        <span class="string">'Effects of %-12s on regions... and connections'</span>,...</span><br><span class="line">        U.name&#123;k&#125;);</span><br><span class="line">    spm_input(str,<span class="number">1</span>,<span class="string">'d'</span>);      <span class="comment">% Effects of JX           on regions... and connections</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:m</span><br><span class="line">        h1(<span class="built_in">i</span>)  = uicontrol(Finter,<span class="string">'String'</span>,xY(<span class="built_in">i</span>).name,...</span><br><span class="line">            <span class="string">'Style'</span>,<span class="string">'text'</span>,...</span><br><span class="line">            <span class="string">'BackgroundColor'</span>,bcolor,...</span><br><span class="line">            <span class="string">'FontSize'</span>,<span class="number">10</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">080</span> <span class="number">350</span>-dx*<span class="built_in">i</span> <span class="number">080</span> <span class="number">020</span>].*WS);</span><br><span class="line">        h2(<span class="built_in">i</span>)  = uicontrol(Finter,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">160</span> <span class="number">360</span>-dx*<span class="built_in">i</span> <span class="number">020</span> <span class="number">020</span>].*WS,...</span><br><span class="line">            <span class="string">'BackgroundColor'</span>,bcolor,...</span><br><span class="line">            <span class="string">'Style'</span>,<span class="string">'radiobutton'</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:m</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:m</span><br><span class="line">            <span class="keyword">if</span> a(<span class="built_in">i</span>,<span class="built_in">j</span>) == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">% Allow modulation of intrinsic connections</span></span><br><span class="line">                <span class="comment">%----------------------------------------------------------</span></span><br><span class="line">                h3(<span class="built_in">i</span>,<span class="built_in">j</span>) = uicontrol(Finter,...</span><br><span class="line">                    <span class="string">'Position'</span>,[<span class="number">220</span>+dx*<span class="built_in">j</span> <span class="number">360</span>-dx*<span class="built_in">i</span> <span class="number">020</span> <span class="number">020</span>].*WS,...</span><br><span class="line">                    <span class="string">'BackgroundColor'</span>,bcolor,...</span><br><span class="line">                    <span class="string">'Style'</span>,<span class="string">'radiobutton'</span>);</span><br><span class="line">                set(h3(<span class="built_in">i</span>,<span class="built_in">j</span>),<span class="string">'TooltipString'</span>, ...</span><br><span class="line">                    sprintf(<span class="string">'from %s to %s'</span>,xY(<span class="built_in">j</span>).name,xY(<span class="built_in">i</span>).name));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%uiwait(Finter);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%-Get c   灏辨槸宸﹁竟鐨勭涓?垪锛屼唬琛ㄨ緭鍏ュ姞鍦ㄩ偅涓剳鍖轰笂锛? * 1</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">%for i = 1:m</span></span><br><span class="line">        <span class="comment">%c(i,k)   = get(h2(i),'Value');</span></span><br><span class="line">    <span class="comment">%end</span></span><br><span class="line"><span class="comment">%c = [1,0,0];</span></span><br><span class="line">    c = Input_c;</span><br><span class="line">    <span class="comment">%-Get b allowing any 2nd order effects   3*3 鐨勭煩闃碉紝浠ｈ〃璋冭妭鍙橀噺鍦ㄥ摢鏉＄嚎涓娿?杩欓噷鏈変笁涓尯鍩燂紝鎵?互鏄?*3</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">% for i = 1:m</span></span><br><span class="line">        <span class="comment">% for j = 1:m</span></span><br><span class="line">            <span class="comment">% if a(i,j)==1</span></span><br><span class="line">                <span class="comment">% b(i,j,k) = get(h3(i,j),'Value');</span></span><br><span class="line">            <span class="comment">% end</span></span><br><span class="line">        <span class="comment">% end</span></span><br><span class="line">    <span class="comment">% end</span></span><br><span class="line"><span class="comment">%b = [0,0,0;0,0,0;0,0,0];</span></span><br><span class="line">    b = Input_b;</span><br><span class="line">    delete([h1(:); h2(:); h3(a==<span class="number">1</span>)])</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">delete(findobj(get(Finter,<span class="string">'Children'</span>),<span class="string">'flat'</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Effects of nonlinear modulations (D matrices)</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="keyword">if</span> options.nonlinear</span><br><span class="line">    uicontrol(Finter,<span class="string">'String'</span>,<span class="string">'done'</span>,<span class="string">'Position'</span>, [<span class="number">300</span> <span class="number">100</span> <span class="number">060</span> <span class="number">020</span>].*WS,...</span><br><span class="line">        <span class="string">'Callback'</span>, <span class="string">'uiresume(gcbf)'</span>);</span><br><span class="line">    <span class="keyword">for</span> k = <span class="number">1</span>:m</span><br><span class="line"></span><br><span class="line">        <span class="comment">%-Buttons and labels</span></span><br><span class="line">        <span class="comment">%------------------------------------------------------------------</span></span><br><span class="line">        str = sprintf(<span class="string">'Effects of %-12s activity on connections'</span>,xY(k).name);</span><br><span class="line">        spm_input(str,<span class="number">1</span>,<span class="string">'d'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:m</span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:m</span><br><span class="line">                <span class="keyword">if</span> a(<span class="built_in">i</span>,<span class="built_in">j</span>)==<span class="number">1</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">% Allow modulation of intrinsic connections</span></span><br><span class="line">                    <span class="comment">%------------------------------------------------------</span></span><br><span class="line">                    h4(<span class="built_in">i</span>,<span class="built_in">j</span>) = uicontrol(Finter,...</span><br><span class="line">                        <span class="string">'Position'</span>,[<span class="number">220</span>+dx*<span class="built_in">j</span> <span class="number">360</span>-dx*<span class="built_in">i</span> <span class="number">020</span> <span class="number">020</span>].*WS,...</span><br><span class="line">                        <span class="string">'BackgroundColor'</span>,bcolor,...</span><br><span class="line">                        <span class="string">'Style'</span>,<span class="string">'radiobutton'</span>);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        uiwait(Finter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">%-Get d allowing any 2nd order effects</span></span><br><span class="line">        <span class="comment">%------------------------------------------------------------------</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:m</span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:m</span><br><span class="line">                <span class="keyword">if</span> a(<span class="built_in">i</span>,<span class="built_in">j</span>)==<span class="number">1</span></span><br><span class="line">                    d(<span class="built_in">i</span>,<span class="built_in">j</span>,k) = get(h4(<span class="built_in">i</span>,<span class="built_in">j</span>),<span class="string">'Value'</span>);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        delete(h4(a==<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">delete(findobj(get(Finter,<span class="string">'Children'</span>),<span class="string">'flat'</span>));</span><br><span class="line">spm_input(<span class="string">'Thank you'</span>,<span class="number">1</span>,<span class="string">'d'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="comment">% Response</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Response variables &amp; confounds (NB: the data have been whitened)</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">n     = <span class="built_in">length</span>(xY);                      <span class="comment">% number of regions</span></span><br><span class="line">v     = <span class="built_in">length</span>(xY(<span class="number">1</span>).u);                 <span class="comment">% number of time points</span></span><br><span class="line">Y.dt  = SPM.xY.RT;</span><br><span class="line">Y.X0  = xY(<span class="number">1</span>).X0;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">    Y.y(:,<span class="built_in">i</span>)  = xY(<span class="built_in">i</span>).u;</span><br><span class="line">    Y.name&#123;<span class="built_in">i</span>&#125; = xY(<span class="built_in">i</span>).name;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Error precision components (one for each region) - i.i.d. (because of W)</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">Y.Q        = spm_Ce(<span class="built_in">ones</span>(<span class="number">1</span>,n)*v);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="comment">% DCM structure</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Endogenous input specification</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isempty</span>(U)</span><br><span class="line">    U.u    = <span class="built_in">zeros</span>(v,<span class="number">1</span>);</span><br><span class="line">    U.name = &#123;<span class="string">'null'</span>&#125;;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Store all variables in DCM structure</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">DCM.a       = a;</span><br><span class="line">DCM.b       = b;</span><br><span class="line">DCM.c       = c;</span><br><span class="line">DCM.d       = d;</span><br><span class="line">DCM.U       = U;</span><br><span class="line">DCM.Y       = Y;</span><br><span class="line">DCM.xY      = xY;</span><br><span class="line">DCM.v       = v;</span><br><span class="line">DCM.n       = n;</span><br><span class="line">DCM.TE      = TE;</span><br><span class="line">DCM.delays  = delays;</span><br><span class="line">DCM.options = options;</span><br><span class="line"></span><br><span class="line"><span class="comment">%-Save</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> spm_check_version(<span class="string">'matlab'</span>,<span class="string">'7'</span>) &gt;= <span class="number">0</span></span><br><span class="line">    save(fullfile(swd,[<span class="string">'DCM_'</span> name <span class="string">'.mat'</span>]),<span class="string">'-V6'</span>,<span class="string">'DCM'</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    save(fullfile(swd,[<span class="string">'DCM_'</span> name <span class="string">'.mat'</span>]),<span class="string">'DCM'</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="dcm模型的估计">DCM模型的估计</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">% 估计DCM模型</span></span><br><span class="line">first_level_path = <span class="string">'D:\FMRI_ROOT\YANTAI\ANALYSIS\first_level_dcm_w_whole\';</span></span><br><span class="line"><span class="string">cd(first_level_path);</span></span><br><span class="line"><span class="string">dir_path = dir('</span><span class="number">2016</span>*<span class="string">');</span></span><br><span class="line"><span class="string">for i = 1: size(dir_path,1)</span></span><br><span class="line"><span class="string">    subject_path = [first_level_path,dir_path(i).name];</span></span><br><span class="line"><span class="string">    cd(subject_path);</span></span><br><span class="line"><span class="string">    dcm_models_path = dir('</span>DCM*<span class="string">');</span></span><br><span class="line"><span class="string">    for j = 1:size(dcm_models_path,1)</span></span><br><span class="line"><span class="string">       dcm_model_path =  [subject_path,'</span>\<span class="string">',dcm_models_path(j).name];</span></span><br><span class="line"><span class="string">       spm_dcm_estimate(dcm_model_path);</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line"><span class="string">end</span></span><br></pre></td></tr></table></figure><h2 id="dcm模型的贝叶斯选择">DCM模型的贝叶斯选择</h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 认知神经科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DCM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SPM做Second_Level分析</title>
      <link href="/hexoblog/2017/04/13/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/%E4%BD%BF%E7%94%A8SPM%E5%81%9ASecond-Level%E5%88%86%E6%9E%90/"/>
      <url>/hexoblog/2017/04/13/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/%E4%BD%BF%E7%94%A8SPM%E5%81%9ASecond-Level%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>组水平分析是用来查看组水平上的结果的。 <a id="more"></a> <img src="QQ截图20170413111153.png"> 选择定义Second_Level按钮 <img src="QQ截图20170413111701.png"> <code>Directory</code>选择结果要存放的位置，<code>Design</code>下的选择单样本T检验，<code>Scans</code>选择做完<code>first_level</code>之后的某一个类别下的同一组的不同被试的<code>con*开头的文件</code>。这些都定义好之后单击运行按钮。 <img src="QQ截图20170413111735.png"> 上面是运行之后的结果。以上步骤是定义设计矩阵的过程，该过程完成之后会在文件夹内生成<code>SPM.mat</code>文件。 <img src="QQ截图20170413191540.png"> 单击估计，选择刚刚生成的<code>SPM.mat</code>文件。 <img src="QQ截图20170413191648.png"> 估计完之后，会生成一些结果文件。 <img src="QQ截图20170413191803.png"> 然后单击result,定义Contrast,这里只需要定义一个T-contrat,设置为1就可以了。 <img src="QQ截图20170413191853.png"> <img src="QQ截图20170413192016.png"> <img src="QQ截图20170413192039.png"> 完成之后会生成<code>spmT*</code>文件。使用<code>xjview</code>就可以看到组水平的激活情况了。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 认知神经科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SPM,Second_Level </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo的使用04-数学公式</title>
      <link href="/hexoblog/2017/04/12/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/Hexo/Hexo%E7%9A%84%E4%BD%BF%E7%94%A804-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
      <url>/hexoblog/2017/04/12/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/Hexo/Hexo%E7%9A%84%E4%BD%BF%E7%94%A804-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>数学公式是我们经常需要使用到的表达工具，只是用键盘上的符号有时候很难表达清楚想要表达的公式，格式也不是很友好。Hexo可以支持Latex公式的显示，我们只需要经过简单的配置就可以使Hexo支持Latex公式的显示。当然，通过使用atom的插件，Latex公式的实时预览也很容易实现，这样本地写作环境和提交之后的格式就是完全一致的。</p><a id="more"></a><h2 id="安装可以实时预览公式的atom插件">安装可以实时预览公式的atom插件</h2><p>https://atom.io/packages/markdown-preview-enhanced</p><h2 id="安装hexo-math">安装hexo-math</h2><p>https://github.com/akfish/hexo-math</p><h2 id="常用的表示">常用的表示</h2><h3 id="希腊字母">希腊字母</h3><table><thead><tr class="header"><th>名称</th><th>Tex书写形式</th><th>效果</th></tr></thead><tbody><tr class="odd"><td>alpha</td><td></td><td><span class="math inline">\(\alpha\)</span></td></tr><tr class="even"><td>beta</td><td></td><td><span class="math inline">\(\beta\)</span></td></tr><tr class="odd"><td>gamma</td><td></td><td><span class="math inline">\(\gamma\)</span></td></tr><tr class="even"><td>theta</td><td></td><td><span class="math inline">\(\theta\)</span></td></tr><tr class="odd"><td>mu</td><td></td><td><span class="math inline">\(\mu\)</span></td></tr><tr class="even"><td>pi</td><td></td><td><span class="math inline">\(\pi\)</span></td></tr><tr class="odd"><td>rho</td><td></td><td><span class="math inline">\(\rho\)</span></td></tr><tr class="even"><td>sigma</td><td></td><td><span class="math inline">\(\sigma\)</span></td></tr><tr class="odd"><td>phi</td><td></td><td><span class="math inline">\(\phi\)</span></td></tr><tr class="even"><td>omega</td><td></td><td><span class="math inline">\(\omega\)</span></td></tr><tr class="odd"><td>chi</td><td></td><td><span class="math inline">\(\chi\)</span></td></tr><tr class="even"><td>psi</td><td></td><td><span class="math inline">\(\psi\)</span></td></tr></tbody></table><h3 id="上标和下标">上标和下标</h3><p>上标用<code>^</code>表示，下标用<code>_</code>表示，需要注意的是，这里的上标和下标的作用范围是紧紧跟在后面的字母或者数字，如果需要多个，需要用<code>{}</code>括起来。例如：<code>x^56</code>会得到<span class="math inline">\(x^56\)</span>,想要得到正确的结果，需要这样书写，<code>x^{56}</code>,这样得到的结果就是<span class="math inline">\(x^{56}\)</span>. 在不用括号会引起歧义的地方必须使用括号，否则编译无法通过，例如<code>x^5^6</code>.</p><h3 id="括号">括号</h3><p>小括号和中括号没有用来表示特殊的含义，所以可以直接使用。大括号的使用需要使用转义字符。</p><h3 id="数学运算">数学运算</h3><table><thead><tr class="header"><th>书写格式</th><th>显示效果</th></tr></thead><tbody><tr class="odd"><td></td><td><span class="math inline">\(\arcsin(xy)\)</span></td></tr><tr class="even"><td></td><td><span class="math inline">\(\sin(x^5)\)</span></td></tr><tr class="odd"><td></td><td><span class="math inline">\(\arccos(x-y)\)</span></td></tr><tr class="even"><td></td><td><span class="math inline">\(\cos(xyz)\)</span></td></tr><tr class="odd"><td></td><td><span class="math inline">\(\arctan(xy)\)</span></td></tr><tr class="even"><td></td><td><span class="math inline">\(\arg()\)</span></td></tr><tr class="odd"><td></td><td><span class="math inline">\(\cosh\)</span></td></tr><tr class="even"><td></td><td><span class="math inline">\(sinh\)</span></td></tr><tr class="odd"><td></td><td><span class="math inline">\(tanh\)</span></td></tr><tr class="even"><td></td><td><span class="math inline">\(\int\)</span></td></tr><tr class="odd"><td></td><td><span class="math inline">\(\iint\)</span></td></tr><tr class="even"><td></td><td><span class="math inline">\(\iiint\)</span></td></tr><tr class="odd"><td></td><td><span class="math inline">\(\oint\)</span></td></tr><tr class="even"><td></td><td><span class="math inline">\(\coprod\)</span></td></tr><tr class="odd"><td></td><td><span class="math inline">\(\bigvee\)</span></td></tr><tr class="even"><td></td><td><span class="math inline">\(\bigwedge\)</span></td></tr><tr class="odd"><td></td><td><span class="math inline">\(\biguplus\)</span></td></tr><tr class="even"><td></td><td><span class="math inline">\(\bigcap\)</span></td></tr><tr class="odd"><td></td><td><span class="math inline">\(\bigcup\)</span></td></tr><tr class="even"><td></td><td><span class="math inline">\(\intop\)</span></td></tr><tr class="odd"><td></td><td><span class="math inline">\(\prod\)</span></td></tr><tr class="even"><td></td><td><span class="math inline">\(\sum\)</span></td></tr><tr class="odd"><td></td><td><span class="math inline">\(\bigoplus\)</span></td></tr><tr class="even"><td></td><td><span class="math inline">\(\smallint\)</span></td></tr><tr class="odd"><td></td><td><span class="math inline">\(\bigodot\)</span></td></tr><tr class="even"><td></td><td><span class="math inline">\(\odot\)</span></td></tr><tr class="odd"><td></td><td><span class="math inline">\(\bigotimes\)</span></td></tr><tr class="even"><td></td><td><span class="math inline">\(\bigsqcup\)</span></td></tr></tbody></table><h3 id="逻辑运算符">逻辑运算符</h3><table><thead><tr class="header"><th>书写格式</th><th>显示效果</th></tr></thead><tbody><tr class="odd"><td></td><td><span class="math inline">\(\forall\)</span></td></tr><tr class="even"><td></td><td><span class="math inline">\(\exists\)</span></td></tr><tr class="odd"><td></td><td><span class="math inline">\(\nexists\)</span></td></tr><tr class="even"><td></td><td><span class="math inline">\(\therefore\)</span></td></tr><tr class="odd"><td></td><td><span class="math inline">\(\because\)</span></td></tr></tbody></table><h3 id="分数">分数</h3><table><thead><tr class="header"><th>书写格式</th><th>显示效果</th><th>示例</th></tr></thead><tbody><tr class="odd"><td>{10}frac{56}{78}</td><td><span class="math inline">\({10}\frac{56}{78}\)</span></td><td></td></tr><tr class="even"><td>489</td><td><span class="math inline">\(4\dfrac89\)</span></td><td></td></tr><tr class="odd"><td>5434</td><td><span class="math inline">\(54\over34\)</span></td><td></td></tr><tr class="even"><td>1089</td><td><span class="math inline">\(10\tfrac89\)</span></td><td></td></tr></tbody></table><h3 id="大括号">大括号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">f(x)=\begin&#123;cases&#125;</span><br><span class="line">        0   &amp;  \text&#123;x&gt;0&#125;\\</span><br><span class="line">        1   &amp;  \text&#123;x&lt;=0&#125;</span><br><span class="line">      \end&#123;cases&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p><span class="math display">\[f(x)=\begin{cases}        0   &amp;  \text{x&gt;0}\\        1   &amp;  \text{x&lt;=0}      \end{cases}\]</span></p><p>公式详细的简介： http://mlworks.cn/posts/introduction-to-mathjax-and-latex-expression/</p><p>Katex支持的所有操作符： https://github.com/Khan/KaTeX/wiki/Function-Support-in-KaTeX</p><p>latex手写符号识别系统： http://detexify.kirelabs.org/classify.html</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工具 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo的使用05-Atom编辑器</title>
      <link href="/hexoblog/2017/04/12/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/Hexo/Hexo%E7%9A%84%E4%BD%BF%E7%94%A805-Atom%E7%BC%96%E8%BE%91%E5%99%A8/"/>
      <url>/hexoblog/2017/04/12/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/Hexo/Hexo%E7%9A%84%E4%BD%BF%E7%94%A805-Atom%E7%BC%96%E8%BE%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>自从开始使用hexo写博客以来，一直在寻找一款合适的编辑器，至少实现以下功能：</p><blockquote><ul><li>markdown语法的着色</li><li>markdown中代码块的着色和编程提示</li><li>实时预览</li><li>根据标题生成目录</li><li>在编辑器中执行<code>hexo new, hexo d,hexo g,hexo clean</code>等命令</li><li>在编辑器中执行<code>git</code>相关的操作</li><li>可视化的界面显示文件修改的异同</li><li>导出markdown为带书签的PDF，样式可以自定义</li></ul></blockquote><p>直到遇到atom，上述功能轻松就实现了，还有许多其他扩展的功能可以使用。 <a id="more"></a></p><h2 id="安装atom">安装atom</h2><p>下载<a href="https://atom.io/" target="_blank" rel="noopener">atom</a>, 安装完成之后默认支持markdown功能，支持实时预览。</p><h2 id="安装markdown增强预览工具支持latex的预览">安装markdown增强预览工具，支持latex的预览</h2><p><code>Ctrl+,</code>打开配置页面，在install中搜索<code>markdown-preview-plus</code>，安装。使用文档：https://atom.io/packages/markdown-preview-plus</p><h2 id="支持hexo命令的配置">支持hexo命令的配置</h2><p><code>Ctrl+,</code>打开配置页面，在install中搜索<code>atom-hexo</code>，安装之后即可使用。atom的命令窗口与sublimeText一样，是<code>Ctrl+Shift+P</code>.</p><p>atom-hexo插件的使用文档：https://atom.io/packages/atom-hexo</p><p>为了使生成的文件自带头部标签信息，还需要安装<code>hexo-front-matter</code>插件，使用方法：https://atom.io/packages/hexo-front-matter</p><h2 id="增加目录功能">增加目录功能</h2><p>在扩展安装页面搜索markdown相关的扩展，把需要的都安装上。可以实现添加目录，导出PDF等各种功能扩展。</p><h2 id="扩展git操作">扩展git操作</h2><p>安装git-plus扩展，可以在命令窗口执行相关的操作。</p><h2 id="增加miniview插件">增加miniView插件</h2><p>安装minimap扩展，可以看到整个页面的缩略图。使用教程：https://atom.io/packages/minimap</p><h2 id="高亮选中的内容">高亮选中的内容</h2><p>安装<code>highlight-selected</code>插件</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工具 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> atom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法专题_栈和队列</title>
      <link href="/hexoblog/2017/04/12/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>/hexoblog/2017/04/12/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>栈是一种实现了后进先出的规则的数据结构。C++里面有实现<code>stack</code>.使用的时候<code>include &lt;stack&gt;</code>,支持的操作有<code>push(),pop(),top()</code>;需要注意的是，<code>pop</code>的作用是弹出栈顶元素，而不会返回栈顶元素，实现返回栈顶元素并弹出的操作应该是<code>int a = s.top(); s.pop();</code>.</p><p>队列是一种先进先出的数据结构。C++里面有两种实现， 一种是普通的队列<code>queue</code>,使用的时候<code>include&lt;queue&gt;</code>,支持的操作和栈类似，<code>push(),pop(),top()</code>分别实现数据的入队，出队和读取队列的头部元素。<code>deque</code>实现了双端队列，支持从两端入队和出队.使用的时候<code>include&lt;deque&gt;</code>。</p><a id="more"></a><h3 id="有效的括号序列">有效的括号序列</h3><p><a href="http://lintcode.com/zh-cn/problem/valid-parentheses/" target="_blank" rel="noopener">有效的括号序列</a></p><p>使用栈存储所有的左括号，一旦遇到右括号就与栈顶的元素比较，如果匹配，弹出栈顶元素，继续，如果不匹配，直接返回false.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidParentheses</span><span class="params">(<span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 括号匹配问题</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; cc;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">char</span>&gt; m;</span><br><span class="line">    m[<span class="string">'('</span>] = <span class="string">')'</span>;</span><br><span class="line">    m[<span class="string">'['</span>] = <span class="string">']'</span>;</span><br><span class="line">    m[<span class="string">'&#123;'</span>] = <span class="string">'&#125;'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">'('</span> || s[i] == <span class="string">'['</span>|| s[i]==<span class="string">'&#123;'</span>)&#123;</span><br><span class="line">            cc.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">')'</span> || s[i] == <span class="string">']'</span> || s[i] == <span class="string">'&#125;'</span>)&#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = cc.top();</span><br><span class="line">            <span class="keyword">if</span>(m[tmp] != s[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cc.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cc.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逆波兰表达式求值">逆波兰表达式求值</h3><p>求逆波兰表达式的值。在逆波兰表达法中，其有效的运算符号包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰计数表达。</p><p><a href="http://lintcode.com/zh-cn/problem/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">逆波兰表达式求值</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运算符只考虑了加减乘除</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">compute</span><span class="params">(T first, T second,<span class="built_in">string</span> op)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(op == <span class="string">"+"</span>) <span class="keyword">return</span> first + second;</span><br><span class="line">    <span class="keyword">if</span>(op == <span class="string">"-"</span>) <span class="keyword">return</span> first - second;</span><br><span class="line">    <span class="keyword">if</span>(op == <span class="string">"*"</span>) <span class="keyword">return</span> first * second;</span><br><span class="line">    <span class="keyword">if</span>(op == <span class="string">"/"</span> &amp;&amp; second != <span class="number">0</span>) <span class="keyword">return</span> first / second;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1000</span>; <span class="comment">// 说明输入的数据有问题</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;tokens)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span> &gt; s;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; op = &#123;<span class="string">"+"</span>,<span class="string">"-"</span>,<span class="string">"*"</span>,<span class="string">"/"</span>&#125;; <span class="comment">// 都是双目运算符，处理逻辑是相同的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;tokens.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(op.count(tokens[i]) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> first=<span class="number">0</span>,second=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(!s.empty())&#123; first = s.top() ; s.pop(); &#125;</span><br><span class="line">            <span class="keyword">if</span>(!s.empty())&#123; second = s.top() ; s.pop(); &#125;</span><br><span class="line">            s.push(compute(second,first,tokens[i]));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            s.push(stoi(tokens[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中缀表达式转换成后缀表达式">中缀表达式转换成后缀表达式</h3><p>利用栈将中缀表达式转换成后缀表达式的步骤(逆波兰表达式)：</p><ol style="list-style-type: decimal"><li>初始化栈cc为空用来存放运算符，初始化string s为空用来存储转换之后的逆波兰表达式；</li><li>从头到尾扫描中缀表达式，遇到数字直接输出到s.</li><li>遇到运算符，如果当前的栈cc为空，则直接入栈；如果遇到的是左括号，直接入栈；如果遇到的运算符的优先级低于栈顶的元素，直接入栈；</li><li>如果遇到的运算符的优先级小于等于当前栈顶的元素，那么持续输出栈顶元素，直到栈顶元素的运算优先级小于当前元素 或者 栈为空 为止。循环退出后将当前运算符入栈。</li><li>如果遇到的是右括号，持续输出栈顶元素，直到遇到左括号，左括号弹出，但不输出到s.</li></ol><p><a href="http://lintcode.com/zh-cn/problem/convert-expression-to-reverse-polish-notation/#" target="_blank" rel="noopener">将表达式转换为逆波兰表达式</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 空字符串不是数字</span></span><br><span class="line">    <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(s.size() == <span class="number">1</span> &amp;&amp; s[<span class="number">0</span>] == <span class="string">'-'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="comment">// 2. 如果第二个字符及以后的不是0--9，不是数字，直接返回false</span></span><br><span class="line">        <span class="keyword">if</span>( (i&gt;<span class="number">0</span> &amp;&amp; (s[i]&lt;<span class="string">'0'</span>||s[i]&gt;<span class="string">'9'</span>)) ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 3. 如果第一个字符不是0--9，也不是-，则不是数字，直接返回false.</span></span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;(s[i]!=<span class="string">'-'</span>)&amp;&amp;(s[i]&lt;<span class="string">'0'</span>||s[i]&gt;<span class="string">'9'</span>) ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; convertToRPN(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;expression) &#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">    <span class="keyword">if</span>(expression.empty()) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 操作符</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; s;</span><br><span class="line">    <span class="comment">// 操作符的优先级</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; kv; </span><br><span class="line">    kv[<span class="string">"+"</span>] = <span class="number">3</span>; kv[<span class="string">"-"</span>] = <span class="number">3</span>; </span><br><span class="line">    kv[<span class="string">"*"</span>] = <span class="number">4</span>; kv[<span class="string">"/"</span>] = <span class="number">4</span>; </span><br><span class="line">    kv[<span class="string">"("</span>] = <span class="number">2</span>; kv[<span class="string">")"</span>] = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;expression.size();i++)&#123;</span><br><span class="line">        <span class="comment">// 1. 如果是数字，直接输出</span></span><br><span class="line">        <span class="keyword">if</span>(isNumber(expression[i]))&#123;</span><br><span class="line">            ans.push_back(expression[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 如果是符号+,-,*,/,(,),需要按照优先级顺序处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(kv[expression[i]] &gt;= <span class="number">2</span> &amp;&amp; kv[expression[i]] &lt;= <span class="number">6</span>)&#123;</span><br><span class="line">            <span class="comment">// 2.1 如果栈为空，或者是左括号，直接入栈</span></span><br><span class="line">            <span class="keyword">if</span>(s.empty() || kv[expression[i]]==<span class="number">2</span> )&#123;</span><br><span class="line">                s.push(expression[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2.2 如果遇到的是右括号，持续输出栈中的元素，直到遇到左括号为止</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(kv[expression[i]] == <span class="number">6</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(!s.empty() &amp;&amp; s.top() != <span class="string">"("</span>)&#123;</span><br><span class="line">                    ans.push_back(s.top()); s.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!s.empty()) s.pop(); <span class="comment">// 弹出左括号</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是+,-,*,/，就要比较和当前栈顶元素的优先级了，如果比栈顶运算符的优先级低，可以直接入栈，</span></span><br><span class="line">            <span class="comment">// 如果高，需要弹出栈顶元素，直到栈顶的运算符低于当前的运算符或者栈为空为止</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(kv[expression[i]]==<span class="number">3</span> || kv[expression[i]]==<span class="number">4</span>)&#123;</span><br><span class="line">                 <span class="comment">// 2.3 如果当前的运算符优先级高于栈顶的，直接入栈</span></span><br><span class="line">                 <span class="keyword">if</span>(kv[expression[i]] &gt; kv[s.top()])&#123;</span><br><span class="line">                     s.push(expression[i]);</span><br><span class="line">                 &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                     <span class="keyword">while</span>(!s.empty() &amp;&amp; kv[expression[i]] &lt;= kv[s.top()])&#123;</span><br><span class="line">                         ans.push_back(s.top()); s.pop();</span><br><span class="line">                     &#125;</span><br><span class="line">                     s.push(expression[i]);</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把栈中的操作符输出</span></span><br><span class="line">    <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">        ans.push_back(s.top()); s.pop(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中缀表达式求值">中缀表达式求值</h3><p>先转换成后缀表达式，再求值。</p><p><a href="http://lintcode.com/zh-cn/problem/expression-evaluation/" target="_blank" rel="noopener">表达式求值</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evaluateExpression</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; expression)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; r = convert(expression);</span><br><span class="line">    <span class="keyword">if</span>(r.empty()) <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> evalRPN(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="表达树构造">表达树构造</h3><p>表达树是一个二叉树的结构，用于衡量特定的表达。所有表达树的叶子都有一个数字字符串值。而所有表达树的非叶子都有另一个操作字符串值。</p><p>给定一个表达数组，请构造该表达的表达树，并返回该表达树的根。</p><p><a href="http://lintcode.com/zh-cn/problem/expression-tree-build/#" target="_blank" rel="noopener">表达树构造</a></p><p>思路： 可以利用以前做过的题目，将本题分解成几个子问题。通过分析我们发现，中缀表达式是表达树的中序遍历，后缀表达式是表达树的后序遍历，通过中缀表达式我们可以得到后缀表达式，这个在之前已经做过。而通过二叉树的中序遍历序列和后序遍历序列也可以很容易的重建出该二叉树。所以该问题分解为这样几个子问题：</p><ol style="list-style-type: decimal"><li>求后缀表达式</li><li>根据中序遍历和后序遍历序列重建二叉树</li></ol><p>需要注意的是，本题中以数字和运算符作为节点的值，这并不能保证节点值的唯一，而重建二叉树的时候要求节点值唯一。这里我们采用定义新结构的方法使得每个节点都是唯一的。具体见代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uniqueNode</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> description;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    uniqueNode():description(<span class="string">""</span>), id(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    uniqueNode(<span class="built_in">string</span> s, <span class="keyword">int</span> i) : description(s), id(i)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Definition of ExpressionTreeNode:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExpressionTreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> symbol;</span><br><span class="line">    ExpressionTreeNode *left, *right;</span><br><span class="line">    ExpressionTreeNode(<span class="built_in">string</span> symbol) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;symbol = symbol;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left = <span class="keyword">this</span>-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历和中序遍历重建二叉树</span></span><br><span class="line"><span class="function">ExpressionTreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;uniqueNode&gt;&amp; inorder, <span class="built_in">vector</span>&lt;uniqueNode&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inorder.empty() || postorder.empty()) &#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125;</span><br><span class="line">    ExpressionTreeNode *node = <span class="keyword">new</span> ExpressionTreeNode(postorder[postorder.size()<span class="number">-1</span>].description);<span class="comment">// 先建立根节点</span></span><br><span class="line">    <span class="keyword">int</span> len = inorder.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; inorder.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder[i].id == postorder[postorder.size()<span class="number">-1</span>].id) &#123;</span><br><span class="line">            <span class="comment">// 找到了中序遍历的根节点，则左面的全部是左子树，右面的全部是右子树。</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;uniqueNode&gt; left_post(i);</span><br><span class="line">            <span class="built_in">vector</span>&lt;uniqueNode&gt; left_vin(i);</span><br><span class="line">            <span class="built_in">vector</span>&lt;uniqueNode&gt; right_post(len - <span class="number">1</span> - i);</span><br><span class="line">            <span class="built_in">vector</span>&lt;uniqueNode&gt; right_vin(len - <span class="number">1</span> - i);</span><br><span class="line">            copy(inorder.begin(), inorder.begin() + i, left_vin.begin());</span><br><span class="line">            copy(inorder.begin() + i + <span class="number">1</span>, inorder.end(), right_vin.begin());</span><br><span class="line">            copy(postorder.begin(), postorder.begin() + i, left_post.begin());</span><br><span class="line">            copy(postorder.begin() + i, postorder.end()<span class="number">-1</span>, right_post.begin());</span><br><span class="line">            node-&gt;left = buildTree(left_vin,left_post);</span><br><span class="line">            node-&gt;right = buildTree(right_vin,right_post);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isnumber</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> a : s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a &gt; <span class="string">'9'</span> || a &lt; <span class="string">'0'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中缀表达式 -&gt; 后缀表达式</span></span><br><span class="line"><span class="comment"> * @param expression</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;uniqueNode&gt; convert(<span class="built_in">vector</span>&lt;uniqueNode&gt; expression) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;uniqueNode&gt; re;</span><br><span class="line">    <span class="built_in">stack</span>&lt;uniqueNode&gt; cc;</span><br><span class="line">    <span class="comment">// 设置运算符的优先级</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; p;</span><br><span class="line">    p[<span class="string">"+"</span>] = <span class="number">3</span>;</span><br><span class="line">    p[<span class="string">"-"</span>] = <span class="number">3</span>;</span><br><span class="line">    p[<span class="string">"*"</span>] = <span class="number">4</span>;</span><br><span class="line">    p[<span class="string">"/"</span>] = <span class="number">4</span>;</span><br><span class="line">    p[<span class="string">"("</span>] = <span class="number">2</span>;</span><br><span class="line">    p[<span class="string">")"</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; expression.size();i++)&#123;</span><br><span class="line">        <span class="comment">// 遇到数字直接入栈</span></span><br><span class="line">        <span class="keyword">if</span>(isnumber(expression[i].description))&#123;</span><br><span class="line">            re.push_back(expression[i]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遇到操作符</span></span><br><span class="line">        <span class="keyword">if</span>(p[expression[i].description] &gt;= <span class="number">1</span> &amp;&amp; p[expression[i].description] &lt;= <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="comment">//栈为空或者遇到左括号，直接入栈</span></span><br><span class="line">            <span class="keyword">if</span>(cc.empty() || p[expression[i].description] == <span class="number">2</span> || p[expression[i].description] &gt; p[cc.top().description])&#123;</span><br><span class="line">                cc.push(expression[i]);</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="comment">//遇到右括号，弹出栈中左括号之前的所有运算符号，输出，最后左括号弹出，不输出</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p[expression[i].description] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(cc.top().description != <span class="string">"("</span>)&#123;</span><br><span class="line">                    <span class="keyword">auto</span> tmp = cc.top();</span><br><span class="line">                    re.push_back(tmp);</span><br><span class="line">                    cc.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                cc.pop(); <span class="comment">// 弹出左括号</span></span><br><span class="line">            &#125;</span><br><span class="line">                <span class="comment">//当前运算符的优先级小于等于栈顶运算符的优先级，应该先计算栈顶的运算符，所以弹出栈顶的运算符，输出，把当前的运算符入栈</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p[expression[i].description] &lt;= p[cc.top().description])&#123;</span><br><span class="line">                <span class="comment">// 弹出栈中优先级高于当前运算符的运算符</span></span><br><span class="line">                <span class="keyword">while</span>(!cc.empty() &amp;&amp; p[expression[i].description] &lt;= p[cc.top().description])&#123;</span><br><span class="line">                    re.push_back(cc.top());</span><br><span class="line">                    cc.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当栈为空 或者 遇到运算符的运算顺序低于当前运算符的时候，循环退出</span></span><br><span class="line">                cc.push(expression[i]);</span><br><span class="line">                <span class="comment">//当前运算符的优先级大于栈顶运算符的优先级，直接入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"error 1."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!cc.empty())&#123;</span><br><span class="line">        re.push_back(cc.top());</span><br><span class="line">        cc.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ExpressionTreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;expression)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;uniqueNode&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; expression.size(); ++i) &#123;</span><br><span class="line">        v.push_back(uniqueNode(expression[i],i+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> last = convert(v);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v.size(); ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(v[j].description == <span class="string">"("</span> || v[j].description == <span class="string">")"</span>)&#123;</span><br><span class="line">            v.erase(v.begin()+j);</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> head = buildTree(v,last);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表达树的特殊结构决定了我们只根据后缀表达式也能构造出来一棵表达树(注意：只根据后序遍历序列是不能构造一棵二叉树的，因为答案不唯一。)，具体的做法是模拟后缀表达式的计算顺序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Definition of ExpressionTreeNode:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExpressionTreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> symbol;</span><br><span class="line">    ExpressionTreeNode *left, *right;</span><br><span class="line">    ExpressionTreeNode(<span class="built_in">string</span> symbol) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;symbol = symbol;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left = <span class="keyword">this</span>-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isnumber</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] &lt; <span class="string">'0'</span> || s[i] &gt; <span class="string">'9'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isoperator</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="string">"+"</span> || s == <span class="string">"-"</span> || s == <span class="string">"*"</span> || s == <span class="string">"/"</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; convert(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; expression) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; re;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; cc;</span><br><span class="line">    <span class="comment">// 设置运算符的优先级</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; p;</span><br><span class="line">    p[<span class="string">"+"</span>] = <span class="number">3</span>;</span><br><span class="line">    p[<span class="string">"-"</span>] = <span class="number">3</span>;</span><br><span class="line">    p[<span class="string">"*"</span>] = <span class="number">4</span>;</span><br><span class="line">    p[<span class="string">"/"</span>] = <span class="number">4</span>;</span><br><span class="line">    p[<span class="string">"("</span>] = <span class="number">2</span>;</span><br><span class="line">    p[<span class="string">")"</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; expression.size();i++)&#123;</span><br><span class="line">        <span class="comment">// 遇到数字直接入栈</span></span><br><span class="line">        <span class="keyword">if</span>(isnumber(expression[i]))&#123;</span><br><span class="line">            re.push_back(expression[i]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遇到操作符</span></span><br><span class="line">        <span class="keyword">if</span>(p[expression[i]] &gt;= <span class="number">1</span> &amp;&amp; p[expression[i]] &lt;= <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="comment">//栈为空或者遇到左括号，直接入栈</span></span><br><span class="line">            <span class="keyword">if</span>(cc.empty() || p[expression[i]] == <span class="number">2</span> || p[expression[i]] &gt; p[cc.top()])&#123;</span><br><span class="line">                cc.push(expression[i]);</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="comment">//遇到右括号，弹出栈中左括号之前的所有运算符号，输出，最后左括号弹出，不输出</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p[expression[i]] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(cc.top() != <span class="string">"("</span>)&#123;</span><br><span class="line">                    <span class="built_in">string</span> tmp = cc.top();</span><br><span class="line">                    re.push_back(tmp);</span><br><span class="line">                    cc.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                cc.pop(); <span class="comment">// 弹出左括号</span></span><br><span class="line">            &#125;</span><br><span class="line">                <span class="comment">//当前运算符的优先级小于等于栈顶运算符的优先级，应该先计算栈顶的运算符，所以弹出栈顶的运算符，输出，把当前的运算符入栈</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p[expression[i]] &lt;= p[cc.top()])&#123;</span><br><span class="line">                <span class="comment">// 弹出栈中优先级高于当前运算符的运算符</span></span><br><span class="line">                <span class="keyword">while</span>(!cc.empty() &amp;&amp; p[expression[i]] &lt;= p[cc.top()])&#123;</span><br><span class="line">                    re.push_back(cc.top());</span><br><span class="line">                    cc.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当栈为空 或者 遇到运算符的运算顺序低于当前运算符的时候，循环退出</span></span><br><span class="line">                cc.push(expression[i]);</span><br><span class="line">                <span class="comment">//当前运算符的优先级大于栈顶运算符的优先级，直接入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"error 1."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!cc.empty())&#123;</span><br><span class="line">        re.push_back(cc.top());</span><br><span class="line">        cc.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ExpressionTreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;expression)</span> </span>&#123;</span><br><span class="line">    expression = convert(expression);</span><br><span class="line">    <span class="keyword">if</span>(expression.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;ExpressionTreeNode*&gt; cc;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; expression.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isnumber(expression[i]))&#123;</span><br><span class="line">            ExpressionTreeNode *node = <span class="keyword">new</span> ExpressionTreeNode(expression[i]);</span><br><span class="line">            cc.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isoperator(expression[i]))&#123;</span><br><span class="line">            ExpressionTreeNode *node = <span class="keyword">new</span> ExpressionTreeNode(expression[i]);</span><br><span class="line">            ExpressionTreeNode *right = cc.top();</span><br><span class="line">            cc.pop();</span><br><span class="line">            ExpressionTreeNode *left = cc.top();</span><br><span class="line">            cc.pop();</span><br><span class="line">            node-&gt;left = left;</span><br><span class="line">            node-&gt;right = right;</span><br><span class="line">            cc.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cc.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简易的正则表达式解析">简易的正则表达式解析</h3><blockquote><ul><li>s = abc3[a], return abcaaa</li><li>s = 3[abc], return abcabcabc</li><li>s = 4[ac]dy, return acacacacdy</li><li>s = 3[2[ad]3[pf]]xyz, return adadpfpfpfadadpfpfpfadadpfpfpfxyz</li></ul></blockquote><p><a href="http://lintcode.com/zh-cn/problem/expression-expand/" target="_blank" rel="noopener">Expression Expand</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">expressionExpand</span><span class="params">(<span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> finished = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]  == <span class="string">'['</span> || s[i] == <span class="string">']'</span>)&#123;</span><br><span class="line">            finished = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(finished) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">int</span> left, right,pre_left;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">'['</span>)&#123;</span><br><span class="line">            left = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">']'</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = left<span class="number">-1</span>; j &gt;= <span class="number">0</span>;--j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j]&gt;=<span class="string">'0'</span> &amp;&amp; s[j]&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                    pre_left = j;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">string</span> num = s.substr(pre_left,left-pre_left);</span><br><span class="line">            <span class="keyword">int</span> count = stoi(num);</span><br><span class="line">            <span class="built_in">string</span> cycle = s.substr(left+<span class="number">1</span>,i-left<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">string</span> cycle_with_count = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">while</span>(count--)&#123;</span><br><span class="line">                cycle_with_count += cycle;</span><br><span class="line">            &#125;</span><br><span class="line">            s.erase(pre_left,i-pre_left+<span class="number">1</span>);</span><br><span class="line">            s.insert(pre_left,cycle_with_count);</span><br><span class="line">            <span class="keyword">return</span> expressionExpand(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> expressionExpand(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带有getmin的栈">带有getMin()的栈</h3><p>实现一个可以在O(1)时间内得到最小值的栈结构。支持<code>pop(),push(),top(),getMin()</code>四种操作。</p><p><a href="http://lintcode.com/zh-cn/problem/min-stack/" target="_blank" rel="noopener">带最小值操作的栈</a></p><p><strong>思路</strong> 使用两个栈来模拟这个栈，一个栈用来保存实际的数据，一个栈用来保存对应数据的最小值。每次入栈和出栈操作的时候，判断最小值有没有发生变化，如果没有发生变化，直接弹出数据，如果发生了变化，更新存储最大值最小值的栈。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackWithGetMin2</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; min_data;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        data.push(val);</span><br><span class="line">        <span class="keyword">if</span>(!min_data.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(min_data.top()&gt;=val)&#123;</span><br><span class="line">                min_data.push(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">           min_data.push(val);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> v = data.top();</span><br><span class="line">        <span class="keyword">if</span>(v &gt; min_data.top())&#123;</span><br><span class="line">            data.pop();</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            data.pop();</span><br><span class="line">            min_data.pop();</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(min_data.empty)&#123;<span class="keyword">throw</span> <span class="keyword">new</span> exception;&#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> min_data.top();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="序列">132序列</h3><p>Given a sequence of n integers a1, a2, …, an, a 132 pattern is a subsequence ai, aj, ak such that i &lt; j &lt; k and ai &lt; ak &lt; aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.</p><p>n will be less than 20,000.</p><p><a href="http://lintcode.com/zh-cn/problem/132-pattern/#" target="_blank" rel="noopener">pattern</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> third = INT32_MIN;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; third) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">while</span> (!s.empty() &amp;&amp; nums[i] &gt; s.top()) &#123;</span><br><span class="line">                third = s.top(); s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        s.push(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用栈实现队列">用栈实现队列</h3><p><a href="">用栈实现队列</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line"></span><br><span class="line">    MyQueue() &#123;</span><br><span class="line">        <span class="comment">// do intialization if necessary</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        stack1.push(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">if</span>(stack2.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack1.empty())&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.empty())&#123;</span><br><span class="line">                <span class="keyword">int</span> a = stack1.top();</span><br><span class="line">                stack1.pop();</span><br><span class="line">                stack2.push(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = stack2.top();</span><br><span class="line">        stack2.pop();</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">if</span>(stack2.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack1.empty())&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.empty())&#123;</span><br><span class="line">                <span class="keyword">int</span> a = stack1.top();</span><br><span class="line">                stack1.pop();</span><br><span class="line">                stack2.push(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = stack2.top();</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="用一个栈排序另外一个栈">用一个栈排序另外一个栈</h3><p>要求排序好的数据就在原来的栈里面。</p><p><strong>思路</strong> 设存放数据的栈是<code>s</code>, 辅助排序的栈是<code>help</code>,一个临时变量<code>v</code>用来暂存从栈里面出来的数据。我们只要确保把<code>s</code>中的数有序的入栈<code>help</code>,然后在反向从<code>help</code>压入<code>s</code>就能得到需要的结果。如果要求从大到小排序，即<code>s</code>栈顶的元素是最大的，那么<code>help</code>中就应该是从小到大排序,栈顶的元素是最小的。每次从<code>s</code>向<code>help</code>移动数据的时候，都要和<code>help</code>的栈顶比较，如果小于栈顶的元素，直接入栈，如果大于栈顶的元素，把栈顶元素入栈到<code>s</code>,直到<code>v</code>中的数小于<code>help</code>的栈顶元素，才将<code>v</code>入栈到<code>help</code>,其实这有点向汉诺塔问题，循环利用两个栈做中转，只不过更加简单。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortStack</span><span class="params">(<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; help;</span><br><span class="line">    help.push( s.top() );</span><br><span class="line">    s.pop();</span><br><span class="line">    <span class="keyword">auto</span> v = s.top();</span><br><span class="line">    <span class="keyword">if</span>(help.top()&gt;v)&#123;</span><br><span class="line">        help.push(v);</span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(help.top()&lt;=v)&#123;</span><br><span class="line">            <span class="keyword">auto</span> temp = help.top();</span><br><span class="line">            help.pop();</span><br><span class="line">            s.push(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        help.push(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈的压入弹出序列">栈的压入、弹出序列</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列<code>1,2,3,4,5</code>是某栈的压入顺序，序列<code>4,5,3,2,1</code>是该压栈序列对应的一个弹出序列,<code>4,3,5,1,2</code>就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><p><strong>思路</strong> 设压入序列是<code>pushV</code>,弹出序列是<code>popV</code>,从<code>pushV</code>中找到第一个和<code>popV</code>首元素相同的元素，假设是<code>a</code>,可以知道<code>a</code>必定是压入栈之后就被弹出来了。假设用一个临时的栈<code>s1</code>保<code>a</code>之前入栈的元素和<code>a</code>,那么此时<code>popV</code>和<code>s1</code>的栈顶元素应该是一致的。 接下来，遍历<code>popV</code>中的元素，与<code>s1</code>中的元素比较，如果相等，弹出该元素,<code>popV</code>的指针加1,继续下一次比较.如果不相等,就把<code>pushV</code>中<code>a</code>后面的元素继续入栈到<code>s1</code>,<code>popV</code>的指针不动，继续比较<code>popV</code>和当前<code>s1</code>的栈顶元素是不是相等。按照这样的规则处理，直到指针走到尽头，看<code>s1</code>中的元素是否非空，如果是空的，<code>popV</code>就是<code>pushV</code>的弹出序列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsPopOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pushV,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popV)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(pushV.size() != popV.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">       <span class="comment">//找到第一个相同的元素</span></span><br><span class="line">       <span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(pushV[i] != popV[<span class="number">0</span>] &amp;&amp; i&lt;pushV.size())&#123;</span><br><span class="line">           s1.push(pushV[i]);</span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br><span class="line">       s1.push(pushV[i]); <span class="comment">//此时是s1栈顶和popV的第一个元素相同；</span></span><br><span class="line">       i++;<span class="comment">//i指向下一元素；</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">size_t</span> j=<span class="number">0</span>;j&lt;=popV.size();j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>( j&lt;popV.size() &amp;&amp; popV[j] == s1.top() )&#123;</span><br><span class="line">              s1.pop();</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&lt;pushV.size())&#123;</span><br><span class="line">               s1.push(pushV[i]);</span><br><span class="line">               j--;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>( j== popV.size() &amp;&amp; s1.empty())&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地代码集锦</title>
      <link href="/hexoblog/2017/04/11/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E9%9B%86%E9%94%A6/"/>
      <url>/hexoblog/2017/04/11/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E9%9B%86%E9%94%A6/</url>
      
        <content type="html"><![CDATA[<p>未整理的本地代码</p><a id="more"></a><h3 id="求数组的部分和的递归实现">求数组的部分和的递归实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 部分和问题，给定的数组中有没有若干可以组成K</span></span><br><span class="line"><span class="comment"> * @param i</span></span><br><span class="line"><span class="comment"> * @param sum</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">partSum</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> sum,<span class="keyword">int</span> k,<span class="keyword">int</span> n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == n) <span class="keyword">return</span> sum == k;</span><br><span class="line">    <span class="keyword">if</span>(partSum(i+<span class="number">1</span>,sum,k,n,v)) <span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(partSum(i+<span class="number">1</span>,sum+v[i],k,n,v)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1 = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(partSum(<span class="number">0</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">4</span>,v1)) <span class="built_in">cout</span>&lt;&lt;<span class="string">"true"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"false"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="背包问题">背包问题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 0--1 背包问题</span></span><br><span class="line"><span class="comment"> * 从第start个物体开始，总重量为weight的背包，返回最大的价值</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rec</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> weight,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; w,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ob)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"rec("</span>&lt;&lt;start&lt;&lt;<span class="string">","</span>&lt;&lt;weight&lt;&lt;<span class="string">")"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 物体的最大个数是w.size()-1,如果超过这个，返回0，含义是从第n个</span></span><br><span class="line">    <span class="comment">//物体开始，得到的价值是0，因为不能放入进去</span></span><br><span class="line">    <span class="keyword">if</span>(start == w.size()) &#123;<span class="keyword">return</span> result;&#125;</span><br><span class="line">    <span class="comment">//如果当前物体的重量已经大于总重量，那么一定不能放入背包，</span></span><br><span class="line">    <span class="comment">//一旦放入重量就超过了</span></span><br><span class="line">    <span class="keyword">if</span>(w[start] &gt; weight)&#123;</span><br><span class="line">        result = rec(start+<span class="number">1</span>,weight,w,v,ob);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果当前物体的重量小于等于最大的重量，那么这个物体可以放入背包，</span></span><br><span class="line">    <span class="comment">//尝试放入和不放入两种情况，选择较大的那个；</span></span><br><span class="line"><span class="comment">//    if(w[start] &lt;= weight)&#123;</span></span><br><span class="line"><span class="comment">//        result = max(rec(start+1,weight,w,v),rec(start+1,weight-w[start],w,v)+v[start]);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">// 记录物品是否放入了背包</span></span><br><span class="line">    <span class="keyword">if</span>(w[start] &lt;= weight)&#123;</span><br><span class="line">        <span class="keyword">int</span> noput = rec(start+<span class="number">1</span>,weight,w,v,ob);</span><br><span class="line">        <span class="keyword">int</span> putted = rec(start+<span class="number">1</span>,weight-w[start],w,v,ob)+v[start];</span><br><span class="line">        <span class="keyword">if</span>(putted &gt; noput)&#123;</span><br><span class="line">            result = putted;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"==="</span>&lt;&lt;<span class="string">"rec("</span>&lt;&lt;start&lt;&lt;<span class="string">","</span>&lt;&lt;weight&lt;&lt;<span class="string">")"</span>&lt;&lt;<span class="string">"==="</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            ob.push_back(start);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result = noput;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> a : v)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : v)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j : i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;j&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 背包问题的动态规划解法</span></span><br><span class="line"><span class="comment"> * dp[i][j] = dp[i+1][j]  当第i个物体的重量大于j的时候；</span></span><br><span class="line"><span class="comment"> * dp[i][i] = max( dp[i+1][j] , dp[i+1][j-w[i]]+v[i] ) 当第i个物体能够装进去的时候，分别尝试装入和不装入，取最大值。</span></span><br><span class="line"><span class="comment"> * @param w</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> * @param weight</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; w,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v,<span class="keyword">int</span> weight)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = w.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(weight+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;weight+<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w[i] &gt; j)&#123;</span><br><span class="line">                dp[i][j] = dp[i+<span class="number">1</span>][j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = max(dp[i+<span class="number">1</span>][j],dp[i+<span class="number">1</span>][j-w[i]] + v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print2(dp);</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][weight];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从状态转移的观点来看</span></span><br><span class="line"><span class="comment"> * dp[i][j] 表示挑选出从0到i物体，总重量不超过j的状态。dp[0][j]表示选择0个物品时的重大价值</span></span><br><span class="line"><span class="comment"> * dp[1][j] 表示选择物体1时候，总重量不超过j的最大的价值</span></span><br><span class="line"><span class="comment"> * 所以有dp[0][j] = 0;</span></span><br><span class="line"><span class="comment"> * dp[i][j] = dp[i-1][j] 当i-1物体不能放入背包时</span></span><br><span class="line"><span class="comment"> * dp[i][j] = dp[i-1][j-w[i]] + v[i] 当i-1物体可以放入背包的时候</span></span><br><span class="line"><span class="comment"> * dp[0][j]</span></span><br><span class="line"><span class="comment"> * @param w</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> * @param weight</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; w,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v,<span class="keyword">int</span> weight)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = w.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(weight+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;weight+<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w[i] &gt; j)&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j] = dp[i][j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j] = max(dp[i][j],dp[i][j-w[i]] + v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print2(dp);</span><br><span class="line">    <span class="keyword">return</span> dp[n][weight];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完全背包问题</span></span><br><span class="line"><span class="comment"> * @param w</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> * @param weight</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp3</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; w,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v,<span class="keyword">int</span> weight)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = w.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(weight+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=weight;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;w[i])&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j] = dp[i][j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j] = max(dp[i][j],dp[i+<span class="number">1</span>][j-w[i]]+v[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print2(dp);</span><br><span class="line">    <span class="keyword">return</span> dp[n][weight];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 0-1背包的变种</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; w,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v,<span class="keyword">int</span> weight)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = w.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(weight+<span class="number">1</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=weight;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;v[i])&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j] = dp[i][j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j] = min(dp[i][j],dp[i+<span class="number">1</span>][j-v[i]]+w[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print2(dp);</span><br><span class="line">    <span class="keyword">return</span> dp[n][weight];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; w = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> weight = <span class="number">7</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; w2 = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2 = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp3(w2,v2,weight)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dijkstra-算法实现">dijkstra 算法实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图的问题</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printV</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : v)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单源最短路问题</span></span><br><span class="line"><span class="comment"> * 从一个固定的点s到其他的所有的点的最短距离</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="comment">// 从from到to的边的权值是cost</span></span><br><span class="line">    <span class="keyword">int</span> from;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line">    edge(<span class="keyword">int</span> f, <span class="keyword">int</span> t, <span class="keyword">int</span> c) : from(f),to(t),cost(c)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; createTu()&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;edge&gt; s;</span><br><span class="line">    s.push_back(edge(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>));  <span class="comment">// 每一行定义一条边</span></span><br><span class="line">    s.push_back(edge(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>));</span><br><span class="line">    s.push_back(edge(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>));</span><br><span class="line">    s.push_back(edge(<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>));</span><br><span class="line">    s.push_back(edge(<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>));</span><br><span class="line">    s.push_back(edge(<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>));</span><br><span class="line">    s.push_back((edge(<span class="number">4</span>,<span class="number">6</span>,<span class="number">1</span>)));</span><br><span class="line">    s.push_back(edge(<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>));</span><br><span class="line">    s.push_back((edge(<span class="number">5</span>,<span class="number">7</span>,<span class="number">5</span>)));</span><br><span class="line">    s.push_back((edge(<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>)));</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bellman_Ford</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;edge&gt; es = createTu(); <span class="comment">//图的存储</span></span><br><span class="line">    <span class="keyword">int</span> V = <span class="number">7</span> ; <span class="comment">// 顶点的数量</span></span><br><span class="line">    <span class="keyword">int</span> E = <span class="number">10</span> ; <span class="comment">// 边的数量</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; d; <span class="comment">//结果的存储</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=V;i++)&#123;</span><br><span class="line">        d.push_back(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    d[s] = <span class="number">0</span>; <span class="comment">//从顶点s出发，顶点的编号从1开始, ds[0] 舍弃不要了</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">bool</span> update = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;E;i++)&#123;</span><br><span class="line">            edge e = es[i];</span><br><span class="line">            <span class="keyword">if</span>(d[e.from] != <span class="number">100</span> &amp;&amp; d[e.to] &gt; d[e.from] + e.cost)&#123;</span><br><span class="line">                d[e.to] = d[e.from] + e.cost;</span><br><span class="line">                update = <span class="literal">true</span>;</span><br><span class="line">                printV(d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!update)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P ; <span class="comment">// first 表示最短距离，second是顶点的编号</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;edge&gt; es = createTu(); <span class="comment">//图的存储</span></span><br><span class="line">    priority_queue&lt;P,<span class="built_in">vector</span>&lt;P&gt;,greater&lt;P&gt; &gt; que;</span><br><span class="line">    <span class="keyword">int</span> V = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">int</span> E = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; d; <span class="comment">//结果的存储</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=V;i++)&#123;</span><br><span class="line">        d.push_back(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    d[s] = <span class="number">0</span>; <span class="comment">//从顶点s出发，顶点的编号从1开始, ds[0] 舍弃不要了</span></span><br><span class="line">    que.push(P(<span class="number">0</span>,s));</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">         P p = que.top();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">int</span> v = p.second;</span><br><span class="line">        <span class="keyword">if</span>(d[v] &lt; p.first) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;es)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Bellman_Ford(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寻找丑数">寻找丑数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; uglies, <span class="keyword">int</span> count, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个用二分定位或许更快，也更稳定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (uglies[i] * n &gt; uglies[count<span class="number">-1</span>]) <span class="keyword">return</span> uglies[i] * n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; uglies(index,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    uglies[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; index; i ++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m2 = getMaxN(uglies, i, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> m3 = getMaxN(uglies, i, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">int</span> m5 = getMaxN(uglies, i, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        uglies[i] = min(m5, min(m2, m3));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uglies[index<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一个整数的数位之和">一个整数的数位之和</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumS</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a)&#123;</span><br><span class="line">        sum += a % <span class="number">10</span>;</span><br><span class="line">        a = a / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最后出现的数字">最后出现的数字</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; v(n,<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 记录数过的数字</span></span><br><span class="line">    <span class="keyword">int</span> deleted = <span class="number">0</span>; <span class="comment">//记录删除的数字</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i])&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count == m)&#123;</span><br><span class="line">            v[i] = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            deleted++;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>( i &gt;= n)&#123;</span><br><span class="line">            i = i % n ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(deleted == n<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寻找连续的整数序列和等于n">寻找连续的整数序列和等于n</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m;</span><br><span class="line">    <span class="comment">// 连续和等于sum，有两种情况，奇数个和偶数个</span></span><br><span class="line">    <span class="comment">//如果奇数个连续的整数和等于sum, 那么位于中间的那个数一定可以被sum整除</span></span><br><span class="line">    <span class="comment">//如果偶数个连续的整数和等于sum,那么必然有最中间的两个数的和可以被sum整除</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="built_in">sqrt</span>(<span class="number">2</span>*sum);i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">if</span>(sum % i != <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// i表示有多少个连续的数字加和成sum,如果sum不能整除i，肯定不可能有解</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span> || i == <span class="number">1</span>)&#123; <span class="comment">//有偶数个数字</span></span><br><span class="line">            <span class="keyword">int</span> pair = sum / i ;</span><br><span class="line">            <span class="keyword">if</span>((pair - <span class="number">1</span> ) % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">int</span> pair1 = (pair - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">//找到了位于最中间位置的两个数字</span></span><br><span class="line">                <span class="keyword">int</span> pair2 = pair1 + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> start = pair1 - i + <span class="number">1</span>; <span class="comment">// 最开始的数字</span></span><br><span class="line">                <span class="keyword">int</span> end = pair2 + i <span class="number">-1</span> ; <span class="comment">//结尾的数字</span></span><br><span class="line">                <span class="keyword">if</span>(start &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> a = start;a&lt;=end;a++)&#123;</span><br><span class="line">                        v.push_back(a);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// 有奇数个数字</span></span><br><span class="line">            <span class="keyword">if</span>(sum % i == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">int</span> mid = sum / i ; <span class="comment">//最中间的数字</span></span><br><span class="line">                <span class="keyword">if</span>(mid - (i<span class="number">-1</span>)/<span class="number">2</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> a = mid - (i<span class="number">-1</span>)/<span class="number">2</span>;a&lt;=mid+(i<span class="number">-1</span>)/<span class="number">2</span>;a++)&#123;</span><br><span class="line">                        v.push_back(a);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!v.empty())&#123;</span><br><span class="line">            m[v[<span class="number">0</span>]] = v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e = m.begin();e!=m.end();e++)&#123;</span><br><span class="line">        result.push_back(e-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多个数字一起构成最小的数字">多个数字一起构成最小的数字</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解题思路： 构成最小的数字，其实质就是从最高位开始，每次都选择最小的数字作为最高位</span></span><br><span class="line"><span class="comment">// 只需要对原来的数字按照下面的规则排序就可以做到</span></span><br><span class="line"><span class="comment">// 把两个数字的最高位对齐，例如</span></span><br><span class="line"><span class="comment">//  3332</span></span><br><span class="line"><span class="comment">//  332</span></span><br><span class="line"><span class="comment">// 从左向右比较，如果数字小的排在前面，如果数字相等，比较后面一位。如果其中一个数字没有了，</span></span><br><span class="line"><span class="comment">// 那么比较另外一个剩下的数字与首数字的关系，如果大于首数字，则该数较大，如果小于该数字，则该数较小</span></span><br><span class="line"><span class="comment">//如果相等，则指针后移，继续比较下一位，直到结束，如果直到结束都没有比较出大小，可以认为两个数一样大.</span></span><br><span class="line"><span class="comment">//使用自定义的比较方法之后，直接使用multiset排序，然后拼接在一起就是结果</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NumBit</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    NumBit(<span class="keyword">int</span> n) : num(n) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> struct NumBit &amp; right)<span class="keyword">const</span>   <span class="comment">//重载&lt;运算符</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vtmp1;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="keyword">this</span>-&gt;num;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            b = n % <span class="number">10</span>;</span><br><span class="line">            vtmp1.insert(vtmp1.begin(),b);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vtmp2;</span><br><span class="line">        <span class="keyword">int</span> n2 = right.num;</span><br><span class="line">        <span class="keyword">int</span> b2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n2)&#123;</span><br><span class="line">            b2 = n2 % <span class="number">10</span>;</span><br><span class="line">            vtmp2.insert(vtmp2.begin(),b2);</span><br><span class="line">            n2 /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ilen = vtmp1.size();</span><br><span class="line">        <span class="keyword">int</span> jlen = vtmp2.size();</span><br><span class="line">        <span class="keyword">while</span>( i&lt;ilen || j&lt;jlen )&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;ilen &amp;&amp; j&lt;jlen &amp;&amp; vtmp1[i] &gt; vtmp2[j])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&lt;ilen &amp;&amp; j&lt;jlen &amp;&amp; vtmp1[i] &lt; vtmp2[j])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&lt;ilen &amp;&amp; j&lt;jlen &amp;&amp; vtmp1[i] == vtmp2[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==ilen)&#123;</span><br><span class="line">                <span class="keyword">if</span>(vtmp2[j] &gt; vtmp2[<span class="number">0</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(vtmp2[j] &lt; vtmp2[<span class="number">0</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == jlen)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j==jlen)&#123;</span><br><span class="line">                <span class="keyword">if</span>(vtmp1[i] &gt; vtmp1[<span class="number">0</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(vtmp1[i] &lt; vtmp1[<span class="number">0</span>]) <span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == ilen)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Int_to_String</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ostringstream</span> stream;</span><br><span class="line">    stream&lt;&lt;n;  <span class="comment">//n为int类型</span></span><br><span class="line">    <span class="keyword">return</span> stream.str();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> re;</span><br><span class="line">    <span class="built_in">multiset</span>&lt;NumBit&gt; s; <span class="comment">// 存放每个数字的各位数字</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.size();i++)&#123;</span><br><span class="line">        NumBit *tmp = <span class="keyword">new</span> NumBit(numbers[i]);</span><br><span class="line">        s.insert(s.end(),*tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">        NumBit t = *s.begin();</span><br><span class="line">        re.append( Int_to_String(t.num));</span><br><span class="line">        s.erase(s.begin(),++s.begin());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次选择最小的数字放在高位上</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到出现次数大于一半的数字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(numbers.size() == <span class="number">1</span>) <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> card = numbers[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">1</span>;i&lt;numbers.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[i] == card)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            count--;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">                card = numbers[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;numbers.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[i] == card)&#123;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(numbers.size()/<span class="number">2</span> &lt; sum)&#123;</span><br><span class="line">        <span class="keyword">return</span>  card;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMinUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = v.size();</span><br><span class="line">    <span class="comment">//统计独立的数字的个数</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; se;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();i++)&#123;</span><br><span class="line">        se.insert(v[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ulen = se.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; count;</span><br><span class="line">    <span class="keyword">int</span> res = len; <span class="comment">// 存放结果，最坏的情况下是数组的长度，结果肯定不会大于这个值</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(t&lt;len &amp;&amp; num &lt;ulen)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count[v[t++]]++ == <span class="number">0</span>)&#123;</span><br><span class="line">                num ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; ulen) <span class="keyword">break</span>;</span><br><span class="line">        res = min(res,t-s);</span><br><span class="line">        <span class="keyword">if</span>(--count[v[s++]] == <span class="number">0</span>)&#123;</span><br><span class="line">            num--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; GetLeastNumbers_Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    sort(input.begin(),input.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        result.push_back(input[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * @param A: An integer array</span></span><br><span class="line"><span class="comment">      * @return: Count the number of element before this element 'ai' is</span></span><br><span class="line"><span class="comment">      *          smaller than it and return count number array</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countOfSmallerNumberII(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A) &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        Node *root = build(<span class="number">0</span>, <span class="number">20000</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = query(root, <span class="number">0</span>, A[i] - <span class="number">1</span>);</span><br><span class="line">            res.push_back(cnt);</span><br><span class="line">            <span class="comment">// 更新计数下标是i的计数</span></span><br><span class="line">            modify(root, A[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countOfSmallerNumberBack(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(A);</span><br><span class="line">        <span class="keyword">int</span> len = A.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            tmp[i] = A[len<span class="number">-1</span>-i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re = countOfSmallerNumberII(tmp);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result(re);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            result[i] = re[len<span class="number">-1</span>-i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">Node *<span class="title">build</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (start == end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(start, end);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Node *root = <span class="keyword">new</span> Node(start, end);</span><br><span class="line">        root-&gt;left = build(start, mid);</span><br><span class="line">        root-&gt;right = build(mid + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(Node *root, <span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;start == root-&gt;end &amp;&amp; root-&gt;start == idx)</span><br><span class="line">        &#123;</span><br><span class="line">            ++(root-&gt;cnt);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = root-&gt;start + ((root-&gt;end - root-&gt;start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (mid &gt;= idx)</span><br><span class="line">        &#123;</span><br><span class="line">            modify(root-&gt;left, idx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            modify(root-&gt;right, idx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root-&gt;cnt = root-&gt;left-&gt;cnt + (root-&gt;right ? root-&gt;right-&gt;cnt : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(Node *root, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;end &lt; start || root-&gt;start &gt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;start &gt;= start &amp;&amp; root-&gt;end &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;cnt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = root-&gt;start + ((root-&gt;end - root-&gt;start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (mid &gt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> query(root-&gt;left, start, end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mid &lt; start)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> query(root-&gt;right, start, end);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftRes = query(root-&gt;left, start, mid);</span><br><span class="line">        <span class="keyword">int</span> rightRes = query(root-&gt;right, mid + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leftRes + rightRes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="链表的操作">链表的操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node *next;</span><br><span class="line">    Node() : value(<span class="number">0</span>),next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    Node(<span class="keyword">int</span> v) : value(v),next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//双向链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    BiNode *pre;</span><br><span class="line">    BiNode *next;</span><br><span class="line">    BiNode() : value(<span class="number">0</span>),pre(<span class="literal">nullptr</span>),next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    BiNode(<span class="keyword">int</span> v) : value(v),pre(<span class="literal">nullptr</span>),next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Node* <span class="title">createLinks</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    Node *head = <span class="keyword">new</span> Node(v[<span class="number">0</span>]); <span class="comment">//头节点，最后需要返回创建的链表的头结点，所以头结点需要保存下来</span></span><br><span class="line">    Node *tmp = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;v.size();++i)&#123;</span><br><span class="line">        Node *node = <span class="keyword">new</span> Node(v[i]);</span><br><span class="line">        tmp-&gt;next = node;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建循环单链表</span></span><br><span class="line"><span class="function">Node* <span class="title">createLinksCycle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    Node *head = <span class="keyword">new</span> Node(v[<span class="number">0</span>]); <span class="comment">//头节点，最后需要返回创建的链表的头结点，所以头结点需要保存下来</span></span><br><span class="line">    Node *tmp = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;v.size();++i)&#123;</span><br><span class="line">        Node *node = <span class="keyword">new</span> Node(v[i]);</span><br><span class="line">        tmp-&gt;next = node;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp-&gt;next = head; <span class="comment">// 让结尾指向开头的第一个元素</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;BiNode*,BiNode*&gt; createBiNode(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.empty()) <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>,<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    BiNode *head = <span class="keyword">new</span> BiNode(v[<span class="number">0</span>]);</span><br><span class="line">    BiNode *tmp = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;v.size();i++)&#123;</span><br><span class="line">        BiNode *node = <span class="keyword">new</span> BiNode(v[i]);</span><br><span class="line">        tmp-&gt;next = node;</span><br><span class="line">        node-&gt;pre = tmp;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    BiNode *tail = tmp;</span><br><span class="line">    <span class="keyword">return</span> &#123;head,tail&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建循环双链表</span></span><br><span class="line">pair&lt;BiNode*,BiNode*&gt; createBiNodeCycle(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.empty()) <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>,<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    BiNode *head = <span class="keyword">new</span> BiNode(v[<span class="number">0</span>]);</span><br><span class="line">    BiNode *tmp = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;v.size();i++)&#123;</span><br><span class="line">        BiNode *node = <span class="keyword">new</span> BiNode(v[i]);</span><br><span class="line">        tmp-&gt;next = node;</span><br><span class="line">        node-&gt;pre = tmp;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    BiNode *tail = tmp;</span><br><span class="line">    tail-&gt;next = head;  <span class="comment">// 尾元素的后面是头元素</span></span><br><span class="line">    head-&gt;pre = tail;  <span class="comment">// 头元素的前面是尾元素</span></span><br><span class="line">    <span class="keyword">return</span> &#123;head,tail&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//反转单向链表</span></span><br><span class="line"><span class="function">Node* <span class="title">notLinks</span><span class="params">(Node* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">    Node *current = head;</span><br><span class="line">    Node *pre=<span class="literal">nullptr</span>;</span><br><span class="line">    Node *next= <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(current)&#123;</span><br><span class="line">        next = current-&gt;next; <span class="comment">// 首先记录current的下一个节点</span></span><br><span class="line">        current-&gt;next = pre; <span class="comment">// curent的下一个节点设置为前一个节点</span></span><br><span class="line">        pre = current; <span class="comment">// pre向前推进一个元素</span></span><br><span class="line">        current = next; <span class="comment">//current像前推进一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre; <span class="comment">//返回指向新链表的头节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BiNode* <span class="title">notBiLinks</span><span class="params">(BiNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">    BiNode *current = head;</span><br><span class="line">    BiNode *pre=<span class="literal">nullptr</span>;</span><br><span class="line">    BiNode *next= <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(current)&#123;</span><br><span class="line">        next = current-&gt;next; <span class="comment">// 首先记录current的下一个节点</span></span><br><span class="line">        current-&gt;next = pre; <span class="comment">// curent的下一个节点设置为前一个节点</span></span><br><span class="line">        current-&gt;pre = next;</span><br><span class="line">        pre = current; <span class="comment">// pre向前推进一个元素</span></span><br><span class="line">        current = next; <span class="comment">//current像前推进一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre; <span class="comment">//返回指向新链表的头节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BiNode* <span class="title">notBiLinks2</span><span class="params">(BiNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">    BiNode *current = head;</span><br><span class="line">    BiNode *newHead;</span><br><span class="line">    <span class="keyword">while</span>(current)&#123;</span><br><span class="line">        BiNode *tmp = current-&gt;pre;</span><br><span class="line">        current-&gt;pre = current-&gt;next;</span><br><span class="line">        current-&gt;next = tmp;</span><br><span class="line">        newHead = current;</span><br><span class="line">        current = current-&gt;pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead; <span class="comment">//返回指向新链表的头节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLinks</span><span class="params">(Node *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *tmp = head;</span><br><span class="line">    <span class="keyword">while</span> (tmp-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tmp-&gt;value &lt;&lt; <span class="string">"-&gt;"</span>;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; tmp-&gt;value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBiLinks</span><span class="params">(BiNode *head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"empty"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    BiNode *tmp = head;</span><br><span class="line">    <span class="keyword">while</span>(tmp-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"["</span>&lt;&lt;tmp-&gt;value&lt;&lt;<span class="string">"]"</span>&lt;&lt;<span class="string">"&lt;-&gt;"</span>;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"["</span>&lt;&lt;tmp-&gt;value&lt;&lt;<span class="string">"]"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Links</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node *head; <span class="comment">// 头节点</span></span><br><span class="line">    Links() : head(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="comment">//创建链表</span></span><br><span class="line">    Links(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v) &#123;</span><br><span class="line">        <span class="keyword">if</span>(v.empty())&#123;</span><br><span class="line">            head = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            Node *first = <span class="keyword">new</span> Node(v[<span class="number">0</span>]);</span><br><span class="line">            head = first;</span><br><span class="line">            Node *tmp = first;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.size(); ++i) &#123;</span><br><span class="line">                Node *node = <span class="keyword">new</span> Node(v[i]);</span><br><span class="line">                tmp-&gt;next = node;</span><br><span class="line">                tmp = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printLinks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node *tmp = head;</span><br><span class="line">        <span class="keyword">while</span> (tmp-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; tmp-&gt;value &lt;&lt; <span class="string">"-&gt;"</span>;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tmp-&gt;value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反转这个链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inverseLinks</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        Node *next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            next = head-&gt;next;</span><br><span class="line">            head-&gt;next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    Node *head = createLinks(v);</span><br><span class="line"><span class="comment">//    Node *CHead = createLinksCycle(v);</span></span><br><span class="line"><span class="comment">//    Node *IHead = notLinks(head);</span></span><br><span class="line">    <span class="keyword">auto</span> Binode = createBiNode(v);</span><br><span class="line"><span class="comment">//    auto *IBiHead = notBiLinks2(Binode.first);</span></span><br><span class="line"><span class="comment">//    auto BinodeC = createBiNodeCycle(v);</span></span><br><span class="line">    printLinks(head);</span><br><span class="line">    printBiLinks(Binode.first);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法专题_排列组合</title>
      <link href="/hexoblog/2017/04/10/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
      <url>/hexoblog/2017/04/10/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>排列组合的问题也是常常出现在算法题中。一种类型是纯数学问题，可以利用排列组合的数学知识求解。一种是需要枚举出所有的状态，经过适当的剪枝和过程的优化才可以得到正确的结果。 <a id="more"></a> 排列组合相关的试题中常见的操作就是枚举各种情况。下面介绍几种按照一定的顺序枚举所有情况的方法。 ## 生成n!种不同的排列po n个元素的全排列一共有n!种。如何按照顺序生成这n!种排列呢？C++中提供了next_permutation这一函数。 next_permutation能够按照顺序产生下一个排列，例如<code>vector&lt;int&gt; v = {1,2,3}</code>, 把v作为参数传递,<code>next_permutation(v.begin(),v.end())</code>返回的是true, v变成了1,2,3的下一个序列1,3,2;如果将3,2,1传入，返回的将是false,因为没有了下一个序列。 产生全排列的方法： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; per(<span class="keyword">int</span> n)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        v.push_back(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; re;</span><br><span class="line">    re.push_back(v);</span><br><span class="line">    <span class="keyword">while</span>(next_permutation(v.begin(),v.end()))&#123;</span><br><span class="line">        re.push_back(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="集合的整数表示">集合的整数表示</h2><p>如果一个集合有n个元素，那么这个集合的所有子集有2<sup>n个（包括空集和自身）。如果我们想要对所有的自己对应一个整数，容易想到的就是按照顺序从1到2</sup>n表示它。</p><blockquote><p>例如：a = {1,2,3} a的所有的子集有： {};{1},{2},{3};{1,2},{1,3},{2,3};{1,2,3}; 0 1 2 3 4 5 6 7</p></blockquote><p>如果像上面那样编码，集合间的操作规律不好找。我们使用下面的方式编码每个子集，目的是使得集合间的操作有规律而容易实现。 我们把所有子集都用B填充成和原来的集合一样的元素个数，保持原来集合中元素的相对位置不变，然后用二进制位1表示出现的元素，用0表示B，如下标所示：</p><table><thead><tr class="header"><th>{B,B,B}</th><th>{B,B,1}</th><th>{B,2,B}</th><th>{B,2,1}</th><th>{3,B,B}</th><th>{3,B,1}</th><th>{3,2,B}</th><th>{3,2,1}</th></tr></thead><tbody><tr class="odd"><td>000</td><td>001</td><td>010</td><td>011</td><td>100</td><td>101</td><td>110</td><td>111</td></tr><tr class="even"><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr></tbody></table><p>集合<code>{0,1,...,n-1}</code>的子集为S，S的整数编码定义为： <code>f(S) = 2^i</code> (i属于子集S) 特别定义：空集用0表示。 所以有如下的对应： &gt;{} : 0 &gt;{1} : 2^(1-1) = 1 &gt;{2} : 2^(2-1) = 2 &gt;{3} : 2^(3-1) = 4 &gt;{1,2} :2<sup>(1-1)+2</sup>(2-1) = 3 &gt;{1,3} :2<sup>(1-1)+2</sup>(3-1) = 5 &gt;{2,3} :2<sup>(2-1)+2</sup>(3-1) = 6 &gt;{1,2,3}:2<sup>(1-1)+2</sup>(2-1)+2<sup>(3-1)=2</sup>3-1=7</p><p>像这样表示后，一些集合的运算可以表示成: &gt; 空集： 0 &gt; 自身： <code>2^n-1</code> <code>(1&lt;&lt;n)-1</code> &gt; 只含有第i个元素的集合：<code>2^i (1&lt;&lt;i)</code> &gt; 判断第i个元素是否属于集合S： <code>if(S&gt;&gt;i&amp;1)</code> 如果第i个元素属于集合S,根据上面的表示方法，该数字的二进制表示中第i为必定是1，所以右移i位之后末尾必定为1. &gt; 向集合中加入第i个元素: <code>S|(1&lt;&lt;i)</code> 就是把第i位置1 &gt; 从集合中去除第i个元素: <code>S&amp;~(1&lt;&lt;i)</code> 就是把第i位置0 &gt; 集合S和T的并集：<code>S|T</code> &gt; 集合S和T的交集：<code>S&amp;T</code></p><h3 id="枚举所有的子集的方法">枚举所有的子集的方法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>^n;i++)&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">//对子集的处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="给出一个子集枚举这个集合的子集的方法">给出一个子集枚举这个集合的子集的方法</h3><p>假设给出的子集的二进制码是： 00101100 （原来集合共八个元素），要枚举这个集合的子集，依然用八位二进制码表示，我们需要一种方法每次从该数字中去掉一个二进制位1，而忽略掉二进制位0.恰巧，以前讲位运算的时候讲过，<code>n&amp;(n-1)</code>的效果就是去除n的最末位的1. <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sub = sup;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;sub&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//sub就是所有的子集</span></span><br><span class="line">  sub = (sub<span class="number">-1</span>)&amp;sub;</span><br><span class="line">&#125;<span class="keyword">while</span>(sub!=sup)  <span class="comment">// -1&amp;sup = sup</span></span><br></pre></td></tr></table></figure></p><h3 id="枚举所有大小为k的子集的办法">枚举所有大小为k的子集的办法</h3><p>所有大小为k的子集，就是二进制位中所有1的位数加起来的和为k的数字。枚举一个二进制码之后的1的个数相同的二进制码的方法有很多中，下面是其中的一种实现。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> comb = (<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(comb &lt; (<span class="number">1</span>&lt;&lt;k))&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;comb; <span class="comment">// 对集合的处理</span></span><br><span class="line">  <span class="keyword">int</span> x = comb &amp; -comb ;</span><br><span class="line">  <span class="keyword">int</span> y = comb + x;</span><br><span class="line">  comb = ((comb&amp;~y)/(x&gt;&gt;<span class="number">1</span>)) | y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>另外一种实现：</p><p>先来分析如何从得到一个数字n的下一个与n二进制1个数相同的数字。例如，n=001001110; 则下一个数字为n2=00101011; 得到下一个数字的操作规则应该是：从最低位开始，找到第一个1的位置。把与这个1相邻的所有1作为一组，这组的最高位1向左移动一位，原来的位置上补0，剩下的1移动到最右边。</p><p>使用位操作完成上述的步骤需要了解如何使用位操作完成以下的功能：</p><ol style="list-style-type: decimal"><li>找到最低位的1的位置： <code>x = n&amp;(-n)</code></li><li>与最低位1相邻的一组1中最高位的1左移一位，其余的位置置0：<code>t = x+n</code>,</li><li>将最低的一组1右移到最右边：<code>(n^t)/(n&amp;(-n)))</code>.</li></ol><p>具体的过程描述如下：</p><ol style="list-style-type: decimal"><li><code>x = n&amp;(-n)</code>,获得n的最后一个1.</li><li><code>t = x + n</code>, n中连续1的最左边的1左移一位，其余位置0.</li><li><code>n^t</code>, n中连续1的最左边的0置1.</li><li><code>(n^t)/x)</code>, 将连续的1移动到最右侧。</li><li><code>((n^t)/x)&gt;&gt;2</code>, 去掉多余的两个1.</li><li><code>ans = t | ((N^t)/x)&gt;&gt;2;</code>, 拼接两部分，得到最后的结果。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求大于N的下一个与N有相同个数1（二进制表示）的数字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NextN</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = N&amp;(-N);</span><br><span class="line">    <span class="keyword">int</span> t = N+x;</span><br><span class="line">    <span class="keyword">int</span> ans = t | ((N^t)/x)&gt;&gt;<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="位操作枚举所有组合情况">位操作枚举所有组合情况</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NextN</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = N&amp;(-N);</span><br><span class="line">    <span class="keyword">int</span> t = N+x;</span><br><span class="line">    <span class="keyword">int</span> ans = t | ((N^t)/x)&gt;&gt;<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; Cnk(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> n,<span class="keyword">int</span> k)&#123;</span><br><span class="line">    <span class="comment">// 输出所有的组合情况Cnk</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; re;</span><br><span class="line">    <span class="keyword">int</span> tmp = (<span class="number">1</span>&lt;&lt;k) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(tmp &lt; <span class="built_in">pow</span>(<span class="number">2.0</span>,n)<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> tt = tmp;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vtmp;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(tt &amp;&amp; i&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tt&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                vtmp.push_back(v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            tt = tt&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        re.push_back(vtmp);</span><br><span class="line">        tmp = NextN(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去除重复元素的cnk,例如 1，2，2，3，3，3，4</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NextN</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = N&amp;(-N);</span><br><span class="line">    <span class="keyword">int</span> t = N+x;</span><br><span class="line">    <span class="keyword">int</span> ans = t | ((N^t)/x)&gt;&gt;<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">int2String</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ostringstream</span> stream;</span><br><span class="line">    stream&lt;&lt;n;  <span class="comment">//n为int类型</span></span><br><span class="line">    <span class="keyword">return</span> stream.str();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">toString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> re;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> s : v)&#123;</span><br><span class="line">        re += int2String(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; Cnk(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> n,<span class="keyword">int</span> k)&#123;</span><br><span class="line">    <span class="comment">// 输出所有的组合情况Cnk</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; re;</span><br><span class="line">    <span class="keyword">int</span> tmp = (<span class="number">1</span>&lt;&lt;k) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(tmp &lt; <span class="built_in">pow</span>(<span class="number">2.0</span>,n)<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> tt = tmp;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vtmp;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(tt &amp;&amp; i&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tt&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                vtmp.push_back(v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            tt = tt&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> key = toString(vtmp);</span><br><span class="line">        re[key] = vtmp;</span><br><span class="line">        tmp = NextN(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法专题_大数据和空间限制</title>
      <link href="/hexoblog/2017/04/10/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%92%8C%E7%A9%BA%E9%97%B4%E9%99%90%E5%88%B6/"/>
      <url>/hexoblog/2017/04/10/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%92%8C%E7%A9%BA%E9%97%B4%E9%99%90%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>主要介绍一些涉及大量数据的一些算法设计问题。</p><a id="more"></a><h2 id="bloom-filter布隆过滤器">Bloom filter（布隆过滤器）</h2><p>宁可错杀三千，绝不放过一个(属于这个集合的肯定不会误判，但是不属于这个集合的却有可能误以为属于这个集合)</p><p>布隆过滤器是一种用来处理大数据的查询的一种方式，该方法允许精确的判断一个元素是否属于一个集合。这里的精确是只可以在一定的精度范围内。例如可以以<code>99.99%</code>的概率确定一个元素属于还是不属于这个集合。 &gt; 布隆过滤器的优势： - 使用很少的空间就可以把精确度做的很高。 - 不需要存储元素本身，在某些对保密要求非常严格的场合有优势 - 不需要顾忌单个元素取值范围的大小，因为它与最终布隆过滤器的大小没有关系 （需要注意的是，单个元素的大小必须在散列函数可以表示的范围内）</p><blockquote><p>布隆过滤器的缺点： - 精确度永远不可能达到1 - 从集合中删除某个元素非常困难</p></blockquote><p>布隆过滤器的原理是，当一个元素被加入集合时，通过K个<a href="#sanlie">散列函数</a>将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。</p><h3 id="散列函数"><span id="sanlie">散列函数</span></h3><p><img src="QQ截图20170410193152.png" alt="QQ截图20170410193152.png"> <img src="2017-04-10_193408.png" alt="2017-04-10_193408.png"> <img src="2017-04-10_193551.png" alt="2017-04-10_193551.png"> <img src="2017-04-10_193709.png" alt="2017-04-10_193709.png"></p><p>在生成布隆过滤器的时候遇到的对象，判断是否属于这个集合的时候是一定不会出错的。只有生成布隆过滤器的时候没有用到的元素，才可能出错。</p><p>布隆过滤器的设计需要考虑两个因素，要表示的数据量n和允许的误差范围p,这里举个例子：n=1000000000, p=0.01。已知数据量和误差范围的时候可以使用如下的公式求解需要布隆数组的位数和需要使用的散列函数的个数。</p><blockquote><ul><li>布隆数组的位数m: m = -(n*lnp)/(ln2)^2</li></ul></blockquote><blockquote><ul><li>散列函数的个数k: k = ln2 * (m/n) = 0.7 * m/n;</li></ul></blockquote><p>公式的具体推导过程可以参考<a href="">这里</a></p><p>参考例题：</p><div class="figure"><img src="2017-03-22_151134.png" alt="2017-03-22_151134.png"><p class="caption">2017-03-22_151134.png</p></div><h2 id="大文件的处理">大文件的处理</h2><p>把一个大的集合通过哈希函数分配到多台机器中，或者分配到多个文件里，这种技巧是处理面试题中涉及到大数据的时候的最常用的技巧。</p><h3 id="只用2gb内存在20亿个数中找出出现次数最多的数字">只用2GB内存在20亿个数中找出出现次数最多的数字</h3><p>统计出现次数，可以使用哈希表，本题的难点是直接使用哈希表的话，内存是放不下的。</p><p>具体做法是：</p><ol style="list-style-type: decimal"><li>使用哈希函数将原来包含20亿个整数的文件分割成16个小文件，使得一样的数字在相同的文件中，文件大小尽可能均匀。</li><li>分别统计16个小文件的整数出现次数，然后得出最后的结果。</li></ol><p>这其实就是分治思想的应用。 关键是使用什么样的哈希函数分割文件，怎样的合并结果策略可以保证得到正确的结果。本题最简单的哈希策略可以是直接用原来的整数当作哈希值，对16取余。余数为0的输出到第一个文件，余数为1的输出到第二个文件，还要注意统计文件中整数的数量，当超过1.25亿的时候就转向下一个文件保存数据，保证16个文件大小的均衡。合并结果的时候，统计每个小文件中出现次数最多的那个，然后判断其他小文件中有没有包含这个数字，有的话，加上，输出最后的结果。</p><h3 id="亿个非负整数中没有出现的数字">40亿个非负整数中没有出现的数字</h3><p>32位无符号整数可以表示大约42亿个数字，一个文件中存储了40亿个数字，那么即使这40亿个数字都不相同，也存在没有出现过的数字，找出这些数字。</p><p>思路：找出没有出现的数字，我们就得有方法记录所有已经出现的数字，只有记住了哪些数字出现过，才可以知道哪些数字没有出现过。所以这个问题是非常费内存的。如何记录40亿个数字的出现呢？ 使用一个40亿长度的数组显然是不能满足内存要求的。 现在考虑如果只用一个比特位表示一个数字是否能满足要求，经过计算，只需要500M的内存基本上就可以了。所以方法是：开辟一个INT32_MAX*2的位数组，记录每个数字出现的情况。遍历完一遍之后，我们就知道了每个数字出现的情况，然后再遍历一遍，遇到0就输出。</p><p>现在考虑如何使用更小的内存处理这个问题，例如10M内存，只找出一个未出现的就可以了。</p><p>解决的思路是分割处理，例如分割成64个子段，第一次遍历，统计落在每个区间的上的数字的数量，必定有一个区间是不满的，找出这个区间，第二次遍历，只处理落在这个区间上的数字，在对应的位上标记1表示出现过。第三次遍历，遇到是0的就输出，就可以了。</p><h3 id="section"></h3><h2 id="一致性哈希算法">一致性哈希算法</h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法专题_二叉树</title>
      <link href="/hexoblog/2017/04/09/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/hexoblog/2017/04/09/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>树是没有环的图。树和链表、图都有关联。链表是树的一种特殊情况，而图都可以对应一棵生成树。学习完链表，学习树，然后学习图，是一个比较容易接受的过程。每个节点最多有两个子节点的树叫做二叉树。二叉树是递归定义的，这导致很多涉及二叉树的问题都可以用递归的方法求解。按照节点数目的不同，二叉树的类型有：完全二叉树，满二叉树和完美二叉树。</p><a id="more"></a><h2 id="二叉树的通用性质">二叉树的通用性质</h2><ul><li>二叉树的第i层节点数目至多是<code>2^(i-1); (i&gt;=1)</code></li><li>深度为K的二叉树至多有<code>2^(K-1)</code>个节点。</li><li>二叉树中出度为2的节点数目记作n2, 叶节点记作n0; 则有<code>n0 = n2 + 1</code></li><li>深度为n的完美二叉树，其节点的数目是<code>2^n -1</code>, 叶节点数目是<code>2^(n-1)</code>, 非叶节点的数目是<code>2^(n-1)-1</code></li><li>节点数目为n的完美二叉树，深度是<code>log2(n+1)</code></li><li>节点数目为n的完全二叉树，深度是<code>[log2(n)] + 1</code> 其中[]表示向下取整</li></ul><h2 id="二叉树的定义">二叉树的定义</h2><p>二叉树的结构和双向链表比较相似，需要两个指针分别指向左孩子和右孩子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义二叉树的结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">int</span> val;</span><br><span class="line">   TreeNode *left, *right;</span><br><span class="line">   TreeNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">       <span class="keyword">this</span>-&gt;val = val;</span><br><span class="line">       <span class="keyword">this</span>-&gt;left = <span class="keyword">this</span>-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的创建生成">二叉树的创建(生成)</h2><p>创建一棵二叉树有多种方式，算法中指定二叉树通常使用“#”表示不存在的节点，这里我们采用两个遍历序列的方式来确定一棵二叉树的结构。前序遍历序列和中序遍历序列可以唯一的确定一颗二叉树的结构，后序遍历序列和中序遍历序列也可以唯一的确定一棵二叉树的结构。</p><h3 id="根据前序遍历和中序遍历重建二叉树">根据前序遍历和中序遍历重建二叉树</h3><p>根据二叉树的前序遍历和中序遍历的结果创建二叉树，根据前序遍历序列和中序遍历序列可以唯一的确定一棵二叉树。 假设前序遍历的序列是pre; 中序遍历的序列是vin;里面都不含有重复数字；首先确定根节点，肯定是pre[0], 然后在vin中寻找pre[0], 它前面的一定是左子树上的，后面的都是右子树上的。假设pre[0]出现在vin[3],可以知道左子树上有三个节点，分别是vin[0],vin[1],vin[2], 在pre中从pre[0]以后数3个数字这三个数字一定是位于左子树上的，剩下的属于右子树。分别按照上面的方法递归处理左右子树，直到只剩下一个元素，返回答案；举例来说，假设<code>pre = [1,2,4,7,3,5,6,8]</code> <code>vin=[4,7,2,1,5,3,8,6]</code>第一次： 可知1是根，2，4，7是1的左子树上的，3,5,6,8,是1的右子树上的。 分别处理序列<code>[2,4,7] [4,7,2]</code> 和<code>[3,5,6,8] [5,3,6,8]</code>第二次： 对于<code>[2,4,7] [4,7,2]</code> 可以得到2是根，而4，7都是左子树上的， 接着处理<code>[4,7] [4,7]</code> 此时4是根，而7位于右子树上，这边处理完毕；对于<code>[3,5,6,8] [5,3,8,6]</code> 可以得到3是根，5是左子树上的，<code>[6,8]</code>是右子树上的。接着处理<code>[6,8][8,6]</code> 此时6是根，而8位于左子树上。</p><p>综合上面的分析，可以得到这个二叉树的形状如下：</p><div class="figure"><img src="construct_tree.svg"></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据前序遍历和中序遍历重建二叉树</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.empty() || vin.empty())&#123;<span class="keyword">return</span> <span class="literal">nullptr</span>;&#125;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);<span class="comment">// 先建立根节点</span></span><br><span class="line">        <span class="keyword">int</span> len = pre.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;vin.size();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vin[i] == pre[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="comment">// 找到了中序遍历的根节点，则左面的全部是左子树，右面的全部是右子树。</span></span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left_pre(i,<span class="number">0</span>);</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left_vin(i,<span class="number">0</span>);</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right_pre(len<span class="number">-1</span>-i,<span class="number">0</span>);</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right_vin(len<span class="number">-1</span>-i,<span class="number">0</span>);</span><br><span class="line">                copy(vin.begin(),vin.begin()+i,left_vin.begin());</span><br><span class="line">                copy(vin.begin()+i+<span class="number">1</span>,vin.end(),right_vin.begin());</span><br><span class="line">                copy(pre.begin()+<span class="number">1</span>,pre.begin()+<span class="number">1</span>+i,left_pre.begin());</span><br><span class="line">                copy(pre.begin()+i+<span class="number">1</span>,pre.end(),right_pre.begin());</span><br><span class="line">                node-&gt;left =  reConstructBinaryTree(left_pre,left_vin);</span><br><span class="line">                node-&gt;right = reConstructBinaryTree(right_pre,right_vin);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/#/description" target="_blank" rel="noopener">leetcode</a> <a href="https://gist.github.com/FF120/8c0508c1412cf1ca486dc10695ea1c94" target="_blank" rel="noopener">gist</a></p><h3 id="根据后序遍历和中序遍历重建二叉树">根据后序遍历和中序遍历重建二叉树</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历和中序遍历重建二叉树</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inorder.empty() || postorder.empty()) &#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125;</span><br><span class="line">    TreeNode *node = <span class="keyword">new</span> TreeNode(postorder[postorder.size()<span class="number">-1</span>]);<span class="comment">// 先建立根节点</span></span><br><span class="line">    <span class="keyword">int</span> len = inorder.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; inorder.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder[i] == postorder[postorder.size()<span class="number">-1</span>]) &#123;</span><br><span class="line">            <span class="comment">// 找到了中序遍历的根节点，则左面的全部是左子树，右面的全部是右子树。</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left_post(i, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left_vin(i, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right_post(len - <span class="number">1</span> - i, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right_vin(len - <span class="number">1</span> - i, <span class="number">0</span>);</span><br><span class="line">            copy(inorder.begin(), inorder.begin() + i, left_vin.begin());</span><br><span class="line">            copy(inorder.begin() + i + <span class="number">1</span>, inorder.end(), right_vin.begin());</span><br><span class="line">            copy(postorder.begin(), postorder.begin() + i, left_post.begin());</span><br><span class="line">            copy(postorder.begin() + i, postorder.end()<span class="number">-1</span>, right_post.begin());</span><br><span class="line">            node-&gt;left = buildTree(left_vin,left_post);</span><br><span class="line">            node-&gt;right = buildTree(right_vin,right_post);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/#/description" target="_blank" rel="noopener">leetcode</a> <a href="https://gist.github.com/FF120/86ed96f2c2a7c110119e191ddcc94cd8" target="_blank" rel="noopener">gist</a></p><h2 id="二叉树的深度">二叉树的深度</h2><p>从根节点到叶节点经过的节点数量定义为二叉树的深度。</p><h3 id="最大深度">最大深度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 二叉树的最大深度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth2</span><span class="params">(TreeNode *root, <span class="keyword">const</span> <span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> dep;</span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> dep+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> maxDepth2(root-&gt;left,dep+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right &amp;&amp; !root-&gt;left) <span class="keyword">return</span> maxDepth2(root-&gt;right,dep+<span class="number">1</span>);     </span><br><span class="line">    <span class="keyword">return</span> max(maxDepth2(root-&gt;left,dep+<span class="number">1</span>),maxDepth2(root-&gt;right,dep+<span class="number">1</span>));   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最小深度">最小深度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的最小深度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDepth2</span><span class="params">(TreeNode* root,<span class="keyword">const</span> <span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> dep;</span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> dep+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left &amp;&amp; !root-&gt;right)  <span class="keyword">return</span> minDepth2(root-&gt;left,dep+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; root-&gt;right)  <span class="keyword">return</span> minDepth2(root-&gt;right,dep+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> min(minDepth2(root-&gt;left,dep+<span class="number">1</span>),minDepth2(root-&gt;right,dep+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的遍历">二叉树的遍历</h2><p>二叉树有三种常见的遍历方式：前序遍历、中序遍历、后序遍历。前中后指的都是根节点相对于左右孩子节点的顺序。所以前序遍历的顺序是 <code>root-left-right</code>, 中序遍历的顺序是 <code>left-root-right</code>, 后序遍历的顺序是 <code>left-right-root</code>.</p><h3 id="前序遍历递归">前序遍历(递归)</h3><p><strong>前序遍历遍历的步骤</strong>：</p><ol style="list-style-type: decimal"><li>输出当前节点</li><li>如果有左孩子，用左孩子做参数递归</li><li>如果有右孩子，用由孩子做参数递归</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode *root) &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> re;</span><br><span class="line">        re.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ll = preorderTraversal(root-&gt;left);</span><br><span class="line">            re.insert(re.end(), ll.begin(), ll.end());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rr = preorderTraversal(root-&gt;right);</span><br><span class="line">            re.insert(re.end(), rr.begin(), rr.end());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="前序遍历非递归">前序遍历(非递归)</h3><p>非递归的实现，递归函数的实现是使用堆栈的方式，所以把递归调用的函数改写成非递归的形式一般也是使用堆栈作为数据结构。</p><p><strong>前序遍历的非递归遍历步骤</strong></p><ol style="list-style-type: decimal"><li>输出当前的节点值，并把当前的节点压入栈</li><li><code>current = current-&gt;left</code>;循环以上步骤直到没有左孩子，执行下面的步骤</li><li>取栈顶元素的右孩子，弹出栈顶元素，然后回到步骤1.</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历的非递归实现</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode *root) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line"> <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> re;</span><br><span class="line"> <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line"> TreeNode *tmp = root;</span><br><span class="line"> <span class="keyword">while</span>(tmp!=<span class="literal">nullptr</span> || !s.empty())&#123; <span class="comment">// 逻辑或是短路的</span></span><br><span class="line"><span class="keyword">while</span>(tmp!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">re.push_back(tmp-&gt;val);</span><br><span class="line">s.push(tmp);</span><br><span class="line">tmp = tmp-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 循环退出说明没有了左孩子</span></span><br><span class="line"><span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">   tmp = s.top();</span><br><span class="line">   s.pop();</span><br><span class="line">   tmp = tmp-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历递归">中序遍历(递归)</h3><p><strong>中序遍历遍历的步骤</strong></p><ol style="list-style-type: decimal"><li>如果当前的节点有左孩子，用左孩子作为参数递归</li><li>输出当前节点</li><li>如果当前节点有右孩子，用右孩子作为参数递归</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历的递归实现</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode *root) &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> re;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ll = inorderTraversal(root-&gt;left);</span><br><span class="line">            re.insert(re.end(),ll.begin(),ll.end());</span><br><span class="line">        &#125;</span><br><span class="line">        re.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rr = inorderTraversal(root-&gt;right);</span><br><span class="line">            re.insert(re.end(),rr.begin(),rr.end());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历非递归">中序遍历(非递归)</h3><p><strong>中序遍历的非递归实现</strong></p><ol style="list-style-type: decimal"><li>对于当前的节点，放入堆栈，然后搜索有没有左孩子，一直向下搜索到没有左孩子为止。</li><li>从堆栈取出栈顶元素，输出，然后搜索右孩子</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历的非递归实现</span></span><br><span class="line"> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode * root) &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> re;</span><br><span class="line">        </span><br><span class="line">        TreeNode* iter = root;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(iter || !s.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(iter)&#123;</span><br><span class="line">                s.push(iter);</span><br><span class="line">                iter = iter-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">                iter = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                re.push_back(iter-&gt;val);</span><br><span class="line">                iter = iter-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历递归">后序遍历(递归)</h3><p><strong>后序遍历遍历的步骤是</strong></p><ol style="list-style-type: decimal"><li>如果当前节点有左孩子，用左孩子作为参数递归</li><li>如果当前节点有右孩子，用右孩子作为参数递归</li><li>输出当前节点</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后续遍历的递归实现</span></span><br><span class="line"> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode *root) &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> re;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ll = postorderTraversal(root-&gt;left);</span><br><span class="line">            re.insert(re.end(),ll.begin(),ll.end());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rr = postorderTraversal(root-&gt;right);</span><br><span class="line">            re.insert(re.end(),rr.begin(),rr.end());</span><br><span class="line">        &#125;</span><br><span class="line">        re.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历非递归">后序遍历(非递归)</h3><p><strong>后序遍历的非递归实现</strong></p><p>第一种思路：对于任一结点P，将其入栈，然后沿其左子树一直往下搜索，直到搜索到没有左孩子的结点，此时该结点出现在栈顶，但是此时不能将其出栈并访问，因此其右孩子还为被访问。所以接下来按照相同的规则对其右子树进行相同的处理，当访问完其右孩子时，该结点又出现在栈顶，此时可以将其出栈并访问。这样就保证了正确的访问顺序。可以看出，在这个过程中，每个结点都两次出现在栈顶，只有在第二次出现在栈顶时，才能访问它。因此需要多设置一个变量标识该结点是否是第一次出现在栈顶。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历的非递归实现</span></span><br></pre></td></tr></table></figure><p>第二种思路：要保证根结点在左孩子和右孩子访问之后才能访问，因此对于任一结点P，先将其入栈。如果P不存在左孩子和右孩子，则可以直接访问它；或者P存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。若非上述两种情况，则将P的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根结点前面被访问。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历的非递归实现</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postOrder(TreeNode *root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> re;</span><br><span class="line"></span><br><span class="line">    TreeNode *p = root;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode *&gt; s; </span><br><span class="line">    TreeNode *last = root;</span><br><span class="line">    s.push(p);</span><br><span class="line">    <span class="keyword">while</span> (!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        p = s.top();</span><br><span class="line">        <span class="keyword">if</span>( (p-&gt;left == <span class="literal">nullptr</span> &amp;&amp; p-&gt;right == <span class="literal">nullptr</span>) || (p-&gt;right == <span class="literal">nullptr</span> &amp;&amp; last == p-&gt;left) || (last == p-&gt;right) )</span><br><span class="line">        &#123;</span><br><span class="line">            re.push_back(p-&gt;val);</span><br><span class="line">            last = p;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">                s.push(p-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left)</span><br><span class="line">                s.push(p-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="层次遍历">层次遍历</h3><p>二叉树的层次遍历类似与图的广度优先搜索，可以使用队列来实现。思路是： 使用两个队列保存相邻两层的节点，循环输出每层的节点</p><p><strong>层次遍历遍历的步骤</strong></p><blockquote><ol style="list-style-type: decimal"><li>初始化两个队列d1,d2;令d1保存root,d2为空</li><li>清空d2,遍历d1中的节点，把d1中节点的所有孩子节点按照顺序放入d2中</li><li>打印d1中的节点</li><li>交换d1和d2;转到2</li></ol><p>循环直到d2中为空，结束。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从底向上层次遍历二叉树</span></span><br><span class="line"> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode *root) &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; v1,v2;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        v1.push_back(root);</span><br><span class="line">        <span class="keyword">while</span>(!v1.empty())&#123;</span><br><span class="line">            <span class="comment">// 遍历v1中的所有节点，将下一层节点保存在v2中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v1.size();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v1[i]-&gt;left)&#123;</span><br><span class="line">                    v2.push_back(v1[i]-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(v1[i]-&gt;right)&#123;</span><br><span class="line">                    v2.push_back(v1[i]-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">            <span class="comment">//打印v1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v1.size();i++)&#123;</span><br><span class="line">                tmp.push_back(v1[i]-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            result.insert(result.begin(),tmp);</span><br><span class="line">            swap(v1,v2);</span><br><span class="line">            v2.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自顶向下遍历二叉树</span></span><br><span class="line"> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; zigzagLevelOrder(TreeNode *root) &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; v1,v2;</span><br><span class="line">        v1.push_back(root);</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!v1.empty())&#123;</span><br><span class="line">            <span class="comment">//遍历v1中的节点，把v1中所有节点的下一级节点存储在v2中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v1.size();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v1[i]-&gt;left)&#123;</span><br><span class="line">                    v2.push_back(v1[i]-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(v1[i]-&gt;right)&#123;</span><br><span class="line">                    v2.push_back(v1[i]-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 打印v1中的节点,如果level 是奇数，则从左向又打印，</span></span><br><span class="line">            <span class="comment">// 如果level是偶数，则从右向左打印</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">if</span>(level % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=v1.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                    tmp.push_back(v1[i]-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(level % <span class="number">2</span> )&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v1.size();i++)&#123;</span><br><span class="line">                    tmp.push_back(v1[i]-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(tmp);</span><br><span class="line">            <span class="comment">// 更新该更新的数据</span></span><br><span class="line">            swap(v1,v2);</span><br><span class="line">            v2.clear();</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 之字形遍历二叉树</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; output;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; row;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span> output;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; first;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; second;</span><br><span class="line">    <span class="keyword">bool</span> odd = <span class="literal">true</span>;</span><br><span class="line">    first.push_back(pRoot);</span><br><span class="line">    <span class="keyword">while</span>(!first.empty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(odd)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; first.size(); ++i) &#123;</span><br><span class="line">                row.push_back(first[i]-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(first[i]-&gt;left)&#123;</span><br><span class="line">                    second.push_back(first[i]-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(first[i]-&gt;right)&#123;</span><br><span class="line">                    second.push_back(first[i]-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            output.push_back(row);</span><br><span class="line">            row.clear();</span><br><span class="line">            swap(first,second);</span><br><span class="line">            second.clear();</span><br><span class="line">            odd = !odd;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = first.size()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                row.push_back(first[i]-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            output.push_back(row);</span><br><span class="line">            row.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; first.size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(first[j]-&gt;left)&#123;</span><br><span class="line">                    second.push_back(first[j]-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(first[j]-&gt;right)&#123;</span><br><span class="line">                    second.push_back(first[j]-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(first,second);</span><br><span class="line">            second.clear();</span><br><span class="line">            odd = !odd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="平衡二叉树">平衡二叉树</h2><p>平衡二叉树的定义是：要么是一棵空树，要么根节点左右两棵子树的高度相差不超过1，并且左右两个子树也是平衡二叉树。</p><h3 id="平衡二叉树的判定">平衡二叉树的判定</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求树的最大深度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">        left += maxDepth(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">        right += maxDepth(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    depth = max(left,right);</span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断二叉树是否是平衡二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left-&gt;left== <span class="literal">nullptr</span> &amp;&amp; root-&gt;left-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> left = isBalanced(root-&gt;left);</span><br><span class="line">    <span class="keyword">bool</span> right = isBalanced(root-&gt;right);</span><br><span class="line">    <span class="keyword">int</span> ldepth = maxDepth(root-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> rdepth = maxDepth(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">abs</span>(ldepth-rdepth)&lt;=<span class="number">1</span> &amp;&amp; left &amp;&amp; right) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树二叉查找树">二叉搜索树(二叉查找树)</h2><p>二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：</p><blockquote><ul><li>若任意结点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若任意结点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>任意结点的左、右子树也分别为二叉查找树。</li><li>没有键值相等的结点（no duplicate nodes）。</li></ul></blockquote><p>因为，一棵由n个结点，随机构造的二叉查找树的高度为lgn，所以顺理成章，一般操作的执行时间为O（lgn）.（至于n个结点的二叉树高度为lgn的证明，可参考算法导论 第12章 二叉查找树 第12.4节）。</p><p>但二叉树若退化成了一棵具有n个结点的线性链后，则此些操作最坏情况运行时间为O（n）。后面我们会看到一种基于二叉查找树-红黑树，它通过一些性质使得树相对平衡，使得最终查找、插入、删除的时间复杂度最坏情况下依然为O（lgn）。</p><h3 id="二叉搜索树的判定">二叉搜索树的判定</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二叉搜索树的遍历序列">二叉搜索树的遍历序列</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思路：如果是二叉搜索树的后序遍历序列，那么最后一个一定是根，并且一定可以存在这样的关系：根前面的元素分成两部分，前一部分都比根小，后一部分都比根大，注意，这里前一部分和后一部分都可能为空。判断给出的序列是否满足这样的规律，然后分别递归判断左右两个分支。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bst</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">       <span class="comment">// 1. 找到第一个比根(r)小的元素，这里作为左右子树的分界</span></span><br><span class="line">       <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">int</span> i=r<span class="number">-1</span>;</span><br><span class="line">       <span class="keyword">while</span>(i&gt;=l &amp;&amp; a[i]&gt;a[r])&#123;</span><br><span class="line">           --i;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 此时i指向从后向前第一个小于a[r]的元素</span></span><br><span class="line">       <span class="comment">// 2. 检查从i到l的所有元素是否都小于a[r]</span></span><br><span class="line">       <span class="keyword">int</span> mid = i;</span><br><span class="line">       <span class="keyword">while</span>(i&gt;=l)&#123;</span><br><span class="line">           <span class="keyword">if</span>(a[i] &gt;= a[r])&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           i--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 此时 i应该等于l-1</span></span><br><span class="line">       <span class="comment">// 3. 划分出左右子树并且确保符合二叉搜索树的要求，递归左右子树，看是否符合要求</span></span><br><span class="line">       <span class="keyword">return</span> bst(a,l,mid) &amp;&amp; bst(a,mid+<span class="number">1</span>,r<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(sequence.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">return</span> bst(sequence,<span class="number">0</span>,sequence.size()<span class="number">-1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="红黑树">红黑树</h2><p>参考文章：http://blog.csdn.net/chenhuajie123/article/details/11951777 红黑树，本质上来说就是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)</p><p>红黑树的性质：</p><blockquote><ol style="list-style-type: decimal"><li>每个结点要么是红的，要么是黑的。</li><li>根结点是黑的。</li><li>每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。</li><li>如果一个结点是红的，那么它的俩个儿子都是黑的。</li><li>对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。</li></ol></blockquote><p>红黑树的示例：</p><div class="figure"><img src="2017-04-11_094148.png" alt="2017-04-11_094148.png"><p class="caption">2017-04-11_094148.png</p></div>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法专题_通用树结构</title>
      <link href="/hexoblog/2017/04/09/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E9%80%9A%E7%94%A8%E6%A0%91%E7%BB%93%E6%9E%84/"/>
      <url>/hexoblog/2017/04/09/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E9%80%9A%E7%94%A8%E6%A0%91%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>学习树结构的时候，做了大量二叉树的题目，了解了二叉树的表示结构和各种操作。但是当遇到普通的树的时候，一时竟不知道如何表示。其实树就是没有环的图。所以用来表示图的两种方法都可以用来表示一般的树结构。</p><a id="more"></a><h2 id="定义">定义</h2><p><strong>邻接表</strong></p><p>用一个二维的数组(或者链表)表示每个节点的相邻的节点有哪些。</p><p><strong>邻接矩阵</strong></p><p>用一个矩阵表示哪两个节点之间直接相连。</p><h2 id="应用">应用</h2><h3 id="无根树化为有根树">无根树化为有根树</h3><p>将一棵树转换成以其中某个节点为根的树。</p><p><a href="http://hihocoder.com/problemset/problem/1542" target="_blank" rel="noopener">hihocoder 1542</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,rt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> par[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    par[x] = p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v[x].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> toit = v[x][i];</span><br><span class="line">        <span class="keyword">if</span>(toit!=p)</span><br><span class="line">            dfs(toit,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; rt;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        v[a].push_back(b);</span><br><span class="line">        v[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(rt,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; par[i] &lt;&lt; (i==n?<span class="string">'\n'</span>:<span class="string">' '</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>做过的算法题汇总表</title>
      <link href="/hexoblog/2017/04/08/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%81%9A%E8%BF%87%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98%E6%B1%87%E6%80%BB%E8%A1%A8/"/>
      <url>/hexoblog/2017/04/08/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%81%9A%E8%BF%87%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98%E6%B1%87%E6%80%BB%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>在各个不同的平台上做过的算法题目。</p><a id="more"></a><h2 id="lintcode">[lintcode]</h2><h3 id="二叉树的前序遍历---c-lintcode">二叉树的前序遍历 - C++ [lintcode]</h3><p><img src="2017-04-08_220703.png" alt="2017-04-08_220703.png"> http://www.lintcode.com/zh-cn/problem/binary-tree-preorder-traversal/ <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition of TreeNode:</span></span><br><span class="line"><span class="comment"> * class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> * public:</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left, *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *         this-&gt;val = val;</span></span><br><span class="line"><span class="comment"> *         this-&gt;left = this-&gt;right = NULL;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param root: The root of binary tree.</span></span><br><span class="line"><span class="comment">     * @return: Preorder in vector which contains node values.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode *root) &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> re;</span><br><span class="line">        re.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ll = preorderTraversal(root-&gt;left);</span><br><span class="line">            re.insert(re.end(), ll.begin(), ll.end());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rr = preorderTraversal(root-&gt;right);</span><br><span class="line">            re.insert(re.end(), rr.begin(), rr.end());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="二叉树的中序遍历---c-lintcode">二叉树的中序遍历 - C++ [lintcode]</h3><p><img src="2017-04-08_220826.png" alt="2017-04-08_220826.png"> http://www.lintcode.com/zh-cn/problem/binary-tree-inorder-traversal/ <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition of TreeNode:</span></span><br><span class="line"><span class="comment"> * class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> * public:</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left, *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *         this-&gt;val = val;</span></span><br><span class="line"><span class="comment"> *         this-&gt;left = this-&gt;right = NULL;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param root: The root of binary tree.</span></span><br><span class="line"><span class="comment">     * @return: Inorder in vector which contains node values.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode *root) &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> re;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ll = inorderTraversal(root-&gt;left);</span><br><span class="line">            re.insert(re.end(),ll.begin(),ll.end());</span><br><span class="line">        &#125;</span><br><span class="line">        re.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rr = inorderTraversal(root-&gt;right);</span><br><span class="line">            re.insert(re.end(),rr.begin(),rr.end());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="二叉树的后序遍历---c-lintcode">二叉树的后序遍历 - C++ [lintcode]</h3><p><img src="2017-04-08_220852.png" alt="2017-04-08_220852.png"> http://www.lintcode.com/zh-cn/problem/binary-tree-postorder-traversal/ <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition of TreeNode:</span></span><br><span class="line"><span class="comment"> * class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> * public:</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left, *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *         this-&gt;val = val;</span></span><br><span class="line"><span class="comment"> *         this-&gt;left = this-&gt;right = NULL;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param root: The root of binary tree.</span></span><br><span class="line"><span class="comment">     * @return: Postorder in vector which contains node values.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode *root) &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> re;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ll = postorderTraversal(root-&gt;left);</span><br><span class="line">            re.insert(re.end(),ll.begin(),ll.end());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rr = postorderTraversal(root-&gt;right);</span><br><span class="line">            re.insert(re.end(),rr.begin(),rr.end());</span><br><span class="line">        &#125;</span><br><span class="line">        re.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="二叉树的最大深度---c-lintcode">二叉树的最大深度 - C++ [lintcode]</h3><p><img src="2017-04-08_220920.png" alt="2017-04-08_220920.png"> http://www.lintcode.com/zh-cn/problem/maximum-depth-of-binary-tree/ <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition of TreeNode:</span></span><br><span class="line"><span class="comment"> * class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> * public:</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left, *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *         this-&gt;val = val;</span></span><br><span class="line"><span class="comment"> *         this-&gt;left = this-&gt;right = NULL;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param root: The root of binary tree.</span></span><br><span class="line"><span class="comment">     * @return: An integer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxDL = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxDR = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            maxDL += maxDepth(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            maxDR += maxDepth(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(maxDL,maxDR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="二叉树的最小深度---c-lintcode">二叉树的最小深度 - C++ [lintcode]</h3><p><img src="2017-04-08_220950.png" alt="2017-04-08_220950.png"> http://www.lintcode.com/zh-cn/problem/minimum-depth-of-binary-tree/ <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition of TreeNode:</span></span><br><span class="line"><span class="comment"> * class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> * public:</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left, *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *         this-&gt;val = val;</span></span><br><span class="line"><span class="comment"> *         this-&gt;left = this-&gt;right = NULL;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param root: The root of binary tree.</span></span><br><span class="line"><span class="comment">     * @return: An integer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxDL = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxDR = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            maxDL += maxDepth(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            maxDR += maxDepth(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(maxDL,maxDR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="二叉树的层次遍历-ii---c-lintcode">二叉树的层次遍历 II - C++ [lintcode]</h3><p><img src="2017-04-08_221012.png" alt="2017-04-08_221012.png"> http://www.lintcode.com/zh-cn/problem/binary-tree-level-order-traversal-ii/ <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition of TreeNode:</span></span><br><span class="line"><span class="comment"> * class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> * public:</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left, *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *         this-&gt;val = val;</span></span><br><span class="line"><span class="comment"> *         this-&gt;left = this-&gt;right = NULL;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param root : The root of binary tree.</span></span><br><span class="line"><span class="comment">     * @return : buttom-up level order a list of lists of integer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode *root) &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; v1,v2;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        v1.push_back(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!v1.empty())&#123;</span><br><span class="line">            <span class="comment">// 遍历v1中的所有节点，将下一层节点保存在v2中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v1.size();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v1[i]-&gt;left)&#123;</span><br><span class="line">                    v2.push_back(v1[i]-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(v1[i]-&gt;right)&#123;</span><br><span class="line">                    v2.push_back(v1[i]-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">            <span class="comment">//打印v1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v1.size();i++)&#123;</span><br><span class="line">                tmp.push_back(v1[i]-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            result.insert(result.begin(),tmp);</span><br><span class="line">            swap(v1,v2);</span><br><span class="line">            v2.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="二叉树的锯齿形层次遍历---c-lintcode">二叉树的锯齿形层次遍历 - C++ [lintcode]</h3><p><img src="2017-04-08_221038.png" alt="2017-04-08_221038.png"> http://www.lintcode.com/zh-cn/problem/binary-tree-zigzag-level-order-traversal/ <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition of TreeNode:</span></span><br><span class="line"><span class="comment"> * class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> * public:</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left, *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *         this-&gt;val = val;</span></span><br><span class="line"><span class="comment"> *         this-&gt;left = this-&gt;right = NULL;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param root: The root of binary tree.</span></span><br><span class="line"><span class="comment">     * @return: A list of lists of integer include</span></span><br><span class="line"><span class="comment">     *          the zigzag level order traversal of its nodes' values</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; zigzagLevelOrder(TreeNode *root) &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; v1,v2;</span><br><span class="line">        v1.push_back(root);</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!v1.empty())&#123;</span><br><span class="line">            <span class="comment">//遍历v1中的节点，把v1中所有节点的下一级节点存储在v2中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v1.size();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v1[i]-&gt;left)&#123;</span><br><span class="line">                    v2.push_back(v1[i]-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(v1[i]-&gt;right)&#123;</span><br><span class="line">                    v2.push_back(v1[i]-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 打印v1中的节点,如果level 是奇数，则从左向又打印，</span></span><br><span class="line">            <span class="comment">// 如果level是偶数，则从右向左打印</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">if</span>(level % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=v1.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                    tmp.push_back(v1[i]-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(level % <span class="number">2</span> )&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v1.size();i++)&#123;</span><br><span class="line">                    tmp.push_back(v1[i]-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(tmp);</span><br><span class="line">            <span class="comment">// 更新该更新的数据</span></span><br><span class="line">            swap(v1,v2);</span><br><span class="line">            v2.clear();</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="用栈实现队列---c-lintcode">用栈实现队列 - C++ [lintcode]</h3><p><img src="2017-04-08_221207.png" alt="2017-04-08_221207.png"> http://www.lintcode.com/zh-cn/problem/implement-queue-by-two-stacks/ <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line"></span><br><span class="line">    MyQueue() &#123;</span><br><span class="line">        <span class="comment">// do intialization if necessary</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        stack1.push(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">if</span>(stack2.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack1.empty())&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.empty())&#123;</span><br><span class="line">                <span class="keyword">int</span> a = stack1.top();</span><br><span class="line">                stack1.pop();</span><br><span class="line">                stack2.push(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = stack2.top();</span><br><span class="line">        stack2.pop();</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">if</span>(stack2.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack1.empty())&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.empty())&#123;</span><br><span class="line">                <span class="keyword">int</span> a = stack1.top();</span><br><span class="line">                stack1.pop();</span><br><span class="line">                stack2.push(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = stack2.top();</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="线段树的构造---c-lintcode">线段树的构造 - C++ [lintcode]</h3><p><img src="2017-04-08_221303.png" alt="2017-04-08_221303.png"> http://www.lintcode.com/zh-cn/problem/segment-tree-build/ <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition of SegmentTreeNode:</span></span><br><span class="line"><span class="comment"> * class SegmentTreeNode &#123;</span></span><br><span class="line"><span class="comment"> * public:</span></span><br><span class="line"><span class="comment"> *     int start, end;</span></span><br><span class="line"><span class="comment"> *     SegmentTreeNode *left, *right;</span></span><br><span class="line"><span class="comment"> *     SegmentTreeNode(int start, int end) &#123;</span></span><br><span class="line"><span class="comment"> *         this-&gt;start = start, this-&gt;end = end;</span></span><br><span class="line"><span class="comment"> *         this-&gt;left = this-&gt;right = NULL;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *@param start, end: Denote an segment / interval</span></span><br><span class="line"><span class="comment">     *@return: The root of Segment Tree</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">SegmentTreeNode * <span class="title">build</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        SegmentTreeNode *node = <span class="keyword">new</span> SegmentTreeNode(start,end);</span><br><span class="line">        <span class="keyword">if</span>( start &lt; end ) &#123;</span><br><span class="line">            node-&gt;left = build(node-&gt;start,(node-&gt;start+node-&gt;end)/<span class="number">2</span>);</span><br><span class="line">            node-&gt;right = build((node-&gt;start+node-&gt;end)/<span class="number">2</span>+<span class="number">1</span>,node-&gt;end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="线段树的查询---c-lintcode">线段树的查询 - C++ [lintcode]</h3><p><img src="2017-04-08_221333.png" alt="2017-04-08_221333.png"> http://www.lintcode.com/zh-cn/problem/segment-tree-query/ <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition of SegmentTreeNode:</span></span><br><span class="line"><span class="comment"> * class SegmentTreeNode &#123;</span></span><br><span class="line"><span class="comment"> * public:</span></span><br><span class="line"><span class="comment"> *     int start, end, max;</span></span><br><span class="line"><span class="comment"> *     SegmentTreeNode *left, *right;</span></span><br><span class="line"><span class="comment"> *     SegmentTreeNode(int start, int end, int max) &#123;</span></span><br><span class="line"><span class="comment"> *         this-&gt;start = start;</span></span><br><span class="line"><span class="comment"> *         this-&gt;end = end;</span></span><br><span class="line"><span class="comment"> *         this-&gt;max = max;</span></span><br><span class="line"><span class="comment"> *         this-&gt;left = this-&gt;right = NULL;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *@param root, start, end: The root of segment tree and</span></span><br><span class="line"><span class="comment">     *                         an segment / interval</span></span><br><span class="line"><span class="comment">     *@return: The maximum number in the interval [start, end]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(SegmentTreeNode *root, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="comment">// 区间比根区间还大的情况</span></span><br><span class="line">        <span class="keyword">if</span>(start &lt;= root-&gt;start &amp;&amp; end &gt;= root-&gt;end)&#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果左边界已经大于等于又边界  或者  右边界已经大于等于左边界， 则不存在的这样的区域</span></span><br><span class="line">        <span class="comment">//返回不影响计算最大值的数字</span></span><br><span class="line">        <span class="keyword">if</span>(start&gt;root-&gt;end || end &lt; root-&gt;start)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ll = query(root-&gt;left,start,end);</span><br><span class="line">        <span class="keyword">int</span> rr = query(root-&gt;right,start,end);</span><br><span class="line">        <span class="keyword">return</span> max(ll,rr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="线段树查询-ii---c-lintcode">线段树查询 II - C++ [lintcode]</h3><p><img src="2017-04-08_221138.png" alt="2017-04-08_221138.png"> http://www.lintcode.com/zh-cn/problem/segment-tree-query-ii/ <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition of SegmentTreeNode:</span></span><br><span class="line"><span class="comment"> * class SegmentTreeNode &#123;</span></span><br><span class="line"><span class="comment"> * public:</span></span><br><span class="line"><span class="comment"> *     int start, end, count;</span></span><br><span class="line"><span class="comment"> *     SegmentTreeNode *left, *right;</span></span><br><span class="line"><span class="comment"> *     SegmentTreeNode(int start, int end, int count) &#123;</span></span><br><span class="line"><span class="comment"> *         this-&gt;start = start;</span></span><br><span class="line"><span class="comment"> *         this-&gt;end = end;</span></span><br><span class="line"><span class="comment"> *         this-&gt;count = count;</span></span><br><span class="line"><span class="comment"> *         this-&gt;left = this-&gt;right = NULL;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *@param root, start, end: The root of segment tree and</span></span><br><span class="line"><span class="comment">     *                         an segment / interval</span></span><br><span class="line"><span class="comment">     *@return: The count number in the interval [start, end]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(SegmentTreeNode *root, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">if</span>(!root||start&gt;end)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果数据非法就返回0，表示这个区间没有元素</span></span><br><span class="line">        <span class="keyword">if</span>(start&lt;=root-&gt;start&amp;&amp;end&gt;=root-&gt;end)</span><br><span class="line">            <span class="keyword">return</span> root-&gt;count;  <span class="comment">//如果给出的区间比根的区间还大，不用查找，直接返回根区间的元素个数</span></span><br><span class="line">        <span class="keyword">int</span> mid = (root-&gt;start + root-&gt;end)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;mid)</span><br><span class="line">             <span class="keyword">return</span> query(root-&gt;right,start,end);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(end&lt;mid+<span class="number">1</span>)</span><br><span class="line">             <span class="keyword">return</span> query(root-&gt;left,start,end);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果跨越分支，应该把两个分支的数据加在一起</span></span><br><span class="line">             <span class="keyword">return</span> query(root-&gt;left,start,mid)+query(root-&gt;right,mid+<span class="number">1</span>,end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="统计前面比自己小的数的个数---c-lintcode">统计前面比自己小的数的个数 - C++ [lintcode]</h3><p><img src="2017-04-08_221234.png" alt="2017-04-08_221234.png"> http://www.lintcode.com/zh-cn/problem/count-of-smaller-number-before-itself/ <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node(<span class="keyword">int</span> _start, <span class="keyword">int</span> _end) :</span><br><span class="line">            start(_start), end(_end), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>),</span><br><span class="line">            cnt(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start, end;</span><br><span class="line">    Node *left, *right;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * @param A: An integer array</span></span><br><span class="line"><span class="comment">      * @return: Count the number of element before this element 'ai' is</span></span><br><span class="line"><span class="comment">      *          smaller than it and return count number array</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countOfSmallerNumberII(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A) &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        Node *root = build(<span class="number">0</span>, <span class="number">20000</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = query(root, <span class="number">0</span>, A[i] - <span class="number">1</span>);</span><br><span class="line">            res.push_back(cnt);</span><br><span class="line">            modify(root, A[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">Node *<span class="title">build</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (start == end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(start, end);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Node *root = <span class="keyword">new</span> Node(start, end);</span><br><span class="line">        root-&gt;left = build(start, mid);</span><br><span class="line">        root-&gt;right = build(mid + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(Node *root, <span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;start == root-&gt;end &amp;&amp; root-&gt;start == idx)</span><br><span class="line">        &#123;</span><br><span class="line">            ++(root-&gt;cnt);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = root-&gt;start + ((root-&gt;end - root-&gt;start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (mid &gt;= idx)</span><br><span class="line">        &#123;</span><br><span class="line">            modify(root-&gt;left, idx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            modify(root-&gt;right, idx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root-&gt;cnt = root-&gt;left-&gt;cnt + (root-&gt;right ? root-&gt;right-&gt;cnt : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(Node *root, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;end &lt; start || root-&gt;start &gt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;start &gt;= start &amp;&amp; root-&gt;end &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;cnt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = root-&gt;start + ((root-&gt;end - root-&gt;start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (mid &gt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> query(root-&gt;left, start, end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mid &lt; start)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> query(root-&gt;right, start, end);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftRes = query(root-&gt;left, start, mid);</span><br><span class="line">        <span class="keyword">int</span> rightRes = query(root-&gt;right, mid + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leftRes + rightRes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="nowcoder">[nowcoder]</h2><h3 id="最小的k个数-c-nowcoder">最小的K个数 C++ [nowcoder]</h3><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=11047976 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; GetLeastNumbers_Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;(<span class="keyword">int</span>)input.size()) <span class="keyword">return</span> result;</span><br><span class="line">        sort(input.begin(),input.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            result.push_back(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="找出出现的次数超过数组长度的一半的数-c-nowcoder">找出出现的次数超过数组长度的一半的数 C++ [nowcoder]</h3><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=11047857 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(numbers.size() == <span class="number">1</span>) <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> card = numbers[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">1</span>;i&lt;numbers.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[i] == card)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            count--;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">                card = numbers[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;numbers.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[i] == card)&#123;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(numbers.size()/<span class="number">2</span> &lt; sum)&#123;</span><br><span class="line">        <span class="keyword">return</span>  card;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="找到第一个只出现一次的字符-c-nowcoder">找到第一个只出现一次的字符 C++ [nowcoder]</h3><p>在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置。如果字符串为空,返回-1 https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=11034739 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 统计每个字母的个数，只出现一次的第一个字母的位置</span></span><br><span class="line">        <span class="keyword">if</span>(str.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hash(<span class="number">256</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;str.size();i++)&#123;</span><br><span class="line">            hash[str[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 之所以这样顺序正确，是因为我们不是按照hash数组的顺序来遍历的</span></span><br><span class="line">        <span class="comment">//而是按照str[i]作为hash数组的下标来遍历的，这一点十分重要</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;str.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">1</span>==hash[str[i]])&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="找到第1500个丑数-c-nowcoder">找到第1500个丑数 C++ [nowcoder]</h3><p>把只包含素因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=11033314 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">7</span>)<span class="keyword">return</span> index;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(index);</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//开始的时候t2,t3,t5都指向开始的1，一旦出现被使用一次的情况，就加1，这样保证</span></span><br><span class="line">        <span class="comment">//不会重复比较，也不会漏掉</span></span><br><span class="line">        <span class="keyword">int</span> t2 = <span class="number">0</span>, t3 = <span class="number">0</span>, t5 = <span class="number">0</span>, i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; index; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            res[i] = min(res[t2] * <span class="number">2</span>, min(res[t3] * <span class="number">3</span>, res[t5] * <span class="number">5</span>));</span><br><span class="line">            <span class="keyword">if</span> (res[i] == res[t2] * <span class="number">2</span>)t2++;</span><br><span class="line">            <span class="keyword">if</span> (res[i] == res[t3] * <span class="number">3</span>)t3++;</span><br><span class="line">            <span class="keyword">if</span> (res[i] == res[t5] * <span class="number">5</span>)t5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[index - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="打印所有数字中最小的一个-c-nowcoder">打印所有数字中最小的一个 C++ [nowcoder]</h3><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=11021544 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NumBit</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    NumBit(<span class="keyword">int</span> n) : num(n) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> struct NumBit &amp; right)<span class="keyword">const</span>   <span class="comment">//重载&lt;运算符</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vtmp1;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="keyword">this</span>-&gt;num;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            b = n % <span class="number">10</span>;</span><br><span class="line">            vtmp1.insert(vtmp1.begin(),b);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vtmp2;</span><br><span class="line">        <span class="keyword">int</span> n2 = right.num;</span><br><span class="line">        <span class="keyword">int</span> b2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n2)&#123;</span><br><span class="line">            b2 = n2 % <span class="number">10</span>;</span><br><span class="line">            vtmp2.insert(vtmp2.begin(),b2);</span><br><span class="line">            n2 /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ilen = vtmp1.size();</span><br><span class="line">        <span class="keyword">int</span> jlen = vtmp2.size();</span><br><span class="line">        <span class="keyword">while</span>( i&lt;ilen || j&lt;jlen )&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;ilen &amp;&amp; j&lt;jlen &amp;&amp; vtmp1[i] &gt; vtmp2[j])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&lt;ilen &amp;&amp; j&lt;jlen &amp;&amp; vtmp1[i] &lt; vtmp2[j])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&lt;ilen &amp;&amp; j&lt;jlen &amp;&amp; vtmp1[i] == vtmp2[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==ilen)&#123;</span><br><span class="line">                <span class="keyword">if</span>(vtmp2[j] &gt; vtmp2[<span class="number">0</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(vtmp2[j] &lt; vtmp2[<span class="number">0</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == jlen)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j==jlen)&#123;</span><br><span class="line">                <span class="keyword">if</span>(vtmp1[i] &gt; vtmp1[<span class="number">0</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(vtmp1[i] &lt; vtmp1[<span class="number">0</span>]) <span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == ilen)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">Int_to_String</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">ostringstream</span> stream;</span><br><span class="line">        stream&lt;&lt;n;  <span class="comment">//n为int类型</span></span><br><span class="line">        <span class="keyword">return</span> stream.str();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解题思路： 构成最小的数字，其实质就是从最高位开始，每次都选择最小的数字作为最高位</span></span><br><span class="line">    <span class="comment">// 只需要对原来的数字按照下面的规则排序就可以做到</span></span><br><span class="line">    <span class="comment">// 把两个数字的最高位对齐，例如</span></span><br><span class="line">    <span class="comment">//  3332</span></span><br><span class="line">    <span class="comment">//  332</span></span><br><span class="line">    <span class="comment">// 从左向右比较，如果数字小的排在前面，如果数字相等，比较后面一位。如果其中一个数字没有了，</span></span><br><span class="line">    <span class="comment">// 那么比较另外一个剩下的数字与首数字的关系，如果大于首数字，则该数较大，如果小于该数字，则该数较小</span></span><br><span class="line">    <span class="comment">//如果相等，则指针后移，继续比较下一位，直到结束，如果直到结束都没有比较出大小，可以认为两个数一样大.</span></span><br><span class="line">    <span class="comment">//使用自定义的比较方法之后，直接使用multiset排序，然后拼接在一起就是结果</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">       <span class="built_in">string</span> re;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;NumBit&gt; s; <span class="comment">// 存放每个数字的各位数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.size();i++)&#123;</span><br><span class="line">            NumBit *tmp = <span class="keyword">new</span> NumBit(numbers[i]);</span><br><span class="line">            s.insert(s.end(),*tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            NumBit t = *s.begin();</span><br><span class="line">            re.append( Int_to_String(t.num));</span><br><span class="line">            s.erase(s.begin(),++s.begin());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每次选择最小的数字放在高位上</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="整数中1出现的次数-c-nowcoder">整数中1出现的次数 C++ [nowcoder]</h3><p>求出1<sub>13的整数中1出现的次数,并算出100</sub>1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。 https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=11014410 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//整体思路是分别计算当各位，十位，百位..为1的时候其他的位有多少中可能的情况</span></span><br><span class="line">        <span class="comment">//其实就是一个有限制条件的排列组合问题</span></span><br><span class="line">        <span class="keyword">float</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tb = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> tail = <span class="number">0</span>; <span class="comment">// 结尾的数字</span></span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            b = n % <span class="number">10</span>;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                tail = tb * <span class="built_in">pow</span>(<span class="number">10.0</span>,i<span class="number">-1</span>) + tail;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"=="</span>&lt;&lt;tail&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(b == <span class="number">0</span>)&#123;</span><br><span class="line">                sum += (n)*<span class="built_in">pow</span>(<span class="number">10.0</span>,i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( b == <span class="number">1</span>)&#123;</span><br><span class="line">                sum += (n)*<span class="built_in">pow</span>(<span class="number">10.0</span>,i) + tail + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum += (n+<span class="number">1</span>)*<span class="built_in">pow</span>(<span class="number">10.0</span>,i);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            tb = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="所有和为s的连续正数序列-c-nowcoder">所有和为S的连续正数序列 C++ [nowcoder]</h3><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=11007141 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m;</span><br><span class="line">    <span class="comment">// 连续和等于sum，有两种情况，奇数个和偶数个</span></span><br><span class="line">    <span class="comment">//如果奇数个连续的整数和等于sum, 那么位于中间的那个数一定可以被sum整除</span></span><br><span class="line">    <span class="comment">//如果偶数个连续的整数和等于sum,那么必然有最中间的两个数的和可以被sum整除</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="built_in">sqrt</span>(<span class="number">2</span>*sum);i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">if</span>(sum % i != <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// i表示有多少个连续的数字加和成sum,如果sum不能整除i，肯定不可能有解</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span> || i == <span class="number">1</span>)&#123; <span class="comment">//有偶数个数字</span></span><br><span class="line">            <span class="keyword">int</span> pair = sum / i ;</span><br><span class="line">            <span class="keyword">if</span>((pair - <span class="number">1</span> ) % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">int</span> pair1 = (pair - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">//找到了位于最中间位置的两个数字</span></span><br><span class="line">                <span class="keyword">int</span> pair2 = pair1 + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> start = pair1 - i + <span class="number">1</span>; <span class="comment">// 最开始的数字</span></span><br><span class="line">                <span class="keyword">int</span> end = pair2 + i <span class="number">-1</span> ; <span class="comment">//结尾的数字</span></span><br><span class="line">                <span class="keyword">if</span>(start &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> a = start;a&lt;=end;a++)&#123;</span><br><span class="line">                        v.push_back(a);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// 有奇数个数字</span></span><br><span class="line">            <span class="keyword">if</span>(sum % i == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">int</span> mid = sum / i ; <span class="comment">//最中间的数字</span></span><br><span class="line">                <span class="keyword">if</span>(mid - (i<span class="number">-1</span>)/<span class="number">2</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> a = mid - (i<span class="number">-1</span>)/<span class="number">2</span>;a&lt;=mid+(i<span class="number">-1</span>)/<span class="number">2</span>;a++)&#123;</span><br><span class="line">                        v.push_back(a);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!v.empty())&#123;</span><br><span class="line">            m[v[<span class="number">0</span>]] = v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e = m.begin();e!=m.end();e++)&#123;</span><br><span class="line">        result.push_back(e-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="循环删除整数数列问题-c-nowcoder">循环删除整数数列问题 C++ [nowcoder]</h3><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10998340 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; v(n,<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 记录数过的数字</span></span><br><span class="line">        <span class="keyword">int</span> deleted = <span class="number">0</span>; <span class="comment">//记录删除的数字</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i])&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count == m)&#123;</span><br><span class="line">                v[i] = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">                deleted++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span>( i &gt;= n)&#123;</span><br><span class="line">                i = i % n ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(deleted == n<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="图中是否包含某条路径-c-nowcoder">图中是否包含某条路径 C++ [nowcoder]</h3><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如[a b c e s f c s a d e e]是3*4矩阵，其包含字符串“bcced”的路径，但是矩阵中不包含“abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10995271 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>* matrix,<span class="keyword">char</span>* path,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">char</span>* str,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t=i*cols+j;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;=rows||j&lt;<span class="number">0</span>||j&gt;=cols||path[t]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(matrix[t]==str[k])&#123;</span><br><span class="line">            path[t]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(str[k+<span class="number">1</span>]==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(dfs(matrix,path,rows,cols,i+<span class="number">1</span>,j,str,k+<span class="number">1</span>)==<span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(dfs(matrix,path,rows,cols,i<span class="number">-1</span>,j,str,k+<span class="number">1</span>)==<span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(dfs(matrix,path,rows,cols,i,j+<span class="number">1</span>,str,k+<span class="number">1</span>)==<span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(dfs(matrix,path,rows,cols,i,j<span class="number">-1</span>,str,k+<span class="number">1</span>)==<span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            path[t]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix==<span class="literal">NULL</span>||str==<span class="literal">NULL</span>||str[<span class="number">0</span>]==<span class="number">0</span>||rows&lt;=<span class="number">0</span>||cols&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">char</span>* path=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100000</span>]();</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;rows;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;cols;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(matrix,path,rows,cols,i,j,str,<span class="number">0</span>)==<span class="literal">true</span>) &#123;<span class="keyword">delete</span>[] path;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] path;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="机器人能够达到多少个格子-c-nowcoder">机器人能够达到多少个格子 C++ [nowcoder]</h3><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10992716 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//求数位之和</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumS</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(a)&#123;</span><br><span class="line">            sum += a % <span class="number">10</span>;</span><br><span class="line">            a = a / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 暴力解法时间复杂度太高</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(rows == <span class="number">1</span>)&#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(sumS(j)&lt;=threshold)&#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cols == <span class="number">1</span>)&#123;</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(sumS(i)&lt;=threshold)&#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(sumS(i) + sumS(j) &lt;= threshold)&#123;</span><br><span class="line">                            count++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="找到只出现一次的数字-c-nowcoder">找到只出现一次的数字 C++ [nowcoder]</h3><p>Given an array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10769216 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = A[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            result ^= A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="查找数组中未出现的最小正整数-c-nowcoder">查找数组中未出现的最小正整数 C++ [nowcoder]</h3><p>请设计一个高效算法，查找数组中未出现的最小正整数。 给定一个整数数组A和数组的大小n，请返回数组中未出现的最小正整数。保证数组大小小于等于500。 测试样例： [-1,2,3,4],4 返回：1 https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10735711 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayMex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findArrayMex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> minValue;</span><br><span class="line">        <span class="keyword">int</span> intV = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            minValue = intV+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i]&gt;=intV)&#123;</span><br><span class="line">                    minValue = min(minValue,A[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(minValue != intV) <span class="keyword">return</span> intV;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">               intV++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="数组的单调和-c-nowcoder">数组的单调和 C++ [nowcoder]</h3><p>现定义数组单调和为所有元素i的f(i)值之和。这里的f(i)函数定义为元素i左边(不包括其自身)小于等于它的数字之和。请设计一个高效算法，计算数组的单调和。 给定一个数组A同时给定数组的大小n，请返回数组的单调和。保证数组大小小于等于500，同时保证单调和不会超过int范围。 测试样例： [1,3,5,2,4,6],6 返回：27</p><p>https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10733959</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonoSum</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calcMonoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">//暴力方法</span></span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[j]&lt;=A[i])&#123;</span><br><span class="line">                    sum+=A[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            total += sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="c是否是a和b的混编-c-nowcoder">C是否是A和B的混编 C++ [nowcoder]</h3><p>A、B和C。如果C包含且仅包含来自A和B的所有字符，而且在C中属于A的字符之间保持原来在A中的顺序，属于B的字符之间保持原来在B中的顺序，那么称C是A和B的混编。实现一个函数，判断C是否是A和B的混编。 给定三个字符串A,B和C，及他们的长度。请返回一个bool值，代表C是否是A和B的混编。保证三个串的长度均小于等于100。 测试样例： “ABC”,3,“12C”,3,“A12BCC”,6 返回：true https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10731304</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mixture</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">chkMixture</span><span class="params">(<span class="built_in">string</span> A, <span class="keyword">int</span> n, <span class="built_in">string</span> B, <span class="keyword">int</span> m, <span class="built_in">string</span> C, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果A+B的长度！= C的长度，肯定不能交错组成</span></span><br><span class="line">        <span class="keyword">if</span>(n+m!=v) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//用动态规划的方法做，开一个dp[n+1][m+1]的数组，</span></span><br><span class="line">        <span class="comment">//dp[i][j] 表示A[1...i-1] 和B[1...j-1] 能否交错组成C[i+j-1]</span></span><br><span class="line">        <span class="comment">//这里第一行和第一列都表示空串，下标是-1时表示是空串。</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m+<span class="number">1</span>,<span class="literal">false</span>));</span><br><span class="line">        <span class="comment">// 定义空串可以由空串交错组成</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//初始化第一列，就是B为空串的时候，C能否由A交错组成。注意题目要求相对顺序不能改变</span></span><br><span class="line">        <span class="comment">//所以如果A == C 就是true,否则后面的全部为false;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i<span class="number">-1</span>] == C[i<span class="number">-1</span>]) dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化第一行。就是A为空串的时候，C能否由B交错组成</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(B[j<span class="number">-1</span>] == C[j<span class="number">-1</span>]) dp[<span class="number">0</span>][j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp[i][j] 有以下两种情况</span></span><br><span class="line">        <span class="comment">// 1. A[i-1] == C[i+j-1] &amp;&amp; dp[i-1][j]</span></span><br><span class="line">        <span class="comment">// 2. B[j-1] == C[i+j-1] &amp;&amp; dp[i][j-1]</span></span><br><span class="line">        <span class="comment">//以上任何一个条件成立，就可以交错组成，否则就不能</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i<span class="number">-1</span>] == C[i+j<span class="number">-1</span>] &amp;&amp; dp[i<span class="number">-1</span>][j] ||</span><br><span class="line">                         B[j<span class="number">-1</span>] == C[i+j<span class="number">-1</span>] &amp;&amp; dp[i][j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="字符串交错组成-c-nowcoder">字符串交错组成 C++ [nowcoder]</h3><p>对于三个字符串A，B，C。我们称C由A和B交错组成当且仅当C包含且仅包含A，B中所有字符，且对应的顺序不改变。请编写一个高效算法，判断C串是否由A和B交错组成。 给定三个字符串A,B和C，及他们的长度。请返回一个bool值，代表C是否由A和B交错组成。保证三个串的长度均小于等于100。 测试样例： “ABC”,3,“12C”,3,“A12BCC”,6 返回：true</p><p>https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10730897</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mixture</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">chkMixture</span><span class="params">(<span class="built_in">string</span> A, <span class="keyword">int</span> n, <span class="built_in">string</span> B, <span class="keyword">int</span> m, <span class="built_in">string</span> C, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果A+B的长度！= C的长度，肯定不能交错组成</span></span><br><span class="line">        <span class="keyword">if</span>(n+m!=v) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//用动态规划的方法做，开一个dp[n+1][m+1]的数组，</span></span><br><span class="line">        <span class="comment">//dp[i][j] 表示A[1...i-1] 和B[1...j-1] 能否交错组成C[i+j-1]</span></span><br><span class="line">        <span class="comment">//这里第一行和第一列都表示空串，下标是-1时表示是空串。</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m+<span class="number">1</span>,<span class="literal">false</span>));</span><br><span class="line">        <span class="comment">// 定义空串可以由空串交错组成</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//初始化第一列，就是B为空串的时候，C能否由A交错组成。注意题目要求相对顺序不能改变</span></span><br><span class="line">        <span class="comment">//所以如果A == C 就是true,否则后面的全部为false;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i<span class="number">-1</span>] == C[i<span class="number">-1</span>]) dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化第一行。就是A为空串的时候，C能否由B交错组成</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(B[j<span class="number">-1</span>] == C[j<span class="number">-1</span>]) dp[<span class="number">0</span>][j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp[i][j] 有以下两种情况</span></span><br><span class="line">        <span class="comment">// 1. A[i-1] == C[i+j-1] &amp;&amp; dp[i-1][j]</span></span><br><span class="line">        <span class="comment">// 2. B[j-1] == C[i+j-1] &amp;&amp; dp[i][j-1]</span></span><br><span class="line">        <span class="comment">//以上任何一个条件成立，就可以交错组成，否则就不能</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i<span class="number">-1</span>] == C[i+j<span class="number">-1</span>] &amp;&amp; dp[i<span class="number">-1</span>][j] ||</span><br><span class="line">                         B[j<span class="number">-1</span>] == C[i+j<span class="number">-1</span>] &amp;&amp; dp[i][j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最小编辑代价-c-nowcoder">最小编辑代价 C++ [nowcoder]</h3><p>对于两个字符串A和B，我们需要进行插入、删除和修改操作将A串变为B串，定义c0，c1，c2分别为三种操作的代价，请设计一个高效算法，求出将A串变为B串所需要的最少代价。 给定两个字符串A和B，及它们的长度和三种操作代价，请返回将A串变为B串所需要的最小代价。保证两串长度均小于等于300，且三种代价值均小于等于100。 测试样例： “abc”,3,“adc”,3,5,3,100 返回：8</p><p>https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10728936</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinCost</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinCost</span><span class="params">(<span class="built_in">string</span> A, <span class="keyword">int</span> n, <span class="built_in">string</span> B, <span class="keyword">int</span> m, <span class="keyword">int</span> c0, <span class="keyword">int</span> c1, <span class="keyword">int</span> c2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(c2 &gt;= c0 + c1) c2 = c0 + c1 ;</span><br><span class="line">        <span class="comment">//动态规划，开一个dp[n+1][m+1]的数组，dp[i][j] 表示把A[i-1]编辑成B[j-1]的最小编辑代价；</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="comment">//初始化第一列，即编辑成空串的代价，想要编辑成空串，代价就是把字符都删除。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i * c1 ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化第一行，将空串编辑成对应字符串的方法就是插入字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j * c0 ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//求解dp[i][j]</span></span><br><span class="line">        <span class="comment">//dp[i][j]有三种情况； A[i-1]编辑成B[j-1]然后替换最后一个字符，需要注意的是，如果最后一个字符相同，则不用替换，所以为dp[i-1][j-1]+c2 或者 dp[i-1][j-1]</span></span><br><span class="line">        <span class="comment">//将A[i]编辑成B[i-1]然后插入B[i] dp[i][j-1]+c0</span></span><br><span class="line">        <span class="comment">//将A[i]删除一个字符得到A[i-1]  然后将A[i-1]编辑成B[j]  dp[i-1][j] + c1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                dp[i][j] = min(dp[i<span class="number">-1</span>][j] + c1,dp[i][j<span class="number">-1</span>] + c0);</span><br><span class="line">                <span class="keyword">if</span>(A[i<span class="number">-1</span>] == B[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j] = min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>],dp[i][j]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = min(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+c2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最大间隔-c-nowcoder">最大间隔 C++ [nowcoder]</h3><p>给定一个递增序列，<code>a1 &lt;a2 &lt;...&lt;an</code> 。定义这个序列的最大间隔为<code>d=max{ai+1 - ai }(1≤i&lt;n)</code>,现在要从<code>a2 ,a3 ..an-1</code>中删除一个元素。问剩余序列的最大间隔最小是多少？ https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10725149 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">2</span>) <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(n,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">               <span class="built_in">cin</span>&gt;&gt;v[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> maxV = v[<span class="number">1</span>] - v[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">//统计原来的最大间隔</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">                maxV = max(maxV,v[i+<span class="number">1</span>]-v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计算删除一个元素之后的最大间隔</span></span><br><span class="line">            <span class="keyword">int</span> minV = v[<span class="number">2</span>] - v[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">1</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">               minV = min(minV,v[i+<span class="number">1</span>]-v[i<span class="number">-1</span>]) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(minV &lt;= maxV)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;maxV&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(minV &gt; maxV)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;minV&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="搬圆桌-c-nowcoder">搬圆桌 c++ [nowcoder]</h3><p>现在有一张半径为r的圆桌，其中心位于(x,y)，现在他想把圆桌的中心移到(x1,y1)。每次移动一步，都必须在圆桌边缘固定一个点然后将圆桌绕这个点旋转。问最少需要移动几步。</p><p>https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10724077</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r, x, y, x1, y1;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;r&gt;&gt;x&gt;&gt;y&gt;&gt;x1&gt;&gt;y1)&#123;</span><br><span class="line">           <span class="keyword">double</span> distance = <span class="built_in">sqrt</span>((<span class="keyword">double</span>)(x-x1) * (x-x1) + (<span class="keyword">double</span>)(y-y1) * (y-y1));</span><br><span class="line">        <span class="comment">//  上取整</span></span><br><span class="line">        <span class="keyword">int</span> step = (<span class="keyword">int</span>)<span class="built_in">ceil</span>(distance / (<span class="number">2</span>*r));</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; step &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="裁减网格纸-c-nowcoder">裁减网格纸 C++ [nowcoder]</h3><p>度度熊有一张网格纸，但是纸上有一些点过的点，每个点都在网格点上，若把网格看成一个坐标轴平行于网格线的坐标系的话，每个点可以用一对整数x，y来表示。度度熊必须沿着网格线画一个正方形，使所有点在正方形的内部或者边界。然后把这个正方形剪下来。问剪掉正方形的最小面积是多少。 https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10721856</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;v[i][<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;v[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x_min=v[<span class="number">0</span>][<span class="number">0</span>]; <span class="keyword">int</span> x_max=v[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> y_min=v[<span class="number">0</span>][<span class="number">1</span>]; <span class="keyword">int</span> y_max=v[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            x_min = min(x_min,v[i][<span class="number">0</span>]);</span><br><span class="line">            x_max = max(x_max,v[i][<span class="number">0</span>]);</span><br><span class="line">            y_min = min(y_min,v[i][<span class="number">1</span>]);</span><br><span class="line">            y_max = max(y_max,v[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = x_max - x_min;</span><br><span class="line">        <span class="keyword">int</span> y = y_max - y_min;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;y)&#123;<span class="built_in">cout</span>&lt;&lt;x*x&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=y)&#123;<span class="built_in">cout</span>&lt;&lt;y*y&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="罪犯转移-c-nowcoder">罪犯转移 C++ [nowcoder]</h3><p>C市现在要转移一批罪犯到D市，C市有n名罪犯，按照入狱时间有顺序，另外每个罪犯有一个罪行值，值越大罪越重。现在为了方便管理，市长决定转移入狱时间连续的c名犯人，同时要求转移犯人的罪行值之和不超过t，问有多少种选择的方式？</p><p>https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10720643</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> n; <span class="keyword">int</span> t; <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;t&gt;&gt;c)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; z(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;z[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;c;i++)&#123;</span><br><span class="line">            sum += z[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;n-c+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;=t)&#123;count++;&#125;</span><br><span class="line">            sum = sum - z[i] + z[i+c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;count&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="首个重复字符-c-nowcoder">首个重复字符 C++ [nowcoder]</h3><p>对于一个字符串，请设计一个高效算法，找到第一次重复出现的字符。 给定一个字符串(不一定全为字母)A及它的长度n。请返回第一个重复出现的字符。保证字符串中有重复字符，字符串的长度小于等于500。 测试样例： “qywyer23tdd”,11 返回：y</p><p>https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10689361 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstRepeat</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findFirstRepeat</span><span class="params">(<span class="built_in">string</span> A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.size();i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(m[A[i]]!=<span class="number">0</span>) <span class="keyword">return</span> A[i];</span><br><span class="line">           <span class="keyword">else</span> m[A[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="棋子翻转">棋子翻转</h3><p>在4x4的棋盘上摆满了黑白棋子，黑白两色的位置和数目随机其中左上角坐标为(1,1),右下角坐标为(4,4),现在依次有一些翻转操作，要对一些给定支点坐标为中心的上下左右四个棋子的颜色进行翻转，请计算出翻转后的棋盘颜色。 给定两个数组A和f,分别为初始棋盘和翻转位置。其中翻转位置共有3个。请返回翻转后的棋盘。 测试样例： [[0,0,1,1],[1,0,1,0],[0,1,1,0],[0,0,1,0]],[[2,2],[3,3],[4,4]] 返回：[[0,1,1,1],[0,0,1,0],[0,1,1,0],[0,0,1,0]]</p><p>https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10681526</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flip</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; flipChess(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; A, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; f) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// f.size() == 3</span></span><br><span class="line">        <span class="keyword">auto</span> cow = A.size();</span><br><span class="line">        <span class="keyword">auto</span> col = A.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;f.size();i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> x = f[i][<span class="number">0</span>]<span class="number">-1</span>; <span class="comment">//转换成程序中常用的以0开始的坐标</span></span><br><span class="line">           <span class="keyword">int</span> y = f[i][<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(x+<span class="number">1</span>&lt;=cow<span class="number">-1</span>)&#123; A[x+<span class="number">1</span>][y] = <span class="number">1</span>-A[x+<span class="number">1</span>][y];&#125;</span><br><span class="line">            <span class="keyword">if</span>(x<span class="number">-1</span>&gt;=<span class="number">0</span>)&#123;A[x<span class="number">-1</span>][y] = <span class="number">1</span>- A[x<span class="number">-1</span>][y];&#125;</span><br><span class="line">            <span class="keyword">if</span>(y<span class="number">-1</span>&gt;=<span class="number">0</span>)&#123;A[x][y<span class="number">-1</span>] = <span class="number">1</span>-A[x][y<span class="number">-1</span>];&#125;</span><br><span class="line">            <span class="keyword">if</span>(y+<span class="number">1</span>&lt;=col<span class="number">-1</span>)&#123;A[x][y+<span class="number">1</span>] = <span class="number">1</span>-A[x][y+<span class="number">1</span>];&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最大差值-c-nowcoder">最大差值 C++ [nowcoder]</h3><p>有一个长为n的数组A，求满足0≤a≤b<n的a[b]-a[a]的最大值。 6879987="" 给定数组a及它的大小n，请返回最大差值。="" 测试样例：="" [10,5],2="" 返回：0="" https:="" www.nowcoder.com="" profile="" codebookdetail?submissionid="10680737" <figure="" class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LongestDistance</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDis</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 暴力方法，计算每一个可能的值，返回其中最大的，自己与自己的可以不计算，都是0</span></span><br><span class="line">        <span class="comment">//时间复杂度O(n^2)</span></span><br><span class="line">        <span class="keyword">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//for(int i=0;i&lt;=n-1;i++)&#123;</span></span><br><span class="line">           <span class="comment">// for(int j=i+1;j&lt;=n-1;j++)&#123;</span></span><br><span class="line">           <span class="comment">//     maxValue = max(maxValue,A[j]-A[i]);</span></span><br><span class="line">           <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//但是暴力方法时间复杂度太高了，这样的题还有优化的解法</span></span><br><span class="line">        <span class="comment">//动态规划，开一个和A一样的数组dp,dp[i]表示当a = A[i]的时候最大差值是多少。</span></span><br><span class="line">        <span class="comment">//当i=n-1时，最大差值为0；当i为0 -- n-2时， dp[i] = max( dp[i+1] + A[i+1] - A[i], 0);</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n,<span class="number">0</span>);</span><br><span class="line">        maxValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            dp[i] = max(dp[i+<span class="number">1</span>] + A[i+<span class="number">1</span>] - A[i],<span class="number">0</span>);</span><br><span class="line">            maxValue = max(maxValue,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回dp中的最大值</span></span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></n的a[b]-a[a]的最大值。></p><h3 id="直方图内最大矩形-c-nowcoder">直方图内最大矩形 C++ [nowcoder]</h3><p>有一个直方图，用一个整数数组表示，其中每列的宽度为1，求所给直方图包含的最大矩形面积。比如，对于直方图[2,7,9,4],它所包含的最大矩形的面积为14(即[7,9]包涵的7x2的矩形)。 给定一个直方图A及它的总宽度n，请返回最大矩形面积。保证直方图宽度小于等于500。保证结果在int范围内。 测试样例： [2,7,9,4,1],5 返回：14</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxInnerRec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对于A中的每一个数字，向前和向后分别搜索，直到找到比它小的数字，计算以</span></span><br><span class="line">        <span class="comment">//当前数字为中心的面积。</span></span><br><span class="line">        <span class="comment">//每次都这样循环，记录其中的最大值返回</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&gt;=<span class="number">0</span> &amp;&amp; A[left]&gt;= A[i])&#123;</span><br><span class="line">                left--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(right&lt;=n<span class="number">-1</span> &amp;&amp; A[right]&gt;=A[i])&#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> area = (right-left<span class="number">-1</span>)*A[i];</span><br><span class="line">            result = max(result,area);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="之字形打印矩阵-c-nowcoder">之字形打印矩阵 C++ [nowcoder]</h3><p>对于一个矩阵，请设计一个算法，将元素按“之”字形打印。具体见样例。 给定一个整数矩阵mat，以及他的维数nxm，请返回一个数组，其中元素依次为打印的数字。 测试样例： [[1,2,3],[4,5,6],[7,8,9],[10,11,12]],4,3 返回：[1,2,3,6,5,4,7,8,9,12,11,10]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; mat, <span class="keyword">int</span> n, <span class="keyword">int</span> m) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">              j = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">while</span>(j&lt;m)&#123;</span><br><span class="line">                  result.push_back(mat[i][j]);</span><br><span class="line">                  j++;</span><br><span class="line">              &#125;</span><br><span class="line">           &#125;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                j = m<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    result.push_back(mat[i][j]);</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="相邻最大差值-c-nowcoder">相邻最大差值 c++ [nowcoder]</h3><p>请设计一个复杂度为O(n)的算法，计算一个未排序数组中排序后相邻元素的最大差值。 给定一个整数数组A和数组的大小n，请返回最大差值。保证数组元素个数大于等于2小于等于500。 测试样例： [9,3,1,10],4 返回：6</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxDivision</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxDivision</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> maxValue = A[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> minValue = A[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//找到最大值和最小值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            maxValue = max(maxValue,A[i]);</span><br><span class="line">            minValue = min(minValue,A[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//生成最大值-最小值+1个桶，A中的数字减去最小值放在对应的桶中，</span></span><br><span class="line">        <span class="comment">//这样，最小值放在第0个桶中，最大值放在最后一个桶中。</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t(maxValue-minValue+<span class="number">1</span>,minValue<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            t[A[i]-minValue] = A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计连续的空桶的数量，这就是最后要的结果</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.size();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t[i] == minValue<span class="number">-1</span>)&#123;</span><br><span class="line">                tmp++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result = max(tmp,result);</span><br><span class="line">                tmp = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一次循环，找到了最大值和最小值</span></span><br><span class="line">        <span class="comment">//第二次循环，将n个数字放到了对应的桶中</span></span><br><span class="line">        <span class="comment">//第三次循环，统计空桶的个数，注意这里循环次数可能显著高于N，如果最大值和最小值相差很大的话。 所以该算法可能尚不满足题目要求的O（N）的复杂度</span></span><br><span class="line">        <span class="keyword">return</span> result+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二分查找-c-nowcoder">二分查找 C++ [nowcoder]</h3><p>对于一个有序数组，我们通常采用二分查找的方式来定位某一元素，请编写二分查找的算法，在数组中查找指定元素。 给定一个整数数组A及它的大小n，同时给定要查找的元素val，请返回它在数组中的位置(从0开始)，若不存在该元素，返回-1。若该元素出现多次，请返回第一次出现的位置。 测试样例： [1,3,5,7,9],5,3 返回：1</p><p>https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10607745</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPos</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="keyword">int</span> n, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">size_t</span> left = <span class="number">0</span>; <span class="keyword">size_t</span> right = n - <span class="number">1</span>; <span class="keyword">size_t</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            mid = (left + right) / <span class="number">2</span> ;</span><br><span class="line">            <span class="keyword">if</span>(A[mid] == val)&#123;</span><br><span class="line">                <span class="comment">// 查找前面是否有相同的元素</span></span><br><span class="line">                <span class="keyword">size_t</span> tp = mid;</span><br><span class="line">                <span class="keyword">while</span>(A[tp] == val)&#123;</span><br><span class="line">                    tp--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> tp+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(A[mid] &gt; val)&#123;</span><br><span class="line">                right = mid <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(A[mid] &lt; val)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最高分是多少">最高分是多少</h3><p>老师想知道从某某同学当中，分数最高的是多少，现在请你编程模拟老师的询问。当然，老师有时候需要更新某位同学的成绩. https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10595364 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">        v.push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> commond;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;commond;</span><br><span class="line">        <span class="keyword">if</span>(commond == <span class="string">'Q'</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> start; <span class="keyword">int</span> end;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;start;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;end;</span><br><span class="line">            <span class="keyword">if</span>(start &gt; end )&#123;</span><br><span class="line">                <span class="keyword">int</span> pp = start;</span><br><span class="line">                start = end;</span><br><span class="line">                end = pp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> it = max_element(v.begin()+start<span class="number">-1</span>,v.begin()+end);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(commond == <span class="string">'U'</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> index; <span class="keyword">int</span> value;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;index;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;value;</span><br><span class="line">            v[index<span class="number">-1</span>] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="从上往下打印二叉树">从上往下打印二叉树</h3><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。 https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10591248 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; PrintFromTopToBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">deque</span>&lt;TreeNode*&gt; tmp;</span><br><span class="line">        tmp.push_back(root);</span><br><span class="line">        <span class="keyword">while</span>( !tmp.empty() )&#123;</span><br><span class="line">            result.push_back( tmp.front()-&gt;val );</span><br><span class="line">            TreeNode* pNode = tmp.front();</span><br><span class="line">            tmp.pop_front();</span><br><span class="line">            <span class="keyword">if</span>(pNode-&gt;left)&#123;</span><br><span class="line">                tmp.push_back(pNode-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pNode-&gt;right)&#123;</span><br><span class="line">                tmp.push_back(pNode-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="顺时针打印矩阵-c-nowcoder">顺时针打印矩阵 C++ [nowcoder]</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10572756 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printEdge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v,<span class="keyword">int</span> li,<span class="keyword">int</span> lj,<span class="keyword">int</span> ri,<span class="keyword">int</span> rj,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;re)&#123;</span><br><span class="line">    <span class="keyword">if</span>(li == ri)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=lj;j&lt;=rj;j++)&#123;</span><br><span class="line">            re.push_back(v[li][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(lj == rj)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=li;i&lt;=ri;i++)&#123;</span><br><span class="line">            re.push_back(v[i][lj]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i=li;</span><br><span class="line">    <span class="keyword">int</span> j=lj;</span><br><span class="line">    <span class="keyword">while</span>(i==li &amp;&amp; j&lt;=rj)&#123;</span><br><span class="line">        re.push_back(v[i][j]);</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    j--;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">while</span>(j==rj &amp;&amp; i&lt;=ri)&#123;</span><br><span class="line">        re.push_back(v[i][j]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    i--;</span><br><span class="line">    j--;</span><br><span class="line">    <span class="keyword">while</span>(i==ri &amp;&amp; j&gt;=lj)&#123;</span><br><span class="line">        re.push_back(v[i][j]);</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    j++;</span><br><span class="line">    i--;</span><br><span class="line">    <span class="keyword">while</span>(j == lj &amp;&amp; i&gt;li)&#123;</span><br><span class="line">        re.push_back(v[i][j]);</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span>(matrix.empty())&#123; <span class="keyword">return</span> result;&#125;</span><br><span class="line">    <span class="keyword">auto</span> cow = matrix.size();</span><br><span class="line">    <span class="keyword">auto</span> col = matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">int</span> li=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lj=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ri=cow<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> rj=col<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(li&lt;=ri &amp;&amp; lj &lt;= rj)&#123;</span><br><span class="line">        printEdge(matrix,li,lj,ri,rj,result);</span><br><span class="line">        li++;</span><br><span class="line">        lj++;</span><br><span class="line">        ri--;</span><br><span class="line">        rj--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="树的子结构-c-nowcoder">树的子结构 C++ [nowcoder]</h3><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><p>https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10561636</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot1||!pRoot2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> falg=help(pRoot1,pRoot2);</span><br><span class="line">        <span class="keyword">if</span>(!falg)&#123;</span><br><span class="line">            falg=help(pRoot1-&gt;left,pRoot2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!falg)&#123;</span><br><span class="line">            falg=help(pRoot1-&gt;right,pRoot2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> falg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">help</span><span class="params">(TreeNode* p1,TreeNode* p2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p2==<span class="literal">NULL</span>)&#123;<span class="comment">//一定先</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p1==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p1-&gt;val!=p2-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> help(p1-&gt;left,p2-&gt;left)&amp;&amp;help(p1-&gt;right,p2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉树的镜像-c-nowcoder">二叉树的镜像 C++ [nowcoder]</h3><p>操作给定的二叉树，将其变换为源二叉树的镜像。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode *pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* tmp = pRoot-&gt;left;</span><br><span class="line">        pRoot-&gt;left= pRoot-&gt;right;</span><br><span class="line">        pRoot-&gt;right = tmp;</span><br><span class="line">        Mirror(pRoot-&gt;left);</span><br><span class="line">        Mirror(pRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="合并两个排序的链表-c-nowcoder">合并两个排序的链表 C++ [nowcoder]</h3><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10559603 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> pHead2;</span><br><span class="line">        <span class="keyword">if</span>(pHead2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> pHead1;</span><br><span class="line">        <span class="keyword">if</span>(pHead1-&gt;val &lt;= pHead2-&gt;val)&#123;</span><br><span class="line">            pHead1-&gt;next = Merge(pHead1-&gt;next,pHead2);</span><br><span class="line">            <span class="keyword">return</span> pHead1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pHead2-&gt;next = Merge(pHead1,pHead2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> pHead2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="调整数组顺序使奇数位于偶数前面-c-nowcoder">调整数组顺序使奇数位于偶数前面 C++ [nowcoder]</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10556963 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ji_index = <span class="number">-1</span>; <span class="comment">// 记录奇数的个数</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="built_in">array</span>.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>( <span class="built_in">array</span>[i]%<span class="number">2</span> == <span class="number">1</span> )&#123;</span><br><span class="line">                tmp = <span class="built_in">array</span>[i];</span><br><span class="line">                <span class="keyword">int</span> j = i<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(j&gt;ji_index)&#123;</span><br><span class="line">                    <span class="built_in">array</span>[j+<span class="number">1</span>] = <span class="built_in">array</span>[j];</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ji_index++;</span><br><span class="line">                <span class="built_in">array</span>[ji_index] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="滑动窗口的最大值-c-nowcoder">滑动窗口的最大值 C++ [nowcoder]</h3><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10555019 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxInWindows(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(num.empty() || num.size() &lt; size) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">1</span>) <span class="keyword">return</span> num;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; win;</span><br><span class="line">        win.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;num.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[win.back()] &gt;= num[i])&#123;</span><br><span class="line">                win.push_back(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!win.empty() &amp;&amp; num[win.back()] &lt; num[i])&#123;</span><br><span class="line">                    win.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">                win.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( i-win.front() == size)&#123;</span><br><span class="line">                win.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=size<span class="number">-1</span>)&#123;</span><br><span class="line">                result.push_back(num[win.front()]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="和为s的两个数字-c-nowcoder">和为S的两个数字 C++ [nowcoder]</h3><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10523746 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; FindNumbersWithSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>,<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>.empty()) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="built_in">array</span>.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i] + <span class="built_in">array</span>[j] &gt; sum)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[i] + <span class="built_in">array</span>[j] &lt; sum)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[i] + <span class="built_in">array</span>[j] == sum)&#123;</span><br><span class="line">                result.push_back(<span class="built_in">array</span>[i]);</span><br><span class="line">                result.push_back(<span class="built_in">array</span>[j]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="链表中环的入口结点">链表中环的入口结点</h3><p>一个链表中包含环，请找出该链表的环的入口结点。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pHead == <span class="literal">nullptr</span> || pHead-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(pHead-&gt;next == pHead) <span class="keyword">return</span> pHead;</span><br><span class="line">        ListNode* a = pHead;</span><br><span class="line">        ListNode* b = pHead;</span><br><span class="line">        <span class="keyword">while</span>(a!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            a = a-&gt;next-&gt;next;</span><br><span class="line">            b = b-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>( a == b)&#123;</span><br><span class="line">               a = pHead;</span><br><span class="line">               <span class="keyword">while</span>(a!=b)&#123;</span><br><span class="line">                   a = a-&gt;next;</span><br><span class="line">                   b = b-&gt;next;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(a==b)&#123;</span><br><span class="line">                   <span class="keyword">return</span> a;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="构建乘积数组">构建乘积数组</h3><p><img src="2017-04-11_102510.png" alt="2017-04-11_102510.png"> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; multiply(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(A.size(),<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 一般的方法时间复杂度是O(n^2), 预处理一下数组，可以将时间复杂度降低至O（n）</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(A.size(),<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(A.size(),<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;A.size();i++)&#123;</span><br><span class="line">            left[i] = left[i<span class="number">-1</span>] * A[i<span class="number">-1</span>];</span><br><span class="line">            right[i] = right[i<span class="number">-1</span>] * A[A.size()-i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.size();i++)&#123;</span><br><span class="line">            v[i] = left[i] * right[A.size()<span class="number">-1</span>-i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="数组中重复的数字">数组中重复的数字</h3><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者3。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//        numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//        length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//        duplication: (Output) the duplicated number in the array number</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(length,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] &gt;= length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (v[ numbers[i] ] == <span class="number">0</span> ) v[ numbers[i] ] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                *duplication = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="不用加减乘除做加法">不用加减乘除做加法</h3><p>写一个函数，求两个整数之和，要求在函数体内不得使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">```c</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Add(int num1, int num2)</span><br><span class="line">    &#123;</span><br><span class="line">        int sum = num1;</span><br><span class="line">        while(num2!=0)&#123;</span><br><span class="line">            sum = num1 ^num2;</span><br><span class="line">            num2 = (num1 &amp; num2)&lt;&lt;1;</span><br><span class="line">            num1 = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="求123n">求1+2+3+…+n</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = n;</span><br><span class="line">        <span class="keyword">bool</span> ans = (n&gt;<span class="number">0</span>) &amp;&amp; ((sum+=Sum_Solution(n<span class="number">-1</span>))&gt;<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="栈的压入弹出序列">栈的压入、弹出序列</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsPopOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pushV,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popV)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushV.size() != popV.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">        <span class="comment">//找到第一个相同的元素</span></span><br><span class="line">        <span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pushV[i] != popV[<span class="number">0</span>] &amp;&amp; i&lt;pushV.size())&#123;</span><br><span class="line">            s1.push(pushV[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        s1.push(pushV[i]); <span class="comment">//此时是s1栈顶和popV的第一个元素相同；</span></span><br><span class="line">        i++;<span class="comment">//i指向下一元素；</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> j=<span class="number">0</span>;j&lt;=popV.size();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( j&lt;popV.size() &amp;&amp; popV[j] == s1.top() )&#123;</span><br><span class="line">               s1.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&lt;pushV.size())&#123;</span><br><span class="line">                s1.push(pushV[i]);</span><br><span class="line">                j--;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( j== popV.size() &amp;&amp; s1.empty())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="包含min函数的栈">包含min函数的栈</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; minV;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        data.push(value);</span><br><span class="line">        <span class="keyword">if</span>(minV.empty() || value &lt;= minV.top())&#123;minV.push(value);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> top = data.top();</span><br><span class="line">        data.pop();</span><br><span class="line">        <span class="keyword">if</span>(top == minV.top())&#123;</span><br><span class="line">            minV.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> data.top();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minV.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="反转链表">反转链表</h3><p>输入一个链表，反转链表后，输出链表的所有元素。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* t = pHead;</span><br><span class="line">        ListNode* next = pHead;</span><br><span class="line">        <span class="keyword">while</span>(t!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            next = t-&gt;next;</span><br><span class="line">            t-&gt;next = pre;</span><br><span class="line">            pre = t;</span><br><span class="line">            t = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="链表中倒数第k个结点">链表中倒数第k个结点</h3><p>输入一个链表，输出该链表中倒数第k个结点。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pListHead, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先获取链表的长度</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        ListNode* temp =  pListHead;</span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;len)&#123;<span class="keyword">return</span> <span class="literal">nullptr</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(k==len)&#123;<span class="keyword">return</span> pListHead;&#125;</span><br><span class="line">        temp = pListHead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-k;i++)&#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">添加笔记</span><br></pre></td></tr></table></figure></p><h3 id="数值的整数次方">数值的整数次方</h3><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(exponent &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;exponent;i++)&#123;</span><br><span class="line">                sum *= base;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;-exponent;i++)&#123;</span><br><span class="line">                sum *= base;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span> / sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="二进制中1的个数">二进制中1的个数</h3><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">             count++;</span><br><span class="line">             n = n&amp;(n<span class="number">-1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> count;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="矩形覆盖">矩形覆盖</h3><p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(number == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(number,<span class="number">0</span>);</span><br><span class="line">        v[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        v[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size()<span class="number">-2</span>;i++)&#123;</span><br><span class="line">            v[i+<span class="number">2</span>] = v[i+<span class="number">1</span>] + v[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v[v.size() <span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="变态跳台阶">变态跳台阶</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(number == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2.0</span>,number<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="跳台阶">跳台阶</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(number==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(number,<span class="number">0</span>);</span><br><span class="line">        v[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        v[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size()<span class="number">-2</span>;i++)&#123;</span><br><span class="line">            v[i+<span class="number">2</span>] = v[i+<span class="number">1</span>] + v[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v[v.size()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="斐波那契数列">斐波那契数列</h3><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f(n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-2</span>;i++)&#123;</span><br><span class="line">            f[i+<span class="number">2</span>] = f[i+<span class="number">1</span>] + f[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="旋转数组的最小数字">旋转数组的最小数字</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rotateArray.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rotateArray.size();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(rotateArray[i]&gt;rotateArray[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> rotateArray[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rotateArray[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="用两个栈实现队列">用两个栈实现队列</h3><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.empty())&#123;</span><br><span class="line">               stack2.push(stack1.top());</span><br><span class="line">               stack1.pop();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">                    <span class="keyword">int</span> topValue = stack2.top();</span><br><span class="line">            stack2.pop();</span><br><span class="line">            <span class="keyword">return</span> topValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="重建二叉树">重建二叉树</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10499929</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(pre.empty() | vin.empty())&#123;<span class="keyword">return</span> <span class="literal">nullptr</span>;&#125;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);<span class="comment">// 先建立根节点</span></span><br><span class="line">        <span class="keyword">int</span> len = pre.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;vin.size();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vin[i] == pre[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="comment">// 找到了中序遍历的根节点，则左面的全部是左子树，右面的全部是右子树。</span></span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left_pre(i,<span class="number">0</span>);</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left_vin(i,<span class="number">0</span>);</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right_pre(len<span class="number">-1</span>-i,<span class="number">0</span>);</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right_vin(len<span class="number">-1</span>-i,<span class="number">0</span>);</span><br><span class="line">                copy(vin.begin(),vin.begin()+i,left_vin.begin());</span><br><span class="line">                copy(vin.begin()+i+<span class="number">1</span>,vin.end(),right_vin.begin());</span><br><span class="line">                copy(pre.begin()+<span class="number">1</span>,pre.begin()+<span class="number">1</span>+i,left_pre.begin());</span><br><span class="line">                copy(pre.begin()+i+<span class="number">1</span>,pre.end(),right_pre.begin());</span><br><span class="line">                node-&gt;left =  reConstructBinaryTree(left_pre,left_vin);</span><br><span class="line">                node-&gt;right = reConstructBinaryTree(right_pre,right_vin);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="从尾到头打印链表">从尾到头打印链表</h3><p>输入一个链表，从尾到头打印链表每个节点的值。 /** * struct ListNode { * int val; * struct ListNode <em>next; </em> ListNode(int x) : * val(x), next(NULL) { * } * }; <em>/ class Solution { public: vector<int> printListFromTailToHead(ListNode</int></em> head) { ListNode* current = head; vector<int> v; while(current != nullptr){ v.insert(v.begin(),current-&gt;val); current = current-&gt;next; } return v; } }; ### 替换空格 请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> newString;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] != <span class="string">' '</span>)&#123;</span><br><span class="line">                newString.push_back(str[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">' '</span>)&#123;</span><br><span class="line">                newString +=<span class="string">"%20"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(str,newString.c_str());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></int></p><h3 id="二维数组中的查找">二维数组中的查找</h3><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cow = <span class="built_in">array</span>.size();</span><br><span class="line">        <span class="keyword">int</span> col = <span class="built_in">array</span>[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=col<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;cow &amp;&amp; j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i][j] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i][j] &gt; target)&#123;</span><br><span class="line">                j = j<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i][j] &lt; target)&#123;</span><br><span class="line">                i = i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++语言技巧</title>
      <link href="/hexoblog/2017/04/07/%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/C++%E8%AF%AD%E8%A8%80%E6%8A%80%E5%B7%A7/"/>
      <url>/hexoblog/2017/04/07/%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/C++%E8%AF%AD%E8%A8%80%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>C++有关的概念和常用的代码。主要包括内存模型(堆内存，栈内存)，虚函数，虚表，const 的用法，include，sizeof, 构造函数等内容。</p><a id="more"></a><h2 id="基础概念">基础概念</h2><h3 id="include-文件包含">include (文件包含)</h3><p><strong><code>include &lt;&gt;</code> 和 <code>include &quot;&quot;</code> 有什么区别？</strong></p><p><code>&lt;&gt;</code>和<code>&quot;&quot;</code>的区别是系统在搜索头文件的时候顺序不同，<code>&lt;&gt;</code>在搜索的时候首先从系统目录开始搜索，然后搜索path环境变量下面，不搜索当前的目录； <code>&quot;&quot;</code>首先搜索当前目录，然后搜索系统和path目录，所以自己写的文件用双引号，系统自带的库用<code>&lt;&gt;</code>,主要是为了搜索快。</p><p><strong>如何避免头文件被重复包含</strong></p><p>按照如下的格式书写头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _HEADERNAME_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _HEADERNAME_H</span></span><br><span class="line"></span><br><span class="line">...<span class="comment">//(头文件内容)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这样头文件在第一次被包含的时候，_HEADERNAME_H 没有被定义，执行定义_HEADERNAME_H的动作并包含头文件的内容， 第二次包含的时候，_HEADERNAME_H 已经被定义，就不会包含后面的内容；<code>_HEADERNAME_H</code>是自定义的名称，需要为每一个头文件起一个不一样的名称，这样才能达到效果。</p><h3 id="常量const">常量(const)</h3><p><strong>常量的定义方式和异同？</strong></p><p>有两种定义方式： <code>define PI 3.14</code> 和 <code>const double PI = 3.14</code>.</p><p><code>define</code> 定义的常量是在编译之前的预处理阶段执行的简单的字符串替换，就是把代码中所有出现<code>PI</code>的地方替换成<code>3.14</code>,不执行语法和类型的检查。 <code>const</code>定义的常量是在编译阶段处理的，有类型的检查和语法的检查，更安全。 如果使用<code>define</code>定义复杂的常量表达式，需要特别注意括号的使用。</p><p><strong>顶层const和底层const</strong></p><p><code>const</code>既可以修饰普通的变量(整形，字符串等)也可以修饰指针，假设一个指针<code>p</code>指向一个变量<code>a</code>, 如果指针是常量(<code>p</code>中存储的地址不能改变) 叫做顶层const, 如果<code>a</code>是常量(<code>a</code>中存储的数值不能改变)，叫做底层const.</p><p>顶层const的定义： <code>int *const p = &amp;a;</code> p 的值不能改变，但是可以通过p改变它指向的a的值； 底层const的定义： <code>const int *p = &amp;a;</code> p 的值可以改变，但是不能通过p改变它指向的a的值。</p><p>既是顶层也是底层：<code>const int *const p = &amp;a;</code> p的值不能改变，也不能通过p改变a的值；</p><p><strong>常量表达式</strong></p><p>值不会改变并且在编译的时候可以确定值的表达式就是常量表达式，可以使用<code>constexpr</code>声明常量表达式，这样编译器会自己判断表达式是否是常量表达式，如果不是，就会报错。<code>constexpr int m = 20 + 90;</code></p><p><code>constexpr</code> 还可以用来修饰函数的返回值，这是一种常量函数，要保证在编译的时候就能得到结果。<code>constexpr int getIntSize(){return 4;}</code>这样一个函数在编译的时候就可以确定其返回值，所以该函数可以用来初始化常量。 需要注意的是，并不一定加了constexpr的函数就一定返回常量，也可以返回非常量，如果用返回非常量的<code>constexpr</code>函数初始化常量，编译器会报错。</p><h3 id="虚函数">虚函数</h3><p>对于非 虚函数的调用，在编译的时候确定调用哪一个，例如函数的重载，通过函数参数的类型，个数就可以确定调用哪一个； 对于虚函数的调用，直到运行的时候才能确定应该调用哪一个函数。 当使用基类的引用调用基类的虚函数的时候，编译器是无法确定到底调用哪一个函数的，需要等到运行时，了解基类的指针或者引用具体绑定到了哪一个子类上，才能确定下来（调用该子类自己实现的函数版本).</p><ol style="list-style-type: decimal"><li>虚函数 不代表 不被实现， 纯虚函数才是不被实现的函数；</li><li>虚函数的目的是允许用基类的指针调用子类的这个函数；（在基类中声明为虚函数就可以，子类中不用带virtual）</li><li>纯虚函数的目的是定义一个接口，规定所有继承该类的的子类必须实现这个函数；</li><li>包含纯虚函数的类是抽象类，不能实例化，不能创建类的实例。</li></ol><p>虚析构函数的作用是在销毁对象的时候首先销毁基类指针指向的子类对象的实例，再执行基类对象的析构函数，如果子类不定义程虚析构函数，则不会执行子类的析构函数，容易造成内存泄漏。</p><h3 id="堆内存和栈内存">堆内存和栈内存</h3><p>http://www.cnblogs.com/yyxt/archive/2015/02/02/4268304.html</p><p><code>char a[] = &quot;1234&quot;;</code> 是存储在栈上的；</p><p><code>char *a = &quot;1234&quot;;</code> 是存储在堆上的；</p><p>栈内存访问的速度快于堆内存，因为堆内存的指针也是存放在栈上的，需要先访问栈，然后去堆上访问，对的地址也是不连续的，这导致访问的速度下降。</p><p><strong>new malloc</strong></p><p><code>new</code> 和 <code>malloc</code> 开辟的内存是存储在堆上的，需要自己去释放内存，否则只有在程序结束之后才有可能被操作系统回收。 <code>delete</code> 和 <code>free</code> 是用来释放内存的，delete 或调用被释放对象的析构函数，安全的释放内存，<code>free</code> 直接释放。</p><h3 id="静态链接和动态连接">静态链接和动态连接</h3><p>源文件–&gt;预编译–&gt;编译–&gt;汇编–&gt; <strong>链接</strong> –&gt;可执行程序</p><p>如果在链接的时候，将源文件中用到的库函数与汇编生成的文件合并生成一个可执行文件，之后的程序仅需要这个可执行文件即可运行，这样的方式叫做静态链接； 缺点是文件可能太大，毕竟一个简单的程序也会包含很多的头文件。</p><p>如果在链接的时候，不把源文件中用到的库合并在一起，而是单独编译，在运行的时候，用到的地方在去寻找该库，这种方式叫做动态链接，动态连接可以有效的避免重复，但是可移植性就受到限制，经常遇到的运行某个程序的时候XX找不到的错误就是动态链接库需要的文件丢失后者没有在正确的路径上导致的。</p><p>参考文章：<a href="http://www.cnblogs.com/52php/p/5681711.html" class="uri" target="_blank" rel="noopener">http://www.cnblogs.com/52php/p/5681711.html</a></p><h2 id="基本操作">基本操作</h2><h3 id="字符串基本操作">字符串基本操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 末尾添加一个字符</span></span><br><span class="line">s.push_back(<span class="string">'a'</span>);</span><br><span class="line"><span class="comment">// 末尾追加一个字符串</span></span><br><span class="line">s.append(<span class="string">"aaa"</span>);</span><br><span class="line"><span class="comment">// 任意位置插入字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//任意位置插入字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//任意位置删除字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//任意位置删除字符串</span></span><br></pre></td></tr></table></figure><h3 id="判断x是否是素数">判断x是否是素数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断x是否是素数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xx = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>((<span class="keyword">double</span>)x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=xx;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>( x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="找出n以内235整除的所有数字">找出n以内，2，3，5整除的所有数字</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回三个数字中的最小值和最小值的索引</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minThree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v, <span class="keyword">int</span> &amp;index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.size()!=<span class="number">3</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> minValue = v[<span class="number">0</span>];</span><br><span class="line">    index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(minValue &gt; v[<span class="number">1</span>])&#123;</span><br><span class="line">        minValue = v[<span class="number">1</span>];</span><br><span class="line">        index = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(minValue &gt; v[<span class="number">2</span>])&#123;</span><br><span class="line">        minValue = v[<span class="number">2</span>];</span><br><span class="line">        index = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找出n以内所有能被2，3，5其中一个或者多个整除的数字</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getNumbers(<span class="keyword">int</span> x)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; results=&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; index235 = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> minValue = minThree(&#123;<span class="number">2</span>*index235[<span class="number">0</span>],<span class="number">3</span>*index235[<span class="number">1</span>],<span class="number">5</span>*index235[<span class="number">2</span>]&#125;,index);</span><br><span class="line">    <span class="keyword">while</span>(minValue&lt;=x)&#123;</span><br><span class="line">        <span class="keyword">if</span>(minValue != results[results.size()<span class="number">-1</span>])&#123;</span><br><span class="line">            results.push_back(minValue);</span><br><span class="line">        &#125;</span><br><span class="line">        index235[index]++;</span><br><span class="line">        minValue = minThree(&#123;<span class="number">2</span>*index235[<span class="number">0</span>],<span class="number">3</span>*index235[<span class="number">1</span>],<span class="number">5</span>*index235[<span class="number">2</span>]&#125;,index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="找出第1500个只包含2或3或5为因子的数字从1开始">找出第1500个只包含2或3或5为因子的数字(从1开始)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回三个数字中的最小值和最小值的索引</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minThree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v, <span class="keyword">int</span> &amp;index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.size()!=<span class="number">3</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> minValue = v[<span class="number">0</span>];</span><br><span class="line">    index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(minValue &gt; v[<span class="number">1</span>])&#123;</span><br><span class="line">        minValue = v[<span class="number">1</span>];</span><br><span class="line">        index = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(minValue &gt; v[<span class="number">2</span>])&#123;</span><br><span class="line">        minValue = v[<span class="number">2</span>];</span><br><span class="line">        index = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找到第K个数字（从1开始）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNumbers</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; index235 = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> minValue = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(count &lt; k)&#123;</span><br><span class="line">        minValue = minThree(&#123;<span class="number">2</span>*index235[<span class="number">0</span>],<span class="number">3</span>*index235[<span class="number">1</span>],<span class="number">5</span>*index235[<span class="number">2</span>]&#125;,index);</span><br><span class="line">        <span class="keyword">if</span>(minValue != tmp)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            tmp = minValue;</span><br><span class="line">        &#125;</span><br><span class="line">        index235[index]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小于等于n的所有素数">小于等于n的所有素数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出x以内的所有素数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getPrimes(<span class="keyword">int</span> x)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Primes;</span><br><span class="line">    <span class="comment">// 初始化 0 - x 都是素数</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; isPrime(x+<span class="number">1</span>,<span class="literal">true</span>);</span><br><span class="line">    isPrime[<span class="number">0</span>] = <span class="literal">false</span>; <span class="comment">// 0 不是素数</span></span><br><span class="line">    isPrime[<span class="number">1</span>] = <span class="literal">false</span>; <span class="comment">// 1 不是素数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=x;i++)&#123;</span><br><span class="line">        <span class="comment">// 如果i是素数，把所有i的倍数设置成不是素数</span></span><br><span class="line">        <span class="keyword">if</span>(isPrime[i])&#123;</span><br><span class="line">            Primes.push_back(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i*<span class="number">2</span>;j&lt;=x;j=j+i)&#123;</span><br><span class="line">                isPrime[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Primes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大公约数">最大公约数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        tmp = y;</span><br><span class="line">        y = x % y;</span><br><span class="line">        x = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义set的比较函数">自定义set的比较函数</h3><p>存入set的元素默认是有序的，但是默认的比较可能不能满足我们的要求，这个时候 就需要自定义比较的函数。 set的排序是使用红黑树的结构，插入删除和取出最小的 元素都比较高效。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NumBit</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    NumBit(<span class="keyword">int</span> n) : num(n) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> struct NumBit &amp; right)<span class="keyword">const</span>   <span class="comment">//重载&lt;运算符</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vtmp1;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="keyword">this</span>-&gt;num;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            b = n % <span class="number">10</span>;</span><br><span class="line">            vtmp1.insert(vtmp1.begin(),b);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vtmp2;</span><br><span class="line">        <span class="keyword">int</span> n2 = right.num;</span><br><span class="line">        <span class="keyword">int</span> b2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n2)&#123;</span><br><span class="line">            b2 = n2 % <span class="number">10</span>;</span><br><span class="line">            vtmp2.insert(vtmp2.begin(),b2);</span><br><span class="line">            n2 /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ilen = vtmp1.size();</span><br><span class="line">        <span class="keyword">int</span> jlen = vtmp2.size();</span><br><span class="line">        <span class="keyword">while</span>( i&lt;ilen || j&lt;jlen )&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;ilen &amp;&amp; j&lt;jlen &amp;&amp; vtmp1[i] &gt; vtmp2[j])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&lt;ilen &amp;&amp; j&lt;jlen &amp;&amp; vtmp1[i] &lt; vtmp2[j])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&lt;ilen &amp;&amp; j&lt;jlen &amp;&amp; vtmp1[i] == vtmp2[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==ilen)&#123;</span><br><span class="line">                <span class="keyword">if</span>(vtmp2[j] &gt; vtmp2[<span class="number">0</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(vtmp2[j] &lt; vtmp2[<span class="number">0</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == jlen)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j==jlen)&#123;</span><br><span class="line">                <span class="keyword">if</span>(vtmp1[i] &gt; vtmp1[<span class="number">0</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(vtmp1[i] &lt; vtmp1[<span class="number">0</span>]) <span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == ilen)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用的时候直接使用上面定义的结构体作为set的类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">multiset</span>&lt;NumBit&gt; s; <span class="comment">//</span></span><br></pre></td></tr></table></figure><h3 id="整数转换成字符串">整数转换成字符串</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Int_to_String</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ostringstream</span> stream;</span><br><span class="line">    stream&lt;&lt;n;  <span class="comment">//n为int类型</span></span><br><span class="line">    <span class="keyword">return</span> stream.str();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十进制数字转换成k进制之后数位之和">十进制数字转换成K进制之后数位之和</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10进制数字 转换成K进制之后各个数位的数字之和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        sum += n % k;</span><br><span class="line">        n = n / k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十进制数字转换成k进制">十进制数字转换成K进制</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; Kin(<span class="keyword">int</span> n,<span class="keyword">int</span> k)&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">while</span>(n/k != <span class="number">0</span>)&#123;</span><br><span class="line">        result.push_front(n%k);</span><br><span class="line">        n = n / k;</span><br><span class="line">    &#125;</span><br><span class="line">    result.push_front(n);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="k进制数字转换成十进制">K进制数字转换成十进制</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将K进制的deque转换成10进制</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kinverse</span><span class="params">(<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; v,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!v.empty())&#123;</span><br><span class="line">        s += v.back() * <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="keyword">float</span>(k),i);</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输入输出重定向">输入输出重定向</h3><p>有的算法题是从接收的是从控制台的输入，而且输入还很多，这个时候如果每次调试都从控制台一次一次的输入测试数据，就会很麻烦。我们可以把要输入的数据保存在一个文本文件中，然后使用输入重定向<a href="http://www.cplusplus.com/reference/cstdio/freopen/" target="_blank" rel="noopener"><code>freopen</code></a>把标准输入重定向到该文件。以输入一个m行n列的矩阵来说，首先把输入数据存储在文本文件<code>d:/A.in</code>中。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 4</span><br><span class="line">1 2 3 4</span><br><span class="line">5 6 7 8</span><br><span class="line">9 10 11 12</span><br><span class="line">13 14 15 16</span><br></pre></td></tr></table></figure></p><p>然后执行下面的代码： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">freopen(<span class="string">"d:\\A.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);<span class="comment">// 输入重定向</span></span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v(m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line"><span class="comment">//读取数据</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;v[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出读取的数据门这里输出到控制台</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;v[i][j]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同样，输出也可以重定向到文件，当有大量的输出或者需要保存输出结果的时候，重定向到文件是一个不错的方法。只需要在输出之前加上下面这段代码，输出就会重定向到文件，这个时候运行程序，控制台就看不到输出了。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">freopen(<span class="string">"d:\\A.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure></p><h3 id="格式化输入输出">格式化输入输出</h3><p>C++定义了一些操纵符来控制输出流的状态，endl就是一个常用的操纵符。</p><p><strong>控制布尔值的格式</strong></p><p><code>boolalpha</code>使得布尔值输出<code>true</code> or <code>false</code>; <code>noboolalpha</code>使得输出变回默认的<code>0</code> or <code>1</code>. <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"default: "</span>&lt;&lt;<span class="literal">true</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;<span class="literal">false</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;boolalpha&lt;&lt;<span class="string">"boolalpha: "</span>&lt;&lt;<span class="literal">true</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;<span class="literal">false</span>&lt;&lt;noboolalpha&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><p><strong>控制整数的输出进制</strong></p><ul><li>八进制： <code>oct</code></li><li>十六进制： <code>hex</code></li><li>十进制： <code>dec</code></li></ul><p><strong>控制固定小数点位数</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>.precision(<span class="number">6</span>);</span><br><span class="line"><span class="built_in">cout</span>.setf(ios::fixed);</span><br></pre></td></tr></table></figure></p><h3 id="数据的表示范围">数据的表示范围</h3><p>以下内容来源于<code>C++ Premier 第五版</code></p><p><strong>整型</strong></p><p>包括整数，字符型，和布尔类型；这类数据在计算机的内部都是以二进制位0和1直接保存的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得整形类型的表示范围， climits</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"char: "</span>&lt;&lt;CHAR_MIN&lt;&lt;<span class="string">" to "</span>&lt;&lt;CHAR_MAX&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"unsinged char: "</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">" to "</span>&lt;&lt;UCHAR_MAX&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"int8: "</span>&lt;&lt;INT8_MIN&lt;&lt;<span class="string">" to "</span>&lt;&lt;INT8_MAX&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"unsinged int8: "</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">" to "</span>&lt;&lt;UINT8_MAX&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"int16: "</span>&lt;&lt;INT16_MIN&lt;&lt;<span class="string">" to "</span>&lt;&lt;INT16_MAX&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"unsigned int16: "</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">" to "</span>&lt;&lt;UINT16_MAX&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"int32: "</span>&lt;&lt;INT32_MIN&lt;&lt;<span class="string">" to "</span>&lt;&lt;INT32_MAX&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"unsigned int32: "</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">" to "</span>&lt;&lt;UINT32_MAX&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"int64: "</span>&lt;&lt;INT64_MIN&lt;&lt;<span class="string">" to "</span>&lt;&lt;INT64_MAX&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"unsigned int64: "</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">" to "</span>&lt;&lt;UINT64_MAX&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><strong>浮点型</strong></p><p>在计算机内部，这种类型是把保存数据的空间分成两部分，一部分存储小数部分，一部分存储指数部分，数的实际大小是通过计算得出来的。 浮点类型由四部分组成： - sign : 符号，正 或 负 - base(radix) : 基数(2,8,10,16) - significand : 尾数 - exponent ： 指数</p><p>浮点类型的大小可以通过包含<a href="http://www.cplusplus.com/reference/cfloat/" target="_blank" rel="noopener"><code>cfloat</code></a>查看。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得浮点类型的表示范围  cfloat</span></span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"float range: "</span>&lt;&lt;FLT_MIN&lt;&lt;<span class="string">" to "</span>&lt;&lt;FLT_MAX&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"float significand: "</span>&lt;&lt;FLT_MANT_DIG&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"float exponent: "</span>&lt;&lt;FLT_MIN_EXP &lt;&lt;<span class="string">" to "</span>&lt;&lt;FLT_MAX_EXP&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"double range: "</span>&lt;&lt;DBL_MIN&lt;&lt;<span class="string">" to "</span>&lt;&lt;DBL_MAX&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"double significant: "</span>&lt;&lt;DBL_MANT_DIG &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"double exponent: "</span>&lt;&lt;DBL_MIN_EXP &lt;&lt;<span class="string">" to "</span>&lt;&lt;DBL_MAX_EXP&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"long double range: "</span>&lt;&lt;LDBL_MIN&lt;&lt;<span class="string">" to "</span>&lt;&lt;LDBL_MAX&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"long double significant: "</span>&lt;&lt;LDBL_MANT_DIG&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"long double exponent"</span>&lt;&lt;LDBL_MIN_EXP&lt;&lt;<span class="string">" to "</span>&lt;&lt;LDBL_MAX_EXP&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"base: "</span>&lt;&lt;FLT_RADIX&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><strong>获得类型所占用的字节数目</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得类型在内存中占的字节数</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"bool: "</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">bool</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"char: "</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">char</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"short: "</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">short</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"int: "</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">int</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"long: "</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">long</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"long long : "</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"float: "</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">float</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"long double: "</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">double</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><strong>类型的使用准则</strong></p><ul><li>明确知道不可能为负，使用无符号数。</li><li>整数运算一般使用<code>int</code>, 需要大数的时候考虑<code>long long</code>.需要小整数的时候考虑<code>signed char</code> or <code>unsigned char</code></li><li>浮点运算用<code>double</code></li></ul><h3 id="快速幂和矩阵快速幂">快速幂和矩阵快速幂</h3><p><strong>整数的快速幂</strong></p><p>求<span class="math inline">\(a^b\)</span>一般的做法是用一个循环，将a累乘b次，这样需要做b次乘法。快速幂的思想是利用了 <span class="math inline">\(a^(b1+b2) = a^b1 + a^b2\)</span> 的思想，把b表示成二进制，然后拆分开，分别求幂，再求和。举例来说：</p><p>假设要求<span class="math inline">\(5^{12}\)</span>,传统的方法是12个5相乘，要做12次乘法运算。快速幂的思想是把12表示成二进制，<code>1100</code> = <span class="math inline">\(2^2+2^3\)</span>, <span class="math display">\[5^{12} = 5^{(2^2+2^3)} = 5^{2^2} * 5^{2^3}\]</span> 2的幂的计算可以由十分迅速的移位计算得到，所有原来需要12个乘法运算才能解决的计算问题，现在编程了只需要三次计算节能解决。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quickPow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>,base=a;</span><br><span class="line">    <span class="keyword">while</span>(b!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>!=<span class="number">0</span>)</span><br><span class="line">        　　ans*=base;</span><br><span class="line">        base*=base;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">　 &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照上面的代码计算出来的实际上是<span class="math inline">\(5^{2^2} * 5^{2^3}\)</span>, 因为我们用的是右移，每次都只判断末尾的一个二进制位，如果是1，就乘入当前的结果。每次循环（不管是不是1），base都要翻倍，因为是二进制，每移动一位就意味着乘以2.</p><p>另外一个需要注意的问题是，实际使用时需要注意数据的范围，如果int的范围不够，可以使用long long类型。</p><p><strong>矩阵的快速幂</strong></p><ul><li><p>矩阵乘法 一个<span class="math inline">\(m*n\)</span>的矩阵 乘以 一个<span class="math inline">\(n*p\)</span>的矩阵，会得到一个<span class="math inline">\(m*p\)</span>的矩阵。矩阵相乘的规则是：第一个矩阵的每一行乘以第二个矩阵的每一列，对应的元素相乘再相加，作为新矩阵对应位置上的元素。朴素的矩阵乘法的代码如下： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrix;</span><br><span class="line"><span class="function">matrix <span class="title">MatricMul</span><span class="params">(matrix A,matrix B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = A.size();</span><br><span class="line">    <span class="keyword">int</span> n1 = A[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">int</span> n2 = B.size();</span><br><span class="line">    <span class="keyword">int</span> p = B[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">if</span>(n1 != n2) &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"no cheng of the two matrix."</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">return</span> matrix();&#125;</span><br><span class="line">    <span class="keyword">int</span> n = n1 = n2;</span><br><span class="line">    <span class="function">matrix <span class="title">C</span><span class="params">(m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(p,<span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;p;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">                C[i][j] += A[i][k] * B[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    matrix A = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line">    matrix B = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line">    matrix C = MatricMul(A,B);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><span class="math inline">\(A^n\)</span> 快速求矩阵的n次幂，注意这里A只能是方阵 矩阵的快速幂和整数的快速幂是一样的，就是重载一下*这个运算符，使得两侧是矩阵的时候，计算的是矩阵乘法。这里我们就不重载运算符了，直接使用上面定义的矩阵乘法函数<code>MatricMul</code>: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">matrix <span class="title">quickPowMatrix</span><span class="params">(matrix A,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    matrix base = A;</span><br><span class="line">    <span class="comment">// 初始化成单位矩阵</span></span><br><span class="line">    <span class="keyword">int</span> len = A.size();</span><br><span class="line">    <span class="function">matrix <span class="title">ans</span><span class="params">(len,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len,<span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.size();i++)&#123;</span><br><span class="line">        ans[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>!=<span class="number">0</span>)</span><br><span class="line">            ans = MatricMul(ans,base);</span><br><span class="line">        base = MatricMul(base,base);</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ul><p>快速幂通常用来求很大的数，这个时候虽然就算速度在可以接受的范围内，但是数据的范围早已经超过了能够表示范围，通常的方法就是mod每个大数，得到一个较小的结果。</p><p>为了减少计算的开销（计算小数的乘法要比计算大数的乘法开销小），通常利用模运算的法则：</p><p><span class="math display">\[(a+b) mod c = (a mod c + b mod c) mod c ;\]</span></p><p><span class="math display">\[(a*b) mod c = (a mod c * b mod c) mod c ;\]</span></p><p>上面的代码每一次计算之后就取模，就可以保证数据的范围不溢出，还能保证比较快的计算速度。</p><p><strong>使用C++的模版技术编写通用的快速幂模版</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">MAXN</span>, <span class="title">T</span> <span class="title">MOD</span>=-1&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T m[MAXN][MAXN];</span><br><span class="line">    Matrix()&#123;&#125;</span><br><span class="line">    <span class="comment">// 如果MOD不是-1，把num取模</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(T num[MAXN][MAXN])</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; MAXN ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; MAXN ; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                m[i][j] = num[i][j];</span><br><span class="line">                <span class="keyword">if</span> (MOD!=<span class="number">-1</span>)</span><br><span class="line">                    m[i][j] %= MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//矩阵乘法的实现</span></span><br><span class="line">    <span class="keyword">friend</span> Matrix <span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix &amp;m1 ,<span class="keyword">const</span> Matrix &amp;m2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i, j, k;</span><br><span class="line">        Matrix ret;</span><br><span class="line">        <span class="built_in">memset</span>(ret.m, <span class="number">0</span>, <span class="keyword">sizeof</span>(ret.m));</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXN; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; MAXN; j++)</span><br><span class="line">                <span class="keyword">if</span> ( m1.m[i][j] )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(k = <span class="number">0</span> ; k &lt; MAXN ; k++)&#123;</span><br><span class="line">                        ret.m[i][k] += m1.m[i][j] * m2.m[j][k];</span><br><span class="line">                        <span class="keyword">if</span> (MOD!=<span class="number">-1</span>) ret.m[i][k] %= MOD;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 矩阵加法的实现</span></span><br><span class="line">    <span class="keyword">friend</span> Matrix <span class="keyword">operator</span>+(<span class="keyword">const</span> Matrix &amp;m1 ,<span class="keyword">const</span> Matrix &amp;m2) &#123;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        Matrix ret;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXN; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; MAXN; j++) &#123;</span><br><span class="line">                ret.m[i][j] = <span class="number">0</span>;</span><br><span class="line">                ret.m[i][j] = m1.m[i][j]+m2.m[i][j];</span><br><span class="line">                <span class="keyword">if</span> (MOD!=<span class="number">-1</span>)</span><br><span class="line">                    ret.m[i][j] %= MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//矩阵快速幂的实现</span></span><br><span class="line">    <span class="keyword">friend</span> Matrix <span class="keyword">operator</span>^(<span class="keyword">const</span> Matrix &amp;_M , LL nx)&#123;</span><br><span class="line">        Matrix ret,M(_M);</span><br><span class="line">        <span class="comment">//ret 初始化成单位矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; MAXN ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; MAXN ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j)</span><br><span class="line">                    ret.m[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> ret.m[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(nx)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nx &amp; <span class="number">1</span>)</span><br><span class="line">                ret = ret * M;</span><br><span class="line">            nx = nx &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            M = M * M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> C[<span class="number">2</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line">    Matrix&lt;<span class="keyword">int</span>,<span class="number">2</span>,<span class="number">1000</span>&gt; mm;</span><br><span class="line">    mm.init(C);</span><br><span class="line">    <span class="keyword">auto</span> add = mm + mm;</span><br><span class="line">    <span class="keyword">auto</span> cheng = mm * mm;</span><br><span class="line">    <span class="keyword">auto</span> mi = mm ^ <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="包含一切的头文件">包含一切的头文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>一个文件包含了所有常用的头文件，你所有使用的函数不再需要引入相应的头文件。该头文件在ACM竞赛中经常被使用，可以减少你包含需要的头文件需要的时间。</p><p>需要注意的是，这个头文件并不是标准的，这意味着可能有的编译器不支持它。</p><h3 id="暂停和计时">暂停和计时</h3><p><strong>暂停</strong></p><p>如果想要让程序暂停几秒继续执行，可以这样使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line">Sleep(<span class="number">2000</span>);  <span class="comment">// 暂停2s, 参数的单位是毫秒</span></span><br></pre></td></tr></table></figure><p><strong>计算程序运行的时间</strong></p><p>有的时候可能要看某段程序运行需要多少时间，可以这样使用： - 秒级计时 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">auto</span> start_time = time(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">//Sleep(3000);</span></span><br><span class="line"><span class="comment">// ... 代码块</span></span><br><span class="line"><span class="keyword">auto</span> end_time = time(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;end_time - start_time&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 输出的是程序运行的秒数。</span></span><br></pre></td></tr></table></figure></p><ul><li>毫秒级计时</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取毫秒级别的时间差</span></span><br><span class="line"><span class="keyword">auto</span> start_time = clock();</span><br><span class="line"><span class="comment">//Sleep(3000);</span></span><br><span class="line"><span class="keyword">auto</span> end_time = clock();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;end_time - start_time&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h3 id="返回一个无序数组排序之后的下标不动原来的数组">返回一个无序数组排序之后的下标，不动原来的数组</h3><p>例如 a = [3,5,2,4,1] , 从小到大排序之后应该是[1,2,3,4,5], 原来在a中的下标是[4,2,0,3,1],我们的目标就是输入a，返回[4,2,0,3,1] <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getOrderIndex(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; order(a.size(),<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.size();i++)&#123;</span><br><span class="line">        order[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(order.begin(), order.begin() + a.size(), [a](<span class="keyword">const</span> <span class="keyword">int</span>&amp; x, <span class="keyword">const</span> <span class="keyword">int</span>&amp; y)-&gt;<span class="keyword">bool</span> &#123; <span class="keyword">return</span> a[x] &lt; a[y];&#125;);</span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>order中就是我们想要的结果。</p><h3 id="读取数量不定的若干个整数">读取数量不定的若干个整数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取一行整数，返回数组</span></span><br><span class="line"><span class="comment"> * @param s</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getInt(<span class="built_in">string</span> &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">    getline(<span class="built_in">cin</span>,s);</span><br><span class="line">    <span class="function"><span class="built_in">istringstream</span> <span class="title">iss</span><span class="params">(s)</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">while</span>(iss &gt;&gt; num)&#123;</span><br><span class="line">        v.push_back(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串转换成整数">字符串转换成整数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用空格分割的字符串转换成整数</span></span><br><span class="line"><span class="comment"> * @param s </span></span><br><span class="line"><span class="comment"> * @return </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; string2int(<span class="built_in">string</span> &amp;s)&#123;</span><br><span class="line">    <span class="function"><span class="built_in">istringstream</span> <span class="title">in</span><span class="params">(s)</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">while</span>(in &gt;&gt; num)&#123;</span><br><span class="line">        v.push_back(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输入挂">输入挂</h3><p>当纯数字的输入规模超过<span class="math inline">\(10^6\)</span>时，可以考虑使用输入挂，比系统自带的cin快很多。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">q_read</span><span class="params">(<span class="keyword">int</span> &amp;num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch; <span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ch = getchar();</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        &#123;</span><br><span class="line">            num = ch - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch = getchar(), <span class="built_in">isdigit</span>(ch)) num = num*<span class="number">10</span>+ch-<span class="string">'0'</span>;</span><br><span class="line">    num *= f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以在开始的时候加入 <code>ios::sync_with_stdio(false);</code>, 它的作用是去掉cin额外的检查开销，达到和scanf相似的输入效率；</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法专题_图问题</title>
      <link href="/hexoblog/2017/04/06/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E5%9B%BE/"/>
      <url>/hexoblog/2017/04/06/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>图由顶点(vertex), 边(edge)组成，所以常用(V,E)来表示图。 图分为两种：有向图和无向图。 <a id="more"></a></p><h2 id="图的表示方法">图的表示方法</h2><div class="figure"><img src="QQ截图20170406150818.png" alt="QQ截图20170406150818.png"><p class="caption">QQ截图20170406150818.png</p></div><h3 id="邻接矩阵表示法">邻接矩阵表示法</h3><p>邻接矩阵表示就是一个二维的矩阵V[i][j] V[i][j] = 1 表示有一条边从节点i连接节点j <img src="QQ截图20170406151130.png" alt="QQ截图20170406151130.png"></p><h3 id="邻接表表示法">邻接表表示法</h3><p>邻接表就是把每个节点直接连接的节点都列举出来。 <img src="QQ截图20170406151320.png" alt="QQ截图20170406151320.png"> <img src="QQ截图20170406151352.png" alt="QQ截图20170406151352.png"></p><h2 id="图的遍历方法">图的遍历方法</h2><h3 id="深度优先遍历">深度优先遍历</h3><p>深度优先遍历用递归实现，借助栈的结构。 <img src="QQ截图20170406151926.png" alt="QQ截图20170406151926.png"> 深度优先搜索的C++语言的实现，图的存储使用邻接矩阵的方式。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="广度优先遍历">广度优先遍历</h3><p>广度优先遍历一般使用队列结构，适用于解决最短路径问题。一般遍历解的状态都是使用 深度优先遍历，因为深度优先遍历可以使用递归函数实现，比较方便。 <img src="QQ截图20170406152025.png" alt="QQ截图20170406152025.png"> <img src="QQ截图20170406152051.png" alt="QQ截图20170406152051.png"> 广度优先搜索的C++语言的实现，图的存储使用邻接矩阵的方式。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="图相关的经典问题">图相关的经典问题</h2><h3 id="二分图的判定">二分图的判定</h3><p>给一个图的顶点着色，相邻的顶点着不同颜色，需要的最少的颜色数，叫做最小着色数。 最小着色数是2的图叫做二分图。</p><p>简单来说，如果图中点可以被分为两组，并且使得所有边都跨越组的边界，则这就是一个二分图。准确地说：把一个图的顶点划分为两个不相交集 U 和V ，使得每一条边都分别连接U、V中的顶点。如果存在这样的划分，则此图为一个二分图。二分图的一个等价定义是：不含有「含奇数条边的环」的图。图 1 是一个二分图。为了清晰，我们以后都把它画成图 2 的形式。 <img src="2017-05-02_152635.png"></p><p>判断一个图是否是二分图，只需要从任意一个节点开始，遍历这个图，给当前节点和相邻节点然不同的色，然后判断有没有相邻的节点同色即可。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="二分图的最大匹配和完美匹配">二分图的最大匹配和完美匹配</h3><p>http://www.renfei.org/blog/bipartite-matching.html</p><p>最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。图 4 是一个最大匹配，它包含 4 条匹配边。</p><p>完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。图 4 是一个完美匹配。显然，完美匹配一定是最大匹配（完美匹配的任何一个点都已经匹配，添加一条新的匹配边一定会与已有的匹配边冲突）。但并非每个图都存在完美匹配。</p><p>举例来说：如下图所示，如果在某一对男孩和女孩之间存在相连的边，就意味着他们彼此喜欢。是否可能让所有男孩和女孩两两配对，使得每对儿都互相喜欢呢？图论中，这就是完美匹配问题。如果换一个说法：最多有多少互相喜欢的男孩/女孩可以配对儿？这就是最大匹配问题。 <img src="2017-05-02_152827.png"> 基本概念讲完了。求解最大匹配问题的一个算法是匈牙利算法，下面讲的概念都为这个算法服务。 <img src="2017-05-02_152847.png"> <strong>交替路</strong>：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。</p><p><strong>增广路</strong>：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路（agumenting path）。例如，图 5 中的一条增广路如图 6 所示（图中的匹配点均用红色标出）： <img src="2017-05-02_153015.png"> 增广路有一个重要特点：非匹配边比匹配边多一条。因此，研究增广路的意义是改进匹配。只要把增广路中的匹配边和非匹配边的身份交换即可。由于中间的匹配节点不存在其他相连的匹配边，所以这样做不会破坏匹配的性质。交换后，图中的匹配边数目比原来多了 1 条。</p><p>我们可以通过不停地找增广路来增加匹配中的匹配边和匹配点。找不到增广路时，达到最大匹配（这是增广路定理）。匈牙利算法正是这么做的。在给出匈牙利算法 DFS 和 BFS 版本的代码之前，先讲一下匈牙利树。</p><p><strong>匈牙利树</strong>一般由 BFS 构造（类似于 BFS 树）。从一个未匹配点出发运行 BFS（唯一的限制是，必须走交替路），直到不能再扩展为止。例如，由图 7，可以得到如图 8 的一棵 BFS 树： <img src="2017-05-02_153241.png"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法专题_动态规划</title>
      <link href="/hexoblog/2017/04/05/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/hexoblog/2017/04/05/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>动态规划方法就是有规律的记忆化搜索方法。一般可以从穷竭搜索中总结出来。 动态规划还可以解决许多排列组合问题。 <a id="more"></a></p><h2 id="背包问题">0-1背包问题</h2><div class="figure"><img src="QQ截图20170406094558.png" alt="QQ截图20170406094558.png"><p class="caption">QQ截图20170406094558.png</p></div><h3 id="使用穷竭搜索">使用穷竭搜索</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 0--1 背包问题</span></span><br><span class="line"><span class="comment"> * 从第start个物体开始，总重量为weight的背包，返回最大的价值</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rec</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> weight,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; w,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ob)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"rec("</span>&lt;&lt;start&lt;&lt;<span class="string">","</span>&lt;&lt;weight&lt;&lt;<span class="string">")"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 物体的最大个数是w.size()-1,如果超过这个，返回0，含义是从第n个</span></span><br><span class="line">    <span class="comment">//物体开始，得到的价值是0，因为不能放入进去</span></span><br><span class="line">    <span class="keyword">if</span>(start == w.size()) &#123;<span class="keyword">return</span> result;&#125;</span><br><span class="line">    <span class="comment">//如果当前物体的重量已经大于总重量，那么一定不能放入背包，</span></span><br><span class="line">    <span class="comment">//一旦放入重量就超过了</span></span><br><span class="line">    <span class="keyword">if</span>(w[start] &gt; weight)&#123;</span><br><span class="line">        result = rec(start+<span class="number">1</span>,weight,w,v,ob);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果当前物体的重量小于等于最大的重量，那么这个物体可以放入背包，</span></span><br><span class="line">    <span class="comment">//尝试放入和不放入两种情况，选择较大的那个；</span></span><br><span class="line"><span class="comment">//    if(w[start] &lt;= weight)&#123;</span></span><br><span class="line"><span class="comment">//        result = max(rec(start+1,weight,w,v),rec(start+1,weight-w[start],w,v)+v[start]);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">// 记录物品是否放入了背包</span></span><br><span class="line">    <span class="keyword">if</span>(w[start] &lt;= weight)&#123;</span><br><span class="line">        <span class="keyword">int</span> noput = rec(start+<span class="number">1</span>,weight,w,v,ob);</span><br><span class="line">        <span class="keyword">int</span> putted = rec(start+<span class="number">1</span>,weight-w[start],w,v,ob)+v[start];</span><br><span class="line">        <span class="keyword">if</span>(putted &gt; noput)&#123;</span><br><span class="line">            result = putted;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"==="</span>&lt;&lt;<span class="string">"rec("</span>&lt;&lt;start&lt;&lt;<span class="string">","</span>&lt;&lt;weight&lt;&lt;<span class="string">")"</span>&lt;&lt;<span class="string">"==="</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            ob.push_back(start);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result = noput;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> a : v)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; w = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> weight = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ob;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;rec(<span class="number">0</span>,weight,w,v,ob)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    print(ob);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用动态规划">使用动态规划</h3><p>动态规划的递推公式实际上可以从上面的穷竭搜索中得到。 rec(i,j) 表示从第i个物体开始，在不超过j的重量的情况下，最大的价值是多少 设置dp[i][j] = rec(i,j); 则可以知道dp[n][j] = 0; 因为最多只有n-1个物体； <code>dp[i][j] = dp[i+1][j]</code> 当第i个物体的重量大于j的时候； <code>dp[i][i] = max( dp[i+1][j] , dp[i+1][j-w[i]]+v[i] )</code> 当第i个物体能够装进去的时候，分别尝试装入和不装入，取最大值。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 背包问题的动态规划解法</span></span><br><span class="line"><span class="comment"> * @param w</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> * @param weight</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; w,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v,<span class="keyword">int</span> weight)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = w.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(weight+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;weight+<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w[i] &gt; j)&#123;</span><br><span class="line">                dp[i][j] = dp[i+<span class="number">1</span>][j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = max(dp[i+<span class="number">1</span>][j],dp[i+<span class="number">1</span>][j-w[i]] + v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print2(dp);</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][weight];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用状态转移的观点">使用状态转移的观点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从状态转移的观点来看</span></span><br><span class="line"><span class="comment"> * dp[i][j] 表示挑选出从0到i物体，总重量不超过j的状态。dp[0][j]表示选择0个物品时的重大价值</span></span><br><span class="line"><span class="comment"> * dp[1][j] 表示选择物体1时候，总重量不超过j的最大的价值</span></span><br><span class="line"><span class="comment"> * 所以有dp[0][j] = 0;</span></span><br><span class="line"><span class="comment"> * dp[i][j] = dp[i-1][j] 当i-1物体不能放入背包时</span></span><br><span class="line"><span class="comment"> * dp[i][j] = dp[i-1][j-w[i]] + v[i] 当i-1物体可以放入背包的时候</span></span><br><span class="line"><span class="comment"> * dp[0][j]</span></span><br><span class="line"><span class="comment"> * @param w</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> * @param weight</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; w,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v,<span class="keyword">int</span> weight)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = w.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(weight+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;weight+<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w[i] &gt; j)&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j] = dp[i][j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j] = max(dp[i][j],dp[i][j-w[i]] + v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print2(dp);</span><br><span class="line">    <span class="keyword">return</span> dp[n][weight];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完全背包问题">完全背包问题</h2><p><img src="QQ截图20170406095153.png" alt="QQ截图20170406095153.png"> 完全背包问题可以这样建立递推关系； dp[i][j] 表示前i-1个物体放入背包，总重量不超过j的情况下的最大价值。i=0时表示没有物体。 w[i] 和 v[i] 表示第i个物体的重量和价值。注意这里dp中的i和w,v中的i相差1.也就是dp[i+1]对应的物体的重量和价值分别是w[i],v[i]; <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i+<span class="number">1</span>][j] := dp[i][j]  第i个物体不放入背包</span><br><span class="line">           := dp[i][j<span class="number">-1</span>*w[i]] + v[i] 第i个物体放入<span class="number">1</span>次的时候</span><br><span class="line">   := dp[i][j<span class="number">-2</span>*w[i]] + <span class="number">2</span>*v[i] 第i个物体放入<span class="number">2</span>次的时候</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure></p><p>上面的递推关系虽然容易理解，却存在这循环，有重复计算的地方。递推关系还可以定义如下：</p><blockquote><p>dp[i+1][j] = dp[i][j] ; 第i个物体无法放入背包的情况 dp[i+1][j] = d[i+1][j-w[i]] + v[i] ; 如果第i个物体可以放入背包，那么最大价值等于 在dp[i+1][j-w[i]]的基础上再放入一个i物品，这时的价值是dp[i+1][j-w[i]] + v[i]; 所以最后的递推关系可以写成： dp[0][j] = 0; dp[i+1][j] = max(dp[i][j],dp[i+1][j-w[i]] + v[i])</p></blockquote><p>完全背包问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完全背包问题</span></span><br><span class="line"><span class="comment"> * @param w</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> * @param weight</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp3</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; w,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v,<span class="keyword">int</span> weight)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = w.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(weight+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=weight;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;w[i])&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j] = dp[i][j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j] = max(dp[i][j],dp[i+<span class="number">1</span>][j-w[i]]+v[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print2(dp);</span><br><span class="line">    <span class="keyword">return</span> dp[n][weight];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上背包的问题的时间复杂度都可以优化到O（nW）也就是物品数量 * 背包容量，空间复杂度可以优化到O（n）. 一般情况下，这样的时间复杂度足够了。但是针对下面这道题，时间复杂度就不够用了，需要另外寻找解题的方法。 &gt; 有n个重量和价值分别为w[i],v[i]的物品，装入容量为W的背包，求最大价值。 &gt; 限制条件： &gt; n : 1–100 ; w[i] : 1–10000000 ; v[i] : 1–100; W : 1–1000000000</p><p>原来背包问题的时间复杂度是O(nW),但是本题’故意’把W设置的很大，使得不能使用原来的方法求解。 仔细分析数据的取值范围发现，v[i]的范围比较小，我们可以转换思路，求解总重量不超过W的情况下价值的最大值， 就是求解相同价值下的总重量的最小值。 dp[i][j] 表示前i-1个物体在价值不超过j的时候的总重量的最小值。 dp[0][j] = INF; 把不存在最小值的情况设置为最大值，这样是方便用min(); dp[0][0] = 0 ; dp[i+1][j] = min(dp[i][j],dp[i][j-v[i]]+w[i])</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 0-1背包的变种</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; w,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v,<span class="keyword">int</span> weight)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = w.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(weight+<span class="number">1</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=weight;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;v[i])&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j] = dp[i][j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j] = min(dp[i][j],dp[i+<span class="number">1</span>][j-v[i]]+w[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print2(dp);</span><br><span class="line">    <span class="keyword">return</span> dp[n][weight];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单词切分">单词切分</h2><p>给出一个字符串s和一个词典，判断字符串s是否可以被空格切分成一个或多个出现在字典中的单词。 样例</p><p>给出</p><p>s = “lintcode”</p><p>dict = [“lint”,“code”]</p><p>返回 true 因为“lintcode”可以被空格切分成“lint code”</p><p><a href="http://lintcode.com/zh-cn/problem/word-break/" target="_blank" rel="noopener">单词切分</a></p><p>思路一：开一个<code>dp[n+1]</code>表示前i个字母能否用空格分割开(按照字典里面给出的单词)。<code>dp[0]=true</code>表示空字符串能够分割开，<code>dp[1]=true</code>当<code>s[0]</code>在字典中存在时。对于<code>dp[j]</code>来说，逐个向前搜索，看是否有<code>s[i,j]</code>存在与dict中的同时<code>dp[i-1]</code>为真。如果有，<code>dp[j]=true</code>,如果搜索到头还没有，<code>dp[j]=false</code>.这种方法最容易想到，但是时间复杂度高。(不能通过<code>lintcode</code>的所有测试用例)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[单词切分](http://lintcode.com/zh-cn/problem/word-break/)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; &amp;dict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; dp(s.size()+<span class="number">1</span>,<span class="literal">false</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dict.find(s.substr(i<span class="number">-1</span>,<span class="number">1</span>))!=dict.end() &amp;&amp; dp[i<span class="number">-1</span>])&#123;</span><br><span class="line">            dp[i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> clen = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">1</span> ; --j) &#123;</span><br><span class="line">            <span class="built_in">string</span> ss = s.substr(j<span class="number">-1</span>,clen);</span><br><span class="line">            <span class="keyword">if</span>(dict.find(ss) != dict.end() &amp;&amp; dp[j<span class="number">-1</span>])&#123;</span><br><span class="line">                dp[i]  = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            clen ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.size()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：上面的算法每次都会回溯到第一个字符，如果字典的最大的字符的长度远远小于字符串的长度(很常见的情况)，会造成大量的浪费，所以可以改进一下，每次只回溯到字典中最大的字符串长度处，这样就能通过<code>lintcode</code>的大规模的数据了。<code>getMaxLen</code>用来获取字典中最长的字符串的长度。但是该方法当dict中最大字符串的长度很长时，时间复杂度并没有降低。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxLen</span><span class="params">( <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; &amp;dict)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> a : dict)&#123;</span><br><span class="line">        maxlen = max(maxlen,(<span class="keyword">int</span>)a.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxlen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[单词切分](http://lintcode.com/zh-cn/problem/word-break/)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; &amp;dict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">if</span>(s.empty() &amp;&amp; dict.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; dp(s.size()+<span class="number">1</span>,<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> maxlen = getMaxLen(dict);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dict.find(s.substr(i<span class="number">-1</span>,<span class="number">1</span>))!=dict.end() &amp;&amp; dp[i<span class="number">-1</span>])&#123;</span><br><span class="line">            dp[i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> clen = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> end = max(<span class="number">1</span>,i<span class="number">-1</span>-maxlen);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= end ; --j) &#123;</span><br><span class="line">            <span class="built_in">string</span> ss = s.substr(j<span class="number">-1</span>,clen);</span><br><span class="line">            <span class="keyword">if</span>(dict.find(ss) != dict.end() &amp;&amp; dp[j<span class="number">-1</span>])&#123;</span><br><span class="line">                dp[i]  = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            clen ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.size()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="换钱的方法数">换钱的方法数</h2><div class="figure"><img src="2017-03-22_105837.png"></div><p>思路： 动态规划。<code>dp[i][j]</code>表示用前<code>i</code>种面值的钱组成<code>j</code>总共有多少中方案。设钱币的面值一共有N中，组成的面值为M，则需要<code>N*(M+1)</code>的数组。第一行表示使用第一种面值的货币组成目标值的方法数量，当<code>j</code>能够被整除时，方法数量为1，否则为0. 第一列表示组成目标值<code>0</code>有多少种情况，无论有几种面值的货币，只有一种方法，就是一个都不用。</p><p>递推公式：</p><ol style="list-style-type: decimal"><li><p><code>dp[i][j] = dp[i-1][j] if j &lt; v[i]</code>, (当面值为<code>v[i]</code>的货币比目标值还要大的时候，肯定一张<code>v[i]</code>都不能使用，这个时候方法数量等于<code>dp[-1][j]</code>).</p></li><li><p><code>dp[i][j] = dp[i-1][j] + dp[i][j-v[i]] if j &gt;= v[i]</code>, (如果目标值比面值为<code>v[i]</code>的钱大，则意味着可以使用<code>v[i]</code>若干次，一直到超过目标值； 在这种情况下，组成目标值的总方法数量为以下几种情况的和： 不使用第i中货币组成j, 方法数量是<code>dp[i-1][j]</code>; 使用第<code>i</code>种货币组成j的数量，<code>dp[i][j-v[i]]</code>, 这个式子可以这样理解： 首先使用一张<code>v[i]</code>,然后用前<code>i</code>中货币组成剩下的<code>j-v[i]</code>目标值，这个值之前计算过，可以直接写出来，就是<code>dp[i][j-v[i]]</code>;</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v,<span class="keyword">int</span> aim)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(v.size(),<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(aim+<span class="number">1</span>));</span><br><span class="line">    <span class="comment">//初始化第一列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();++i)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化第一行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=aim;j++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = j%v[<span class="number">0</span>]==<span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;v.size();++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=aim;++j)&#123;</span><br><span class="line">            dp[i][j] = j-v[i]&gt;=<span class="number">0</span> ? dp[i<span class="number">-1</span>][j]+dp[i][j-v[i]] : dp[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印动态规划表格</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dp.size();++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;dp[<span class="number">0</span>].size();++j)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;dp[i][j]&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[v.size()<span class="number">-1</span>][aim];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> aim = <span class="number">7</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; getNum(v,aim) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法专题_链表</title>
      <link href="/hexoblog/2017/03/23/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E9%93%BE%E8%A1%A8/"/>
      <url>/hexoblog/2017/03/23/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>链表是一种比较基础的数据结构，主要类型有单链表，双链表，循环链表等。 链表的实现可以使用数组；也可以使用结构体和指针实现。</p><a id="more"></a><h2 id="链表的基础知识">链表的基础知识</h2><h2 id="链表的基本操作">链表的基本操作</h2><p>C++11的标准中，结构体和类并没有本质的不同。所有可以用结构体和类来定义节点的数据结构。 单链表通常包含一个<code>val</code>和一个指向下一个节点的指针<code>*next</code>,双向链表通常包含一个<code>val</code>和两个指针<code>*pre</code>,<code>*next</code>,分别指向前面的节点和后面的节点。</p><h3 id="链表节点结构的定义">链表节点结构的定义</h3><h4 id="单链表">单链表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单链表节点的定义-使用结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node *next;</span><br><span class="line">    Node() : value(<span class="number">0</span>),next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    Node(<span class="keyword">int</span> v) : value(v),next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     ListNode *next;</span><br><span class="line">     ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">     <span class="keyword">this</span>-&gt;val = val;</span><br><span class="line">         <span class="keyword">this</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="双向链表">双向链表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双向链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    BiNode *pre;</span><br><span class="line">    BiNode *next;</span><br><span class="line">    BiNode() : value(<span class="number">0</span>),pre(<span class="literal">nullptr</span>),next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    BiNode(<span class="keyword">int</span> v) : value(v),pre(<span class="literal">nullptr</span>),next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="链表的创建">链表的创建</h3><h4 id="单链表-1">单链表</h4><p>首先判断是不是空，如果是空，返回空链表 如果不是空，创建第一个元素的节点，并用头指针指向它，日后返回这个头指针； 然后从第二个元素开始，创建新的节点，把这个节点赋值个前一个节点的next指针，然后更新tmp指向当前新创建的节点。 核心的语句： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node *node = <span class="keyword">new</span> Node(v[i]);</span><br><span class="line">tmp-&gt;next = node;</span><br><span class="line">tmp = tmp-&gt;next;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">createLinks</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    Node *head = <span class="keyword">new</span> Node(v[<span class="number">0</span>]); <span class="comment">//头节点，最后需要返回创建的链表的头结点，所以头结点需要保存下来</span></span><br><span class="line">    Node *tmp = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;v.size();++i)&#123;</span><br><span class="line">        Node *node = <span class="keyword">new</span> Node(v[i]);</span><br><span class="line">        tmp-&gt;next = node;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双链表">双链表</h4><p>双向链表的创建需要返回两个指针，一个指向头部，便于正向遍历链表；另外一个指向尾部，便于逆向遍历链表 首先判断是不是空，如果是空，返回空链表 用第一个元素创建节点，并用头节点指向它 创建临时变量指向第一个节点，此临时变量一直指向当前创建的节点 从数组的第二个元素开始创建新的节点，创建的节点的pre设置为tmp, 然后把tmp的next赋值成node,即让tmp所指向的节点连接到当前创建的节点上 更新tmp使它指向当前新创建的节点。 循环体结束后，tmp正好指向最会一个创建的节点，所以把tmp赋值给tail 返回head和tail; 关键语句： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BiNode *node = new BiNode(v[i]);</span><br><span class="line">node-&gt;pre = tmp;</span><br><span class="line">tmp-&gt;next = node;</span><br><span class="line">tmp = tmp-&gt;next;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;BiNode*,BiNode*&gt; createBiNode(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.empty()) <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>,<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    BiNode *head = <span class="keyword">new</span> BiNode(v[<span class="number">0</span>]);</span><br><span class="line">    BiNode *tmp = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;v.size();i++)&#123;</span><br><span class="line">        BiNode *node = <span class="keyword">new</span> BiNode(v[i]);</span><br><span class="line"> node-&gt;pre = tmp;</span><br><span class="line">         tmp-&gt;next = node;</span><br><span class="line">         tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    BiNode *tail = tmp;</span><br><span class="line">    <span class="keyword">return</span> &#123;head,tail&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环链表">循环链表</h4><p>循环链表就是结尾的元素又指向了开头的元素。所以创建过程基本上是一样的，指示在结尾的处理稍有不同。 循环单链表只需要在结尾添加<code>tmp-&gt;next = head;</code> 循环双向链表只需要在结尾添加<code>tail-&gt;next = head;  // 尾元素的后面是头元素  head-&gt;pre = tail;  // 头元素的前面是尾元素</code> .</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建循环单链表</span></span><br><span class="line"><span class="function">Node* <span class="title">createLinksCycle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    Node *head = <span class="keyword">new</span> Node(v[<span class="number">0</span>]); <span class="comment">//头节点，最后需要返回创建的链表的头结点，所以头结点需要保存下来</span></span><br><span class="line">    Node *tmp = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;v.size();++i)&#123;</span><br><span class="line">        Node *node = <span class="keyword">new</span> Node(v[i]);</span><br><span class="line">        tmp-&gt;next = node;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp-&gt;next = head; <span class="comment">// 让结尾指向开头的第一个元素</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建循环双链表</span></span><br><span class="line">pair&lt;BiNode*,BiNode*&gt; createBiNodeCycle(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.empty()) <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>,<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    BiNode *head = <span class="keyword">new</span> BiNode(v[<span class="number">0</span>]);</span><br><span class="line">    BiNode *tmp = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;v.size();i++)&#123;</span><br><span class="line">        BiNode *node = <span class="keyword">new</span> BiNode(v[i]);</span><br><span class="line">        tmp-&gt;next = node;</span><br><span class="line">        node-&gt;pre = tmp;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    BiNode *tail = tmp;</span><br><span class="line">    tail-&gt;next = head;  <span class="comment">// 尾元素的后面是头元素</span></span><br><span class="line">    head-&gt;pre = tail;  <span class="comment">// 头元素的前面是尾元素</span></span><br><span class="line">    <span class="keyword">return</span> &#123;head,tail&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表的插入和删除">链表的插入和删除</h3><h4 id="单链表-2">单链表</h4><p>要在单链表中插入一个节点，只需要知道插入位置的前一个节点就可以了。假设c指向了插入位置的前一个节点，n是新创建的节点 那么插入的方法是： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n-&gt;next = c-&gt;next ; <span class="comment">//新节点n的后一个节点设置成c的后一个节点</span></span><br><span class="line">c-&gt;next = n; <span class="comment">//c节点指向新插入的节点</span></span><br></pre></td></tr></table></figure></p><p>注意如果插入的位置是链表的头部，需要单独处理。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n-&gt;next = head; //新插入的节点的下一个节点连接到头节点</span><br><span class="line">head = n; //头结点编程新插入的节点</span><br></pre></td></tr></table></figure></p><h4 id="双链表-1">双链表</h4><p>双链表既可以向前访问，也可以向后访问。所以插入一个节点，只需要知道要插入的位置的前一个节点，或者要插入位置的后一个节点就可以了。 假设c代表要插入位置的前一个节点；n代表新插入的节点，b代表插入位置的后一个节点。 利用c的插入方法是： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n-&gt;next = c-&gt;next;</span><br><span class="line">c-&gt;next-&gt;pre = n; <span class="comment">// 这两句将新的节点和后面的节点连接起来</span></span><br><span class="line">n-&gt;pre = c;</span><br><span class="line">c-&gt;next = n; <span class="comment">//这两句将c和n连接起来</span></span><br></pre></td></tr></table></figure></p><p>如果要在头节点之前插入，会发现头结点之前没有节点了，所以不能使用上面的语句，需要另外处理： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n-&gt;next = head;</span><br><span class="line">head-&gt;pre = n;</span><br><span class="line">head = n;</span><br></pre></td></tr></table></figure></p><p>利用b的插入方法是： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n-&gt;pre = b-&gt;pre;</span><br><span class="line">b-&gt;pre-&gt;next = n; <span class="comment">// 把新的节点和b前面的节点连接起来</span></span><br><span class="line">n-&gt;next = b;</span><br><span class="line">b-&gt;pre = n;  <span class="comment">// 把新的节点和b连接起来</span></span><br></pre></td></tr></table></figure></p><p>如果在最后一个节点后面插入节点，会发现没有b,这个时候需要另外处理： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n-&gt;pre = tail;</span><br><span class="line">tail-&gt;next = n;</span><br><span class="line">tail = n;</span><br></pre></td></tr></table></figure></p><h4 id="循环链表-1">循环链表</h4><p>循环链表的插入和删除没有了像上面不循环的链表那样需要另外处理头部和尾部的情况。所以插入操作更加简单。 如果插入的是头节点的话，注意head的更新情况即可。 ### 链表的删除</p><h4 id="单链表-3">单链表</h4><p>删除单链表的某一个节点，只需要知道该节点的前一个节点。假设要删除的节点的前一个节点是c. 删除操作：<code>c-&gt;next = c-&gt;next-&gt;next;</code> 如果删除的是第一个节点，则直接<code>head = head-&gt;next;</code> 如果删除的是最后一个节点，则直接<code>c-&gt;next=nullptr</code>.</p><h4 id="双链表-2">双链表</h4><p>同插入类似，双链表的删除只需要知道要删除的节点的前一个节点或者后一个节点就可以了。假设c是前一个节点，b是后一个节点。 删除操作1： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c-&gt;next = c-&gt;next-&gt;next;</span><br><span class="line">c-&gt;next-&gt;next-&gt;pre = c;</span><br></pre></td></tr></table></figure></p><p>删除操作2： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b-&gt;pre = b-&gt;pre-&gt;pre;</span><br><span class="line">b-&gt;pre-&gt;pre-&gt;next = b;</span><br></pre></td></tr></table></figure></p><p>删除首节点和尾节点同样需要特殊考虑； 删除首节点：<code>b-&gt;pre = nullptr;head = b</code>; 删除尾节点：<code>c-&gt;next=nullptr;tail=c;</code> 需要的注意的是，这样做只是从head和tail开始访问的话，再也访问不到被删除的节点，但是实际上，从删除的节点还有指针指向这个链表的某个节点。 如果想要删除干净，就是彻底断开连接，可以使用下面的语句： 删除首节点：<code>b-&gt;pre-&gt;next=nullptr; b-&gt;pre=nullptr;head=b;</code> 删除尾节点：<code>c-&gt;next-&gt;pre=nullptr;c-&gt;next=nullptr;tail=c;</code></p><h4 id="循环链表-2">循环链表</h4><p>循环链表的插入和删除同样不需要考虑特殊的情况，如果插入的是头节点的话，注意head的更新情况即可。</p><h3 id="链表的替换">链表的替换</h3><p>想要更新链表中的某个值，只需要查找到该节点c，然后执行<code>c-&gt;val = new_value;</code>即可。</p><h3 id="链表的反向">链表的反向</h3><h4 id="单链表-4">单链表</h4><p>基本思路是设置三个指针pre,current,next;分别代表相邻的三个节点。 每次循环执行下面的操作： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">next = current-&gt;next; <span class="comment">// 首先记录current的下一个节点</span></span><br><span class="line">current-&gt;next = pre; <span class="comment">// curent的下一个节点设置为前一个节点</span></span><br><span class="line">pre = current; <span class="comment">// pre向前推进一个元素</span></span><br><span class="line">current = next; <span class="comment">//current像前推进一个元素</span></span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">notLinks</span><span class="params">(Node* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">    Node *current = head;</span><br><span class="line">    Node *pre=<span class="literal">nullptr</span>;</span><br><span class="line">    Node *next= <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(current)&#123;</span><br><span class="line">        next = current-&gt;next; <span class="comment">// 首先记录current的下一个节点</span></span><br><span class="line">        current-&gt;next = pre; <span class="comment">// curent的下一个节点设置为前一个节点</span></span><br><span class="line">        pre = current; <span class="comment">// pre向前推进一个元素</span></span><br><span class="line">        current = next; <span class="comment">//current像前推进一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre; <span class="comment">//返回指向新链表的头节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双链表-3">双链表</h4><p>双向链表的反转与单向链表的思路一致，设置三个指针pre,current,next分别指向相邻的三个节点； 每次循环这样操作： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">next = current-&gt;next; <span class="comment">// 首先记录current的下一个节点</span></span><br><span class="line">current-&gt;next = pre; <span class="comment">// curent的下一个节点设置为前一个节点</span></span><br><span class="line">current-&gt;pre = next;</span><br><span class="line">pre = current; <span class="comment">// pre向前推进一个元素</span></span><br><span class="line">current = next; <span class="comment">//current像前推进一个元素</span></span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BiNode* <span class="title">notBiLinks</span><span class="params">(BiNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">    BiNode *current = head;</span><br><span class="line">    BiNode *pre=<span class="literal">nullptr</span>;</span><br><span class="line">    BiNode *next= <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(current)&#123;</span><br><span class="line">        next = current-&gt;next; <span class="comment">// 首先记录current的下一个节点</span></span><br><span class="line">        current-&gt;next = pre; <span class="comment">// curent的下一个节点设置为前一个节点</span></span><br><span class="line">        current-&gt;pre = next;</span><br><span class="line">        pre = current; <span class="comment">// pre向前推进一个元素</span></span><br><span class="line">        current = next; <span class="comment">//current像前推进一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre; <span class="comment">//返回指向新链表的头节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，在逻辑上双向链表是没有正反的，以上所说的反向是在相同的输出函数下，输出的顺序正好相反。 也可以利用这一点反转双向链表，只需要把链表节点的指针pre,next交换一下即可。具体代码如下： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BiNode *tmp = current-&gt;pre;</span><br><span class="line">current-&gt;pre = current-&gt;next;</span><br><span class="line">current-&gt;next = tmp;  <span class="comment">// 以上三行交换两个变量的值</span></span><br><span class="line">newHead = current;   <span class="comment">//存储下来当前节点，日后返回该节点</span></span><br><span class="line">current = current-&gt;pre; <span class="comment">//处理下一个节点</span></span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BiNode* <span class="title">notBiLinks2</span><span class="params">(BiNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">    BiNode *current = head;</span><br><span class="line">    BiNode *newHead;</span><br><span class="line">    <span class="keyword">while</span>(current)&#123;</span><br><span class="line">        BiNode *tmp = current-&gt;pre;</span><br><span class="line">        current-&gt;pre = current-&gt;next;</span><br><span class="line">        current-&gt;next = tmp;</span><br><span class="line">        newHead = current;</span><br><span class="line">        current = current-&gt;pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead; <span class="comment">//返回指向新链表的头节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环链表-3">循环链表</h4><p>循环链表的反转没有什么实际的意义，只是用来练习链表的处理。具体的步骤和上面的基本相同。</p><h3 id="链表的可视化">链表的可视化</h3><h4 id="打印单链表">打印单链表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLinks</span><span class="params">(Node *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *tmp = head;</span><br><span class="line">    <span class="keyword">while</span> (tmp-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tmp-&gt;value &lt;&lt; <span class="string">"-&gt;"</span>;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; tmp-&gt;value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印出来的样式</p><blockquote><p>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6</p></blockquote><h4 id="打印双向链表">打印双向链表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBiLinks</span><span class="params">(BiNode *head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"empty"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    BiNode *tmp = head;</span><br><span class="line">    <span class="keyword">while</span>(tmp-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"["</span>&lt;&lt;tmp-&gt;value&lt;&lt;<span class="string">"]"</span>&lt;&lt;<span class="string">"&lt;-&gt;"</span>;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"["</span>&lt;&lt;tmp-&gt;value&lt;&lt;<span class="string">"]"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印出来的样式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; [1]&lt;-&gt;[2]&lt;-&gt;[3]&lt;-&gt;[4]&lt;-&gt;[5]&lt;-&gt;[6]</span><br></pre></td></tr></table></figure><h2 id="单链表类的定义">单链表类的定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Links</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node *head; <span class="comment">// 头节点</span></span><br><span class="line">    Links() : head(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="comment">//创建链表</span></span><br><span class="line">    Links(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v) &#123;</span><br><span class="line">        <span class="keyword">if</span>(v.empty())&#123;</span><br><span class="line">            head = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            Node *first = <span class="keyword">new</span> Node(v[<span class="number">0</span>]);</span><br><span class="line">            head = first;</span><br><span class="line">            Node *tmp = first;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.size(); ++i) &#123;</span><br><span class="line">                Node *node = <span class="keyword">new</span> Node(v[i]);</span><br><span class="line">                tmp-&gt;next = node;</span><br><span class="line">                tmp = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printLinks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node *tmp = head;</span><br><span class="line">        <span class="keyword">while</span> (tmp-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; tmp-&gt;value &lt;&lt; <span class="string">"-&gt;"</span>;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tmp-&gt;value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反转这个链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inverseLinks</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        Node *next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            next = head-&gt;next;</span><br><span class="line">            head-&gt;next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="双向链表类的定义">双向链表类的定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双向链表的实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BiLinks</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BiNode *head;</span><br><span class="line">    BiNode *tail;</span><br><span class="line">    BiLinks() : head(<span class="literal">nullptr</span>),tail(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    BiLinks(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)&#123;</span><br><span class="line">        BiNode *first = <span class="keyword">new</span> BiNode(v[<span class="number">0</span>]);</span><br><span class="line">        head = first;</span><br><span class="line">        BiNode *tmp = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;v.size();i++)&#123;</span><br><span class="line">            BiNode *node = <span class="keyword">new</span> BiNode(v[i]);</span><br><span class="line">            tmp-&gt;next = node;</span><br><span class="line">            node-&gt;pre = tmp;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printBiLinks</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || tail == <span class="literal">nullptr</span>)&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"empty!"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">        BiNode *tmp = head;</span><br><span class="line">        <span class="keyword">while</span>(tmp-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"["</span>&lt;&lt;tmp-&gt;value&lt;&lt;<span class="string">"]"</span>&lt;&lt;<span class="string">"-&gt;"</span>;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"["</span>&lt;&lt;tmp-&gt;value&lt;&lt;<span class="string">"]"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        tmp = tail;</span><br><span class="line">        <span class="keyword">while</span>(tmp-&gt;pre!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            tmp = tmp-&gt;pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(tmp-&gt;next!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;tmp-&gt;value&lt;&lt;<span class="string">"&lt;-&gt;"</span>;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; tmp-&gt;value &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inverseBiLinks</span><span class="params">()</span></span>&#123;</span><br><span class="line">        BiNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        BiNode *next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            next = head-&gt;next;</span><br><span class="line">            head-&gt;next= pre;</span><br><span class="line">            head-&gt;pre = next;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="链表操作的完整示例">链表操作的完整示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node *next;</span><br><span class="line">    Node() : value(<span class="number">0</span>),next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    Node(<span class="keyword">int</span> v) : value(v),next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//双向链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    BiNode *pre;</span><br><span class="line">    BiNode *next;</span><br><span class="line">    BiNode() : value(<span class="number">0</span>),pre(<span class="literal">nullptr</span>),next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    BiNode(<span class="keyword">int</span> v) : value(v),pre(<span class="literal">nullptr</span>),next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Node* <span class="title">createLinks</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    Node *head = <span class="keyword">new</span> Node(v[<span class="number">0</span>]); <span class="comment">//头节点，最后需要返回创建的链表的头结点，所以头结点需要保存下来</span></span><br><span class="line">    Node *tmp = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;v.size();++i)&#123;</span><br><span class="line">        Node *node = <span class="keyword">new</span> Node(v[i]);</span><br><span class="line">        tmp-&gt;next = node;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建循环单链表</span></span><br><span class="line"><span class="function">Node* <span class="title">createLinksCycle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    Node *head = <span class="keyword">new</span> Node(v[<span class="number">0</span>]); <span class="comment">//头节点，最后需要返回创建的链表的头结点，所以头结点需要保存下来</span></span><br><span class="line">    Node *tmp = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;v.size();++i)&#123;</span><br><span class="line">        Node *node = <span class="keyword">new</span> Node(v[i]);</span><br><span class="line">        tmp-&gt;next = node;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp-&gt;next = head; <span class="comment">// 让结尾指向开头的第一个元素</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;BiNode*,BiNode*&gt; createBiNode(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.empty()) <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>,<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    BiNode *head = <span class="keyword">new</span> BiNode(v[<span class="number">0</span>]);</span><br><span class="line">    BiNode *tmp = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;v.size();i++)&#123;</span><br><span class="line">        BiNode *node = <span class="keyword">new</span> BiNode(v[i]);</span><br><span class="line">        tmp-&gt;next = node;</span><br><span class="line">        node-&gt;pre = tmp;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    BiNode *tail = tmp;</span><br><span class="line">    <span class="keyword">return</span> &#123;head,tail&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建循环双链表</span></span><br><span class="line">pair&lt;BiNode*,BiNode*&gt; createBiNodeCycle(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.empty()) <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>,<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    BiNode *head = <span class="keyword">new</span> BiNode(v[<span class="number">0</span>]);</span><br><span class="line">    BiNode *tmp = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;v.size();i++)&#123;</span><br><span class="line">        BiNode *node = <span class="keyword">new</span> BiNode(v[i]);</span><br><span class="line">        tmp-&gt;next = node;</span><br><span class="line">        node-&gt;pre = tmp;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    BiNode *tail = tmp;</span><br><span class="line">    tail-&gt;next = head;  <span class="comment">// 尾元素的后面是头元素</span></span><br><span class="line">    head-&gt;pre = tail;  <span class="comment">// 头元素的前面是尾元素</span></span><br><span class="line">    <span class="keyword">return</span> &#123;head,tail&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//反转单向链表</span></span><br><span class="line"><span class="function">Node* <span class="title">notLinks</span><span class="params">(Node* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">    Node *current = head;</span><br><span class="line">    Node *pre=<span class="literal">nullptr</span>;</span><br><span class="line">    Node *next= <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(current)&#123;</span><br><span class="line">        next = current-&gt;next; <span class="comment">// 首先记录current的下一个节点</span></span><br><span class="line">        current-&gt;next = pre; <span class="comment">// curent的下一个节点设置为前一个节点</span></span><br><span class="line">        pre = current; <span class="comment">// pre向前推进一个元素</span></span><br><span class="line">        current = next; <span class="comment">//current像前推进一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre; <span class="comment">//返回指向新链表的头节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BiNode* <span class="title">notBiLinks</span><span class="params">(BiNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">    BiNode *current = head;</span><br><span class="line">    BiNode *pre=<span class="literal">nullptr</span>;</span><br><span class="line">    BiNode *next= <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(current)&#123;</span><br><span class="line">        next = current-&gt;next; <span class="comment">// 首先记录current的下一个节点</span></span><br><span class="line">        current-&gt;next = pre; <span class="comment">// curent的下一个节点设置为前一个节点</span></span><br><span class="line">        current-&gt;pre = next;</span><br><span class="line">        pre = current; <span class="comment">// pre向前推进一个元素</span></span><br><span class="line">        current = next; <span class="comment">//current像前推进一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre; <span class="comment">//返回指向新链表的头节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BiNode* <span class="title">notBiLinks2</span><span class="params">(BiNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">    BiNode *current = head;</span><br><span class="line">    BiNode *newHead;</span><br><span class="line">    <span class="keyword">while</span>(current)&#123;</span><br><span class="line">        BiNode *tmp = current-&gt;pre;</span><br><span class="line">        current-&gt;pre = current-&gt;next;</span><br><span class="line">        current-&gt;next = tmp;</span><br><span class="line">        newHead = current;</span><br><span class="line">        current = current-&gt;pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead; <span class="comment">//返回指向新链表的头节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLinks</span><span class="params">(Node *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *tmp = head;</span><br><span class="line">    <span class="keyword">while</span> (tmp-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tmp-&gt;value &lt;&lt; <span class="string">"-&gt;"</span>;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; tmp-&gt;value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBiLinks</span><span class="params">(BiNode *head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"empty"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    BiNode *tmp = head;</span><br><span class="line">    <span class="keyword">while</span>(tmp-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"["</span>&lt;&lt;tmp-&gt;value&lt;&lt;<span class="string">"]"</span>&lt;&lt;<span class="string">"&lt;-&gt;"</span>;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"["</span>&lt;&lt;tmp-&gt;value&lt;&lt;<span class="string">"]"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Links</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node *head; <span class="comment">// 头节点</span></span><br><span class="line">    Links() : head(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="comment">//创建链表</span></span><br><span class="line">    Links(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v) &#123;</span><br><span class="line">        <span class="keyword">if</span>(v.empty())&#123;</span><br><span class="line">            head = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            Node *first = <span class="keyword">new</span> Node(v[<span class="number">0</span>]);</span><br><span class="line">            head = first;</span><br><span class="line">            Node *tmp = first;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.size(); ++i) &#123;</span><br><span class="line">                Node *node = <span class="keyword">new</span> Node(v[i]);</span><br><span class="line">                tmp-&gt;next = node;</span><br><span class="line">                tmp = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printLinks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node *tmp = head;</span><br><span class="line">        <span class="keyword">while</span> (tmp-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; tmp-&gt;value &lt;&lt; <span class="string">"-&gt;"</span>;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tmp-&gt;value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反转这个链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inverseLinks</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        Node *next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            next = head-&gt;next;</span><br><span class="line">            head-&gt;next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    Node *head = createLinks(v);</span><br><span class="line"><span class="comment">//    Node *CHead = createLinksCycle(v);</span></span><br><span class="line"><span class="comment">//    Node *IHead = notLinks(head);</span></span><br><span class="line">    <span class="keyword">auto</span> Binode = createBiNode(v);</span><br><span class="line"><span class="comment">//    auto *IBiHead = notBiLinks2(Binode.first);</span></span><br><span class="line"><span class="comment">//    auto BinodeC = createBiNodeCycle(v);</span></span><br><span class="line">    printLinks(head);</span><br><span class="line">    printBiLinks(Binode.first);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习_Theano使用技巧</title>
      <link href="/hexoblog/2017/03/22/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_Theano%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/hexoblog/2017/03/22/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_Theano%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="theano-介绍">theano 介绍</h2><p>Theano is a Python library that allows you to define, optimize, and evaluate mathematical expressions involving multi-dimensional arrays efficiently. (http://deeplearning.net/software/theano/)</p><a id="more"></a><h2 id="theano-安装">theano 安装</h2><p>（http://deeplearning.net/software/theano/install_windows.html#install-windows） Windows平台成功的安装方式，先安装anaconda, 然后执行 <code>$ conda install mingw libpython</code></p><p><strong>错误信息</strong> . collect2.exe: error: ld returned 1 exit status</p><h2 id="theano-基本操作">theano 基本操作</h2><h3 id="引入常用的包">引入常用的包</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> theano <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> theano.tensor <span class="keyword">as</span> T</span><br><span class="line"><span class="comment">## 计算卷积的函数</span></span><br><span class="line"><span class="keyword">from</span> theano.tensor.nnet <span class="keyword">import</span> conv</span><br></pre></td></tr></table></figure><h3 id="函数的定义和计算">函数的定义和计算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 标量</span></span><br><span class="line">x = T.dscalar(<span class="string">'a'</span>)</span><br><span class="line">y = T.dscalar(<span class="string">'b'</span>)</span><br><span class="line">z = x * y ** <span class="number">2</span></span><br><span class="line">f = function([x,y],z)</span><br><span class="line"><span class="comment"># 向量</span></span><br><span class="line">x = T.vector(<span class="string">'a'</span>)</span><br><span class="line">z = x + x</span><br><span class="line">f = function([x],z)</span><br><span class="line">f([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="comment"># 矩阵</span></span><br><span class="line">x = T.dmatrix(<span class="string">'x'</span>)</span><br><span class="line">y = T.dmatrix(<span class="string">'y'</span>)</span><br><span class="line">z = x + y</span><br><span class="line">f = function([x,y],z)</span><br><span class="line">f(np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]),np.array([[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 逻辑回归函数</span></span><br><span class="line"><span class="comment"># 验证 1 / (1 + T.exp(-x))   == (1 + T.tanh(x/2)) / 2</span></span><br><span class="line">x = T.dmatrix(<span class="string">'x'</span>)</span><br><span class="line">s = <span class="number">1</span> / (<span class="number">1</span> + T.exp(-x))</span><br><span class="line">f = function([x],s)</span><br><span class="line">f(np.array([[<span class="number">4</span>,<span class="number">-1</span>],[<span class="number">2</span>,<span class="number">3</span>]]))</span><br><span class="line"></span><br><span class="line">s2 = (<span class="number">1</span> + T.tanh(x/<span class="number">2</span>)) / <span class="number">2</span></span><br><span class="line">f2 = function([x],s2)</span><br><span class="line">f2(np.array([[<span class="number">4</span>,<span class="number">-1</span>],[<span class="number">2</span>,<span class="number">3</span>]]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 一次计算多个函数</span></span><br><span class="line">a,b = T.dmatrices(<span class="string">'a'</span>,<span class="string">'b'</span>)</span><br><span class="line">f1 = a + b</span><br><span class="line">f2 = a - b</span><br><span class="line">f3 = a*b</span><br><span class="line">f4 = a**b</span><br><span class="line">f = function([a,b],[f1,f2,f3,f4])</span><br><span class="line">ss = f(np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">5</span>]]),np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">5</span>]]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为输入参数设置默认值</span></span><br><span class="line"><span class="keyword">from</span> theano <span class="keyword">import</span> In</span><br><span class="line">x,y = T.dscalars(<span class="string">'x'</span>,<span class="string">'y'</span>)</span><br><span class="line">z = x + y</span><br><span class="line">f = function([x,In(y,value=<span class="number">1</span>)],z)</span><br><span class="line"><span class="comment"># 只传入x， y的默认值就是1</span></span><br><span class="line">f(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 截止到目前为止，变量都只是在函数内部使用，没有共享</span></span><br><span class="line"><span class="comment"># 下面看看如何实现值的累加</span></span><br><span class="line"><span class="keyword">from</span> theano <span class="keyword">import</span> shared</span><br><span class="line">count = shared(<span class="number">0</span>) <span class="comment"># 计数值初始化为0</span></span><br><span class="line">inc = T.iscalar(<span class="string">'inc'</span>)</span><br><span class="line">f = function([inc],count,updates=[(count,count+inc)])</span><br><span class="line">f(<span class="number">10</span>)</span><br><span class="line">f(<span class="number">2</span>)</span><br><span class="line">count.get_value()</span><br><span class="line">count.set_value(<span class="number">-1</span>)</span><br><span class="line">count.get_value()</span><br><span class="line"></span><br><span class="line"><span class="comment">## 随机数</span></span><br><span class="line"><span class="keyword">from</span> theano.tensor.shared_randomstreams <span class="keyword">import</span> RandomStreams</span><br><span class="line">srng = RandomStreams(seed=<span class="number">234</span>)</span><br><span class="line">rv_u = srng.uniform((<span class="number">2</span>,<span class="number">2</span>)) <span class="comment"># 均匀分布的随机数</span></span><br><span class="line">rv_n = srng.normal((<span class="number">2</span>,<span class="number">2</span>)) <span class="comment"># 正太分布的随机数</span></span><br><span class="line">f = function([],rv_u)</span><br><span class="line">g = function([],rv_n,no_default_updates = <span class="literal">True</span>)</span><br><span class="line">nearly_zeros = function([],rv_u + rv_u<span class="number">-2</span> * rv_u)</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">g()</span><br><span class="line">nearly_zeros()</span><br><span class="line"><span class="comment"># 设置随机数发生器的种子</span></span><br><span class="line">rng_val = rv_u.rng.get_value(borrow=<span class="literal">True</span>)</span><br><span class="line">rng_val.seed(<span class="number">100</span>)</span><br><span class="line">rv_u.rng.set_value(rng_val,borrow=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="求函数的导数">求函数的导数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> theano</span><br><span class="line"><span class="keyword">import</span> theano.tensor <span class="keyword">as</span> T</span><br><span class="line"><span class="keyword">from</span> theano <span class="keyword">import</span> pp</span><br><span class="line">x = T.dscalar(<span class="string">'x'</span>)</span><br><span class="line">y = x ** <span class="number">2</span></span><br><span class="line">gy = T.grad(y,x)</span><br><span class="line">pp(gy)</span><br><span class="line"></span><br><span class="line">f = theano.function([x], gy)</span><br><span class="line">f(<span class="number">4</span>)  <span class="comment"># x的平方的导数</span></span><br></pre></td></tr></table></figure><h3 id="卷积操作">卷积操作</h3><h4 id="d卷积">2D卷积</h4><p>theano计算卷积的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> theano.tensor.nnet <span class="keyword">import</span> conv2d</span><br><span class="line">output = conv2d(</span><br><span class="line">    input, filters, input_shape=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>), filter_shape=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>),</span><br><span class="line">    border_mode=(<span class="number">1</span>, <span class="number">1</span>), subsample=(<span class="number">2</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>上式计算的是类似下面这样的卷积：</p><div class="figure"><img src="2017-05-12_161131.png"></div><p>其中各个参数的含义是：</p><ul><li>input(batch size, input channels, input rows, input columns)</li></ul><blockquote><p>batch size : 一次处理的样本数量 input channels : input feature map 的数量 input rows: input feature map 的行 input columns: input feature map 的列</p></blockquote><ul><li>filters(output channels, input channels, filter rows, filter columns).</li></ul><blockquote><p>output channels ： output feature map 的数量 input channels : input feature map 的数量 filter rows ：卷积核的行 filter columns : 卷积核的列</p></blockquote><ul><li>input_shape(batch size (b), input channels (c), input rows (i1), input columns (i2))</li></ul><blockquote><p>batch size : 一次处理的样本数量 input channels : input feature map 的个数 input rows: input feature map 的行 input columns : input feature map 的列</p></blockquote><ul><li>filter_shape(output channels (c1), input channels (c2), filter rows (k1), filter columns (k2))</li></ul><blockquote><p>output channels ： output feature map 的个数 input channels : input feature map 的个数 filter rows &amp; filter columns ： 卷积核的大小</p></blockquote><ul><li>border_mode: ‘valid’, ‘half’, ‘full’ or (p_1, p_2)</li></ul><blockquote><p>边缘补0的模式。</p></blockquote><ul><li>subsample: (s1, s2)</li></ul><blockquote><p>定义卷积核的步长。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
            <tag> theano </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_人脸识别</title>
      <link href="/hexoblog/2017/03/22/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
      <url>/hexoblog/2017/03/22/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="现有平台">现有平台</h2><ul><li><p>Face++ 旷世 （https://www.faceplusplus.com.cn/） <img src="2017-03-22_154013.png" alt="2017-03-22_154013.png"></p></li><li><p>商汤科技 （http://www.sensetime.com/index/）</p></li><li><p>云从科技 （http://www.cloudwalk.cn/index.html）</p></li><li><p>腾讯优图</p></li><li><p>百度人脸团队</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客收藏</title>
      <link href="/hexoblog/2017/03/22/%E6%94%B6%E8%97%8F%E5%A4%B9/%E5%8D%9A%E5%AE%A2%E9%9B%86%E9%94%A6/"/>
      <url>/hexoblog/2017/03/22/%E6%94%B6%E8%97%8F%E5%A4%B9/%E5%8D%9A%E5%AE%A2%E9%9B%86%E9%94%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="bloom-filter概念和原理">Bloom Filter概念和原理</h2><p>http://blog.csdn.net/jiaomeng/article/details/1495500</p>]]></content>
      
      
      <categories>
          
          <category> 收藏夹 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 收藏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法专题_位运算</title>
      <link href="/hexoblog/2017/03/21/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/hexoblog/2017/03/21/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>每种编程语言中都会有相关的位运算操作符，实现二进制的按位运算。 位运算有四种：与(&amp;)，或(|)，非(~),异或(^) 熟悉每种位运算的特点，是做与位运算有关的题目的基础。</p><a id="more"></a><h2 id="与">与(&amp;)</h2><ul><li><code>0&amp;0=0; 0&amp;1=0; 1&amp;0=0; 1&amp;1=1;</code></li><li>仔细观察上面的操作，发现与操作的结果与二进制加法的进位规则非常一致。 <code>0+0=0 ; 0+1=0; 1+0=0; 1+1 = 1;</code> (此处等号后面的数字表示应该的进位)</li><li><code>n = n&amp;(n-1)</code> 该操作的效果是把n的最后一个二进制1变为0. 此操作在涉及统计二进制数中1的个数的时候比较有用。</li><li><code>n = n&amp;(~n+1)</code> 该操作的效果是把n的最右边的二进制1留下，其余的1全部置0.</li><li><code>n = n&amp;(-n)</code> 该操作的效果是得到n的最后一个1</li></ul><h2 id="或">或(|)</h2><ul><li><code>0|0=0; 0|1=1; 1|0=1; 1|1=1;</code></li><li>``</li></ul><h2 id="非">非(~)</h2><ul><li><code>~0=1; ~1=0</code></li></ul><h2 id="异或">异或(^)</h2><ul><li><code>0^0=0;1^1=0; 0^1=1;1^0=1;</code></li><li>仔细观察上面的操作，发现异或操作的结果与二进制加法(忽略进位的情况下)规则一致。 <code>0+0=0;0+1=1;1+0=1;1+1=0;</code>(此处等号后面的数字是无进位加法的结果)</li><li><code>a^0=a; a^a=0; a^a^a=a</code> 偶数个a异或的结果是0，奇数个a异或的结果是a.</li><li><code>a^(a^b)=b;b^(a^b)=a;</code> 此规则可以用来交换两个数字，无需额外的空间</li></ul><h2 id="除法">除法</h2><ul><li><code>(a)/(a &amp; (-a));</code>, 去除末尾的若干个0. 例如 1011000 -&gt; 1011</li></ul><h2 id="相关的应用">相关的应用</h2><h3 id="交换两个整数不适用额外的空间">交换两个整数(不适用额外的空间)</h3><p>此题是典型的利用异或运算的性质求解的题。 - <code>a^a = 0;  a^0 = a;</code> - <code>a^(a^b) = b ; b^(a^b) = a ;</code> 具体的交换代码如下： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a^b;</span><br><span class="line">b = a^b;</span><br><span class="line">a = a^b;</span><br></pre></td></tr></table></figure></p><p>分析一下这三行代码，我们把原来的a,b 记作a1,b1;把交换之后的记作a2,b2;最后要达到的结果是a2=b1;b2=a1; 第一行，<code>a=a^b</code>, 此时a的值已经改变，变成了<code>a^b</code>的值； 第二行变成<code>b = (a^b)^b = a</code>, 此时b的值已经改变，变成了a的值。 第三行，此时的<code>a=a^b</code>,而<code>b=a</code>,所以 <code>a=a^b=(a^b)^a=b</code>,a变成了b的值。 通过分析可以发现，其实充当暂存中间结果的变量是a, a先存储了a^b的值，然后去跟b异或得到a,再跟得到的a异或得到b. 而一般的需要第三个变量做中介的交换思路是首先把b存起来，因为在b=a时，b的值丢失了。之所以利用异或不怕b的值丢失， 是因为可以利用得到的a再次得到b.</p><h3 id="不用比较找出两个数中较大的数">不用比较找出两个数中较大的数</h3><p><img src="2017-03-21_222908.png" alt="2017-03-21_222908.png"> 不用比较运算符比较两个数字的大小，可以使用减法运算符。 如果也不能使用减法运算符，可以考虑只使用位运算实现减法运算。 <code>a-b = c</code> 如果<code>c&gt;0,a&gt;b;</code> 如果<code>c&lt;0;c&lt;b;</code>但是不幸的是，还是用到的<code>&lt;</code>或者<code>&gt;</code> C++中有函数<code>signbit(x)</code>可以返回x的符号，使用的时候需要注意包含头文件<code>#include &lt;cmath&gt;</code> 另外需要注意的问题就是整数的溢出，<code>a-b</code>如果a是正数，b是负数，就会变成两个整数相加，这时候如果二者都接近 INT类型表示的边界，就会超出能够表示的最大的数的范围，产生正溢出。 同理，如果a是负数,b是正数，同样可能超出 能够表示的最小的负数的范围，产生负溢出。 幸运的是，如果知道二者异号，很容易判断谁大谁小。所以先判断是否是异号比较好，可以防止数据溢出产生错误。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//找出两个数中较大的数字，不使用任何比较运算</span></span><br><span class="line"><span class="comment">// 不比较两个元素，只能做差</span></span><br><span class="line"><span class="comment">//两个数做差或涉及到溢出的问题</span></span><br><span class="line"><span class="comment">// a - b 如果a 接近最大的整数，b接近最大的负数， 就会溢出</span></span><br><span class="line"><span class="comment">// a- b 如果a 接近最大的负数，b接近最大的正数，也会溢出</span></span><br><span class="line"><span class="comment">//所以先判断正负，再做差</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(signbit(a) &amp;&amp; !signbit(b))&#123;<span class="keyword">return</span> b;&#125;</span><br><span class="line">    <span class="keyword">if</span>(signbit(b) &amp;&amp; !signbit(a))&#123;<span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="keyword">if</span>(signbit(a-b))&#123;<span class="keyword">return</span> b;&#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;getMax(<span class="number">5435651</span>,<span class="number">-2393</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不使用任何算术运算只使用位运算实现加减乘除">不使用任何算术运算只使用位运算实现加减乘除</h3><ul><li><p>加法运算的思路 不考虑进位的情况下， <code>a^b</code> 就是<code>a+b</code>的结果 只考虑进位的情况下， <code>(a&amp;b)&lt;&lt;1</code> 就是<code>a+b</code>的结果 所以综合二者，就能得到加法的正确答案。</p></li><li><p>减法的思路 <code>a-b = a+(-b);</code> 而<code>-b = ~b+1</code> 每个二进制位取反再加1.</p></li><li><p>乘法运算的思路 a*b 把b看成二进制位，每次把a左移（相当于乘以2），看b对应的位置上是否是1， 是1就将结果加到最终的结果上，是0就不加，返回最后的结果。</p></li><li><p>除法运算的思路 <img src="2017-03-21_223709.png" alt="2017-03-21_223709.png"> <img src="2017-03-21_223758.png" alt="2017-03-21_223758.png"> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用位运算实现加法运算</span></span><br><span class="line"><span class="comment"> * 按照二进制位加法 0 + 0 = 0 | 0 + 1 = 1 | 1 + 1 = 0</span></span><br><span class="line"><span class="comment"> * 如果不考虑进位，该规则正好与异或相同</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 考虑什么时候会产生进位 0 + 0 = 0 0 + 1 = 0 1+ 1 = 1</span></span><br><span class="line"><span class="comment"> * 该规则正好与  &amp; 运算一致</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 所以分别考虑无进位相加和只考虑进位的结果  加在一起就好了。</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum =a ;</span><br><span class="line">    <span class="keyword">while</span>(b!=<span class="number">0</span>)&#123;</span><br><span class="line">        sum = a ^ b;</span><br><span class="line">        b = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        a = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用位实现减法运算， 不能用-运算符</span></span><br><span class="line"><span class="comment"> * @param a</span></span><br><span class="line"><span class="comment"> * @param b</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minus2</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="comment">// a - b == a + (-b)</span></span><br><span class="line">    <span class="comment">// -b == ~b + 1</span></span><br><span class="line">    add(a,add(~b,<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用位运算实现乘法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cheng</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">            sum = add(sum,a);</span><br><span class="line">        &#125;</span><br><span class="line">        a&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cheng(<span class="number">-20</span>,<span class="number">500</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ul><h3 id="整数的二进制表达中有多少个1">整数的二进制表达中有多少个1</h3><p>题目： 给定一个32位的整数，可0，可正，可负，返回该整数的二进制表达中有多少个1. 第一种方法是每次右移，然后统计1的个数，这种方法需要统计32次。 第二种方法只有原来数字中有多少个1有关，1越少速度越快。 n = n&amp;(n-1) 该操作可以抹掉n最右边的1 n = n&amp;(~n+1) 该操作可以得到n最右侧的1 使用上面的任意一种操作，可以设计算法实现只与1的个数有关的算法。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统计整数的二进制表达中有多少个1</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&amp;<span class="number">1</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * n&amp;(n-1)的作用就是消除n最右边的1</span></span><br><span class="line"><span class="comment"> * @param a</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSumA</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a!=<span class="number">0</span>)&#123;</span><br><span class="line">        a = a&amp;(a<span class="number">-1</span>);</span><br><span class="line">        ++sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; getSumA(<span class="number">8</span>)&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="找出一个只出现一次的数字">找出一个只出现一次的数字</h3><p>题目： 一个整数数组中，只有一个数字只出现了一次，其他所有数字都出现的两次，找出这个出现一次的数字。 变种： 一个整数数组中，只有一个数字出现了奇数次，其他所有的数字都出现了偶数次，找出这个出现奇数次的数字。 了解异或运算特点，<code>a^a = 0;  a^0 = a; a^a^a = a;</code> 出现偶数次的数在异或运算下都是0，出现奇数次的数异或之后就是它本身。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只有一个数字出现了奇数次，其余的数字都出现了偶数次，找出这个数字</span></span><br><span class="line"><span class="comment"> * 找出这个数字</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">research</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> re = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> a:v)&#123;</span><br><span class="line">        re = re ^ a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个题目还可以从另外一个角度去理解，K个K进制的数字如果忽略进位相加的话，结果一定是0.那么nK个K进制的数字相加的话，结果 也一定是0. 而异或恰好是二进制无进位相加的实现。 了解了这一点，如果我们能够像异或这样，实现任意的K进制数无进位相加的结果，就可以解决下面这样的问题： 在其他数字都出现K次的数组中找出只出现一次的数字。</p><h3 id="找出两个只出现一次的数字">找出两个只出现一次的数字</h3><p>题目：一个整数数组中，只有两个数字只出现了一次，其他所有数字都出现的两次，找出这两个数字。 思路：异或一遍之后得到的结果是a^b， a,b必然有一位是不同的(如果结果是0，那么a=b，说明并没有两个只出现一次的数字)。 根据这个二进制位将原来的数据分成两组，分别异或一遍即可得到这两个数字。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只有两个数出现了奇数次，找出这两个数</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; research2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">int</span> r1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : v)&#123;</span><br><span class="line">        r1 = r1 ^ i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> bit1 = r1 &amp; (~r1 +<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ab = <span class="number">0</span>; <span class="comment">// 现在r1保存的是两个出现奇数次的数的异或</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> j : v)&#123;</span><br><span class="line">        <span class="keyword">if</span>((j&amp;bit1) != <span class="number">0</span>)&#123;</span><br><span class="line">           ab = ab ^ j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result.push_back(ab);</span><br><span class="line">    result.push_back(ab^r1);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="找出三个只出现一次的数字">找出三个只出现一次的数字</h3><p>题目：一个整数数组中，只有三个数字只出现了一次，其他所有数字都出现的两次，找出这三个数字。 思路：整体异或一遍，得到<code>x=a^b^c</code>. 设<code>f(x)</code>表示获取x的最后一位二进制1，例如<code>f(10100)=00100</code>. <code>n = f(x^a)^f(x^b)^f(x^c)</code>, 设n的最后一个二进制位1在第m位上。则有<code>x^a,x^b,x^c</code>只有一个数字在第m位上是1，其余的两个数字在第m位上都是0. (具体的推导过程参考<a href="http://zhedahht.blog.163.com/blog/static/25411174201283084246412/" target="_blank" rel="noopener">这里</a>).</p><p>算法步骤：</p><ol style="list-style-type: decimal"><li><code>abc = 0;  循环一遍：abc^=v[i]</code> , 得到<code>x=a^b^c</code>;</li><li><code>g1 = 0; 循环一遍：g1^=getLastOne(abc^v[i]);</code>, 得到上面提到的n.</li><li><code>g1 = getLastOne(g1)</code>, 得到分界数字，上面提到的第m位置1的数字。</li><li>把所有满足<code>getLastOne( v[i] ^ abc ) == g1</code>条件的分成一组，该组中只包含<code>a,b,c</code>三个数字中的一个数字，异或一遍，得到a.</li><li>剩下的就是找到两个数字了。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLastOne</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &amp; -(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v,<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b,<span class="keyword">int</span> &amp;c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.size() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> abc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();i++)&#123;</span><br><span class="line">        abc = abc ^ v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> g1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();i++)&#123;</span><br><span class="line">        g1 = g1 ^ getLastOne(abc^v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// g1 只有1位是1，a,b,c中只有一个数字的这一位是1</span></span><br><span class="line">    g1 = getLastOne(g1);</span><br><span class="line">    a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(getLastOne( v[i] ^ abc ) == g1)&#123;</span><br><span class="line">            a = a ^ v[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> bc = abc ^ a;</span><br><span class="line">    <span class="keyword">int</span> g2 = getLastOne(bc);</span><br><span class="line">    b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i]&amp;g2 &amp;&amp; v[i]!=a)&#123;</span><br><span class="line">            b = b ^ v[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c = bc ^ b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在其他数字都出现k次的数组中找到只出现一次的数">在其他数字都出现K次的数组中找到只出现一次的数</h3><p>这里要明白一个规律，K个相同的K进制的数无进位相加的话，结果必然是0，因为所有是0的位还是0，所有不是0的位都加到了需要进位，除去进位，就是0. 明白了上面的一点，这个问题就容易解决了。首先把所有的数字转换成K进制，然后实现无进位相加的函数,再把结果转换回十进制输出即可。</p><p>另外一种解法：</p><p>可以统计所有数字每个二进制位上1的个数。然后每个二进制位对K取余，哪些出现K次的数字累加到对应位上的和肯定是K的倍数，取余之后就是0.剩下来的就是那个只出现一次的数字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个十进制的数转换成K进制</span></span><br><span class="line"><span class="comment"> * @param n</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; Kin(<span class="keyword">int</span> n,<span class="keyword">int</span> k)&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">while</span>(n/k != <span class="number">0</span>)&#123;</span><br><span class="line">        result.push_front(n%k);</span><br><span class="line">        n = n / k;</span><br><span class="line">    &#125;</span><br><span class="line">    result.push_front(n);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将K进制的deque转换成10进制</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kinverse</span><span class="params">(<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; v,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!v.empty())&#123;</span><br><span class="line">        s += v.back() * <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="keyword">float</span>(k),i);</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现两个vector按照K进制相加，忽略进位</span></span><br><span class="line"><span class="comment"> * @param v1</span></span><br><span class="line"><span class="comment"> * @param v2</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; addV(<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; v1,<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; v2,<span class="keyword">int</span> k)&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span>(v1.size() &lt; v2.size())&#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp = v1;</span><br><span class="line">        v1 = v2;</span><br><span class="line">        v2 = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!v2.empty())&#123;</span><br><span class="line">        result.push_front( (v1.back() + v2.back() ) % k );</span><br><span class="line">        v1.pop_back();</span><br><span class="line">        v2.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!v1.empty())&#123;</span><br><span class="line">        result.push_front( v1.back() );</span><br><span class="line">        v1.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现v中的十进制数按照K进制相加，忽略进位，返回和</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> * @param k</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kplus</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : v)&#123;</span><br><span class="line">        result = addV(result,Kin(i,k),k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Kinverse(result,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    vector&lt;int&gt; v = &#123;1,2,2,3,3,4,4,5,5,70&#125;;</span></span><br><span class="line"><span class="comment">//    auto reuslt = research2(v);</span></span><br><span class="line"><span class="comment">//    std::cout &lt;&lt; reuslt[0] &lt;&lt;" "&lt;&lt;reuslt[1] &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Kplus(v,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; counts(<span class="number">64</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = v[i];</span><br><span class="line">        <span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                counts[index]++;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();i++)&#123;</span><br><span class="line">        counts[i] = counts[i] % k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> base = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;counts.size();i++)&#123;</span><br><span class="line">        number += counts[i] * base;</span><br><span class="line">        base  = base *<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速的求一个整数的n次方">快速的求一个整数的N次方</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * f(n) = f(n-1) + f(n-2)</span></span><br><span class="line"><span class="comment"> * 1 1 2 3 5 8 ...</span></span><br><span class="line"><span class="comment"> * 要求实现O(logn)的算法</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">            v.insert(v.end(),<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">            v.insert(v.end(),<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            v.insert(v.end(),v[i<span class="number">-2</span>]+v[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:v)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v.back();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param n</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNum2</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> s = n&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">double</span> t = powf(<span class="number">2</span>,i);</span><br><span class="line">            sum += powf(a,t);</span><br><span class="line">        &#125;</span><br><span class="line">        n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="450" src="//music.163.com/outchain/player?type=0&amp;id=631401164&amp;auto=1&amp;height=430"></iframe>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵和用矩阵表示的图的相关问题</title>
      <link href="/hexoblog/2017/03/21/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E7%9F%A9%E9%98%B5%E5%92%8C%E5%9B%BE/"/>
      <url>/hexoblog/2017/03/21/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E7%9F%A9%E9%98%B5%E5%92%8C%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>图，路径，矩阵操作的相关问题。 <a id="more"></a></p><h2 id="旋转打印矩阵">旋转打印矩阵</h2><p>设计一个函数，打印矩阵的最外层，然后循环调用这个函数， 可以实现旋转打印矩阵。同样，矩阵整体旋转多少度的问题也可以这样 解决，设计一个旋转最外层的函数，每次调用这个函数，就可以实现整个 矩阵的旋转。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顺时针打印矩阵最外层</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printEdge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m,<span class="keyword">int</span> li,<span class="keyword">int</span> lj,<span class="keyword">int</span> ri,<span class="keyword">int</span> rj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(li == ri) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = lj; j &lt;= rj; ++j) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; m[li][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(lj == rj)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=li;i&lt;=ri;++i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;m[i][lj]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = li;</span><br><span class="line">    <span class="keyword">int</span> j = lj;</span><br><span class="line">    <span class="keyword">while</span>(i == li &amp;&amp; j &lt;= rj)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;m[i][j]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    --j;</span><br><span class="line">    ++i;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=ri&amp;&amp;j==rj)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;m[i][j]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    --i;</span><br><span class="line">    --j;</span><br><span class="line">    <span class="keyword">while</span>(i == ri &amp;&amp; j&gt;=lj)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;m[i][j]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        --j;</span><br><span class="line">    &#125;</span><br><span class="line">    ++j;</span><br><span class="line">    --i;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;li &amp;&amp; j==lj)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;m[i][j]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        --i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逆时针打印矩阵的最外层</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> * @param li</span></span><br><span class="line"><span class="comment"> * @param lj</span></span><br><span class="line"><span class="comment"> * @param ri</span></span><br><span class="line"><span class="comment"> * @param rj</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printEdge2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v,<span class="keyword">int</span> li,<span class="keyword">int</span> lj,<span class="keyword">int</span> ri,<span class="keyword">int</span> rj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=li;</span><br><span class="line">    <span class="keyword">int</span> j=lj;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= ri &amp;&amp; j == lj)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;v[i][j]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    --i;</span><br><span class="line">    ++j;</span><br><span class="line">    <span class="keyword">while</span>(i == ri &amp;&amp; j &lt;= rj)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;v[i][j]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    --j;</span><br><span class="line">    --i;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=li &amp;&amp; j==rj)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;v[i][j]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        --i;</span><br><span class="line">    &#125;</span><br><span class="line">    ++i;</span><br><span class="line">    --j;</span><br><span class="line">    <span class="keyword">while</span>(i == li &amp;&amp; j&gt;lj)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;v[i][j]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        --j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顺时针旋转矩阵最外圈90度</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> * @param li</span></span><br><span class="line"><span class="comment"> * @param lj</span></span><br><span class="line"><span class="comment"> * @param ri</span></span><br><span class="line"><span class="comment"> * @param rj</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotateEdge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;v,<span class="keyword">int</span> li,<span class="keyword">int</span> lj,<span class="keyword">int</span> ri,<span class="keyword">int</span> rj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> times = ri - li;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>;c&lt;times;++c)&#123;</span><br><span class="line">        tmp = v[li][lj+c];</span><br><span class="line">        v[li][lj+c] = v[ri-c][lj];</span><br><span class="line">        v[ri-c][lj] = v[ri][rj-c];</span><br><span class="line">        v[ri][rj-c] = v[li+c][rj];</span><br><span class="line">        v[li+c][rj] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逆时针旋转最外圈90度</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> * @param li</span></span><br><span class="line"><span class="comment"> * @param lj</span></span><br><span class="line"><span class="comment"> * @param ri</span></span><br><span class="line"><span class="comment"> * @param rj</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotateEdge2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;v,<span class="keyword">int</span> li,<span class="keyword">int</span> lj,<span class="keyword">int</span> ri,<span class="keyword">int</span> rj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> times = ri-li;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;times;++c)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = v[li+c][lj];</span><br><span class="line">        v[li+c][lj] = v[li][rj-c];</span><br><span class="line">        v[li][rj-c] = v[ri-c][rj];</span><br><span class="line">        v[ri-c][rj] = v[ri][li+c];</span><br><span class="line">        v[ri][lj+c] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 旋转最外圈180 度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotateEdge3</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;v,<span class="keyword">int</span> li,<span class="keyword">int</span> lj,<span class="keyword">int</span> ri,<span class="keyword">int</span> rj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> times = ri - li;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>;c&lt;times;++c)&#123;</span><br><span class="line">        tmp = v[li][lj+c];</span><br><span class="line">        v[li][lj+c] = v[ri][rj-c];</span><br><span class="line">        v[ri][rj-c] = tmp;</span><br><span class="line">        tmp = v[li+c][rj];</span><br><span class="line">        v[li+c][rj] = v[ri-c][lj];</span><br><span class="line">        v[ri-c][lj] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顺时针打印矩阵</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printM1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = v.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> n = v[<span class="number">0</span>].size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a&lt;=m &amp;&amp; b &lt;= n)&#123;</span><br><span class="line">        printEdge(v,a,b,m,n);</span><br><span class="line">        ++a;</span><br><span class="line">        ++b;</span><br><span class="line">        --m;</span><br><span class="line">        --n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逆时针打印数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printM2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = v.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> n = v[<span class="number">0</span>].size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a&lt;=m &amp;&amp; b &lt;= n)&#123;</span><br><span class="line">        printEdge2(v,a,b,m,n);</span><br><span class="line">        ++a;</span><br><span class="line">        ++b;</span><br><span class="line">        --m;</span><br><span class="line">        --n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotateM</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = v.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> n = v[<span class="number">0</span>].size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a&lt;=m &amp;&amp; b &lt;= n)&#123;</span><br><span class="line">        rotateEdge(v,a,b,m,n);</span><br><span class="line">        ++a;</span><br><span class="line">        ++b;</span><br><span class="line">        --m;</span><br><span class="line">        --n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotateM2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = v.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> n = v[<span class="number">0</span>].size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a&lt;=m &amp;&amp; b &lt;= n)&#123;</span><br><span class="line">        rotateEdge2(v,a,b,m,n);</span><br><span class="line">        ++a;</span><br><span class="line">        ++b;</span><br><span class="line">        --m;</span><br><span class="line">        --n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 矩阵打印输出</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:v)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j:i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;j&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,&#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;,&#123;<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>&#125;&#125;;</span><br><span class="line">    print(v);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"---------------"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    rotateEdge3(v,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">    print(v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="之字型打印矩阵">之字型打印矩阵</h2><div class="figure"><img src="2017-03-22_143007.png" alt="2017-03-22_143007.png"><p class="caption">2017-03-22_143007.png</p></div><h2 id="在行和列都排序好的矩阵中寻找数">在行和列都排序好的矩阵中寻找数</h2><p><img src="2017-03-22_143218.png" alt="2017-03-22_143218.png"> - 提示： 从矩阵的右上角开始寻找。</p><h2 id="子矩阵的最大累加和问题">子矩阵的最大累加和问题</h2><p><img src="2017-03-22_143443.png" alt="2017-03-22_143443.png"> - 提示： 利用子数组的最大累加和的解法 - 必须含有两行的矩阵的累加和就是先把对应的列相加，形成一个向量，在求这个向量的最大累加和</p><h2 id="打印n个数组整体最大的top-k">打印N个数组整体最大的top K</h2><p><img src="2017-03-22_144046.png" alt="2017-03-22_144046.png"> <img src="2017-03-22_145742.png" alt="2017-03-22_145742.png"></p><h2 id="边界都是1的最大正方形的大小">边界都是1的最大正方形的大小</h2><div class="figure"><img src="2017-03-22_150725.png" alt="2017-03-22_145906.png"><p class="caption">2017-03-22_145906.png</p></div><h2 id="打印最短通路值">打印最短通路值</h2><p><img src="2017-03-22_150224.png" alt="2017-03-22_150224.png"> 时间复杂度O（N<em>M），使用宽度优先搜索。 ## 矩阵的最小路径和 <img src="2017-03-22_102322.png" alt="2017-03-22_102322.png"> 用动态规划的方法，dp[i][j]表示从左上角走到i,j的最小路径和。 时间复杂度O（M</em>N），空间复杂度经过优化之后可以达到O(min{M,N})</p><h2 id="龙与地下城游戏问题">龙与地下城游戏问题</h2><p><img src="2017-03-22_110145.png" alt="2017-03-22_110145.png"> dp[i][j] 表示骑士在位置i,j的时候，如果要能走到最后，最少应该具有的血量。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="n皇后问题">N皇后问题</h2><div class="figure"><img src="2017-03-22_110620.png" alt="2017-03-22_110620.png"><p class="caption">2017-03-22_110620.png</p></div>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法专题_二维数组</title>
      <link href="/hexoblog/2017/03/21/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"/>
      <url>/hexoblog/2017/03/21/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>主要是关于两个数组，两个字符串的相关问题。 <a id="more"></a></p><h2 id="最长公共子序列"><a href="http://lintcode.com/zh-cn/problem/longest-common-subsequence/#" target="_blank" rel="noopener">最长公共子序列</a></h2><div class="figure"><img src="2017-03-21_093231.png"></div><p>解法: 动态规划。设<code>str1</code>长度是<code>m</code>, <code>str2</code>长度是<code>n</code>, 开一个大小是<code>dp[m+1][n+1]</code>的二维数组，<code>dp[0][j]</code>和<code>dp[i][0]</code>分别表示第一行和第一列，全部初始化为0. <code>dp[i][j]</code>表示<code>str1</code>前<code>i</code>个字符和<code>str2</code>前<code>j</code>个字符组成的最长公共子序列的长度。<code>dp[0][0]</code>表示两个字符串都是空串的情况下最长公共子序列的长度为0.</p><p>递推公式： <code>dp[i][j] = max(dp[i-1][j],dp[i][j-1])</code>, <code>dp[i][j] = max(dp[i][j],dp[i-1][j-1]+1) if(str1[i] == str2[j])</code></p><p>含义是： <code>str1[i]</code>和 <code>str2[j]</code> 的最长公共子序列 首先应该是 <code>str1[i-1]</code>与<code>str2[j]</code> <code>str[i</code>]与<code>str2[j-1]</code> 中较长的那个， 然后比较 <code>str1[i]</code>与<code>str2[j]</code>是否相等，如果相等，还可能是<code>str1[i-1]str2[j-1]</code>的长度 + 1 与当前的<code>dp[i][j]</code>中较大的那个。</p><p>输出找到的最长公共子序列的方法：</p><ol style="list-style-type: decimal"><li><p>如果格子<code>dp[i][j]</code>对应的<code>str1[i-1] == str2[j-1]</code>，则把这个字符放入 LCS 中，并跳入<code>dp[i-1][j-1]</code>中继续进行判断；</p></li><li><p>如果格子<code>dp[i][j]</code>对应的 <code>str1[i-1] ≠str2[j-1]</code>，则比较<code>dp[i-1][j]</code>和<code>dp[i][j-1]</code>的值，跳入值较大的格子继续进行判断；(如果相等，说明存在多个最长的子序列)</p></li><li><p>直到<code>i</code>或<code>j</code> 小于等于零为止，倒序输出 LCS 。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxlength</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1,<span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">size_t</span> m = s1.size();</span><br><span class="line">    <span class="keyword">size_t</span> n = s2.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>)); <span class="comment">// 第一行，第一列初始化为0</span></span><br><span class="line">    <span class="comment">//动态规划的递推公式</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(s1[i<span class="number">-1</span>] == s2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                dp[i][j] = max(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最长的子序列</span></span><br><span class="line">    <span class="keyword">int</span> i = m;</span><br><span class="line">    <span class="keyword">int</span> j = n;</span><br><span class="line">    <span class="built_in">string</span> cstr ;</span><br><span class="line">    <span class="keyword">while</span>(i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1[i<span class="number">-1</span>] == s2[j<span class="number">-1</span>])&#123;</span><br><span class="line">            cstr.insert(cstr.begin(),s1[i<span class="number">-1</span>]);</span><br><span class="line">            i--; j--;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j] &gt;= dp[i][j<span class="number">-1</span>])&#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j] &lt; dp[i][j<span class="number">-1</span>])&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cstr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"2bcd"</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">"a2ed"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;getMaxlength(s1,s2) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长公共子串问题"><a href="http://lintcode.com/zh-cn/problem/longest-common-substring/#" target="_blank" rel="noopener">最长公共子串问题</a></h2><div class="figure"><img src="2017-03-21_093641.png" alt="2017-03-21_093641.png"><p class="caption">2017-03-21_093641.png</p></div><p>解法：动态规划。 <code>dp[i][j]</code>表示以<code>i,j</code>结尾的<code>str1,str2</code>的最长子串是多少； 如果<code>str1[i]!=str2[j]</code>,则为<code>0</code>，否则，<code>str1[i] == str[2][j]</code>,<code>dp[i][j] = dp[i-1][j-1]+1</code>; 找到dp表中最大的值输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 两个字符串的最长公共子串</span></span><br><span class="line"><span class="comment"> * @param s1</span></span><br><span class="line"><span class="comment"> * @param s2</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubstring</span><span class="params">(<span class="built_in">string</span> &amp;A, <span class="built_in">string</span> &amp;B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(A.empty() || B.empty()) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> m = A.size();</span><br><span class="line">    <span class="keyword">size_t</span> n = B.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i<span class="number">-1</span>] == B[j<span class="number">-1</span>])&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                ans = max(ans,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最长公共子串</span></span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ii = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j] &gt; tmp)&#123;</span><br><span class="line">                tmp = dp[i][j];</span><br><span class="line">                ii = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; A.substr(ii-ans,ans) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"1ab2345cd"</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">"12345ef"</span>;</span><br><span class="line">    getMaxC(s1,s2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小的编辑代价">最小的编辑代价</h2><p><img src="2017-03-21_094030.png" alt="2017-03-21_094030.png"> 解法：动态规划，dp[i][j]的值代表把str1[0…i-1]编辑成[str2[0..j-1] 的最小的代价。注意这里生成的是M+1，N+1的dp矩阵，第一行和第一列都是空字符， 用来表示全部添加或者全部删除。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最小编辑代价</span></span><br><span class="line"><span class="comment"> * @param a</span></span><br><span class="line"><span class="comment"> * @param b</span></span><br><span class="line"><span class="comment"> * @param ic</span></span><br><span class="line"><span class="comment"> * @param dc</span></span><br><span class="line"><span class="comment"> * @param rc</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">(<span class="built_in">string</span> a,<span class="built_in">string</span> b,<span class="keyword">int</span> ic,<span class="keyword">int</span> dc,<span class="keyword">int</span> rc)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果先删除在插入的代价小于直接替换的代价，那么就永远不使用直接替换</span></span><br><span class="line">    <span class="keyword">if</span>(dc+ic&lt;=rc)&#123;rc = dc+ic;&#125;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(a.size()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(b.size()+<span class="number">1</span>));</span><br><span class="line">    <span class="comment">//初始化第一列，把a[i]编辑成空串的代价</span></span><br><span class="line">    <span class="comment">//要把a[i]编辑成空串只有一种方法，就是把所有的字符都删除</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=a.size();++i)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dc*i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化第一行，把空串编辑成b[j]的方法也只有一种，就是插入相应的字符</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=b.size();++j)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = ic*j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//动态规划的递推公式</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a.size();++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=b.size();++j)&#123;</span><br><span class="line">            dp[i][j] = min(dp[i<span class="number">-1</span>][j]+dc,dp[i][j<span class="number">-1</span>]+ic);</span><br><span class="line">            <span class="keyword">if</span>(a[i<span class="number">-1</span>] == b[j<span class="number">-1</span>])&#123;</span><br><span class="line">                dp[i][j] = min(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = min(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+rc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出动态规划表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> row : dp)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> cow : row)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;cow&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  dp[a.size()][b.size()];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a = <span class="string">"ab12cd3"</span>;</span><br><span class="line">    <span class="built_in">string</span> b = <span class="string">"abcdf"</span>;</span><br><span class="line">    <span class="keyword">int</span> ic = <span class="number">5</span>; <span class="keyword">int</span> dc = <span class="number">3</span>; <span class="keyword">int</span> rc = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; getMin(a,b,ic,dc,rc) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="字符串的交错组成">字符串的交错组成</h2><p><img src="2017-03-21_094649.png" alt="2017-03-21_094649.png"> 解法： 动态规划，生成M+1，N+1的dp矩阵，dp[i][j]表示aim[0,i+j-1] 能否被str1[0…i-1]和str2[0…j-1]交错组成。注意第一行和第一列都是空串。 aim[-1]表示aim为空串的时候。str1[-1],str2[-1]都表示是空串的时候。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符串的交错组成</span></span><br><span class="line"><span class="comment"> * 判断aim能够由str1  and str2 交错组成</span></span><br><span class="line"><span class="comment"> * @param s1</span></span><br><span class="line"><span class="comment"> * @param s2</span></span><br><span class="line"><span class="comment"> * @param aim</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isCom</span><span class="params">(<span class="built_in">string</span> s1,<span class="built_in">string</span> s2,<span class="built_in">string</span> aim)</span></span>&#123;</span><br><span class="line">    <span class="comment">//先从长度判断</span></span><br><span class="line">    <span class="keyword">if</span>(s1.size() + s2.size() != aim.size())&#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(s1.size()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(s2.size()+<span class="number">1</span>));</span><br><span class="line">    <span class="comment">//空串可以被空串交错组成</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//初始化第一列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s1.size();++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1[i<span class="number">-1</span>] != aim[i<span class="number">-1</span>])&#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化第一行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;s2.size();++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s2[j<span class="number">-1</span>] != aim[j<span class="number">-1</span>])&#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s1.size();++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=s2.size();++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i<span class="number">-1</span>] == aim[i+j<span class="number">-1</span>] &amp;&amp; dp[i<span class="number">-1</span>][j]</span><br><span class="line">                    || s2[j<span class="number">-1</span>] == aim[i+j<span class="number">-1</span>] &amp;&amp; dp[i][j<span class="number">-1</span>])&#123;</span><br><span class="line">                dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出dp数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:dp)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j:i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;j&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s1.size()][s2.size()];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"ABC"</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">"123"</span>;</span><br><span class="line">    <span class="built_in">string</span> aim = <span class="string">"12AA3C"</span>;</span><br><span class="line">    <span class="keyword">auto</span> result = isCom(s1,s2,aim);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;result;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="判断两个字符串是否互为旋转词">判断两个字符串是否互为旋转词</h2><p><img src="2017-03-22_110804.png" alt="2017-03-22_110804.png"> 思路： 将其中一个字符串复制一份，拼接在后面，然后在这个长字符串中查找另外一个短的有没有出现。 例如判断a,b字符串，只需要find(a,b+b)!=(b+b).end() 就是旋转词，否则就不是。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="section"></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态因果模型(DCM)的批量定义和估计</title>
      <link href="/hexoblog/2017/03/20/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/%E5%8A%A8%E6%80%81%E5%9B%A0%E6%9E%9C%E6%A8%A1%E5%9E%8B(DCM)%E7%9A%84%E6%89%B9%E9%87%8F%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BC%B0%E8%AE%A1/"/>
      <url>/hexoblog/2017/03/20/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/%E5%8A%A8%E6%80%81%E5%9B%A0%E6%9E%9C%E6%A8%A1%E5%9E%8B(DCM)%E7%9A%84%E6%89%B9%E9%87%8F%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BC%B0%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>借助SPM中的DCM，实现批量定义模型和批量估计。附带一些批量查看和保存结果的函数。 重写了SPM中的一些函数，带extend的为重写的函数。 <a id="more"></a></p><h2 id="spm_dcm_specify_extend.m">spm_dcm_specify_extend.m</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DCM</span> = <span class="title">spm_dcm_specify_extend</span><span class="params">(spmmatfile,name,VOIs,condition_mask,TE,Input_a,Input_b,Input_c)</span></span></span><br><span class="line"><span class="comment">% Specify inputs of a DCM</span></span><br><span class="line"><span class="comment">% FORMAT [DCM] = spm_dcm_specify</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% DCM  - the DCM structure (see spm_dcm_ui)</span></span><br><span class="line"><span class="comment">%__________________________________________________________________________</span></span><br><span class="line"><span class="comment">% Copyright (C) 2008 Wellcome Trust Centre for Neuroimaging</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Karl Friston</span></span><br><span class="line"><span class="comment">% $Id: spm_dcm_specify.m 4185 2011-02-01 18:46:18Z guillaume $</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Interactive window</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">Finter = spm_figure(<span class="string">'GetWin'</span>,<span class="string">'Interactive'</span>);</span><br><span class="line">bcolor = get(Finter,<span class="string">'color'</span>);</span><br><span class="line">WS     = spm(<span class="string">'WinScale'</span>);</span><br><span class="line">dx     = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">spm_input(<span class="string">'Specify DCM:...  '</span>,<span class="number">1</span>,<span class="string">'d'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="comment">% Get design and directory</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="comment">%[spmmatfile, sts] = spm_select(1,'^SPM\.mat$','Select SPM.mat');</span></span><br><span class="line"><span class="comment">%spmmatfile = 'D:\FMRI_ROOT\YANTAI\ANALYSIS\first_level_dcm_w_whole\20160716002\SPM.mat';</span></span><br><span class="line">sts = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> ~sts, DCM = []; <span class="keyword">return</span>; <span class="keyword">end</span></span><br><span class="line">swd = spm_str_manip(spmmatfile,<span class="string">'H'</span>);</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">    load(fullfile(swd,<span class="string">'SPM.mat'</span>))</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">    error([<span class="string">'Cannot read '</span> fullfile(swd,<span class="string">'SPM.mat'</span>)]);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="comment">% Name</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="comment">%name  = spm_input('name for DCM_???.mat','+1','s');</span></span><br><span class="line"><span class="comment">%name = 'HG_DCM';</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="comment">% Outputs</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Get cell array of region structures</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">% VOI1_path = 'd:\fmri_root\yantai\aNALYSIS\first_level_dcm_w_whole\20160716002\VOI_HG_DW_1.mat';</span></span><br><span class="line"><span class="comment">% VOI2_path = 'd:\fmri_root\yantai\aNALYSIS\first_level_dcm_w_whole\20160716002\VOI_MFG_DW_1.mat';</span></span><br><span class="line"><span class="comment">% VOI3_path = 'd:\fmri_root\yantai\aNALYSIS\first_level_dcm_w_whole\20160716002\VOI_STG_DW_1.mat';</span></span><br><span class="line"><span class="comment">% VOIs = &#123;VOI1_path;VOI2_path;VOI3_path&#125;;</span></span><br><span class="line"><span class="comment">%P     = cellstr(spm_select([1 8],'^VOI.*\.mat$',&#123;'select VOIs'&#125;,'',swd));</span></span><br><span class="line">P = VOIs;</span><br><span class="line">m     = <span class="built_in">numel</span>(P);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:m</span><br><span class="line">    p     = load(P&#123;<span class="built_in">i</span>&#125;,<span class="string">'xY'</span>);</span><br><span class="line">    xY(<span class="built_in">i</span>) = p.xY;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="comment">% Inputs</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Get (nc) 'causes' or inputs U</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">spm_input(<span class="string">'Input specification:...  '</span>,<span class="number">1</span>,<span class="string">'d'</span>);</span><br><span class="line">Sess   = SPM.Sess(xY(<span class="number">1</span>).Sess);</span><br><span class="line"><span class="comment">%condition_mask = [1,0,0,0]; % 配置包含哪个条件，不包含哪个条件＿</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isempty</span>(Sess.U)</span><br><span class="line">    <span class="comment">% spontaneous activity, i.e. no stimuli</span></span><br><span class="line">    nc = <span class="number">0</span>;</span><br><span class="line">    U = [];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">% with stimuli</span></span><br><span class="line">    U.dt   = Sess.U(<span class="number">1</span>).dt;</span><br><span class="line">    u      = <span class="built_in">length</span>(Sess.U);</span><br><span class="line">    U.name = &#123;&#125;;</span><br><span class="line">    U.u    = [];</span><br><span class="line">    <span class="keyword">for</span>  <span class="built_in">i</span> = <span class="number">1</span>:u  <span class="comment">%i 是条件的编号  1＿JX＿ 2＿DW   3＿RL 4＿ZR</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">length</span>(Sess.U(<span class="built_in">i</span>).name)</span><br><span class="line">            str = [<span class="string">'include '</span> Sess.U(<span class="built_in">i</span>).name&#123;<span class="built_in">j</span>&#125; <span class="string">'?'</span>];  <span class="comment">% include JX</span></span><br><span class="line">            <span class="keyword">if</span> condition_mask(<span class="built_in">i</span>)<span class="comment">%spm_input(str,'+1','y/n',[1 0],1)   include JX20 ,yes 1 ; no 0;</span></span><br><span class="line">                U.u             = [U.u Sess.U(<span class="built_in">i</span>).u(<span class="number">33</span>:<span class="keyword">end</span>,<span class="built_in">j</span>)];</span><br><span class="line">                U.name&#123;<span class="keyword">end</span> + <span class="number">1</span>&#125; = Sess.U(<span class="built_in">i</span>).name&#123;<span class="built_in">j</span>&#125;;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    nc     = <span class="built_in">size</span>(U.u,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="comment">% Timings</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"></span><br><span class="line">spm_input(<span class="string">'Timing information:...  '</span>,<span class="number">-1</span>,<span class="string">'d'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%-Slice timings</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">RT     = SPM.xY.RT;</span><br><span class="line"><span class="comment">%delays = spm_input('Slice timings [s]','+1','r', repmat(RT,1,m),m,[0 RT]);</span></span><br><span class="line">delays = <span class="built_in">repmat</span>(RT,<span class="number">1</span>,m)';</span><br><span class="line"><span class="comment">%-Echo time (TE) of data acquisition</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">%TE    = 0.04;  %==================================================================自己输入TE的忽===================</span></span><br><span class="line">TE_ok = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ~TE_ok</span><br><span class="line">    <span class="comment">%TE = spm_input('Echo time, TE [s]', '+1', 'r', TE);</span></span><br><span class="line">    <span class="keyword">if</span> ~TE || (TE &lt; <span class="number">0</span>) || (TE &gt; <span class="number">0.1</span>)</span><br><span class="line">        str = &#123; <span class="string">'Extreme value for TE or TE undefined.'</span>,...</span><br><span class="line">            <span class="string">'Please re-enter TE (in seconds!)'</span>&#125;;</span><br><span class="line">        spm_input(str,<span class="string">'+1'</span>,<span class="string">'bd'</span>,<span class="string">'OK'</span>,[<span class="number">1</span>],<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        TE_ok = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="comment">% Model options</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="keyword">if</span> nc                                                     <span class="comment">% there are inputs</span></span><br><span class="line">    spm_input(<span class="string">'Model options:...  '</span>,<span class="number">-1</span>,<span class="string">'d'</span>);</span><br><span class="line">    <span class="comment">%options.nonlinear  = spm_input('modulatory effects','+1','b',&#123;'bilinear','nonlinear'&#125;,[0 1],1);  </span></span><br><span class="line">    options.nonlinear = <span class="number">0</span>; <span class="comment">%modulatory effects :  0: bilinear  , 1: nonlinear</span></span><br><span class="line"><span class="comment">%options.two_state  = spm_input('states per region', '+1','b',&#123;'one','two'&#125;,[0 1],1);</span></span><br><span class="line">options.two_state = <span class="number">0</span> ; <span class="comment">% states per region ; 0: one  ; 1 : two</span></span><br><span class="line">    <span class="comment">%options.stochastic = spm_input('stochastic effects','+1','b',&#123;'no','yes'&#125;,[0 1],1);</span></span><br><span class="line">options.stochastic = <span class="number">0</span> ; <span class="comment">%stochastic effects; 0 : no ; 1 : yes,</span></span><br><span class="line">    <span class="comment">%options.centre     = spm_input('centre input',      '+1','b',&#123;'no','yes'&#125;,[0 1],1);</span></span><br><span class="line">options.centre = <span class="number">0</span> ; <span class="comment">% centre input ; 0 : no 1: yes;</span></span><br><span class="line">    options.endogenous = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    options.nonlinear  = <span class="number">0</span>;</span><br><span class="line">    options.two_state  = <span class="number">0</span>;</span><br><span class="line">    options.stochastic = <span class="number">1</span>;</span><br><span class="line">    options.centre     = <span class="number">1</span>;</span><br><span class="line">    options.endogenous = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="comment">% Graph connections</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line">a     = <span class="built_in">zeros</span>(m,m);</span><br><span class="line"><span class="keyword">if</span> options.endogenous</span><br><span class="line">    b     = <span class="built_in">zeros</span>(m,m,<span class="number">1</span>);</span><br><span class="line">    c     = <span class="built_in">zeros</span>(m,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    b     = <span class="built_in">zeros</span>(m,m,nc);</span><br><span class="line">    c     = <span class="built_in">zeros</span>(m,nc);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">d     = <span class="built_in">zeros</span>(m,m,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%-Intrinsic connections (A matrix)</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Buttons and labels</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">spm_input(<span class="string">'Specify intrinsic connections from'</span>,<span class="number">1</span>,<span class="string">'d'</span>)</span><br><span class="line">spm_input(<span class="string">'to'</span>,<span class="number">3</span>,<span class="string">'d'</span>)</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:m</span><br><span class="line">    str    = sprintf(<span class="string">'%s %i'</span>,xY(<span class="built_in">i</span>).name,<span class="built_in">i</span>);</span><br><span class="line">    h1(<span class="built_in">i</span>)  = uicontrol(Finter,<span class="string">'String'</span>,str,...</span><br><span class="line">        <span class="string">'Style'</span>,<span class="string">'text'</span>,...</span><br><span class="line">        <span class="string">'FontSize'</span>,<span class="number">10</span>,...</span><br><span class="line">        <span class="string">'BackgroundColor'</span>,bcolor,...</span><br><span class="line">        <span class="string">'HorizontalAlignment'</span>,<span class="string">'right'</span>,...</span><br><span class="line">        <span class="string">'Position'</span>,[<span class="number">080</span> <span class="number">350</span>-dx*<span class="built_in">i</span> <span class="number">080</span> <span class="number">020</span>].*WS);</span><br><span class="line">    h2(<span class="built_in">i</span>)  = uicontrol(Finter,<span class="string">'String'</span>,sprintf(<span class="string">'%i'</span>,<span class="built_in">i</span>),...</span><br><span class="line">        <span class="string">'Style'</span>,<span class="string">'text'</span>,...</span><br><span class="line">        <span class="string">'FontSize'</span>,<span class="number">10</span>,...</span><br><span class="line">        <span class="string">'BackgroundColor'</span>,bcolor,...</span><br><span class="line">        <span class="string">'Position'</span>,[<span class="number">180</span>+dx*<span class="built_in">i</span> <span class="number">350</span> <span class="number">010</span> <span class="number">020</span>].*WS);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:m</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:m</span><br><span class="line">        h3(<span class="built_in">i</span>,<span class="built_in">j</span>) = uicontrol(Finter,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">180</span>+dx*<span class="built_in">j</span> <span class="number">350</span>-dx*<span class="built_in">i</span> <span class="number">020</span> <span class="number">020</span>].*WS,...</span><br><span class="line">            <span class="string">'BackgroundColor'</span>,bcolor,...</span><br><span class="line">            <span class="string">'Style'</span>,<span class="string">'radiobutton'</span>);</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">i</span> == <span class="built_in">j</span></span><br><span class="line">            set(h3(<span class="built_in">i</span>,<span class="built_in">j</span>),<span class="string">'Value'</span>,<span class="number">1</span>,...</span><br><span class="line">                <span class="string">'enable'</span>,<span class="string">'off'</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            set(h3(<span class="built_in">i</span>,<span class="built_in">j</span>),<span class="string">'enable'</span>,<span class="string">'on'</span>,<span class="string">'TooltipString'</span>, ...</span><br><span class="line">                sprintf(<span class="string">'from %s to %s'</span>,xY(<span class="built_in">j</span>).name,xY(<span class="built_in">i</span>).name));</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> nc &amp;&amp; <span class="built_in">i</span>~=<span class="built_in">j</span></span><br><span class="line">            set(h3(<span class="built_in">i</span>,<span class="built_in">j</span>),<span class="string">'Value'</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            set(h3(<span class="built_in">i</span>,<span class="built_in">j</span>),<span class="string">'Value'</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">uicontrol(Finter,<span class="string">'String'</span>,<span class="string">'done'</span>,<span class="string">'Position'</span>, [<span class="number">300</span> <span class="number">100</span> <span class="number">060</span> <span class="number">020</span>].*WS,...</span><br><span class="line">    <span class="string">'Callback'</span>, <span class="string">'uiresume(gcbf)'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%uiwait(Finter);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Get a  a 就是DCM模型的连接矩阿</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">%for i = 1:m</span></span><br><span class="line"><span class="comment">%    for j = 1:m</span></span><br><span class="line"><span class="comment">%       a(i,j) = get(h3(i,j),'Value');</span></span><br><span class="line"><span class="comment">%   end</span></span><br><span class="line"><span class="comment">%end</span></span><br><span class="line"><span class="comment">%a = [1,1,1;1,1,1;1,1,1];  %=========================================================定义的DCM模型，此处有三个节点，所以是3*3的矩阵；</span></span><br><span class="line">a = Input_a;</span><br><span class="line">delete(findobj(get(Finter,<span class="string">'Children'</span>),<span class="string">'flat'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">%-Effects of causes (B and C matrices)</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line">uicontrol(Finter,<span class="string">'String'</span>,<span class="string">'done'</span>,<span class="string">'Position'</span>, [<span class="number">300</span> <span class="number">100</span> <span class="number">060</span> <span class="number">020</span>].*WS,...</span><br><span class="line">    <span class="string">'Callback'</span>, <span class="string">'uiresume(gcbf)'</span>);</span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:nc</span><br><span class="line"></span><br><span class="line">    <span class="comment">%-Buttons and labels</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    str   = sprintf(...</span><br><span class="line">        <span class="string">'Effects of %-12s on regions... and connections'</span>,...</span><br><span class="line">        U.name&#123;k&#125;);</span><br><span class="line">    spm_input(str,<span class="number">1</span>,<span class="string">'d'</span>);      <span class="comment">% Effects of JX           on regions... and connections</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:m</span><br><span class="line">        h1(<span class="built_in">i</span>)  = uicontrol(Finter,<span class="string">'String'</span>,xY(<span class="built_in">i</span>).name,...</span><br><span class="line">            <span class="string">'Style'</span>,<span class="string">'text'</span>,...</span><br><span class="line">            <span class="string">'BackgroundColor'</span>,bcolor,...</span><br><span class="line">            <span class="string">'FontSize'</span>,<span class="number">10</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">080</span> <span class="number">350</span>-dx*<span class="built_in">i</span> <span class="number">080</span> <span class="number">020</span>].*WS);</span><br><span class="line">        h2(<span class="built_in">i</span>)  = uicontrol(Finter,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">160</span> <span class="number">360</span>-dx*<span class="built_in">i</span> <span class="number">020</span> <span class="number">020</span>].*WS,...</span><br><span class="line">            <span class="string">'BackgroundColor'</span>,bcolor,...</span><br><span class="line">            <span class="string">'Style'</span>,<span class="string">'radiobutton'</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:m</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:m</span><br><span class="line">            <span class="keyword">if</span> a(<span class="built_in">i</span>,<span class="built_in">j</span>) == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">% Allow modulation of intrinsic connections</span></span><br><span class="line">                <span class="comment">%----------------------------------------------------------</span></span><br><span class="line">                h3(<span class="built_in">i</span>,<span class="built_in">j</span>) = uicontrol(Finter,...</span><br><span class="line">                    <span class="string">'Position'</span>,[<span class="number">220</span>+dx*<span class="built_in">j</span> <span class="number">360</span>-dx*<span class="built_in">i</span> <span class="number">020</span> <span class="number">020</span>].*WS,...</span><br><span class="line">                    <span class="string">'BackgroundColor'</span>,bcolor,...</span><br><span class="line">                    <span class="string">'Style'</span>,<span class="string">'radiobutton'</span>);</span><br><span class="line">                set(h3(<span class="built_in">i</span>,<span class="built_in">j</span>),<span class="string">'TooltipString'</span>, ...</span><br><span class="line">                    sprintf(<span class="string">'from %s to %s'</span>,xY(<span class="built_in">j</span>).name,xY(<span class="built_in">i</span>).name));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%uiwait(Finter);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%-Get c   就是左边的第丿?，代表输入加在那个脑区上＿ * 1</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">%for i = 1:m</span></span><br><span class="line">        <span class="comment">%c(i,k)   = get(h2(i),'Value');</span></span><br><span class="line">    <span class="comment">%end</span></span><br><span class="line"><span class="comment">%c = [1,0,0];</span></span><br><span class="line">    c = Input_c;</span><br><span class="line">    <span class="comment">%-Get b allowing any 2nd order effects   3*3 的矩阵，代表调节变量在哪条线上??里有三个区域，承?昿*3</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">% for i = 1:m</span></span><br><span class="line">        <span class="comment">% for j = 1:m</span></span><br><span class="line">            <span class="comment">% if a(i,j)==1</span></span><br><span class="line">                <span class="comment">% b(i,j,k) = get(h3(i,j),'Value');</span></span><br><span class="line">            <span class="comment">% end</span></span><br><span class="line">        <span class="comment">% end</span></span><br><span class="line">    <span class="comment">% end</span></span><br><span class="line"><span class="comment">%b = [0,0,0;0,0,0;0,0,0];</span></span><br><span class="line">    b = Input_b;</span><br><span class="line">    delete([h1(:); h2(:); h3(a==<span class="number">1</span>)])</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">delete(findobj(get(Finter,<span class="string">'Children'</span>),<span class="string">'flat'</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Effects of nonlinear modulations (D matrices)</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="keyword">if</span> options.nonlinear</span><br><span class="line">    uicontrol(Finter,<span class="string">'String'</span>,<span class="string">'done'</span>,<span class="string">'Position'</span>, [<span class="number">300</span> <span class="number">100</span> <span class="number">060</span> <span class="number">020</span>].*WS,...</span><br><span class="line">        <span class="string">'Callback'</span>, <span class="string">'uiresume(gcbf)'</span>);</span><br><span class="line">    <span class="keyword">for</span> k = <span class="number">1</span>:m</span><br><span class="line"></span><br><span class="line">        <span class="comment">%-Buttons and labels</span></span><br><span class="line">        <span class="comment">%------------------------------------------------------------------</span></span><br><span class="line">        str = sprintf(<span class="string">'Effects of %-12s activity on connections'</span>,xY(k).name);</span><br><span class="line">        spm_input(str,<span class="number">1</span>,<span class="string">'d'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:m</span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:m</span><br><span class="line">                <span class="keyword">if</span> a(<span class="built_in">i</span>,<span class="built_in">j</span>)==<span class="number">1</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">% Allow modulation of intrinsic connections</span></span><br><span class="line">                    <span class="comment">%------------------------------------------------------</span></span><br><span class="line">                    h4(<span class="built_in">i</span>,<span class="built_in">j</span>) = uicontrol(Finter,...</span><br><span class="line">                        <span class="string">'Position'</span>,[<span class="number">220</span>+dx*<span class="built_in">j</span> <span class="number">360</span>-dx*<span class="built_in">i</span> <span class="number">020</span> <span class="number">020</span>].*WS,...</span><br><span class="line">                        <span class="string">'BackgroundColor'</span>,bcolor,...</span><br><span class="line">                        <span class="string">'Style'</span>,<span class="string">'radiobutton'</span>);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        uiwait(Finter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">%-Get d allowing any 2nd order effects</span></span><br><span class="line">        <span class="comment">%------------------------------------------------------------------</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:m</span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:m</span><br><span class="line">                <span class="keyword">if</span> a(<span class="built_in">i</span>,<span class="built_in">j</span>)==<span class="number">1</span></span><br><span class="line">                    d(<span class="built_in">i</span>,<span class="built_in">j</span>,k) = get(h4(<span class="built_in">i</span>,<span class="built_in">j</span>),<span class="string">'Value'</span>);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        delete(h4(a==<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">delete(findobj(get(Finter,<span class="string">'Children'</span>),<span class="string">'flat'</span>));</span><br><span class="line">spm_input(<span class="string">'Thank you'</span>,<span class="number">1</span>,<span class="string">'d'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="comment">% Response</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Response variables &amp; confounds (NB: the data have been whitened)</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">n     = <span class="built_in">length</span>(xY);                      <span class="comment">% number of regions</span></span><br><span class="line">v     = <span class="built_in">length</span>(xY(<span class="number">1</span>).u);                 <span class="comment">% number of time points</span></span><br><span class="line">Y.dt  = SPM.xY.RT;</span><br><span class="line">Y.X0  = xY(<span class="number">1</span>).X0;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">    Y.y(:,<span class="built_in">i</span>)  = xY(<span class="built_in">i</span>).u;</span><br><span class="line">    Y.name&#123;<span class="built_in">i</span>&#125; = xY(<span class="built_in">i</span>).name;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Error precision components (one for each region) - i.i.d. (because of W)</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">Y.Q        = spm_Ce(<span class="built_in">ones</span>(<span class="number">1</span>,n)*v);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="comment">% DCM structure</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Endogenous input specification</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isempty</span>(U)</span><br><span class="line">    U.u    = <span class="built_in">zeros</span>(v,<span class="number">1</span>);</span><br><span class="line">    U.name = &#123;<span class="string">'null'</span>&#125;;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Store all variables in DCM structure</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">DCM.a       = a;</span><br><span class="line">DCM.b       = b;</span><br><span class="line">DCM.c       = c;</span><br><span class="line">DCM.d       = d;</span><br><span class="line">DCM.U       = U;</span><br><span class="line">DCM.Y       = Y;</span><br><span class="line">DCM.xY      = xY;</span><br><span class="line">DCM.v       = v;</span><br><span class="line">DCM.n       = n;</span><br><span class="line">DCM.TE      = TE;</span><br><span class="line">DCM.delays  = delays;</span><br><span class="line">DCM.options = options;</span><br><span class="line"></span><br><span class="line"><span class="comment">%-Save</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> spm_check_version(<span class="string">'matlab'</span>,<span class="string">'7'</span>) &gt;= <span class="number">0</span></span><br><span class="line">    save(fullfile(swd,[<span class="string">'DCM_'</span> name <span class="string">'.mat'</span>]),<span class="string">'-V6'</span>,<span class="string">'DCM'</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    save(fullfile(swd,[<span class="string">'DCM_'</span> name <span class="string">'.mat'</span>]),<span class="string">'DCM'</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="spm_getspm_extend.m">spm_getSPM_extend.m</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[SPM,xSPM]</span> = <span class="title">spm_getSPM_extend</span><span class="params">(varargin)</span></span></span><br><span class="line"><span class="comment">% Compute a specified and thresholded SPM/PPM following estimation</span></span><br><span class="line"><span class="comment">% FORMAT [SPM,xSPM] = spm_getSPM;</span></span><br><span class="line"><span class="comment">% Query SPM in interactive mode.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% FORMAT [SPM,xSPM] = spm_getSPM(xSPM);</span></span><br><span class="line"><span class="comment">% Query SPM in batch mode. See below for a description of fields that may</span></span><br><span class="line"><span class="comment">% be present in xSPM input. Values for missing fields will be queried</span></span><br><span class="line"><span class="comment">% interactively.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%FORMAT [SPM,xSPM] = spm_getSPM(spm_mat_path,InputIC,InputMask，InputthresDesc，Input_u);</span></span><br><span class="line"><span class="comment">% spm_mat_path : SPM.mat path</span></span><br><span class="line"><span class="comment">% InputIC : 选择设置的第几个Contrast,整数＿</span></span><br><span class="line"><span class="comment">% InputMask;  %  0 none  1 contrast  2 image ============</span></span><br><span class="line"><span class="comment">% InputthresDesc ;  %===p value adjustment to control: 'FWE' or 'none'==</span></span><br><span class="line"><span class="comment">% Input_u; %threshold  默认0.001====</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-GUI setup</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">spm_help(<span class="string">'!ContextHelp'</span>,mfilename)</span><br><span class="line">spm(<span class="string">'Pointer'</span>,<span class="string">'Arrow'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%-Select SPM.mat &amp; note SPM results directory</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> nargin == <span class="number">1</span></span><br><span class="line">    xSPM = varargin&#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> nargin &gt; <span class="number">1</span></span><br><span class="line">    spm_mat_path = varargin&#123;<span class="number">1</span>&#125;;</span><br><span class="line">InputIC = varargin&#123;<span class="number">2</span>&#125;;</span><br><span class="line">    InputMask = varargin&#123;<span class="number">3</span>&#125;;</span><br><span class="line">    InputthresDesc = varargin&#123;<span class="number">4</span>&#125;;</span><br><span class="line">    Input_u = varargin&#123;<span class="number">5</span>&#125;;</span><br><span class="line">    Input_k = varargin&#123;<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">    swd = xSPM.swd;</span><br><span class="line">    sts = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">    sts = <span class="number">1</span>;</span><br><span class="line">    spmmatfile = spm_mat_path;</span><br><span class="line">    swd = spm_str_manip(spmmatfile,<span class="string">'H'</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> ~sts, SPM = []; xSPM = []; <span class="keyword">return</span>; <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Preliminaries...</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Load SPM.mat</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">    load(fullfile(swd,<span class="string">'SPM.mat'</span>));</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">    error([<span class="string">'Cannot read '</span> fullfile(swd,<span class="string">'SPM.mat'</span>)]);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">SPM.swd = swd;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Change directory so that relative filenames are valid</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">cd(SPM.swd);</span><br><span class="line"></span><br><span class="line"><span class="comment">%-Check the model has been estimated</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">    SPM.xVol.S;</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">%-Check the model has been estimated</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    str = &#123; <span class="string">'This model has not been estimated.'</span>;...</span><br><span class="line">            <span class="string">'Would you like to estimate it now?'</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> spm_input(str,<span class="number">1</span>,<span class="string">'bd'</span>,<span class="string">'yes|no'</span>,[<span class="number">1</span>,<span class="number">0</span>],<span class="number">1</span>)</span><br><span class="line">        SPM = spm_spm(SPM);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        SPM = []; xSPM = [];</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">xX   = SPM.xX;                      <span class="comment">%-Design definition structure</span></span><br><span class="line">XYZ  = SPM.xVol.XYZ;                <span class="comment">%-XYZ coordinates</span></span><br><span class="line">S    = SPM.xVol.S;                  <span class="comment">%-search Volume &#123;voxels&#125;</span></span><br><span class="line">R    = SPM.xVol.R;                  <span class="comment">%-search Volume &#123;resels&#125;</span></span><br><span class="line">M    = SPM.xVol.M(<span class="number">1</span>:<span class="number">3</span>,<span class="number">1</span>:<span class="number">3</span>);         <span class="comment">%-voxels to mm matrix</span></span><br><span class="line">VOX  = <span class="built_in">sqrt</span>(<span class="built_in">diag</span>(M'*M))';           <span class="comment">%-voxel dimensions</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="comment">% - C O N T R A S T S ,   S P M    C O M P U T A T I O N ,    M A S K I N G</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Get contrasts</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">try</span>, xCon = SPM.xCon; <span class="keyword">catch</span>, xCon = &#123;&#125;; <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">    Ic        = xSPM.Ic;</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">    Ic = InputIC;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isempty</span>(xCon)</span><br><span class="line">    <span class="comment">% figure out whether new contrasts were defined, but not selected</span></span><br><span class="line">    <span class="comment">% do this by comparing length of SPM.xCon to xCon, remember added</span></span><br><span class="line">    <span class="comment">% indices to run spm_contrasts on them as well</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">        noxCon = <span class="built_in">numel</span>(SPM.xCon);</span><br><span class="line">    <span class="keyword">catch</span></span><br><span class="line">        noxCon = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    IcAdd = (noxCon+<span class="number">1</span>):<span class="built_in">numel</span>(xCon);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    IcAdd = [];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">nc        = <span class="built_in">length</span>(Ic);  <span class="comment">% Number of contrasts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Allow user to extend the null hypothesis for conjunctions</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% n: conjunction number</span></span><br><span class="line"><span class="comment">% u: Null hyp is k&lt;=u effects real; Alt hyp is k&gt;u effects real</span></span><br><span class="line"><span class="comment">%    (NB Here u is from Friston et al 2004 paper, not statistic thresh).</span></span><br><span class="line"><span class="comment">%                  u         n</span></span><br><span class="line"><span class="comment">% Conjunction Null nc-1      1     |    u = nc-n</span></span><br><span class="line"><span class="comment">% Intermediate     1..nc-2   nc-u  |    #effects under null &lt;= u</span></span><br><span class="line"><span class="comment">% Global Null      0         nc    |    #effects under alt  &gt; u,  &gt;= u+1</span></span><br><span class="line"><span class="comment">%----------------------------------+---------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> nc &gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">        n = xSPM.n;</span><br><span class="line">    <span class="keyword">catch</span></span><br><span class="line">        <span class="keyword">if</span> nc==<span class="number">2</span></span><br><span class="line">            But = <span class="string">'Conjunction|Global'</span>;      Val=[<span class="number">1</span> nc];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            But = <span class="string">'Conj''n|Intermed|Global'</span>; Val=[<span class="number">1</span> NaN nc];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        n = spm_input(<span class="string">'Null hyp. to assess?'</span>,<span class="string">'+1'</span>,<span class="string">'b'</span>,But,Val,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isnan</span>(n)</span><br><span class="line">            <span class="keyword">if</span> nc == <span class="number">3</span>,</span><br><span class="line">                n = nc - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                n = nc - spm_input(<span class="string">'Effects under null '</span>,<span class="string">'0'</span>,<span class="string">'n1'</span>,<span class="string">'1'</span>,nc<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Enforce orthogonality of multiple contrasts for conjunction</span></span><br><span class="line"><span class="comment">% (Orthogonality within subspace spanned by contrasts)</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> nc &gt; <span class="number">1</span> &amp;&amp; n &gt; <span class="number">1</span> &amp;&amp; ~spm_FcUtil(<span class="string">'|_?'</span>,xCon(Ic), xX.xKXs)</span><br><span class="line">    </span><br><span class="line">    OrthWarn = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">%-Successively orthogonalise</span></span><br><span class="line">    <span class="comment">%-NB: This loop is peculiarly controlled to account for the</span></span><br><span class="line">    <span class="comment">%     possibility that Ic may shrink if some contrasts disappear</span></span><br><span class="line">    <span class="comment">%     on orthogonalisation (i.e. if there are colinearities)</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="built_in">i</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">i</span> &lt; nc), <span class="built_in">i</span> = <span class="built_in">i</span> + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">%-Orthogonalise (subspace spanned by) contrast i w.r.t. previous</span></span><br><span class="line">        <span class="comment">%------------------------------------------------------------------</span></span><br><span class="line">        oxCon = spm_FcUtil(<span class="string">'|_'</span>,xCon(Ic(<span class="built_in">i</span>)), xX.xKXs, xCon(Ic(<span class="number">1</span>:<span class="built_in">i</span><span class="number">-1</span>)));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">%-See if this orthogonalised contrast has already been entered</span></span><br><span class="line">        <span class="comment">% or is colinear with a previous one. Define a new contrast if</span></span><br><span class="line">        <span class="comment">% neither is the case.</span></span><br><span class="line">        <span class="comment">%------------------------------------------------------------------</span></span><br><span class="line">        d     = spm_FcUtil(<span class="string">'In'</span>,oxCon,xX.xKXs,xCon);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> spm_FcUtil(<span class="string">'0|[]'</span>,oxCon,xX.xKXs)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">%-Contrast was colinear with a previous one - drop it</span></span><br><span class="line">            <span class="comment">%--------------------------------------------------------------</span></span><br><span class="line">            Ic(<span class="built_in">i</span>) = [];</span><br><span class="line">            <span class="built_in">i</span>     = <span class="built_in">i</span> - <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">elseif</span> any(d)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">%-Contrast unchanged or already defined - note index</span></span><br><span class="line">            <span class="comment">%--------------------------------------------------------------</span></span><br><span class="line">            Ic(<span class="built_in">i</span>) = <span class="built_in">min</span>(d);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">%-Define orthogonalised contrast as new contrast</span></span><br><span class="line">            <span class="comment">%--------------------------------------------------------------</span></span><br><span class="line">            OrthWarn   = OrthWarn + <span class="number">1</span>;</span><br><span class="line">            conlst     = sprintf(<span class="string">'%d,'</span>,Ic(<span class="number">1</span>:<span class="built_in">i</span><span class="number">-1</span>));</span><br><span class="line">            oxCon.name = sprintf(<span class="string">'%s (orth. w.r.t &#123;%s&#125;)'</span>, xCon(Ic(<span class="built_in">i</span>)).name,...</span><br><span class="line">                                  conlst(<span class="number">1</span>:<span class="keyword">end</span><span class="number">-1</span>));</span><br><span class="line">            xCon       = [xCon, oxCon];</span><br><span class="line">            Ic(<span class="built_in">i</span>)      = <span class="built_in">length</span>(xCon);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">end</span> <span class="comment">% while...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> OrthWarn</span><br><span class="line">        warning(<span class="string">'SPM:ConChange'</span>,<span class="string">'%d contrasts orthogonalized'</span>,OrthWarn)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    SPM.xCon = xCon;</span><br><span class="line"><span class="keyword">end</span> <span class="comment">% if nc&gt;1...</span></span><br><span class="line">SPM.xCon = xCon;</span><br><span class="line"></span><br><span class="line"><span class="comment">%-Apply masking</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">    Mask = ~<span class="built_in">isempty</span>(xSPM.Im) * (isnumeric(xSPM.Im) + <span class="number">2</span>*iscellstr(xSPM.Im));</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">    <span class="comment">% Mask = spm_input('mask with other contrast(s)','+1','y/n',[1,0],2);</span></span><br><span class="line">    Mask = InputMask;  <span class="comment">%  0 none  1 contrast  2 image =================================================</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> Mask == <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">%-Get contrasts for masking</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">        Im = xSPM.Im;</span><br><span class="line">    <span class="keyword">catch</span></span><br><span class="line">        [Im,xCon] = spm_conman(SPM,<span class="string">'T&amp;F'</span>,-Inf,...</span><br><span class="line">            <span class="string">'Select contrasts for masking...'</span>,<span class="string">' for masking'</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">%-Threshold for mask (uncorrected p-value)</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">        pm = xSPM.pm;</span><br><span class="line">    <span class="keyword">catch</span></span><br><span class="line">        pm = spm_input(<span class="string">'uncorrected mask p-value'</span>,<span class="string">'+1'</span>,<span class="string">'r'</span>,<span class="number">0.05</span>,<span class="number">1</span>,[<span class="number">0</span>,<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">%-Inclusive or exclusive masking</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">        Ex = xSPM.Ex;</span><br><span class="line">    <span class="keyword">catch</span></span><br><span class="line">        Ex = spm_input(<span class="string">'nature of mask'</span>,<span class="string">'+1'</span>,<span class="string">'b'</span>,<span class="string">'inclusive|exclusive'</span>,[<span class="number">0</span>,<span class="number">1</span>],<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">elseif</span> Mask == <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">%-Get mask images</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">        Im = xSPM.Im;</span><br><span class="line">    <span class="keyword">catch</span></span><br><span class="line">        Im = cellstr(spm_select([<span class="number">1</span> Inf],<span class="string">'image'</span>,<span class="string">'Select mask image(s)'</span>));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">%-Inclusive or exclusive masking</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">        Ex = xSPM.Ex;</span><br><span class="line">    <span class="keyword">catch</span></span><br><span class="line">        Ex = spm_input(<span class="string">'nature of mask'</span>,<span class="string">'+1'</span>,<span class="string">'b'</span>,<span class="string">'inclusive|exclusive'</span>,[<span class="number">0</span>,<span class="number">1</span>],<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    pm = [];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    Im = [];</span><br><span class="line">    pm = [];</span><br><span class="line">    Ex = [];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Create/Get title string for comparison</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> nc == <span class="number">1</span></span><br><span class="line">    str  = xCon(Ic).name;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    str  = [sprintf(<span class="string">'contrasts &#123;%d'</span>,Ic(<span class="number">1</span>)),sprintf(<span class="string">',%d'</span>,Ic(<span class="number">2</span>:<span class="keyword">end</span>)),<span class="string">'&#125;'</span>];</span><br><span class="line">    <span class="keyword">if</span> n == nc</span><br><span class="line">        str = [str <span class="string">' (global null)'</span>];</span><br><span class="line">    <span class="keyword">elseif</span> n == <span class="number">1</span></span><br><span class="line">        str = [str <span class="string">' (conj. null)'</span>];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        str = [str sprintf(<span class="string">' (Ha: k&gt;=%d)'</span>,(nc-n)+<span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> Ex</span><br><span class="line">    mstr = <span class="string">'masked [excl.] by'</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    mstr = <span class="string">'masked [incl.] by'</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> isnumeric(Im)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">length</span>(Im) == <span class="number">1</span></span><br><span class="line">        str = sprintf(<span class="string">'%s (%s %s at p=%g)'</span>,str,mstr,xCon(Im).name,pm);</span><br><span class="line">    <span class="keyword">elseif</span> ~<span class="built_in">isempty</span>(Im)</span><br><span class="line">        str = [sprintf(<span class="string">'%s (%s &#123;%d'</span>,str,mstr,Im(<span class="number">1</span>)),...</span><br><span class="line">            sprintf(<span class="string">',%d'</span>,Im(<span class="number">2</span>:<span class="keyword">end</span>)),...</span><br><span class="line">            sprintf(<span class="string">'&#125; at p=%g)'</span>,pm)];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">elseif</span> iscellstr(Im) &amp;&amp; <span class="built_in">numel</span>(Im) &gt; <span class="number">0</span></span><br><span class="line">    [pf,nf,ef] = spm_fileparts(Im&#123;<span class="number">1</span>&#125;);</span><br><span class="line">    str  = sprintf(<span class="string">'%s (%s %s'</span>,str,mstr,[nf ef]);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">2</span>:<span class="built_in">numel</span>(Im)</span><br><span class="line">        [pf,nf,ef] = spm_fileparts(Im&#123;<span class="built_in">i</span>&#125;);</span><br><span class="line">        str =[str sprintf(<span class="string">', %s'</span>,[nf ef])];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    str = [str <span class="string">')'</span>];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">    titlestr = xSPM.title;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isempty</span>(titlestr)</span><br><span class="line">        titlestr = str;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">    titlestr = str;<span class="comment">% 名称，可以自定义========================================================================</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Bayesian or classical Inference?</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="keyword">if</span> isfield(SPM,<span class="string">'PPM'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% Make sure SPM.PPM.xCon field exists</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> ~isfield(SPM.PPM,<span class="string">'xCon'</span>)</span><br><span class="line">        SPM.PPM.xCon = [];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% Set Bayesian con type</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    SPM.PPM.xCon(Ic).PSTAT = xCon(Ic).STAT;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% Make all new contrasts Bayesian contrasts </span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    [xCon(Ic).STAT] = deal(<span class="string">'P'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> all(strcmp([SPM.PPM.xCon(Ic).PSTAT],<span class="string">'T'</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% Simple contrast</span></span><br><span class="line">        <span class="comment">%------------------------------------------------------------------</span></span><br><span class="line">        str = <span class="string">'Effect size threshold for PPM'</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> isfield(SPM.PPM,<span class="string">'VB'</span>) <span class="comment">% 1st level Bayes</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">% For VB - set default effect size to zero</span></span><br><span class="line">            <span class="comment">%--------------------------------------------------------------</span></span><br><span class="line">            Gamma = <span class="number">0</span>;</span><br><span class="line">            xCon(Ic).eidf = spm_input(str,<span class="string">'+1'</span>,<span class="string">'e'</span>,sprintf(<span class="string">'%0.2f'</span>,Gamma));</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">elseif</span> nc == <span class="number">1</span> &amp;&amp; <span class="built_in">isempty</span>(xCon(Ic).Vcon) <span class="comment">% 2nd level Bayes</span></span><br><span class="line">            <span class="comment">% con image not yet written</span></span><br><span class="line">            <span class="comment">%--------------------------------------------------------------</span></span><br><span class="line">            <span class="keyword">if</span> spm_input(<span class="string">'Inference'</span>,<span class="number">1</span>,<span class="string">'b'</span>,&#123;<span class="string">'Bayesian'</span>,<span class="string">'classical'</span>&#125;,[<span class="number">1</span> <span class="number">0</span>]);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">%-Get Bayesian threshold (Gamma) stored in xCon(Ic).eidf</span></span><br><span class="line">                <span class="comment">% The default is one conditional s.d. of the contrast</span></span><br><span class="line">                <span class="comment">%----------------------------------------------------------</span></span><br><span class="line">                Gamma         = <span class="built_in">sqrt</span>(xCon(Ic).c'*SPM.PPM.Cb*xCon(Ic).c);</span><br><span class="line">                xCon(Ic).eidf = spm_input(str,<span class="string">'+1'</span>,<span class="string">'e'</span>,sprintf(<span class="string">'%0.2f'</span>,Gamma));</span><br><span class="line">                xCon(Ic).STAT = <span class="string">'P'</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">% Compound contrast using Chi^2 statistic</span></span><br><span class="line">        <span class="comment">%------------------------------------------------------------------</span></span><br><span class="line">        <span class="keyword">if</span> ~isfield(xCon(Ic),<span class="string">'eidf'</span>) || <span class="built_in">isempty</span>(xCon(Ic).eidf)</span><br><span class="line">            xCon(Ic).eidf = <span class="number">0</span>; <span class="comment">% temporarily</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Compute &amp; store contrast parameters, contrast/ESS images, &amp; SPM images</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line">SPM.xCon = xCon;</span><br><span class="line"><span class="keyword">if</span> isnumeric(Im)</span><br><span class="line">    SPM  = spm_contrasts(SPM, unique([Ic, Im, IcAdd]));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    SPM  = spm_contrasts(SPM, unique([Ic, IcAdd]));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">xCon     = SPM.xCon;</span><br><span class="line">STAT     = xCon(Ic(<span class="number">1</span>)).STAT;</span><br><span class="line">VspmSv   = <span class="built_in">cat</span>(<span class="number">1</span>,xCon(Ic).Vspm);</span><br><span class="line"></span><br><span class="line"><span class="comment">%-Check conjunctions - Must be same STAT w/ same df</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> (nc &gt; <span class="number">1</span>) &amp;&amp; (any(diff(double(<span class="built_in">cat</span>(<span class="number">1</span>,xCon(Ic).STAT)))) || ...</span><br><span class="line">                any(<span class="built_in">abs</span>(diff(<span class="built_in">cat</span>(<span class="number">1</span>,xCon(Ic).eidf))) &gt; <span class="number">1</span>))</span><br><span class="line">    error(<span class="string">'illegal conjunction: can only conjoin SPMs of same STAT &amp; df'</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Degrees of Freedom and STAT string describing marginal distribution</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">df     = [xCon(Ic(<span class="number">1</span>)).eidf xX.erdf];</span><br><span class="line"><span class="keyword">if</span> nc &gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">1</span></span><br><span class="line">        str = sprintf(<span class="string">'^&#123;%d \\&#123;Ha:k\\geq%d\\&#125;&#125;'</span>,nc,(nc-n)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        str = sprintf(<span class="string">'^&#123;%d \\&#123;Ha:k=%d\\&#125;&#125;'</span>,nc,(nc-n)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    str = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> STAT</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'T'</span></span><br><span class="line">        STATstr = sprintf(<span class="string">'%c%s_&#123;%.0f&#125;'</span>,<span class="string">'T'</span>,str,df(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'F'</span></span><br><span class="line">        STATstr = sprintf(<span class="string">'%c%s_&#123;%.0f,%.0f&#125;'</span>,<span class="string">'F'</span>,str,df(<span class="number">1</span>),df(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'P'</span></span><br><span class="line">        STATstr = sprintf(<span class="string">'%s^&#123;%0.2f&#125;'</span>,<span class="string">'PPM'</span>,df(<span class="number">1</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Compute (unfiltered) SPM pointlist for masked conjunction requested</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line">fprintf(<span class="string">'\t%-32s: %30s'</span>,<span class="string">'SPM computation'</span>,<span class="string">'...initialising'</span>)            <span class="comment">%-#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Compute conjunction as minimum of SPMs</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">Z     = Inf;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = Ic</span><br><span class="line">    Z = <span class="built_in">min</span>(Z,spm_get_data(xCon(<span class="built_in">i</span>).Vspm,XYZ));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Copy of Z and XYZ before masking, for later use with FDR</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">XYZum = XYZ;</span><br><span class="line">Zum   = Z;</span><br><span class="line"></span><br><span class="line"><span class="comment">%-Compute mask and eliminate masked voxels</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">numel</span>(Im)</span><br><span class="line">    </span><br><span class="line">    fprintf(<span class="string">'%s%30s'</span>,<span class="built_in">repmat</span>(sprintf(<span class="string">'\b'</span>),<span class="number">1</span>,<span class="number">30</span>),<span class="string">'...masking'</span>)           <span class="comment">%-#</span></span><br><span class="line">    <span class="keyword">if</span> isnumeric(Im)</span><br><span class="line">        Mask = spm_get_data(xCon(Im(<span class="built_in">i</span>)).Vspm,XYZ);</span><br><span class="line">        um   = spm_u(pm,[xCon(Im(<span class="built_in">i</span>)).eidf,xX.erdf],xCon(Im(<span class="built_in">i</span>)).STAT);</span><br><span class="line">        <span class="keyword">if</span> Ex</span><br><span class="line">            Q = Mask &lt;= um;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Q = Mask &gt;  um;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        v = spm_vol(Im&#123;<span class="built_in">i</span>&#125;);</span><br><span class="line">        Mask = spm_get_data(v,v.mat\SPM.xVol.M*[XYZ; <span class="built_in">ones</span>(<span class="number">1</span>,<span class="built_in">size</span>(XYZ,<span class="number">2</span>))]);</span><br><span class="line">        Q = Mask ~= <span class="number">0</span> &amp; ~<span class="built_in">isnan</span>(Mask);</span><br><span class="line">        <span class="keyword">if</span> Ex, Q = ~Q; <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    XYZ   = XYZ(:,Q);</span><br><span class="line">    Z     = Z(Q);</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isempty</span>(Q)</span><br><span class="line">        fprintf(<span class="string">'\n'</span>)                                                   <span class="comment">%-#</span></span><br><span class="line">        warning(<span class="string">'SPM:NoVoxels'</span>,<span class="string">'No voxels survive masking at p=%4.2f'</span>,pm);</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="comment">% - H E I G H T   &amp;   E X T E N T   T H R E S H O L D S</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"></span><br><span class="line">u   = -Inf;        <span class="comment">% height threshold</span></span><br><span class="line">k   = <span class="number">0</span>;           <span class="comment">% extent threshold &#123;voxels&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Get FDR mode</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">    topoFDR = spm_get_defaults(<span class="string">'stats.topoFDR'</span>);</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">    topoFDR = <span class="built_in">true</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Height threshold - classical inference</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> STAT ~= <span class="string">'P'</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">%-Get height threshold</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    fprintf(<span class="string">'%s%30s'</span>,<span class="built_in">repmat</span>(sprintf(<span class="string">'\b'</span>),<span class="number">1</span>,<span class="number">30</span>),<span class="string">'...height threshold'</span>)  <span class="comment">%-#</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">        thresDesc = xSPM.thresDesc;</span><br><span class="line">    <span class="keyword">catch</span></span><br><span class="line">        <span class="keyword">if</span> topoFDR</span><br><span class="line">            str = <span class="string">'FWE|none'</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            str = <span class="string">'FWE|FDR|none'</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        thresDesc = InputthresDesc;<span class="comment">%===p value adjustment to control: 'FWE' or 'none'====================================================================</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> thresDesc</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> <span class="string">'FWE'</span> <span class="comment">% Family-wise false positive rate</span></span><br><span class="line">            <span class="comment">%--------------------------------------------------------------</span></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">                u = xSPM.u;</span><br><span class="line">            <span class="keyword">catch</span></span><br><span class="line">                u = spm_input(<span class="string">'p value (FWE)'</span>,<span class="string">'+0'</span>,<span class="string">'r'</span>,<span class="number">0.05</span>,<span class="number">1</span>,[<span class="number">0</span>,<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            thresDescDes = [<span class="string">'p&lt;'</span> num2str(u) <span class="string">' ('</span> thresDesc <span class="string">')'</span>];</span><br><span class="line">            u = spm_uc(u,df,STAT,R,n,S);</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> <span class="string">'FDR'</span> <span class="comment">% False discovery rate</span></span><br><span class="line">            <span class="comment">%--------------------------------------------------------------</span></span><br><span class="line">            <span class="keyword">if</span> topoFDR,</span><br><span class="line">                fprintf(<span class="string">'\n'</span>);                                          <span class="comment">%-#</span></span><br><span class="line">                error(<span class="string">'Change defaults.stats.topoFDR to use voxel FDR'</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">                u = xSPM.u;</span><br><span class="line">            <span class="keyword">catch</span></span><br><span class="line">                u = spm_input(<span class="string">'p value (FDR)'</span>,<span class="string">'+0'</span>,<span class="string">'r'</span>,<span class="number">0.05</span>,<span class="number">1</span>,[<span class="number">0</span>,<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            thresDescDes = [<span class="string">'p&lt;'</span> num2str(u) <span class="string">' ('</span> thresDesc <span class="string">')'</span>];</span><br><span class="line">            u = spm_uc_FDR(u,df,STAT,n,VspmSv,<span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> <span class="string">'none'</span>  <span class="comment">% No adjustment: p for conjunctions is p of the conjunction SPM</span></span><br><span class="line">            <span class="comment">%--------------------------------------------------------------</span></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">                u = xSPM.u;</span><br><span class="line">            <span class="keyword">catch</span></span><br><span class="line">                u = Input_u; <span class="comment">%threshold  默认0.001========================================================================</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span> u &lt;= <span class="number">1</span></span><br><span class="line">                thresDescDes = [<span class="string">'p&lt;'</span> num2str(u) <span class="string">' (unc.)'</span>];</span><br><span class="line">                u = spm_u(u^(<span class="number">1</span>/n),df,STAT);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                thresDescDes = [STAT <span class="string">'='</span> num2str(u) ];</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">otherwise</span></span><br><span class="line">            <span class="comment">%--------------------------------------------------------------</span></span><br><span class="line">            fprintf(<span class="string">'\n'</span>);                                              <span class="comment">%-#</span></span><br><span class="line">            error(<span class="string">'Unknown control method "%s".'</span>,thresDesc);</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">end</span> <span class="comment">% switch thresDesc</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">%-Compute p-values for topological and voxel-wise FDR (all search voxels)</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> ~topoFDR</span><br><span class="line">        fprintf(<span class="string">'%s%30s'</span>,<span class="built_in">repmat</span>(sprintf(<span class="string">'\b'</span>),<span class="number">1</span>,<span class="number">30</span>),<span class="string">'...for voxelFDR'</span>)  <span class="comment">%-#</span></span><br><span class="line">        <span class="keyword">switch</span> STAT</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'Z'</span></span><br><span class="line">                Ps = (<span class="number">1</span>-spm_Ncdf(Zum)).^n;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'T'</span></span><br><span class="line">                Ps = (<span class="number">1</span> - spm_Tcdf(Zum,df(<span class="number">2</span>))).^n;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'X'</span></span><br><span class="line">                Ps = (<span class="number">1</span>-spm_Xcdf(Zum,df(<span class="number">2</span>))).^n;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'F'</span></span><br><span class="line">                Ps = (<span class="number">1</span> - spm_Fcdf(Zum,df)).^n;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        Ps = <span class="built_in">sort</span>(Ps);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">%-Peak FDR</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    [up,Pp] = spm_uc_peakFDR(<span class="number">0.05</span>,df,STAT,R,n,Zum,XYZum,u);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">%-Cluster FDR</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> STAT == <span class="string">'T'</span> &amp;&amp; n == <span class="number">1</span></span><br><span class="line">        V2R        = <span class="number">1</span>/prod(SPM.xVol.FWHM(SPM.xVol.DIM &gt; <span class="number">1</span>));</span><br><span class="line">        [uc,Pc,ue] = spm_uc_clusterFDR(<span class="number">0.05</span>,df,STAT,R,n,Zum,XYZum,V2R,u);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        uc  = NaN;</span><br><span class="line">        ue  = NaN;</span><br><span class="line">        Pc  = [];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">%-Peak FWE</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    uu      = spm_uc(<span class="number">0.05</span>,df,STAT,R,n,S);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">%-Height threshold - Bayesian inference</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">elseif</span> STAT == <span class="string">'P'</span></span><br><span class="line">    </span><br><span class="line">    u_default = <span class="number">1</span> - <span class="number">1</span>/SPM.xVol.S;</span><br><span class="line">    str       = <span class="string">'Posterior probability threshold for PPM'</span>;</span><br><span class="line">    u         = spm_input(str,<span class="string">'+0'</span>,<span class="string">'r'</span>,u_default,<span class="number">1</span>);</span><br><span class="line">    thresDescDes = [<span class="string">'P&gt;'</span>  num2str(u) <span class="string">' (PPM)'</span>];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span> <span class="comment">% (if STAT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Calculate height threshold filtering</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">Q      = <span class="built_in">find</span>(Z &gt; u);</span><br><span class="line"></span><br><span class="line"><span class="comment">%-Apply height threshold</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">Z      = Z(:,Q);</span><br><span class="line">XYZ    = XYZ(:,Q);</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isempty</span>(Q)</span><br><span class="line">    fprintf(<span class="string">'\n'</span>);                                                      <span class="comment">%-#</span></span><br><span class="line">    warning(<span class="string">'SPM:NoVoxels'</span>,<span class="string">'No voxels survive height threshold at u=%0.2g'</span>,u);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Extent threshold</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> ~<span class="built_in">isempty</span>(XYZ)</span><br><span class="line">    </span><br><span class="line">    fprintf(<span class="string">'%s%30s'</span>,<span class="built_in">repmat</span>(sprintf(<span class="string">'\b'</span>),<span class="number">1</span>,<span class="number">30</span>),<span class="string">'...extent threshold'</span>); <span class="comment">%-#</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">%-Get extent threshold [default = 0]</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">        k = xSPM.k;</span><br><span class="line">    <span class="keyword">catch</span></span><br><span class="line">        k = Input_k;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">%-Calculate extent threshold filtering</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    A     = spm_clusters(XYZ);</span><br><span class="line">    Q     = [];</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">max</span>(A)</span><br><span class="line">        <span class="built_in">j</span> = <span class="built_in">find</span>(A == <span class="built_in">i</span>);</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">length</span>(<span class="built_in">j</span>) &gt;= k, Q = [Q <span class="built_in">j</span>]; <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% ...eliminate voxels</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    Z     = Z(:,Q);</span><br><span class="line">    XYZ   = XYZ(:,Q);</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isempty</span>(Q)</span><br><span class="line">        fprintf(<span class="string">'\n'</span>);                                                  <span class="comment">%-#</span></span><br><span class="line">        warning(<span class="string">'SPM:NoVoxels'</span>,<span class="string">'No voxels survive extent threshold at k=%0.2g'</span>,k);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    </span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span> <span class="comment">% (if ~isempty(XYZ))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-For Bayesian inference provide (default) option to display contrast values</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> STAT == <span class="string">'P'</span></span><br><span class="line">    <span class="keyword">if</span> spm_input(<span class="string">'Plot effect-size/statistic'</span>,<span class="number">1</span>,<span class="string">'b'</span>,&#123;<span class="string">'Yes'</span>,<span class="string">'No'</span>&#125;,[<span class="number">1</span> <span class="number">0</span>])</span><br><span class="line">        Z = spm_get_data(xCon(Ic).Vcon,XYZ);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="comment">% - E N D</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line">fprintf(<span class="string">'%s%30s\n'</span>,<span class="built_in">repmat</span>(sprintf(<span class="string">'\b'</span>),<span class="number">1</span>,<span class="number">30</span>),<span class="string">'...done'</span>)                <span class="comment">%-#</span></span><br><span class="line">spm(<span class="string">'Pointer'</span>,<span class="string">'Arrow'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%-Assemble output structures of unfiltered data</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line">xSPM   = struct( ...</span><br><span class="line">            <span class="string">'swd'</span>,      swd,...</span><br><span class="line">            <span class="string">'title'</span>,    titlestr,...</span><br><span class="line">            <span class="string">'Z'</span>,        Z,...</span><br><span class="line">            <span class="string">'n'</span>,        n,...</span><br><span class="line">            <span class="string">'STAT'</span>,     STAT,...</span><br><span class="line">            <span class="string">'df'</span>,       df,...</span><br><span class="line">            <span class="string">'STATstr'</span>,  STATstr,...</span><br><span class="line">            <span class="string">'Ic'</span>,       Ic,...</span><br><span class="line">            <span class="string">'Im'</span>,       &#123;Im&#125;,...</span><br><span class="line">            <span class="string">'pm'</span>,       pm,...</span><br><span class="line">            <span class="string">'Ex'</span>,       Ex,...</span><br><span class="line">            <span class="string">'u'</span>,        u,...</span><br><span class="line">            <span class="string">'k'</span>,        k,...</span><br><span class="line">            <span class="string">'XYZ'</span>,      XYZ,...</span><br><span class="line">            <span class="string">'XYZmm'</span>,    SPM.xVol.M(<span class="number">1</span>:<span class="number">3</span>,:)*[XYZ; <span class="built_in">ones</span>(<span class="number">1</span>,<span class="built_in">size</span>(XYZ,<span class="number">2</span>))],...</span><br><span class="line">            <span class="string">'S'</span>,        SPM.xVol.S,...</span><br><span class="line">            <span class="string">'R'</span>,        SPM.xVol.R,...</span><br><span class="line">            <span class="string">'FWHM'</span>,     SPM.xVol.FWHM,...</span><br><span class="line">            <span class="string">'M'</span>,        SPM.xVol.M,...</span><br><span class="line">            <span class="string">'iM'</span>,       SPM.xVol.iM,...</span><br><span class="line">            <span class="string">'DIM'</span>,      SPM.xVol.DIM,...</span><br><span class="line">            <span class="string">'VOX'</span>,      VOX,...</span><br><span class="line">            <span class="string">'Vspm'</span>,     VspmSv,...</span><br><span class="line">            <span class="string">'thresDesc'</span>,thresDesc);</span><br><span class="line"></span><br><span class="line"><span class="comment">%-RESELS per voxel (density) if it exists</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">try</span>, xSPM.VRpv = SPM.xVol.VRpv; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">    xSPM.units = SPM.xVol.units;</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">    <span class="keyword">try</span>, xSPM.units = varargin&#123;<span class="number">1</span>&#125;.units; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-p-values for topological and voxel-wise FDR</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">try</span>, xSPM.Ps    = Ps;             <span class="keyword">end</span>  <span class="comment">% voxel   FDR</span></span><br><span class="line"><span class="keyword">try</span>, xSPM.Pp    = Pp;             <span class="keyword">end</span>  <span class="comment">% peak    FDR</span></span><br><span class="line"><span class="keyword">try</span>, xSPM.Pc    = Pc;             <span class="keyword">end</span>  <span class="comment">% cluster FDR</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-0.05 critical thresholds for FWEp, FDRp, FWEc, FDRc</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">try</span>, xSPM.uc    = [uu up ue uc];  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="spm_regions_extend.m">spm_regions_extend.m</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[Y,xY]</span> = <span class="title">spm_regions_extend</span><span class="params">(xSPM,SPM,hReg,xY,Input_VOINames,Input_is,Input_VOI_path)</span></span></span><br><span class="line"><span class="comment">% VOI time-series extraction of adjusted data (&amp; local eigenimage analysis)</span></span><br><span class="line"><span class="comment">% FORMAT [Y xY] = spm_regions(xSPM,SPM,hReg,[xY]);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% FORMAT [Y xY] = spm_regions(xSPM,SPM,hReg,[xY],Input_VOIName,Input_i)</span></span><br><span class="line"><span class="comment">% Input_VOIName : 抽取的VOI的名称</span></span><br><span class="line"><span class="comment">% Input_i : adjust_contrst 这里选择那个F-All的,整数，1 是dont adjust, 2 是F-All.</span></span><br><span class="line"><span class="comment">% Input_VOI_path : 抽取VOI所使用的Mask的路径;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> nargin &lt; <span class="number">4</span>, xY = []; <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> nargin &gt; <span class="number">5</span></span><br><span class="line">    Input_VOIName = Input_VOINames;</span><br><span class="line">    Input_i =Input_is;</span><br><span class="line">    xY = [];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%-Get figure handles</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">Finter = spm_figure(<span class="string">'FindWin'</span>,<span class="string">'Interactive'</span>);</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isempty</span>(Finter), noGraph = <span class="number">1</span>; <span class="keyword">else</span> noGraph = <span class="number">0</span>; <span class="keyword">end</span></span><br><span class="line">header = get(Finter,<span class="string">'Name'</span>);</span><br><span class="line">set(Finter,<span class="string">'Name'</span>,<span class="string">'VOI time-series extraction'</span>);</span><br><span class="line"><span class="keyword">if</span> ~noGraph, Fgraph = spm_figure(<span class="string">'GetWin'</span>,<span class="string">'Graphics'</span>); <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Find nearest voxel [Euclidean distance] in point list</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isempty</span>(xSPM.XYZmm)</span><br><span class="line">    spm(<span class="string">'alert!'</span>,<span class="string">'No suprathreshold voxels!'</span>,mfilename,<span class="number">0</span>);</span><br><span class="line">    Y = []; xY = [];</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">    xyz    = xY.xyz;</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">    xyz    = spm_XYZreg(<span class="string">'NearestXYZ'</span>,...</span><br><span class="line">             spm_XYZreg(<span class="string">'GetCoords'</span>,hReg),xSPM.XYZmm);</span><br><span class="line">    xY.xyz = xyz;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% and update GUI location</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">spm_XYZreg(<span class="string">'SetCoords'</span>,xyz,hReg);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Get adjustment options and VOI name</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> ~noGraph</span><br><span class="line">    <span class="keyword">if</span> ~<span class="built_in">isempty</span>(xY.xyz)</span><br><span class="line">        posstr = sprintf(<span class="string">'at [%3.0f %3.0f %3.0f]'</span>,xY.xyz);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        posstr = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    spm_input(posstr,<span class="number">1</span>,<span class="string">'d'</span>,<span class="string">'VOI time-series extraction'</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ~isfield(xY,<span class="string">'name'</span>)</span><br><span class="line">    xY.name    = Input_VOIName; <span class="comment">%name of region char字符串类型 ========================================================================</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ~isfield(xY,<span class="string">'Ic'</span>)</span><br><span class="line">    q     = <span class="number">0</span>;</span><br><span class="line">    Con   = &#123;<span class="string">'&lt;don''t adjust&gt;'</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(SPM.xCon)</span><br><span class="line">        <span class="keyword">if</span> strcmp(SPM.xCon(<span class="built_in">i</span>).STAT,<span class="string">'F'</span>)</span><br><span class="line">            q(<span class="keyword">end</span> + <span class="number">1</span>) = <span class="built_in">i</span>;</span><br><span class="line">            Con&#123;<span class="keyword">end</span> + <span class="number">1</span>&#125; = SPM.xCon(<span class="built_in">i</span>).name;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">i</span>     = Input_i; <span class="comment">% adjust_contrst 这里选择那个F-All的,整数，1 是dont adjust, 2 是F-All. =====================================================================</span></span><br><span class="line">    xY.Ic = q(<span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-If fMRI data then ask user to select session</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> isfield(SPM,<span class="string">'Sess'</span>) &amp;&amp; ~isfield(xY,<span class="string">'Sess'</span>)</span><br><span class="line">    s       = <span class="built_in">length</span>(SPM.Sess);</span><br><span class="line">    <span class="keyword">if</span> s &gt; <span class="number">1</span></span><br><span class="line">        s   = spm_input(<span class="string">'which session'</span>,<span class="string">'!+1'</span>,<span class="string">'n1'</span>,s,s);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    xY.Sess = s;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Specify VOI</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">xY.M = xSPM.M;</span><br><span class="line">[xY, xY.XYZmm, Q] = spm_ROI_extend(xY, xSPM.XYZmm,Input_VOI_path);<span class="comment">%--------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">try</span>, xY = rmfield(xY,<span class="string">'M'</span>); <span class="keyword">end</span></span><br><span class="line"><span class="keyword">try</span>, xY = rmfield(xY,<span class="string">'rej'</span>); <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isempty</span>(xY.XYZmm)</span><br><span class="line">    warning(<span class="string">'Empty region.'</span>);</span><br><span class="line">    Y = [];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Extract required data from results files</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line">spm(<span class="string">'Pointer'</span>,<span class="string">'Watch'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%-Get raw data, whiten and filter </span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">y        = spm_get_data(SPM.xY.VY,xSPM.XYZ(:,Q));</span><br><span class="line">y        = spm_filter(SPM.xX.K,SPM.xX.W*y);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Computation</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Remove null space of contrast</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> xY.Ic</span><br><span class="line"></span><br><span class="line">    <span class="comment">%-Parameter estimates: beta = xX.pKX*xX.K*y</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="built_in">beta</span>  = spm_get_data(SPM.Vbeta,xSPM.XYZ(:,Q));</span><br><span class="line"></span><br><span class="line">    <span class="comment">%-subtract Y0 = XO*beta,  Y = Yc + Y0 + e</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    y     = y - spm_FcUtil(<span class="string">'Y0'</span>,SPM.xCon(xY.Ic),SPM.xX.xKXs,<span class="built_in">beta</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Confounds</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">xY.X0     = SPM.xX.xKXs.X(:,[SPM.xX.iB SPM.xX.iG]);</span><br><span class="line"></span><br><span class="line"><span class="comment">%-Extract session-specific rows from data and confounds</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">    <span class="built_in">i</span>     = SPM.Sess(xY.Sess).row;</span><br><span class="line">    y     = y(<span class="built_in">i</span>,:);</span><br><span class="line">    xY.X0 = xY.X0(<span class="built_in">i</span>,:);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% and add session-specific filter confounds</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">    xY.X0 = [xY.X0 SPM.xX.K(xY.Sess).X0];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">    xY.X0 = [xY.X0 SPM.xX.K(xY.Sess).KH]; <span class="comment">% Compatibility check</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Remove null space of X0</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">xY.X0     = xY.X0(:,any(xY.X0));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Compute regional response in terms of first eigenvariate</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">[m n]   = <span class="built_in">size</span>(y);</span><br><span class="line"><span class="keyword">if</span> m &gt; n</span><br><span class="line">    [v s v] = svd(y'*y);</span><br><span class="line">    s       = <span class="built_in">diag</span>(s);</span><br><span class="line">    v       = v(:,<span class="number">1</span>);</span><br><span class="line">    u       = y*v/<span class="built_in">sqrt</span>(s(<span class="number">1</span>));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    [u s u] = svd(y*y');</span><br><span class="line">    s       = <span class="built_in">diag</span>(s);</span><br><span class="line">    u       = u(:,<span class="number">1</span>);</span><br><span class="line">    v       = y'*u/<span class="built_in">sqrt</span>(s(<span class="number">1</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">d       = <span class="built_in">sign</span>(sum(v));</span><br><span class="line">u       = u*d;</span><br><span class="line">v       = v*d;</span><br><span class="line">Y       = u*<span class="built_in">sqrt</span>(s(<span class="number">1</span>)/n);</span><br><span class="line"></span><br><span class="line"><span class="comment">%-Set in structure</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">xY.y    = y;</span><br><span class="line">xY.u    = Y;</span><br><span class="line">xY.v    = v;</span><br><span class="line">xY.s    = s;</span><br><span class="line"></span><br><span class="line"><span class="comment">%-Display VOI weighting and eigenvariate</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="keyword">if</span> ~noGraph</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% show position</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    spm_results_ui(<span class="string">'Clear'</span>,Fgraph);</span><br><span class="line">    <span class="built_in">figure</span>(Fgraph);</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    spm_dcm_display(xY)</span><br><span class="line"></span><br><span class="line">    <span class="comment">% show dynamics</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">        <span class="built_in">plot</span>(SPM.xY.RT*[<span class="number">1</span>:<span class="built_in">length</span>(xY.u)],Y)</span><br><span class="line">        str = <span class="string">'time (seconds&#125;'</span>;</span><br><span class="line">    <span class="keyword">catch</span></span><br><span class="line">        <span class="built_in">plot</span>(Y)</span><br><span class="line">        str = <span class="string">'scan'</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    title([<span class="string">'1st eigenvariate: '</span> xY.name],<span class="string">'FontSize'</span>,<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">if</span> strcmpi(xY.def,<span class="string">'mask'</span>)</span><br><span class="line">        [p,n,e] = fileparts(xY.spec.fname);</span><br><span class="line">        posstr  = sprintf(<span class="string">'from mask %s'</span>, [n e]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        posstr  = sprintf(<span class="string">'at [%3.0f %3.0f %3.0f]'</span>,xY.xyz);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    str = &#123; str;<span class="string">' '</span>;...</span><br><span class="line">        sprintf(<span class="string">'%d voxels in VOI %s'</span>,<span class="built_in">length</span>(Q),posstr);...</span><br><span class="line">        sprintf(<span class="string">'Variance: %0.2f%%'</span>,s(<span class="number">1</span>)*<span class="number">100</span>/sum(s))&#125;;</span><br><span class="line">    xlabel(str)</span><br><span class="line">    axis tight square</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Save</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line">str = [<span class="string">'VOI_'</span> xY.name <span class="string">'.mat'</span>];</span><br><span class="line"><span class="keyword">if</span> isfield(xY,<span class="string">'Sess'</span>) &amp;&amp; isfield(SPM,<span class="string">'Sess'</span>)</span><br><span class="line">    str = sprintf(<span class="string">'VOI_%s_%i.mat'</span>,xY.name,xY.Sess);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> spm_check_version(<span class="string">'matlab'</span>,<span class="string">'7'</span>) &gt;= <span class="number">0</span></span><br><span class="line">    save(fullfile(SPM.swd,str),<span class="string">'-V6'</span>,<span class="string">'Y'</span>,<span class="string">'xY'</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    save(fullfile(SPM.swd,str),<span class="string">'Y'</span>,<span class="string">'xY'</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">fprintf(<span class="string">'   VOI saved as %s\n'</span>,spm_str_manip(fullfile(SPM.swd,str),<span class="string">'k55'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">%-Reset title</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">set(Finter,<span class="string">'Name'</span>,header);</span><br><span class="line">spm(<span class="string">'Pointer'</span>,<span class="string">'Arrow'</span>)</span><br></pre></td></tr></table></figure><h2 id="spm_result_ui_extend.m">spm_result_ui_extend.m</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">varargout</span> = <span class="title">spm_result_ui_extend</span><span class="params">(varargin)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% FORMAT [hreg,xSPM,SPM] = spm_results_ui('Setup')</span></span><br><span class="line"><span class="comment">% Query SPM and setup GUI. </span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% FORMAT [hreg,xSPM,SPM] = spm_results_ui('Setup',xSPM)</span></span><br><span class="line"><span class="comment">% Query SPM and setup GUI using a xSPM input structure. This allows to run</span></span><br><span class="line"><span class="comment">% results setup without user interaction. See spm_getSPM for details of</span></span><br><span class="line"><span class="comment">% allowed fields.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% FORMAT hReg = spm_results_ui('SetupGUI',M,DIM,xSPM,Finter)</span></span><br><span class="line"><span class="comment">% Setup results GUI in Interactive window</span></span><br><span class="line"><span class="comment">% M       - 4x4 transformation matrix relating voxel to "real" co-ordinates</span></span><br><span class="line"><span class="comment">% DIM     - 3 vector of image X, Y &amp; Z dimensions</span></span><br><span class="line"><span class="comment">% xSPM    - structure containing xSPM. Required fields are:</span></span><br><span class="line"><span class="comment">% .Z      - minimum of n Statistics &#123;filtered on u and k&#125;</span></span><br><span class="line"><span class="comment">% .XYZmm  - location of voxels &#123;mm&#125;</span></span><br><span class="line"><span class="comment">% Finter  - handle (or 'Tag') of Interactive window (default 'Interactive')</span></span><br><span class="line"><span class="comment">% hReg    - handle of XYZ registry object</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% FORMAT spm_results_ui('DrawButts',hReg,DIM,Finter,WS,FS)</span></span><br><span class="line"><span class="comment">% Draw GUI buttons</span></span><br><span class="line"><span class="comment">% hReg    - handle of XYZ registry object</span></span><br><span class="line"><span class="comment">% DIM     - 3 vector of image X, Y &amp; Z dimensions</span></span><br><span class="line"><span class="comment">% Finter  - handle of Interactive window</span></span><br><span class="line"><span class="comment">% WS      - WinScale  [Default spm('WinScale') ]</span></span><br><span class="line"><span class="comment">% FS      - FontSizes [Default spm('FontSizes')]</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% FORMAT hFxyz = spm_results_ui('DrawXYZgui',M,DIM,xSPM,xyz,Finter)</span></span><br><span class="line"><span class="comment">% Setup editable XYZ control widgets at foot of Interactive window</span></span><br><span class="line"><span class="comment">% M      - 4x4 transformation matrix relating voxel to "real" co-ordinates</span></span><br><span class="line"><span class="comment">% DIM    - 3 vector of image X, Y &amp; Z dimensions</span></span><br><span class="line"><span class="comment">% xSPM   - structure containing SPM; Required fields are:</span></span><br><span class="line"><span class="comment">% .Z     - minimum of n Statistics &#123;filtered on u and k&#125;</span></span><br><span class="line"><span class="comment">% .XYZmm - location of voxels &#123;mm&#125;</span></span><br><span class="line"><span class="comment">% xyz    - Initial xyz location &#123;mm&#125;</span></span><br><span class="line"><span class="comment">% Finter - handle of Interactive window</span></span><br><span class="line"><span class="comment">% hFxyz  - handle of XYZ control - the frame containing the edit widgets</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% FORMAT spm_results_ui('EdWidCB')</span></span><br><span class="line"><span class="comment">% Callback for editable XYZ control widgets</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% FORMAT spm_results_ui('UpdateSPMval',hFxyz)</span></span><br><span class="line"><span class="comment">% FORMAT spm_results_ui('UpdateSPMval',UD)</span></span><br><span class="line"><span class="comment">% Updates SPM value string in Results GUI (using data from UserData of hFxyz)</span></span><br><span class="line"><span class="comment">% hFxyz - handle of frame enclosing widgets - the Tag object for this control</span></span><br><span class="line"><span class="comment">% UD    - XYZ data structure (UserData of hFxyz).</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% FORMAT xyz = spm_results_ui('GetCoords',hFxyz)</span></span><br><span class="line"><span class="comment">% Get current co-ordinates from editable XYZ control</span></span><br><span class="line"><span class="comment">% hFxyz - handle of frame enclosing widgets - the Tag object for this control</span></span><br><span class="line"><span class="comment">% xyz   - current co-ordinates &#123;mm&#125;</span></span><br><span class="line"><span class="comment">% NB: When using the results section, should use XYZregistry to get/set location</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% FORMAT [xyz,d] = spm_results_ui('SetCoords',xyz,hFxyz,hC)</span></span><br><span class="line"><span class="comment">% Set co-ordinates to XYZ widget</span></span><br><span class="line"><span class="comment">% xyz   - (Input) desired co-ordinates &#123;mm&#125;</span></span><br><span class="line"><span class="comment">% hFxyz - handle of XYZ control - the frame containing the edit widgets</span></span><br><span class="line"><span class="comment">% hC    - handle of calling object, if used as a callback. [Default 0]</span></span><br><span class="line"><span class="comment">% xyz   - (Output) Desired co-ordinates are rounded to nearest voxel if hC</span></span><br><span class="line"><span class="comment">%         is not specified, or is zero. Otherwise, caller is assumed to</span></span><br><span class="line"><span class="comment">%         have checked verity of desired xyz co-ordinates. Output xyz returns</span></span><br><span class="line"><span class="comment">%         co-ordinates actually set &#123;mm&#125;.</span></span><br><span class="line"><span class="comment">% d     - Euclidean distance between desired and set co-ordinates.</span></span><br><span class="line"><span class="comment">% NB: When using the results section, should use XYZregistry to get/set location</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% FORMAT hFxyz = spm_results_ui('FindXYZframe',h)</span></span><br><span class="line"><span class="comment">% Find/check XYZ edit widgets frame handle, 'Tag'ged 'hFxyz'</span></span><br><span class="line"><span class="comment">% h     - handle of frame enclosing widgets, or containing figure [default gcf]</span></span><br><span class="line"><span class="comment">%         If ischar(h), then uses spm_figure('FindWin',h) to locate named figures</span></span><br><span class="line"><span class="comment">% hFxyz - handle of confirmed XYZ editable widgets control</span></span><br><span class="line"><span class="comment">%         Errors if hFxyz is not an XYZ widget control, or a figure containing</span></span><br><span class="line"><span class="comment">%         a unique such control</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% FORMAT spm_results_ui('PlotUi',hAx)</span></span><br><span class="line"><span class="comment">% GUI for adjusting plot attributes - Sets up controls just above results GUI</span></span><br><span class="line"><span class="comment">% hAx - handle of axes to work with</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% FORMAT spm_results_ui('PlotUiCB')</span></span><br><span class="line"><span class="comment">% CallBack handler for Plot attribute GUI</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% FORMAT Fgraph = spm_results_ui('Clear',F,mode)</span></span><br><span class="line"><span class="comment">% Clears results subpane of Graphics window, deleting all but semi-permanent</span></span><br><span class="line"><span class="comment">% results section stuff</span></span><br><span class="line"><span class="comment">% F      - handle of Graphics window [Default spm_figure('FindWin','Graphics')]</span></span><br><span class="line"><span class="comment">% mode   - 1 [default] - clear results subpane</span></span><br><span class="line"><span class="comment">%        - 0           - clear results subpane and hide results stuff</span></span><br><span class="line"><span class="comment">%        - 2           - clear, but respect 'NextPlot' 'add' axes</span></span><br><span class="line"><span class="comment">%                        (which is set by `hold on`)</span></span><br><span class="line"><span class="comment">% Fgraph - handle of Graphics window</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% FORMAT hMP = spm_results_ui('LaunchMP',M,DIM,hReg,hBmp)</span></span><br><span class="line"><span class="comment">% Prototype callback handler for integrating MultiPlanar toolbox</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% FORMAT spm_results_ui('Delete',h)</span></span><br><span class="line"><span class="comment">% deletes HandleGraphics objects, but only if they're valid, thus avoiding</span></span><br><span class="line"><span class="comment">% warning statements from MATLAB.</span></span><br><span class="line"><span class="comment">%__________________________________________________________________________</span></span><br><span class="line"> </span><br><span class="line">SVNid = <span class="string">'$Rev: 4209 $'</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">%-Condition arguments</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> nargin == <span class="number">0</span>, Action=<span class="string">'SetUp'</span>; <span class="keyword">else</span> Action=varargin&#123;<span class="number">1</span>&#125;; <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="keyword">switch</span> lower(Action), <span class="keyword">case</span> <span class="string">'setup'</span>                         <span class="comment">%-Set up results</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">%-Initialise</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    SPMid = spm(<span class="string">'FnBanner'</span>,mfilename,SVNid);</span><br><span class="line">    [Finter,Fgraph,CmdLine] = spm(<span class="string">'FnUIsetup'</span>,<span class="string">'Stats: Results'</span>);</span><br><span class="line">    spm_clf(<span class="string">'Satellite'</span>)</span><br><span class="line">    FS    = spm(<span class="string">'FontSizes'</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">%-Get thresholded xSPM data and parameters of design</span></span><br><span class="line">    <span class="comment">%======================================================================</span></span><br><span class="line">    <span class="keyword">if</span> nargin &gt; <span class="number">1</span></span><br><span class="line">        [SPM,xSPM] = spm_getSPM_extend(varargin&#123;<span class="number">2</span>&#125;);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        [SPM,xSPM] = spm_getSPM;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isempty</span>(xSPM) </span><br><span class="line">        varargout = &#123;[],[],[]&#125;;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">%-Ensure pwd = swd so that relative filenames are valid</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    cd(SPM.swd)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">%-Get space information</span></span><br><span class="line">    <span class="comment">%======================================================================</span></span><br><span class="line">    M         = SPM.xVol.M;</span><br><span class="line">    DIM       = SPM.xVol.DIM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">%-Space units</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">            units = SPM.xVol.units;</span><br><span class="line">        <span class="keyword">catch</span></span><br><span class="line">            units = xSPM.units;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">catch</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">            <span class="keyword">if</span> strcmp(spm(<span class="string">'CheckModality'</span>),<span class="string">'EEG'</span>)</span><br><span class="line">                datatype = &#123;...</span><br><span class="line">                    <span class="string">'Volumetric (2D/3D)'</span>,...</span><br><span class="line">                    <span class="string">'Scalp-Time'</span>,...</span><br><span class="line">                    <span class="string">'Scalp-Frequency'</span>,...</span><br><span class="line">                    <span class="string">'Time-Frequency'</span>,...</span><br><span class="line">                    <span class="string">'Frequency-Frequency'</span>&#125;;</span><br><span class="line">                selected = spm_input(<span class="string">'Data Type: '</span>,<span class="string">'+1'</span>,<span class="string">'m'</span>,datatype);</span><br><span class="line">                datatype = datatype&#123;selected&#125;;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                datatype = <span class="string">'Volumetric (2D/3D)'</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">catch</span></span><br><span class="line">            datatype     = <span class="string">'Volumetric (2D/3D)'</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span> datatype</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'Volumetric (2D/3D)'</span></span><br><span class="line">                units    = &#123;<span class="string">'mm'</span> <span class="string">'mm'</span> <span class="string">'mm'</span>&#125;;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'Scalp-Time'</span></span><br><span class="line">                units    = &#123;<span class="string">'mm'</span> <span class="string">'mm'</span> <span class="string">'ms'</span>&#125;;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'Scalp-Frequency'</span></span><br><span class="line">                units    = &#123;<span class="string">'mm'</span> <span class="string">'mm'</span> <span class="string">'Hz'</span>&#125;;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'Time-Frequency'</span></span><br><span class="line">                units    = &#123;<span class="string">'Hz'</span> <span class="string">'ms'</span> <span class="string">''</span>&#125;;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'Frequency-Frequency'</span></span><br><span class="line">                units    = &#123;<span class="string">'Hz'</span> <span class="string">'Hz'</span> <span class="string">''</span>&#125;;</span><br><span class="line">            <span class="keyword">otherwise</span></span><br><span class="line">                error(<span class="string">'Unknown data type.'</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> DIM(<span class="number">3</span>) == <span class="number">1</span>, units&#123;<span class="number">3</span>&#125; = <span class="string">''</span>; <span class="keyword">end</span></span><br><span class="line">    xSPM.units      = units;</span><br><span class="line">    SPM.xVol.units  = units;</span><br><span class="line">    </span><br><span class="line">     </span><br><span class="line">    <span class="comment">%-Setup Results User Interface; Display MIP, design matrix &amp; parameters</span></span><br><span class="line">    <span class="comment">%======================================================================</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">%-Setup results GUI</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    spm_clf(Finter);</span><br><span class="line">    spm(<span class="string">'FigName'</span>,[<span class="string">'SPM&#123;'</span>,xSPM.STAT,<span class="string">'&#125;: Results'</span>],Finter,CmdLine);</span><br><span class="line">    hReg      = spm_results_ui(<span class="string">'SetupGUI'</span>,M,DIM,xSPM,Finter);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">%-Setup design interrogation menu</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    hDesRepUI = spm_DesRep(<span class="string">'DesRepUI'</span>,SPM);</span><br><span class="line">    <span class="built_in">figure</span>(Finter)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">%-Setup contrast menu</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    hC = uimenu(Finter,<span class="string">'Label'</span>,<span class="string">'Contrasts'</span>, <span class="string">'Tag'</span>,<span class="string">'ContrastsUI'</span>);</span><br><span class="line">    hC1 = uimenu(hC,<span class="string">'Label'</span>,<span class="string">'New Contrast...'</span>,...</span><br><span class="line">        <span class="string">'UserData'</span>,struct(<span class="string">'Ic'</span>,<span class="number">0</span>),...</span><br><span class="line">        <span class="string">'Callback'</span>,&#123;@mychgcon,xSPM&#125;);</span><br><span class="line">    hC1 = uimenu(hC,<span class="string">'Label'</span>,<span class="string">'Change Contrast'</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">numel</span>(SPM.xCon)</span><br><span class="line">        hC2 = uimenu(hC1,<span class="string">'Label'</span>,[SPM.xCon(<span class="built_in">i</span>).STAT, <span class="string">': '</span>, SPM.xCon(<span class="built_in">i</span>).name], ...</span><br><span class="line">            <span class="string">'UserData'</span>,struct(<span class="string">'Ic'</span>,<span class="built_in">i</span>),...</span><br><span class="line">            <span class="string">'Callback'</span>,&#123;@mychgcon,xSPM&#125;);</span><br><span class="line">        <span class="keyword">if</span> any(xSPM.Ic == <span class="built_in">i</span>)</span><br><span class="line">            set(hC2,<span class="string">'ForegroundColor'</span>,[<span class="number">0</span> <span class="number">0</span> <span class="number">1</span>],<span class="string">'Checked'</span>,<span class="string">'on'</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    hC1 = uimenu(hC,<span class="string">'Label'</span>,<span class="string">'Previous Contrast'</span>,...</span><br><span class="line">        <span class="string">'Accelerator'</span>,<span class="string">'P'</span>,...</span><br><span class="line">        <span class="string">'UserData'</span>,struct(<span class="string">'Ic'</span>,xSPM.Ic<span class="number">-1</span>),...</span><br><span class="line">        <span class="string">'Callback'</span>,&#123;@mychgcon,xSPM&#125;);</span><br><span class="line">    <span class="keyword">if</span> xSPM.Ic<span class="number">-1</span>&lt;<span class="number">1</span>, set(hC1,<span class="string">'Enable'</span>,<span class="string">'off'</span>); <span class="keyword">end</span></span><br><span class="line">    hC1 = uimenu(hC,<span class="string">'Label'</span>,<span class="string">'Next Contrast'</span>,...</span><br><span class="line">        <span class="string">'Accelerator'</span>,<span class="string">'N'</span>,...</span><br><span class="line">        <span class="string">'UserData'</span>,struct(<span class="string">'Ic'</span>,xSPM.Ic+<span class="number">1</span>),...</span><br><span class="line">        <span class="string">'Callback'</span>,&#123;@mychgcon,xSPM&#125;);</span><br><span class="line">    <span class="keyword">if</span> xSPM.Ic+<span class="number">1</span>&gt;<span class="built_in">numel</span>(SPM.xCon), set(hC1,<span class="string">'Enable'</span>,<span class="string">'off'</span>); <span class="keyword">end</span></span><br><span class="line">    hC1 = uimenu(hC,<span class="string">'Label'</span>,<span class="string">'Significance level'</span>,<span class="string">'Separator'</span>,<span class="string">'on'</span>);</span><br><span class="line">    xSPMtmp = xSPM; xSPMtmp.thresDesc = <span class="string">''</span>;</span><br><span class="line">    uimenu(hC1,<span class="string">'Label'</span>,<span class="string">'Change...'</span>,<span class="string">'UserData'</span>,struct(<span class="string">'Ic'</span>,xSPM.Ic),...</span><br><span class="line">        <span class="string">'Callback'</span>,&#123;@mychgcon,xSPMtmp&#125;);</span><br><span class="line">    xSPMtmp = xSPM; xSPMtmp.thresDesc = <span class="string">'p&lt;0.05 (FWE)'</span>;</span><br><span class="line">    uimenu(hC1,<span class="string">'Label'</span>,<span class="string">'Set to 0.05 (FWE)'</span>,<span class="string">'UserData'</span>,struct(<span class="string">'Ic'</span>,xSPM.Ic),...</span><br><span class="line">        <span class="string">'Callback'</span>,&#123;@mychgcon,xSPMtmp&#125;);</span><br><span class="line">    xSPMtmp = xSPM; xSPMtmp.thresDesc = <span class="string">'p&lt;0.001 (unc.)'</span>;</span><br><span class="line">    uimenu(hC1,<span class="string">'Label'</span>,<span class="string">'Set to 0.001 (unc.)'</span>,<span class="string">'UserData'</span>,struct(<span class="string">'Ic'</span>,xSPM.Ic),...</span><br><span class="line">        <span class="string">'Callback'</span>,&#123;@mychgcon,xSPMtmp&#125;);</span><br><span class="line">    uimenu(hC1,<span class="string">'Label'</span>,[xSPM.thresDesc <span class="string">', k='</span> num2str(xSPM.k)],...</span><br><span class="line">        <span class="string">'Enable'</span>,<span class="string">'off'</span>,<span class="string">'Separator'</span>,<span class="string">'on'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">%-Setup Maximum intensity projection (MIP) &amp; register</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    hMIPax = axes(<span class="string">'Parent'</span>,Fgraph,<span class="string">'Position'</span>,[<span class="number">0.05</span> <span class="number">0.60</span> <span class="number">0.55</span> <span class="number">0.36</span>],<span class="string">'Visible'</span>,<span class="string">'off'</span>);</span><br><span class="line">    hMIPax = spm_mip_ui(xSPM.Z,xSPM.XYZmm,M,DIM,hMIPax,units);</span><br><span class="line"> </span><br><span class="line">    spm_XYZreg(<span class="string">'XReg'</span>,hReg,hMIPax,<span class="string">'spm_mip_ui'</span>);</span><br><span class="line">    <span class="keyword">if</span> xSPM.STAT == <span class="string">'P'</span></span><br><span class="line">        str = xSPM.STATstr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        str = [<span class="string">'SPM\&#123;'</span>,xSPM.STATstr,<span class="string">'\&#125;'</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    text(<span class="number">240</span>,<span class="number">260</span>,str,...</span><br><span class="line">        <span class="string">'Interpreter'</span>,<span class="string">'TeX'</span>,...</span><br><span class="line">        <span class="string">'FontSize'</span>,FS(<span class="number">14</span>),<span class="string">'Fontweight'</span>,<span class="string">'Bold'</span>,...</span><br><span class="line">        <span class="string">'Parent'</span>,hMIPax)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">%-Print comparison title</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    hTitAx = axes(<span class="string">'Parent'</span>,Fgraph,...</span><br><span class="line">        <span class="string">'Position'</span>,[<span class="number">0.02</span> <span class="number">0.95</span> <span class="number">0.96</span> <span class="number">0.02</span>],...</span><br><span class="line">        <span class="string">'Visible'</span>,<span class="string">'off'</span>);</span><br><span class="line"> </span><br><span class="line">    text(<span class="number">0.5</span>,<span class="number">0</span>,xSPM.title,<span class="string">'Parent'</span>,hTitAx,...</span><br><span class="line">        <span class="string">'HorizontalAlignment'</span>,<span class="string">'center'</span>,...</span><br><span class="line">        <span class="string">'VerticalAlignment'</span>,<span class="string">'baseline'</span>,...</span><br><span class="line">        <span class="string">'FontWeight'</span>,<span class="string">'Bold'</span>,<span class="string">'FontSize'</span>,FS(<span class="number">14</span>))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">%-Print SPMresults: Results directory &amp; thresholding info</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    hResAx = axes(<span class="string">'Parent'</span>,Fgraph,...</span><br><span class="line">        <span class="string">'Position'</span>,[<span class="number">0.05</span> <span class="number">0.55</span> <span class="number">0.45</span> <span class="number">0.05</span>],...</span><br><span class="line">        <span class="string">'DefaultTextVerticalAlignment'</span>,<span class="string">'baseline'</span>,...</span><br><span class="line">        <span class="string">'DefaultTextFontSize'</span>,FS(<span class="number">9</span>),...</span><br><span class="line">        <span class="string">'DefaultTextColor'</span>,[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]*<span class="number">.7</span>,...</span><br><span class="line">        <span class="string">'Units'</span>,<span class="string">'points'</span>,...</span><br><span class="line">        <span class="string">'Visible'</span>,<span class="string">'off'</span>);</span><br><span class="line">    AxPos = get(hResAx,<span class="string">'Position'</span>); set(hResAx,<span class="string">'YLim'</span>,[<span class="number">0</span>,AxPos(<span class="number">4</span>)])</span><br><span class="line">    h     = text(<span class="number">0</span>,<span class="number">24</span>,<span class="string">'SPMresults:'</span>,<span class="string">'Parent'</span>,hResAx,...</span><br><span class="line">        <span class="string">'FontWeight'</span>,<span class="string">'Bold'</span>,<span class="string">'FontSize'</span>,FS(<span class="number">14</span>));</span><br><span class="line">    text(get(h,<span class="string">'Extent'</span>)*[<span class="number">0</span>;<span class="number">0</span>;<span class="number">1</span>;<span class="number">0</span>],<span class="number">24</span>,spm_str_manip(SPM.swd,<span class="string">'a30'</span>),<span class="string">'Parent'</span>,hResAx)</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">        thresDesc = xSPM.thresDesc;</span><br><span class="line">        text(<span class="number">0</span>,<span class="number">12</span>,sprintf(<span class="string">'Height threshold %c = %0.6f  &#123;%s&#125;'</span>,xSPM.STAT,xSPM.u,thresDesc),<span class="string">'Parent'</span>,hResAx)</span><br><span class="line">    <span class="keyword">catch</span></span><br><span class="line">        text(<span class="number">0</span>,<span class="number">12</span>,sprintf(<span class="string">'Height threshold %c = %0.6f'</span>,xSPM.STAT,xSPM.u),<span class="string">'Parent'</span>,hResAx)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    text(<span class="number">0</span>,<span class="number">00</span>,sprintf(<span class="string">'Extent threshold k = %0.0f voxels'</span>,xSPM.k), <span class="string">'Parent'</span>,hResAx)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">%-Plot design matrix</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    hDesMtx   = axes(<span class="string">'Parent'</span>,Fgraph,<span class="string">'Position'</span>,[<span class="number">0.65</span> <span class="number">0.55</span> <span class="number">0.25</span> <span class="number">0.25</span>]);</span><br><span class="line">    hDesMtxIm = image((SPM.xX.nKX + <span class="number">1</span>)*<span class="number">32</span>);</span><br><span class="line">    xlabel(<span class="string">'Design matrix'</span>)</span><br><span class="line">    set(hDesMtxIm,<span class="string">'ButtonDownFcn'</span>,<span class="string">'spm_DesRep(''SurfDesMtx_CB'')'</span>,...</span><br><span class="line">        <span class="string">'UserData'</span>,struct(...</span><br><span class="line">        <span class="string">'X'</span>,        SPM.xX.xKXs.X,...</span><br><span class="line">        <span class="string">'fnames'</span>,   &#123;<span class="built_in">reshape</span>(&#123;SPM.xY.VY.fname&#125;,<span class="built_in">size</span>(SPM.xY.VY))&#125;,...</span><br><span class="line">        <span class="string">'Xnames'</span>,   &#123;SPM.xX.name&#125;))</span><br><span class="line"> </span><br><span class="line">    <span class="comment">%-Plot contrasts</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    nPar   = <span class="built_in">size</span>(SPM.xX.X,<span class="number">2</span>);</span><br><span class="line">    xx     = [<span class="built_in">repmat</span>([<span class="number">0</span>:nPar<span class="number">-1</span>],<span class="number">2</span>,<span class="number">1</span>);<span class="built_in">repmat</span>([<span class="number">1</span>:nPar],<span class="number">2</span>,<span class="number">1</span>)];</span><br><span class="line">    nCon   = <span class="built_in">length</span>(xSPM.Ic);</span><br><span class="line">    xCon   = SPM.xCon;</span><br><span class="line">    <span class="keyword">if</span> nCon</span><br><span class="line">        dy     = <span class="number">0.15</span>/<span class="built_in">max</span>(nCon,<span class="number">2</span>);</span><br><span class="line">        hConAx = axes(<span class="string">'Position'</span>,[<span class="number">0.65</span> (<span class="number">0.80</span> + dy*<span class="number">.1</span>) <span class="number">0.25</span> dy*(nCon<span class="number">-.1</span>)],...</span><br><span class="line">            <span class="string">'Tag'</span>,<span class="string">'ConGrphAx'</span>,<span class="string">'Visible'</span>,<span class="string">'off'</span>);</span><br><span class="line">        title(<span class="string">'contrast(s)'</span>)</span><br><span class="line">        htxt   = get(hConAx,<span class="string">'title'</span>);</span><br><span class="line">        set(htxt,<span class="string">'Visible'</span>,<span class="string">'on'</span>,<span class="string">'HandleVisibility'</span>,<span class="string">'on'</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> ii = nCon:<span class="number">-1</span>:<span class="number">1</span></span><br><span class="line">        axes(<span class="string">'Position'</span>,[<span class="number">0.65</span> (<span class="number">0.80</span> + dy*(nCon - ii +<span class="number">.1</span>)) <span class="number">0.25</span> dy*<span class="number">.9</span>])</span><br><span class="line">        <span class="keyword">if</span> xCon(xSPM.Ic(ii)).STAT == <span class="string">'T'</span> &amp;&amp; <span class="built_in">size</span>(xCon(xSPM.Ic(ii)).c,<span class="number">2</span>) == <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">            <span class="comment">%-Single vector contrast for SPM&#123;t&#125; - bar</span></span><br><span class="line">            <span class="comment">%--------------------------------------------------------------</span></span><br><span class="line">            yy = [<span class="built_in">zeros</span>(<span class="number">1</span>,nPar);<span class="built_in">repmat</span>(xCon(xSPM.Ic(ii)).c',<span class="number">2</span>,<span class="number">1</span>);<span class="built_in">zeros</span>(<span class="number">1</span>,nPar)];</span><br><span class="line">            h  = patch(xx,yy,[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]*<span class="number">.5</span>);</span><br><span class="line">            set(gca,<span class="string">'Tag'</span>,<span class="string">'ConGrphAx'</span>,...</span><br><span class="line">                <span class="string">'Box'</span>,<span class="string">'off'</span>,<span class="string">'TickDir'</span>,<span class="string">'out'</span>,...</span><br><span class="line">                <span class="string">'XTick'</span>,spm_DesRep(<span class="string">'ScanTick'</span>,nPar,<span class="number">10</span>) - <span class="number">0.5</span>,<span class="string">'XTickLabel'</span>,<span class="string">''</span>,...</span><br><span class="line">                <span class="string">'XLim'</span>, [<span class="number">0</span>,nPar],...</span><br><span class="line">                <span class="string">'YTick'</span>,[<span class="number">-1</span>,<span class="number">0</span>,+<span class="number">1</span>],<span class="string">'YTickLabel'</span>,<span class="string">''</span>,...</span><br><span class="line">                <span class="string">'YLim'</span>,[<span class="built_in">min</span>(xCon(xSPM.Ic(ii)).c),<span class="built_in">max</span>(xCon(xSPM.Ic(ii)).c)] +...</span><br><span class="line">                [<span class="number">-1</span> +<span class="number">1</span>] * <span class="built_in">max</span>(<span class="built_in">abs</span>(xCon(xSPM.Ic(ii)).c))/<span class="number">10</span>  )</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line"> </span><br><span class="line">            <span class="comment">%-F-contrast - image</span></span><br><span class="line">            <span class="comment">%--------------------------------------------------------------</span></span><br><span class="line">            h = image((xCon(xSPM.Ic(ii)).c'/<span class="built_in">max</span>(<span class="built_in">abs</span>(xCon(xSPM.Ic(ii)).c(:)))+<span class="number">1</span>)*<span class="number">32</span>);</span><br><span class="line">            set(gca,<span class="string">'Tag'</span>,<span class="string">'ConGrphAx'</span>,...</span><br><span class="line">                <span class="string">'Box'</span>,<span class="string">'on'</span>,<span class="string">'TickDir'</span>,<span class="string">'out'</span>,...</span><br><span class="line">                <span class="string">'XTick'</span>,spm_DesRep(<span class="string">'ScanTick'</span>,nPar,<span class="number">10</span>),<span class="string">'XTickLabel'</span>,<span class="string">''</span>,...</span><br><span class="line">                <span class="string">'XLim'</span>, [<span class="number">0</span>,nPar]+<span class="number">0.5</span>,...</span><br><span class="line">                <span class="string">'YTick'</span>,[<span class="number">0</span>:<span class="built_in">size</span>(SPM.xCon(xSPM.Ic(ii)).c,<span class="number">2</span>)]+<span class="number">0.5</span>,...</span><br><span class="line">                <span class="string">'YTickLabel'</span>,<span class="string">''</span>,...</span><br><span class="line">                <span class="string">'YLim'</span>, [<span class="number">0</span>,<span class="built_in">size</span>(xCon(xSPM.Ic(ii)).c,<span class="number">2</span>)]+<span class="number">0.5</span> )</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        ylabel(num2str(xSPM.Ic(ii)))</span><br><span class="line">        set(h,<span class="string">'ButtonDownFcn'</span>,<span class="string">'spm_DesRep(''SurfCon_CB'')'</span>,...</span><br><span class="line">            <span class="string">'UserData'</span>, struct( <span class="string">'i'</span>,        xSPM.Ic(ii),...</span><br><span class="line">            <span class="string">'h'</span>,        htxt,...</span><br><span class="line">            <span class="string">'xCon'</span>,     xCon(xSPM.Ic(ii))))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">%-Store handles of results section Graphics window objects</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    H  = get(Fgraph,<span class="string">'Children'</span>);</span><br><span class="line">    H  = findobj(H,<span class="string">'flat'</span>,<span class="string">'HandleVisibility'</span>,<span class="string">'on'</span>);</span><br><span class="line">    H  = findobj(H);</span><br><span class="line">    Hv = get(H,<span class="string">'Visible'</span>);</span><br><span class="line">    set(hResAx,<span class="string">'Tag'</span>,<span class="string">'PermRes'</span>,<span class="string">'UserData'</span>,struct(<span class="string">'H'</span>,H,<span class="string">'Hv'</span>,&#123;Hv&#125;))</span><br><span class="line"> </span><br><span class="line">    <span class="comment">%-Finished results setup</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    varargout = &#123;hReg,xSPM,SPM&#125;;</span><br><span class="line">    spm(<span class="string">'Pointer'</span>,<span class="string">'Arrow'</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">%======================================================================</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'setupgui'</span>                            <span class="comment">%-Set up results section GUI</span></span><br><span class="line">    <span class="comment">%======================================================================</span></span><br><span class="line">        <span class="comment">% hReg = spm_results_ui('SetupGUI',M,DIM,xSPM,Finter)</span></span><br><span class="line">        <span class="keyword">if</span> nargin &lt; <span class="number">5</span>, Finter=<span class="string">'Interactive'</span>; <span class="keyword">else</span> Finter = varargin&#123;<span class="number">5</span>&#125;; <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> nargin &lt; <span class="number">4</span>, error(<span class="string">'Insufficient arguments'</span>), <span class="keyword">end</span></span><br><span class="line">        M      = varargin&#123;<span class="number">2</span>&#125;;</span><br><span class="line">        DIM    = varargin&#123;<span class="number">3</span>&#125;;</span><br><span class="line">        Finter = spm_figure(<span class="string">'GetWin'</span>,Finter);</span><br><span class="line">        WS     = spm(<span class="string">'WinScale'</span>);</span><br><span class="line">        FS     = spm(<span class="string">'FontSizes'</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">%-Create frame for Results GUI objects</span></span><br><span class="line">        <span class="comment">%------------------------------------------------------------------</span></span><br><span class="line">        hReg    = uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'Frame'</span>,<span class="string">'Position'</span>,[<span class="number">001</span> <span class="number">001</span> <span class="number">400</span> <span class="number">190</span>].*WS,...</span><br><span class="line">                           <span class="string">'BackgroundColor'</span>,spm(<span class="string">'Colour'</span>));</span><br><span class="line">        hFResUi = uicontrol(Finter,...</span><br><span class="line">                     <span class="string">'Style'</span>,<span class="string">'Pushbutton'</span>,...</span><br><span class="line">                     <span class="string">'enable'</span>,<span class="string">'off'</span>,...</span><br><span class="line">                     <span class="string">'Position'</span>,[<span class="number">008</span> <span class="number">007</span> <span class="number">387</span> <span class="number">178</span>].*WS);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">%-Initialise registry in hReg frame object</span></span><br><span class="line">        <span class="comment">%------------------------------------------------------------------</span></span><br><span class="line">        [hReg,xyz] = spm_XYZreg(<span class="string">'InitReg'</span>,hReg,M,DIM,[<span class="number">0</span>;<span class="number">0</span>;<span class="number">0</span>]);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">%-Setup editable XYZ widgets &amp; cross register with registry</span></span><br><span class="line">        <span class="comment">%------------------------------------------------------------------</span></span><br><span class="line">        hFxyz      = spm_results_ui(<span class="string">'DrawXYZgui'</span>,M,DIM,varargin&#123;<span class="number">4</span>&#125;,xyz,Finter);</span><br><span class="line">        spm_XYZreg(<span class="string">'XReg'</span>,hReg,hFxyz,<span class="string">'spm_results_ui'</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">%-Set up buttons for results functions</span></span><br><span class="line">        <span class="comment">%------------------------------------------------------------------</span></span><br><span class="line">        spm_results_ui(<span class="string">'DrawButts'</span>,hReg,DIM,Finter,WS,FS);</span><br><span class="line"> </span><br><span class="line">        varargout  = &#123;hReg&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">%======================================================================</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'drawbutts'</span>   <span class="comment">%-Draw results section buttons in Interactive window</span></span><br><span class="line">    <span class="comment">%======================================================================</span></span><br><span class="line">        <span class="comment">% spm_results_ui('DrawButts',hReg,DIM,Finter,WS,FS)</span></span><br><span class="line">        <span class="comment">%</span></span><br><span class="line">        <span class="keyword">if</span> nargin&lt;<span class="number">3</span>, error(<span class="string">'Insufficient arguments'</span>), <span class="keyword">end</span></span><br><span class="line">        hReg = varargin&#123;<span class="number">2</span>&#125;;</span><br><span class="line">        DIM  = varargin&#123;<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> nargin&lt;<span class="number">4</span>,  Finter = spm_figure(<span class="string">'FindWin'</span>,<span class="string">'Interactive'</span>);</span><br><span class="line">        <span class="keyword">else</span> Finter = varargin&#123;<span class="number">4</span>&#125;; <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> nargin &lt; <span class="number">5</span>, WS = spm(<span class="string">'WinScale'</span>);  <span class="keyword">else</span>  WS = varargin&#123;<span class="number">5</span>&#125;; <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> nargin &lt; <span class="number">6</span>, FS = spm(<span class="string">'FontSizes'</span>); <span class="keyword">else</span>  FS = varargin&#123;<span class="number">6</span>&#125;; <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">%-p-values</span></span><br><span class="line">        <span class="comment">%------------------------------------------------------------------</span></span><br><span class="line">        uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'Text'</span>,<span class="string">'String'</span>,<span class="string">'p-values'</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">020</span> <span class="number">168</span> <span class="number">080</span> <span class="number">015</span>].*WS,...</span><br><span class="line">            <span class="string">'FontAngle'</span>,<span class="string">'Italic'</span>,...</span><br><span class="line">            <span class="string">'FontSize'</span>,FS(<span class="number">10</span>),...</span><br><span class="line">            <span class="string">'HorizontalAlignment'</span>,<span class="string">'Left'</span>,...</span><br><span class="line">            <span class="string">'ForegroundColor'</span>,<span class="string">'w'</span>)</span><br><span class="line">        uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'PushButton'</span>,<span class="string">'String'</span>,<span class="string">'whole brain'</span>,<span class="string">'FontSize'</span>,FS(<span class="number">10</span>),...</span><br><span class="line">            <span class="string">'ToolTipString'</span>,...</span><br><span class="line">            <span class="string">'tabulate summary of local maxima, p-values &amp; statistics'</span>,...</span><br><span class="line">            <span class="string">'Callback'</span>,<span class="string">'spm_list(''List'',xSPM,hReg);'</span>,...</span><br><span class="line">            <span class="string">'Interruptible'</span>,<span class="string">'on'</span>,<span class="string">'Enable'</span>,<span class="string">'on'</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">015</span> <span class="number">145</span> <span class="number">100</span> <span class="number">020</span>].*WS)</span><br><span class="line">        uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'PushButton'</span>,<span class="string">'String'</span>,<span class="string">'current cluster'</span>,<span class="string">'FontSize'</span>,FS(<span class="number">10</span>),...</span><br><span class="line">            <span class="string">'ToolTipString'</span>,...</span><br><span class="line">            <span class="string">'tabulate p-values &amp; statistics for local maxima of nearest cluster'</span>,...</span><br><span class="line">            <span class="string">'Callback'</span>,<span class="string">'spm_list(''ListCluster'',xSPM,hReg);'</span>,...</span><br><span class="line">            <span class="string">'Interruptible'</span>,<span class="string">'on'</span>,<span class="string">'Enable'</span>,<span class="string">'on'</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">015</span> <span class="number">120</span> <span class="number">100</span> <span class="number">020</span>].*WS)</span><br><span class="line">        uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'PushButton'</span>,<span class="string">'String'</span>,<span class="string">'small volume'</span>,<span class="string">'FontSize'</span>,FS(<span class="number">10</span>),...</span><br><span class="line">            <span class="string">'ToolTipString'</span>,[<span class="string">'Small Volume Correction - corrected p-values '</span>,...</span><br><span class="line">            <span class="string">'for a small search region'</span>],...</span><br><span class="line">            <span class="string">'Callback'</span>,<span class="string">'spm_VOI(SPM,xSPM,hReg);'</span>,...</span><br><span class="line">            <span class="string">'Interruptible'</span>,<span class="string">'on'</span>,<span class="string">'Enable'</span>,<span class="string">'on'</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">015</span> <span class="number">095</span> <span class="number">100</span> <span class="number">020</span>].*WS)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment">%-SPM area - used for Volume of Interest analyses</span></span><br><span class="line">        <span class="comment">%------------------------------------------------------------------</span></span><br><span class="line">        uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'Text'</span>,<span class="string">'String'</span>,<span class="string">'Multivariate'</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">135</span> <span class="number">168</span> <span class="number">80</span> <span class="number">015</span>].*WS,...</span><br><span class="line">            <span class="string">'FontAngle'</span>,<span class="string">'Italic'</span>,...</span><br><span class="line">            <span class="string">'FontSize'</span>,FS(<span class="number">10</span>),...</span><br><span class="line">            <span class="string">'HorizontalAlignment'</span>,<span class="string">'Left'</span>,...</span><br><span class="line">            <span class="string">'ForegroundColor'</span>,<span class="string">'w'</span>)</span><br><span class="line">        uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'PushButton'</span>,<span class="string">'String'</span>,<span class="string">'eigenvariate'</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">130</span> <span class="number">145</span> <span class="number">70</span> <span class="number">020</span>].*WS,...</span><br><span class="line">            <span class="string">'ToolTipString'</span>,...</span><br><span class="line">            <span class="string">'Responses (principal eigenvariate) in volume of interest'</span>,...</span><br><span class="line">            <span class="string">'Callback'</span>,<span class="string">'[Y,xY] = spm_regions(xSPM,SPM,hReg)'</span>,...</span><br><span class="line">            <span class="string">'Interruptible'</span>,<span class="string">'on'</span>,<span class="string">'Enable'</span>,<span class="string">'on'</span>,...</span><br><span class="line">            <span class="string">'FontSize'</span>,FS(<span class="number">10</span>),<span class="string">'ForegroundColor'</span>,[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>]/<span class="number">3</span>)</span><br><span class="line">        uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'PushButton'</span>,<span class="string">'String'</span>,<span class="string">'CVA'</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">205</span> <span class="number">145</span> <span class="number">65</span> <span class="number">020</span>].*WS,...</span><br><span class="line">            <span class="string">'ToolTipString'</span>,...</span><br><span class="line">            <span class="string">'Canonical variates analysis for the current contrast and VOI'</span>,...</span><br><span class="line">            <span class="string">'Callback'</span>,<span class="string">'CVA = spm_cva(xSPM,SPM,hReg)'</span>,...</span><br><span class="line">            <span class="string">'Interruptible'</span>,<span class="string">'on'</span>,<span class="string">'Enable'</span>,<span class="string">'on'</span>,...</span><br><span class="line">            <span class="string">'FontSize'</span>,FS(<span class="number">10</span>),<span class="string">'ForegroundColor'</span>,[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>]/<span class="number">3</span>)</span><br><span class="line">        uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'PushButton'</span>,<span class="string">'String'</span>,<span class="string">'multivariate Bayes'</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">130</span> <span class="number">120</span> <span class="number">140</span> <span class="number">020</span>].*WS,...</span><br><span class="line">            <span class="string">'ToolTipString'</span>,...</span><br><span class="line">            <span class="string">'Multivariate Bayes'</span>,...</span><br><span class="line">            <span class="string">'Callback'</span>,<span class="string">'[MVB] = spm_mvb_ui(xSPM,SPM,hReg)'</span>,...</span><br><span class="line">            <span class="string">'Interruptible'</span>,<span class="string">'on'</span>,<span class="string">'Enable'</span>,<span class="string">'on'</span>,...</span><br><span class="line">            <span class="string">'FontSize'</span>,FS(<span class="number">10</span>),<span class="string">'ForegroundColor'</span>,[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>]/<span class="number">3</span>)</span><br><span class="line">        uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'PushButton'</span>,<span class="string">'String'</span>,<span class="string">'BMS'</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">130</span> <span class="number">95</span> <span class="number">68</span> <span class="number">020</span>].*WS,...</span><br><span class="line">            <span class="string">'ToolTipString'</span>,...</span><br><span class="line">            <span class="string">'Compare or review a multivariate Bayesian model'</span>,...</span><br><span class="line">            <span class="string">'Callback'</span>,<span class="string">'[F,P]  = spm_mvb_bmc'</span>,...</span><br><span class="line">            <span class="string">'Interruptible'</span>,<span class="string">'on'</span>,<span class="string">'Enable'</span>,<span class="string">'on'</span>,...</span><br><span class="line">            <span class="string">'FontSize'</span>,FS(<span class="number">8</span>),<span class="string">'ForegroundColor'</span>,[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>]/<span class="number">3</span>)</span><br><span class="line">        uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'PushButton'</span>,<span class="string">'String'</span>,<span class="string">'p-value'</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">202</span> <span class="number">95</span> <span class="number">68</span> <span class="number">020</span>].*WS,...</span><br><span class="line">            <span class="string">'ToolTipString'</span>,...</span><br><span class="line">            <span class="string">'Randomisation testing of a multivariate Bayesian model'</span>,...</span><br><span class="line">            <span class="string">'Callback'</span>,<span class="string">'spm_mvb_p'</span>,...</span><br><span class="line">            <span class="string">'Interruptible'</span>,<span class="string">'on'</span>,<span class="string">'Enable'</span>,<span class="string">'on'</span>,...</span><br><span class="line">            <span class="string">'FontSize'</span>,FS(<span class="number">8</span>),<span class="string">'ForegroundColor'</span>,[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>]/<span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="comment">%-Hemodynamic modelling</span></span><br><span class="line">        <span class="comment">%------------------------------------------------------------------</span></span><br><span class="line">        <span class="keyword">if</span> strcmp(spm(<span class="string">'CheckModality'</span>),<span class="string">'FMRI'</span>)</span><br><span class="line">            uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'PushButton'</span>,<span class="string">'String'</span>,<span class="string">'Hemodynamics'</span>,...</span><br><span class="line">                <span class="string">'FontSize'</span>,FS(<span class="number">10</span>),...</span><br><span class="line">                <span class="string">'ToolTipString'</span>,<span class="string">'Hemodynamic modelling of regional response'</span>,...</span><br><span class="line">                <span class="string">'Callback'</span>,<span class="string">'[Ep,Cp,K1,K2] = spm_hdm_ui(xSPM,SPM,hReg);'</span>,...</span><br><span class="line">                <span class="string">'Interruptible'</span>,<span class="string">'on'</span>,<span class="string">'Enable'</span>,<span class="string">'on'</span>,...</span><br><span class="line">                <span class="string">'Position'</span>,[<span class="number">130</span> <span class="number">055</span> <span class="number">140</span> <span class="number">020</span>].*WS,...</span><br><span class="line">                <span class="string">'ForegroundColor'</span>,[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>]/<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">%-Not currently used</span></span><br><span class="line">        <span class="comment">%------------------------------------------------------------------</span></span><br><span class="line">        <span class="comment">%uicontrol(Finter,'Style','PushButton','String','','FontSize',FS(10),...</span></span><br><span class="line">        <span class="comment">%     'ToolTipString','',...</span></span><br><span class="line">        <span class="comment">%     'Callback','',...</span></span><br><span class="line">        <span class="comment">%     'Interruptible','on','Enable','on',...</span></span><br><span class="line">        <span class="comment">%     'Position',[015 055 100 020].*WS)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">%-Visualisation</span></span><br><span class="line">        <span class="comment">%------------------------------------------------------------------</span></span><br><span class="line">        uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'Text'</span>,<span class="string">'String'</span>,<span class="string">'Display'</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">290</span> <span class="number">168</span> <span class="number">065</span> <span class="number">015</span>].*WS,...</span><br><span class="line">            <span class="string">'FontAngle'</span>,<span class="string">'Italic'</span>,...</span><br><span class="line">            <span class="string">'FontSize'</span>,FS(<span class="number">10</span>),...</span><br><span class="line">            <span class="string">'HorizontalAlignment'</span>,<span class="string">'Left'</span>,...</span><br><span class="line">            <span class="string">'ForegroundColor'</span>,<span class="string">'w'</span>)</span><br><span class="line">        uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'PushButton'</span>,<span class="string">'String'</span>,<span class="string">'plot'</span>,<span class="string">'FontSize'</span>,FS(<span class="number">10</span>),...</span><br><span class="line">            <span class="string">'ToolTipString'</span>,<span class="string">'plot data &amp; contrasts at current voxel'</span>,...</span><br><span class="line">            <span class="string">'Callback'</span>,<span class="string">'[Y,y,beta,Bcov] = spm_graph(xSPM,SPM,hReg);'</span>,...</span><br><span class="line">            <span class="string">'Interruptible'</span>,<span class="string">'on'</span>,<span class="string">'Enable'</span>,<span class="string">'on'</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">285</span> <span class="number">145</span> <span class="number">100</span> <span class="number">020</span>].*WS,...</span><br><span class="line">            <span class="string">'Tag'</span>,<span class="string">'plotButton'</span>)</span><br><span class="line"> </span><br><span class="line">        str  = &#123; <span class="string">'overlays...'</span>,<span class="string">'slices'</span>,<span class="string">'sections'</span>,<span class="string">'render'</span>,<span class="string">'previous sections'</span>,<span class="string">'previous render'</span>&#125;;</span><br><span class="line">        tstr = &#123; <span class="string">'overlay filtered SPM on another image: '</span>,...</span><br><span class="line">            <span class="string">'3 slices / '</span>,<span class="string">'ortho sections / '</span>,<span class="string">'render /'</span>,<span class="string">'previous ortho sections /'</span>,<span class="string">'previous surface rendering'</span>&#125;;</span><br><span class="line"> </span><br><span class="line">        tmp  = &#123; <span class="string">'spm_transverse(''set'',xSPM,hReg)'</span>,...</span><br><span class="line">            <span class="string">'spm_sections(xSPM,hReg)'</span>,...</span><br><span class="line">            [<span class="string">'spm_render(   struct( ''XYZ'',    xSPM.XYZ,'</span>,...</span><br><span class="line">            <span class="string">'''t'',     xSPM.Z'','</span>,...</span><br><span class="line">            <span class="string">'''mat'',   xSPM.M,'</span>,...</span><br><span class="line">            <span class="string">'''dim'',   xSPM.DIM))'</span>],...</span><br><span class="line">            [<span class="string">'global prevsect;'</span>,<span class="string">'spm_sections(xSPM,hReg,prevsect)'</span>],...</span><br><span class="line">            [<span class="string">'global prevrend;'</span>,<span class="string">'if ~isstruct(prevrend)'</span>,...</span><br><span class="line">            <span class="string">'prevrend = struct(''rendfile'','''',''brt'',[],''col'',[]); end;'</span>,...            </span><br><span class="line">            <span class="string">'spm_render(    struct( ''XYZ'',    xSPM.XYZ,'</span>,...</span><br><span class="line">            <span class="string">'''t'',     xSPM.Z'','</span>,...</span><br><span class="line">            <span class="string">'''mat'',   xSPM.M,'</span>,...</span><br><span class="line">            <span class="string">'''dim'',   xSPM.DIM),prevrend.brt,prevrend.rendfile)'</span>]&#125;;</span><br><span class="line"> </span><br><span class="line">        uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'PopUp'</span>,<span class="string">'String'</span>,str,<span class="string">'FontSize'</span>,FS(<span class="number">10</span>),...</span><br><span class="line">            <span class="string">'ToolTipString'</span>,<span class="built_in">cat</span>(<span class="number">2</span>,tstr&#123;:&#125;),...</span><br><span class="line">            <span class="string">'Callback'</span>,<span class="string">'spm(''PopUpCB'',gcbo)'</span>,...</span><br><span class="line">            <span class="string">'UserData'</span>,tmp,...</span><br><span class="line">            <span class="string">'Interruptible'</span>,<span class="string">'on'</span>,<span class="string">'Enable'</span>,<span class="string">'on'</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">285</span> <span class="number">120</span> <span class="number">100</span> <span class="number">020</span>].*WS)</span><br><span class="line"> </span><br><span class="line">        uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'PushButton'</span>,<span class="string">'String'</span>,<span class="string">'save'</span>,<span class="string">'FontSize'</span>,FS(<span class="number">10</span>),...</span><br><span class="line">            <span class="string">'ToolTipString'</span>,<span class="string">'save thresholded SPM as image'</span>,...</span><br><span class="line">            <span class="string">'Callback'</span>,[<span class="string">'spm_write_filtered(xSPM.Z,xSPM.XYZ,xSPM.DIM,xSPM.M,'</span>,...</span><br><span class="line">              <span class="string">'sprintf(''SPM&#123;%c&#125;-filtered: u = %5.3f, k = %d'','</span>,...</span><br><span class="line">              <span class="string">'xSPM.STAT,xSPM.u,xSPM.k));'</span>],...</span><br><span class="line">            <span class="string">'Interruptible'</span>,<span class="string">'on'</span>,<span class="string">'Enable'</span>,<span class="string">'on'</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">285</span> <span class="number">095</span> <span class="number">100</span> <span class="number">020</span>].*WS)</span><br><span class="line"> </span><br><span class="line">        <span class="comment">%-ResultsUI controls</span></span><br><span class="line">        <span class="comment">%------------------------------------------------------------------</span></span><br><span class="line">        hClear = uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'PushButton'</span>,<span class="string">'String'</span>,<span class="string">'clear'</span>,...</span><br><span class="line">            <span class="string">'ToolTipString'</span>,<span class="string">'clears results subpane'</span>,...</span><br><span class="line">            <span class="string">'FontSize'</span>,FS(<span class="number">9</span>),<span class="string">'ForegroundColor'</span>,<span class="string">'b'</span>,...</span><br><span class="line">            <span class="string">'Callback'</span>,[<span class="string">'spm_results_ui(''Clear''); '</span>,...</span><br><span class="line">              <span class="string">'spm_input(''!DeleteInputObj''),'</span>,...</span><br><span class="line">              <span class="string">'spm_clf(''Satellite'')'</span>],...</span><br><span class="line">            <span class="string">'Interruptible'</span>,<span class="string">'on'</span>,<span class="string">'Enable'</span>,<span class="string">'on'</span>,...</span><br><span class="line">            <span class="string">'DeleteFcn'</span>,<span class="string">'spm_clf(''Graphics'')'</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">285</span> <span class="number">055</span> <span class="number">035</span> <span class="number">018</span>].*WS);</span><br><span class="line"> </span><br><span class="line">        hExit  = uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'PushButton'</span>,<span class="string">'String'</span>,<span class="string">'exit'</span>,...</span><br><span class="line">            <span class="string">'ToolTipString'</span>,<span class="string">'exit the results section'</span>,...</span><br><span class="line">            <span class="string">'FontSize'</span>,FS(<span class="number">9</span>),<span class="string">'ForegroundColor'</span>,<span class="string">'r'</span>,...</span><br><span class="line">            <span class="string">'Callback'</span>,<span class="string">'spm_results_ui(''close'')'</span>,...</span><br><span class="line">            <span class="string">'Interruptible'</span>,<span class="string">'on'</span>,<span class="string">'Enable'</span>,<span class="string">'on'</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">325</span> <span class="number">055</span> <span class="number">035</span> <span class="number">018</span>].*WS);</span><br><span class="line"> </span><br><span class="line">        hHelp  = uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'PushButton'</span>,<span class="string">'String'</span>,<span class="string">'?'</span>,...</span><br><span class="line">            <span class="string">'ToolTipString'</span>,<span class="string">'results section help'</span>,...</span><br><span class="line">            <span class="string">'FontSize'</span>,FS(<span class="number">9</span>),<span class="string">'ForegroundColor'</span>,<span class="string">'g'</span>,...</span><br><span class="line">            <span class="string">'Callback'</span>,<span class="string">'spm_help(''spm_results_ui'')'</span>,...</span><br><span class="line">            <span class="string">'Interruptible'</span>,<span class="string">'on'</span>,<span class="string">'Enable'</span>,<span class="string">'on'</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">365</span> <span class="number">055</span> <span class="number">020</span> <span class="number">018</span>].*WS);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">%======================================================================</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'drawxyzgui'</span>                                   <span class="comment">%-Draw XYZ GUI area</span></span><br><span class="line">    <span class="comment">%======================================================================</span></span><br><span class="line">        <span class="comment">% hFxyz = spm_results_ui('DrawXYZgui',M,DIM,xSPM,xyz,Finter)</span></span><br><span class="line">        <span class="keyword">if</span> nargin&lt;<span class="number">6</span>,  Finter=spm_figure(<span class="string">'FindWin'</span>,<span class="string">'Interactive'</span>);</span><br><span class="line">        <span class="keyword">else</span> Finter=varargin&#123;<span class="number">6</span>&#125;; <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> nargin &lt; <span class="number">5</span>, xyz=[<span class="number">0</span>;<span class="number">0</span>;<span class="number">0</span>]; <span class="keyword">else</span> xyz=varargin&#123;<span class="number">5</span>&#125;; <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> nargin &lt; <span class="number">4</span>, error(<span class="string">'Insufficient arguments'</span>), <span class="keyword">end</span></span><br><span class="line">        DIM     = varargin&#123;<span class="number">3</span>&#125;;</span><br><span class="line">        M       = varargin&#123;<span class="number">2</span>&#125;;</span><br><span class="line">        xyz     = spm_XYZreg(<span class="string">'RoundCoords'</span>,xyz,M,DIM);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">%-Font details</span></span><br><span class="line">        <span class="comment">%------------------------------------------------------------------</span></span><br><span class="line">        WS      = spm(<span class="string">'WinScale'</span>);</span><br><span class="line">        FS      = spm(<span class="string">'FontSizes'</span>);</span><br><span class="line">        PF      = spm_platform(<span class="string">'fonts'</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">%-Create XYZ control objects</span></span><br><span class="line">        <span class="comment">%------------------------------------------------------------------</span></span><br><span class="line">        hFxyz = uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'Pushbutton'</span>,...</span><br><span class="line">            <span class="string">'visible'</span>,<span class="string">'off'</span>,<span class="string">'enable'</span>,<span class="string">'off'</span>,<span class="string">'Position'</span>,[<span class="number">010</span> <span class="number">010</span> <span class="number">265</span> <span class="number">030</span>].*WS);</span><br><span class="line">        uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'Text'</span>,<span class="string">'String'</span>,<span class="string">'co-ordinates'</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">020</span> <span class="number">035</span> <span class="number">090</span> <span class="number">016</span>].*WS,...</span><br><span class="line">            <span class="string">'FontAngle'</span>,<span class="string">'Italic'</span>,...</span><br><span class="line">            <span class="string">'FontSize'</span>,FS(<span class="number">10</span>),...</span><br><span class="line">            <span class="string">'HorizontalAlignment'</span>,<span class="string">'Left'</span>,...</span><br><span class="line">            <span class="string">'ForegroundColor'</span>,<span class="string">'w'</span>)</span><br><span class="line"> </span><br><span class="line">        uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'Text'</span>,<span class="string">'String'</span>,<span class="string">'x ='</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">020</span> <span class="number">015</span> <span class="number">024</span> <span class="number">018</span>].*WS,...</span><br><span class="line">            <span class="string">'FontName'</span>,PF.times,<span class="string">'FontSize'</span>,FS(<span class="number">10</span>),<span class="string">'FontAngle'</span>,<span class="string">'Italic'</span>,...</span><br><span class="line">            <span class="string">'HorizontalAlignment'</span>,<span class="string">'Center'</span>);</span><br><span class="line">        hX   = uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'Edit'</span>,<span class="string">'String'</span>,sprintf(<span class="string">'%.2f'</span>,xyz(<span class="number">1</span>)),...</span><br><span class="line">            <span class="string">'ToolTipString'</span>,<span class="string">'enter x-coordinate'</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">044</span> <span class="number">015</span> <span class="number">056</span> <span class="number">020</span>].*WS,...</span><br><span class="line">            <span class="string">'FontSize'</span>,FS(<span class="number">10</span>),<span class="string">'BackGroundColor'</span>,[<span class="number">.8</span>,<span class="number">.8</span>,<span class="number">1</span>],...</span><br><span class="line">            <span class="string">'HorizontalAlignment'</span>,<span class="string">'Right'</span>,...</span><br><span class="line">            <span class="string">'Tag'</span>,<span class="string">'hX'</span>,...</span><br><span class="line">            <span class="string">'Callback'</span>,<span class="string">'spm_results_ui(''EdWidCB'')'</span>);</span><br><span class="line"> </span><br><span class="line">        uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'Text'</span>,<span class="string">'String'</span>,<span class="string">'y ='</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">105</span> <span class="number">015</span> <span class="number">024</span> <span class="number">018</span>].*WS,...</span><br><span class="line">            <span class="string">'FontName'</span>,PF.times,<span class="string">'FontSize'</span>,FS(<span class="number">10</span>),<span class="string">'FontAngle'</span>,<span class="string">'Italic'</span>,...</span><br><span class="line">            <span class="string">'HorizontalAlignment'</span>,<span class="string">'Center'</span>)</span><br><span class="line">        hY   = uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'Edit'</span>,<span class="string">'String'</span>,sprintf(<span class="string">'%.2f'</span>,xyz(<span class="number">2</span>)),...</span><br><span class="line">            <span class="string">'ToolTipString'</span>,<span class="string">'enter y-coordinate'</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">129</span> <span class="number">015</span> <span class="number">056</span> <span class="number">020</span>].*WS,...</span><br><span class="line">            <span class="string">'FontSize'</span>,FS(<span class="number">10</span>),<span class="string">'BackGroundColor'</span>,[<span class="number">.8</span>,<span class="number">.8</span>,<span class="number">1</span>],...</span><br><span class="line">            <span class="string">'HorizontalAlignment'</span>,<span class="string">'Right'</span>,...</span><br><span class="line">            <span class="string">'Tag'</span>,<span class="string">'hY'</span>,...</span><br><span class="line">            <span class="string">'Callback'</span>,<span class="string">'spm_results_ui(''EdWidCB'')'</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> DIM(<span class="number">3</span>) ~= <span class="number">1</span></span><br><span class="line">        uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'Text'</span>,<span class="string">'String'</span>,<span class="string">'z ='</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">190</span> <span class="number">015</span> <span class="number">024</span> <span class="number">018</span>].*WS,...</span><br><span class="line">            <span class="string">'FontName'</span>,PF.times,<span class="string">'FontSize'</span>,FS(<span class="number">10</span>),<span class="string">'FontAngle'</span>,<span class="string">'Italic'</span>,...</span><br><span class="line">            <span class="string">'HorizontalAlignment'</span>,<span class="string">'Center'</span>)</span><br><span class="line">        hZ   = uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'Edit'</span>,<span class="string">'String'</span>,sprintf(<span class="string">'%.2f'</span>,xyz(<span class="number">3</span>)),...</span><br><span class="line">            <span class="string">'ToolTipString'</span>,<span class="string">'enter z-coordinate'</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">214</span> <span class="number">015</span> <span class="number">056</span> <span class="number">020</span>].*WS,...</span><br><span class="line">            <span class="string">'FontSize'</span>,FS(<span class="number">10</span>),<span class="string">'BackGroundColor'</span>,[<span class="number">.8</span>,<span class="number">.8</span>,<span class="number">1</span>],...</span><br><span class="line">            <span class="string">'HorizontalAlignment'</span>,<span class="string">'Right'</span>,...</span><br><span class="line">            <span class="string">'Tag'</span>,<span class="string">'hZ'</span>,...</span><br><span class="line">            <span class="string">'Callback'</span>,<span class="string">'spm_results_ui(''EdWidCB'')'</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        hZ = [];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">%-Statistic value reporting pane</span></span><br><span class="line">        <span class="comment">%------------------------------------------------------------------</span></span><br><span class="line">        uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'Text'</span>,<span class="string">'String'</span>,<span class="string">'statistic'</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">285</span> <span class="number">035</span> <span class="number">090</span> <span class="number">016</span>].*WS,...</span><br><span class="line">            <span class="string">'FontAngle'</span>,<span class="string">'Italic'</span>,...</span><br><span class="line">            <span class="string">'FontSize'</span>,FS(<span class="number">10</span>),...</span><br><span class="line">            <span class="string">'HorizontalAlignment'</span>,<span class="string">'Left'</span>,...</span><br><span class="line">            <span class="string">'ForegroundColor'</span>,<span class="string">'w'</span>)</span><br><span class="line">        hSPM = uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'Text'</span>,<span class="string">'String'</span>,<span class="string">''</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">285</span> <span class="number">012</span> <span class="number">100</span> <span class="number">020</span>].*WS,...</span><br><span class="line">            <span class="string">'FontSize'</span>,FS(<span class="number">10</span>),...</span><br><span class="line">            <span class="string">'HorizontalAlignment'</span>,<span class="string">'Center'</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment">%-Store data</span></span><br><span class="line">        <span class="comment">%------------------------------------------------------------------</span></span><br><span class="line">        set(hFxyz,<span class="string">'Tag'</span>,<span class="string">'hFxyz'</span>,<span class="string">'UserData'</span>,struct(...</span><br><span class="line">            <span class="string">'hReg'</span>, [],...</span><br><span class="line">            <span class="string">'M'</span>,    M,...</span><br><span class="line">            <span class="string">'DIM'</span>,  DIM,...</span><br><span class="line">            <span class="string">'XYZ'</span>,  varargin&#123;<span class="number">4</span>&#125;.XYZmm,...</span><br><span class="line">            <span class="string">'Z'</span>,    varargin&#123;<span class="number">4</span>&#125;.Z,...</span><br><span class="line">            <span class="string">'hX'</span>,   hX,...</span><br><span class="line">            <span class="string">'hY'</span>,   hY,...</span><br><span class="line">            <span class="string">'hZ'</span>,   hZ,...</span><br><span class="line">            <span class="string">'hSPM'</span>, hSPM,...</span><br><span class="line">            <span class="string">'xyz'</span>,  xyz ));</span><br><span class="line"> </span><br><span class="line">        set([hX,hY,hZ],<span class="string">'UserData'</span>,hFxyz)</span><br><span class="line">        varargout = &#123;hFxyz&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">%======================================================================</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'edwidcb'</span>                          <span class="comment">%-Callback for editable widgets</span></span><br><span class="line">    <span class="comment">%======================================================================</span></span><br><span class="line">        <span class="comment">% spm_results_ui('EdWidCB')</span></span><br><span class="line"> </span><br><span class="line">        hC    = gcbo;</span><br><span class="line">        d     = <span class="built_in">find</span>(strcmp(get(hC,<span class="string">'Tag'</span>),&#123;<span class="string">'hX'</span>,<span class="string">'hY'</span>,<span class="string">'hZ'</span>&#125;));</span><br><span class="line">        hFxyz = get(hC,<span class="string">'UserData'</span>);</span><br><span class="line">        UD    = get(hFxyz,<span class="string">'UserData'</span>);</span><br><span class="line">        xyz   = UD.xyz;</span><br><span class="line">        nxyz  = xyz;</span><br><span class="line"> </span><br><span class="line">        o = evalin(<span class="string">'base'</span>,[<span class="string">'['</span>,get(hC,<span class="string">'String'</span>),<span class="string">']'</span>],<span class="string">'sprintf(''error'')'</span>);</span><br><span class="line">        <span class="keyword">if</span> ischar(o) || <span class="built_in">length</span>(o)&gt;<span class="number">1</span></span><br><span class="line">            warning(sprintf(<span class="string">'%s: Error evaluating ordinate:\n\t%s'</span>,...</span><br><span class="line">                mfilename,lasterr))</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nxyz(d) = o;</span><br><span class="line">            nxyz = spm_XYZreg(<span class="string">'RoundCoords'</span>,nxyz,UD.M,UD.DIM);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(xyz(d)-nxyz(d))&gt;<span class="number">0</span></span><br><span class="line">            UD.xyz = nxyz; set(hFxyz,<span class="string">'UserData'</span>,UD)</span><br><span class="line">            <span class="keyword">if</span> ~<span class="built_in">isempty</span>(UD.hReg), spm_XYZreg(<span class="string">'SetCoords'</span>,nxyz,UD.hReg,hFxyz); <span class="keyword">end</span></span><br><span class="line">            set(hC,<span class="string">'String'</span>,sprintf(<span class="string">'%.3f'</span>,nxyz(d)))</span><br><span class="line">            spm_results_ui(<span class="string">'UpdateSPMval'</span>,UD)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line">    <span class="comment">%======================================================================</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'updatespmval'</span>                           <span class="comment">%-Update SPM value in GUI</span></span><br><span class="line">    <span class="comment">%======================================================================</span></span><br><span class="line">        <span class="comment">% spm_results_ui('UpdateSPMval',hFxyz)</span></span><br><span class="line">        <span class="comment">% spm_results_ui('UpdateSPMval',UD)</span></span><br><span class="line">        <span class="keyword">if</span> nargin&lt;<span class="number">2</span>, error(<span class="string">'insufficient arguments'</span>), <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> isstruct(varargin&#123;<span class="number">2</span>&#125;), UD=varargin&#123;<span class="number">2</span>&#125;; <span class="keyword">else</span> UD = get(varargin&#123;<span class="number">2</span>&#125;,<span class="string">'UserData'</span>); <span class="keyword">end</span></span><br><span class="line">        <span class="built_in">i</span>  = spm_XYZreg(<span class="string">'FindXYZ'</span>,UD.xyz,UD.XYZ);</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isempty</span>(<span class="built_in">i</span>), str = <span class="string">''</span>; <span class="keyword">else</span> str = sprintf(<span class="string">'%6.2f'</span>,UD.Z(<span class="built_in">i</span>)); <span class="keyword">end</span></span><br><span class="line">        set(UD.hSPM,<span class="string">'String'</span>,str);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">%======================================================================</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'getcoords'</span>             <span class="comment">% Get current co-ordinates from XYZ widget</span></span><br><span class="line">    <span class="comment">%======================================================================</span></span><br><span class="line">        <span class="comment">% xyz = spm_results_ui('GetCoords',hFxyz)</span></span><br><span class="line">        <span class="keyword">if</span> nargin&lt;<span class="number">2</span>, hFxyz=<span class="string">'Interactive'</span>; <span class="keyword">else</span> hFxyz=varargin&#123;<span class="number">2</span>&#125;; <span class="keyword">end</span></span><br><span class="line">        hFxyz     = spm_results_ui(<span class="string">'FindXYZframe'</span>,hFxyz);</span><br><span class="line">        varargout = &#123;getfield(get(hFxyz,<span class="string">'UserData'</span>),<span class="string">'xyz'</span>)&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">%======================================================================</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'setcoords'</span>                       <span class="comment">% Set co-ordinates to XYZ widget</span></span><br><span class="line">    <span class="comment">%======================================================================</span></span><br><span class="line">        <span class="comment">% [xyz,d] = spm_results_ui('SetCoords',xyz,hFxyz,hC)</span></span><br><span class="line">        <span class="keyword">if</span> nargin&lt;<span class="number">4</span>, hC=<span class="number">0</span>; <span class="keyword">else</span> hC=varargin&#123;<span class="number">4</span>&#125;; <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> nargin&lt;<span class="number">3</span>, hFxyz=spm_results_ui(<span class="string">'FindXYZframe'</span>); <span class="keyword">else</span> hFxyz=varargin&#123;<span class="number">3</span>&#125;; <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> nargin&lt;<span class="number">2</span>, error(<span class="string">'Set co-ords to what!'</span>); <span class="keyword">else</span> xyz=varargin&#123;<span class="number">2</span>&#125;; <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">%-If this is an internal call, then don't do anything</span></span><br><span class="line">        <span class="keyword">if</span> hFxyz==hC, <span class="keyword">return</span>, <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">        UD = get(hFxyz,<span class="string">'UserData'</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">%-Check validity of coords only when called without a caller handle</span></span><br><span class="line">        <span class="comment">%------------------------------------------------------------------</span></span><br><span class="line">        <span class="keyword">if</span> hC &lt;= <span class="number">0</span></span><br><span class="line">            [xyz,d] = spm_XYZreg(<span class="string">'RoundCoords'</span>,xyz,UD.M,UD.DIM);</span><br><span class="line">            <span class="keyword">if</span> d&gt;<span class="number">0</span> &amp;&amp; nargout&lt;<span class="number">2</span>, warning(sprintf(...</span><br><span class="line">                <span class="string">'%s: Co-ords rounded to nearest voxel centre: Discrepancy %.2f'</span>,...</span><br><span class="line">                mfilename,d))</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            d = [];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">%-Update xyz information &amp; widget strings</span></span><br><span class="line">        <span class="comment">%------------------------------------------------------------------</span></span><br><span class="line">        UD.xyz = xyz; set(hFxyz,<span class="string">'UserData'</span>,UD)</span><br><span class="line">        set(UD.hX,<span class="string">'String'</span>,sprintf(<span class="string">'%.2f'</span>,xyz(<span class="number">1</span>)))</span><br><span class="line">        set(UD.hY,<span class="string">'String'</span>,sprintf(<span class="string">'%.2f'</span>,xyz(<span class="number">2</span>)))</span><br><span class="line">        set(UD.hZ,<span class="string">'String'</span>,sprintf(<span class="string">'%.2f'</span>,xyz(<span class="number">3</span>)))</span><br><span class="line">        spm_results_ui(<span class="string">'UpdateSPMval'</span>,UD)</span><br><span class="line"> </span><br><span class="line">        <span class="comment">%-Tell the registry, if we've not been called by the registry...</span></span><br><span class="line">        <span class="comment">%------------------------------------------------------------------</span></span><br><span class="line">        <span class="keyword">if</span> (~<span class="built_in">isempty</span>(UD.hReg) &amp;&amp; UD.hReg~=hC)</span><br><span class="line">            spm_XYZreg(<span class="string">'SetCoords'</span>,xyz,UD.hReg,hFxyz);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">%-Return arguments</span></span><br><span class="line">        <span class="comment">%------------------------------------------------------------------</span></span><br><span class="line">        varargout = &#123;xyz,d&#125;;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">%======================================================================</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'findxyzframe'</span>                                  <span class="comment">% Find hFxyz frame</span></span><br><span class="line">    <span class="comment">%======================================================================</span></span><br><span class="line">        <span class="comment">% hFxyz = spm_results_ui('FindXYZframe',h)</span></span><br><span class="line">        <span class="comment">% Sorts out hFxyz handles</span></span><br><span class="line">        <span class="keyword">if</span> nargin&lt;<span class="number">2</span>, h=<span class="string">'Interactive'</span>; <span class="keyword">else</span>, h=varargin&#123;<span class="number">2</span>&#125;; <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> ischar(h), h=spm_figure(<span class="string">'FindWin'</span>,h); <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> ~ishandle(h), error(<span class="string">'invalid handle'</span>), <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> ~strcmp(get(h,<span class="string">'Tag'</span>),<span class="string">'hFxyz'</span>), h=findobj(h,<span class="string">'Tag'</span>,<span class="string">'hFxyz'</span>); <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isempty</span>(h), error(<span class="string">'XYZ frame not found'</span>), <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">length</span>(h)&gt;<span class="number">1</span>, error(<span class="string">'Multiple XYZ frames found'</span>), <span class="keyword">end</span></span><br><span class="line">        varargout = &#123;h&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">%======================================================================</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'plotui'</span>                               <span class="comment">%-GUI for plot manipulation</span></span><br><span class="line">    <span class="comment">%======================================================================</span></span><br><span class="line">        <span class="comment">% spm_results_ui('PlotUi',hAx)</span></span><br><span class="line">        <span class="keyword">if</span> nargin&lt;<span class="number">2</span>, hAx=gca; <span class="keyword">else</span> hAx=varargin&#123;<span class="number">2</span>&#125;; <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">        WS = spm(<span class="string">'WinScale'</span>);</span><br><span class="line">        FS = spm(<span class="string">'FontSizes'</span>);</span><br><span class="line">        Finter=spm_figure(<span class="string">'FindWin'</span>,<span class="string">'Interactive'</span>);</span><br><span class="line">        <span class="built_in">figure</span>(Finter)</span><br><span class="line"> </span><br><span class="line">        <span class="comment">%-Check there aren't already controls!</span></span><br><span class="line">        <span class="comment">%------------------------------------------------------------------</span></span><br><span class="line">        hGraphUI = findobj(Finter,<span class="string">'Tag'</span>,<span class="string">'hGraphUI'</span>);</span><br><span class="line">        <span class="keyword">if</span> ~<span class="built_in">isempty</span>(hGraphUI)           <span class="comment">%-Controls exist</span></span><br><span class="line">            hBs = get(hGraphUI,<span class="string">'UserData'</span>);</span><br><span class="line">            <span class="keyword">if</span> hAx==get(hBs(<span class="number">1</span>),<span class="string">'UserData'</span>)  <span class="comment">%-Controls linked to these axes</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>                <span class="comment">%-Old controls remain</span></span><br><span class="line">                delete(findobj(Finter,<span class="string">'Tag'</span>,<span class="string">'hGraphUIbg'</span>))</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">%-Frames &amp; text</span></span><br><span class="line">        <span class="comment">%------------------------------------------------------------------</span></span><br><span class="line">        hGraphUIbg = uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'Frame'</span>,<span class="string">'Tag'</span>,<span class="string">'hGraphUIbg'</span>,...</span><br><span class="line">            <span class="string">'BackgroundColor'</span>,spm(<span class="string">'Colour'</span>),...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">001</span> <span class="number">196</span> <span class="number">400</span> <span class="number">055</span>].*WS);</span><br><span class="line">        hGraphUI   = uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'Frame'</span>,<span class="string">'Tag'</span>,<span class="string">'hGraphUI'</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">008</span> <span class="number">202</span> <span class="number">387</span> <span class="number">043</span>].*WS);</span><br><span class="line">        hGraphUIButtsF = uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'Frame'</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">010</span> <span class="number">205</span> <span class="number">380</span> <span class="number">030</span>].*WS);</span><br><span class="line">        hText = uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'Text'</span>,<span class="string">'String'</span>,<span class="string">'plot controls'</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">020</span> <span class="number">227</span> <span class="number">080</span> <span class="number">016</span>].*WS,...</span><br><span class="line">            <span class="string">'FontWeight'</span>,<span class="string">'Normal'</span>,...</span><br><span class="line">            <span class="string">'FontAngle'</span>,<span class="string">'Italic'</span>,<span class="string">'FontSize'</span>,FS(<span class="number">10</span>),...</span><br><span class="line">            <span class="string">'HorizontalAlignment'</span>,<span class="string">'Left'</span>,...</span><br><span class="line">            <span class="string">'ForegroundColor'</span>,<span class="string">'w'</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">%-Controls</span></span><br><span class="line">        <span class="comment">%------------------------------------------------------------------</span></span><br><span class="line">        h1 = uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'CheckBox'</span>,<span class="string">'String'</span>,<span class="string">'hold'</span>,...</span><br><span class="line">            <span class="string">'ToolTipString'</span>,<span class="string">'toggle hold to overlay plots'</span>,...</span><br><span class="line">            <span class="string">'FontSize'</span>,FS(<span class="number">10</span>),...</span><br><span class="line">            <span class="string">'Value'</span>,strcmp(get(hAx,<span class="string">'NextPlot'</span>),<span class="string">'add'</span>),...</span><br><span class="line">            <span class="string">'Callback'</span>,[...</span><br><span class="line">            <span class="string">'if get(gcbo,''Value''), '</span>,...</span><br><span class="line">            <span class="string">'set(get(gcbo,''UserData''),''NextPlot'',''add''), '</span>,...</span><br><span class="line">            <span class="string">'else, '</span>,...</span><br><span class="line">            <span class="string">'set(get(gcbo,''UserData''),''NextPlot'',''replace''), '</span>,...</span><br><span class="line">            <span class="string">'end'</span>],...</span><br><span class="line">            <span class="string">'Interruptible'</span>,<span class="string">'on'</span>,<span class="string">'Enable'</span>,<span class="string">'on'</span>,...</span><br><span class="line">            <span class="string">'Tag'</span>,<span class="string">'holdButton'</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">015</span> <span class="number">210</span> <span class="number">070</span> <span class="number">020</span>].*WS);</span><br><span class="line">        set(findobj(<span class="string">'Tag'</span>,<span class="string">'plotButton'</span>),<span class="string">'UserData'</span>,h1);</span><br><span class="line"> </span><br><span class="line">        h2 = uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'CheckBox'</span>,<span class="string">'String'</span>,<span class="string">'grid'</span>,...</span><br><span class="line">            <span class="string">'ToolTipString'</span>,<span class="string">'toggle axes grid'</span>,...</span><br><span class="line">            <span class="string">'FontSize'</span>,FS(<span class="number">10</span>),...</span><br><span class="line">            <span class="string">'Value'</span>,strcmp(get(hAx,<span class="string">'XGrid'</span>),<span class="string">'on'</span>),...</span><br><span class="line">            <span class="string">'Callback'</span>,[...</span><br><span class="line">            <span class="string">'if get(gcbo,''Value''), '</span>,...</span><br><span class="line">            <span class="string">'set(get(gcbo,''UserData''),''XGrid'',''on'','</span>...</span><br><span class="line">            <span class="string">'''YGrid'',''on'',''ZGrid'',''on''), '</span>,...</span><br><span class="line">            <span class="string">'else, '</span>,...</span><br><span class="line">            <span class="string">'set(get(gcbo,''UserData''),''XGrid'',''off'','</span>...</span><br><span class="line">            <span class="string">'''YGrid'',''off'',''ZGrid'',''off''), '</span>,...</span><br><span class="line">            <span class="string">'end'</span>],...</span><br><span class="line">            <span class="string">'Interruptible'</span>,<span class="string">'on'</span>,<span class="string">'Enable'</span>,<span class="string">'on'</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">090</span> <span class="number">210</span> <span class="number">070</span> <span class="number">020</span>].*WS);</span><br><span class="line">        h3 = uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'CheckBox'</span>,<span class="string">'String'</span>,<span class="string">'Box'</span>,...</span><br><span class="line">            <span class="string">'ToolTipString'</span>,<span class="string">'toggle axes box'</span>,...</span><br><span class="line">            <span class="string">'FontSize'</span>,FS(<span class="number">10</span>),...</span><br><span class="line">            <span class="string">'Value'</span>,strcmp(get(hAx,<span class="string">'Box'</span>),<span class="string">'on'</span>),...</span><br><span class="line">            <span class="string">'Callback'</span>,[...</span><br><span class="line">            <span class="string">'if get(gcbo,''Value''), '</span>,...</span><br><span class="line">            <span class="string">'set(get(gcbo,''UserData''),''Box'',''on''), '</span>,...</span><br><span class="line">            <span class="string">'else, '</span>,...</span><br><span class="line">            <span class="string">'set(get(gcbo,''UserData''),''Box'',''off''), '</span>,...</span><br><span class="line">            <span class="string">'end'</span>],...</span><br><span class="line">            <span class="string">'Interruptible'</span>,<span class="string">'on'</span>,<span class="string">'Enable'</span>,<span class="string">'on'</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">165</span> <span class="number">210</span> <span class="number">070</span> <span class="number">020</span>].*WS);</span><br><span class="line">        h4 = uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'PopUp'</span>,...</span><br><span class="line">            <span class="string">'ToolTipString'</span>,<span class="string">'edit axis text annotations'</span>,...</span><br><span class="line">            <span class="string">'FontSize'</span>,FS(<span class="number">10</span>),...</span><br><span class="line">            <span class="string">'String'</span>,<span class="string">'text|Title|Xlabel|Ylabel'</span>,...</span><br><span class="line">            <span class="string">'Callback'</span>,<span class="string">'spm_results_ui(''PlotUiCB'')'</span>,...</span><br><span class="line">            <span class="string">'Interruptible'</span>,<span class="string">'on'</span>,<span class="string">'Enable'</span>,<span class="string">'on'</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">240</span> <span class="number">210</span> <span class="number">070</span> <span class="number">020</span>].*WS);</span><br><span class="line">        h5 = uicontrol(Finter,<span class="string">'Style'</span>,<span class="string">'PopUp'</span>,...</span><br><span class="line">            <span class="string">'ToolTipString'</span>,<span class="string">'change various axes attributes'</span>,...</span><br><span class="line">            <span class="string">'FontSize'</span>,FS(<span class="number">10</span>),...</span><br><span class="line">            <span class="string">'String'</span>,<span class="string">'attrib|LineWidth|XLim|YLim|handle'</span>,...</span><br><span class="line">            <span class="string">'Callback'</span>,<span class="string">'spm_results_ui(''PlotUiCB'')'</span>,...</span><br><span class="line">            <span class="string">'Interruptible'</span>,<span class="string">'off'</span>,<span class="string">'Enable'</span>,<span class="string">'on'</span>,...</span><br><span class="line">            <span class="string">'Position'</span>,[<span class="number">315</span> <span class="number">210</span> <span class="number">070</span> <span class="number">020</span>].*WS);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">%-Handle storage for linking, and DeleteFcns for linked deletion</span></span><br><span class="line">        <span class="comment">%------------------------------------------------------------------</span></span><br><span class="line">        set(hGraphUI,<span class="string">'UserData'</span>,[h1,h2,h3,h4,h5])</span><br><span class="line">        set([h1,h2,h3,h4,h5],<span class="string">'UserData'</span>,hAx)</span><br><span class="line"> </span><br><span class="line">        set(hGraphUIbg,<span class="string">'UserData'</span>,...</span><br><span class="line">            [hGraphUI,hGraphUIButtsF,hText,h1,h2,h3,h4,h5],...</span><br><span class="line">            <span class="string">'DeleteFcn'</span>,<span class="string">'spm_results_ui(''Delete'',get(gcbo,''UserData''))'</span>)</span><br><span class="line">        set(hAx,<span class="string">'UserData'</span>,hGraphUIbg,...</span><br><span class="line">            <span class="string">'DeleteFcn'</span>,<span class="string">'spm_results_ui(''Delete'',get(gcbo,''UserData''))'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">%======================================================================</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'plotuicb'</span></span><br><span class="line">    <span class="comment">%======================================================================</span></span><br><span class="line">        <span class="comment">% spm_results_ui('PlotUiCB')</span></span><br><span class="line">        hPM = gcbo;</span><br><span class="line">        v   = get(hPM,<span class="string">'Value'</span>);</span><br><span class="line">        <span class="keyword">if</span> v==<span class="number">1</span>, <span class="keyword">return</span>, <span class="keyword">end</span></span><br><span class="line">        str = cellstr(get(hPM,<span class="string">'String'</span>));</span><br><span class="line">        str = str&#123;v&#125;;</span><br><span class="line"> </span><br><span class="line">        hAx = get(hPM,<span class="string">'UserData'</span>);</span><br><span class="line">        <span class="keyword">switch</span> str</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'Title'</span></span><br><span class="line">                h = get(hAx,<span class="string">'Title'</span>);</span><br><span class="line">                set(h,<span class="string">'String'</span>,spm_input(<span class="string">'Enter title:'</span>,<span class="number">-1</span>,<span class="string">'s+'</span>,get(h,<span class="string">'String'</span>)))</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'Xlabel'</span></span><br><span class="line">                h = get(hAx,<span class="string">'Xlabel'</span>);</span><br><span class="line">                set(h,<span class="string">'String'</span>,spm_input(<span class="string">'Enter X axis label:'</span>,<span class="number">-1</span>,<span class="string">'s+'</span>,get(h,<span class="string">'String'</span>)))</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'Ylabel'</span></span><br><span class="line">                h = get(hAx,<span class="string">'Ylabel'</span>);</span><br><span class="line">                set(h,<span class="string">'String'</span>,spm_input(<span class="string">'Enter Y axis label:'</span>,<span class="number">-1</span>,<span class="string">'s+'</span>,get(h,<span class="string">'String'</span>)))</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'LineWidth'</span></span><br><span class="line">                lw = spm_input(<span class="string">'Enter LineWidth'</span>,<span class="number">-1</span>,<span class="string">'e'</span>,get(hAx,<span class="string">'LineWidth'</span>),<span class="number">1</span>);</span><br><span class="line">                set(hAx,<span class="string">'LineWidth'</span>,lw)</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'XLim'</span></span><br><span class="line">                XLim = spm_input(<span class="string">'Enter XLim'</span>,<span class="number">-1</span>,<span class="string">'e'</span>,get(hAx,<span class="string">'XLim'</span>),[<span class="number">1</span>,<span class="number">2</span>]);</span><br><span class="line">                set(hAx,<span class="string">'XLim'</span>,XLim)</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'YLim'</span></span><br><span class="line">                YLim = spm_input(<span class="string">'Enter YLim'</span>,<span class="number">-1</span>,<span class="string">'e'</span>,get(hAx,<span class="string">'YLim'</span>),[<span class="number">1</span>,<span class="number">2</span>]);</span><br><span class="line">                set(hAx,<span class="string">'YLim'</span>,YLim)</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'handle'</span></span><br><span class="line">                varargout=&#123;hAx&#125;;</span><br><span class="line">            <span class="keyword">otherwise</span></span><br><span class="line">                warning([<span class="string">'Unknown action: '</span>,str])</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">        set(hPM,<span class="string">'Value'</span>,<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">%======================================================================</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'clear'</span>                                    <span class="comment">%-Clear results subpane</span></span><br><span class="line">    <span class="comment">%======================================================================</span></span><br><span class="line">        <span class="comment">% Fgraph = spm_results_ui('Clear',F,mode)</span></span><br><span class="line">        <span class="comment">% mode 1 [default] usual, mode 0 - clear &amp; hide Res stuff, 2 - RNP</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> nargin&lt;<span class="number">3</span>, mode=<span class="number">1</span>; <span class="keyword">else</span>, mode=varargin&#123;<span class="number">3</span>&#125;; <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> nargin&lt;<span class="number">2</span>, F=<span class="string">'Graphics'</span>; <span class="keyword">else</span>, F=varargin&#123;<span class="number">2</span>&#125;; <span class="keyword">end</span></span><br><span class="line">        F = spm_figure(<span class="string">'FindWin'</span>,F);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">%-Clear input objects from 'Interactive' window</span></span><br><span class="line">        <span class="comment">%------------------------------------------------------------------</span></span><br><span class="line">        <span class="comment">%spm_input('!DeleteInputObj')</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment">%-Get handles of objects in Graphics window &amp; note permanent results objects</span></span><br><span class="line">        <span class="comment">%------------------------------------------------------------------</span></span><br><span class="line">        H = get(F,<span class="string">'Children'</span>);                          <span class="comment">%-Get contents of window</span></span><br><span class="line">        H = findobj(H,<span class="string">'flat'</span>,<span class="string">'HandleVisibility'</span>,<span class="string">'on'</span>);  <span class="comment">%-Drop GUI components</span></span><br><span class="line">        h = findobj(H,<span class="string">'flat'</span>,<span class="string">'Tag'</span>,<span class="string">'PermRes'</span>);          <span class="comment">%-Look for 'PermRes' object</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> ~<span class="built_in">isempty</span>(h)</span><br><span class="line">            <span class="comment">%-Found 'PermRes' object</span></span><br><span class="line">            <span class="comment">% This has handles of permanent results objects in it's UserData</span></span><br><span class="line">            tmp  = get(h,<span class="string">'UserData'</span>);</span><br><span class="line">            HR   = tmp.H;</span><br><span class="line">            HRv  = tmp.Hv;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">%-No trace of permanent results objects</span></span><br><span class="line">            HR   = [];</span><br><span class="line">            HRv  = &#123;&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        H = setdiff(H,HR);              <span class="comment">%-Drop permanent results obj</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment">%-Delete stuff as appropriate</span></span><br><span class="line">        <span class="comment">%------------------------------------------------------------------</span></span><br><span class="line">        <span class="keyword">if</span> mode==<span class="number">2</span>  <span class="comment">%-Don't delete axes with NextPlot 'add'</span></span><br><span class="line">            H = setdiff(H,findobj(H,<span class="string">'flat'</span>,<span class="string">'Type'</span>,<span class="string">'axes'</span>,<span class="string">'NextPlot'</span>,<span class="string">'add'</span>));</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">        delete(H)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> mode==<span class="number">0</span>  <span class="comment">%-Hide the permanent results section stuff</span></span><br><span class="line">            set(HR,<span class="string">'Visible'</span>,<span class="string">'off'</span>)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            set(HR,&#123;<span class="string">'Visible'</span>&#125;,HRv)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line">    <span class="comment">%======================================================================</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'close'</span>                                            <span class="comment">%-Close Results</span></span><br><span class="line">    <span class="comment">%======================================================================</span></span><br><span class="line">        spm_clf(<span class="string">'Interactive'</span>);</span><br><span class="line">        spm_clf(<span class="string">'Graphics'</span>);</span><br><span class="line">        close(spm_figure(<span class="string">'FindWin'</span>,<span class="string">'Satellite'</span>));</span><br><span class="line">        evalin(<span class="string">'base'</span>,<span class="string">'clear'</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">%======================================================================</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'launchmp'</span>                            <span class="comment">%-Launch multiplanar toolbox</span></span><br><span class="line">    <span class="comment">%======================================================================</span></span><br><span class="line">        <span class="comment">% hMP = spm_results_ui('LaunchMP',M,DIM,hReg,hBmp)</span></span><br><span class="line">        <span class="keyword">if</span> nargin&lt;<span class="number">5</span>, hBmp = gcbo; <span class="keyword">else</span> hBmp = varargin&#123;<span class="number">5</span>&#125;; <span class="keyword">end</span></span><br><span class="line">        hReg = varargin&#123;<span class="number">4</span>&#125;;</span><br><span class="line">        DIM  = varargin&#123;<span class="number">3</span>&#125;;</span><br><span class="line">        M    = varargin&#123;<span class="number">2</span>&#125;;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">%-Check for existing MultiPlanar toolbox</span></span><br><span class="line">        hMP  = get(hBmp,<span class="string">'UserData'</span>);</span><br><span class="line">        <span class="keyword">if</span> ishandle(hMP)</span><br><span class="line">            <span class="built_in">figure</span>(ancestor(hMP,<span class="string">'figure'</span>));</span><br><span class="line">            varargout = &#123;hMP&#125;;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">%-Initialise and cross-register MultiPlanar toolbox</span></span><br><span class="line">        hMP = spm_XYZreg_Ex2(<span class="string">'Create'</span>,M,DIM);</span><br><span class="line">        spm_XYZreg(<span class="string">'Xreg'</span>,hReg,hMP,<span class="string">'spm_XYZreg_Ex2'</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">%-Setup automatic deletion of MultiPlanar on deletion of results controls</span></span><br><span class="line">        set(hBmp,<span class="string">'Enable'</span>,<span class="string">'on'</span>,<span class="string">'UserData'</span>,hMP)</span><br><span class="line">        set(hBmp,<span class="string">'DeleteFcn'</span>,<span class="string">'spm_results_ui(''delete'',get(gcbo,''UserData''))'</span>)</span><br><span class="line"> </span><br><span class="line">        varargout = &#123;hMP&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">%======================================================================</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'delete'</span>                           <span class="comment">%-Delete HandleGraphics objects</span></span><br><span class="line">    <span class="comment">%======================================================================</span></span><br><span class="line">        <span class="comment">% spm_results_ui('Delete',h)</span></span><br><span class="line">        h = varargin&#123;<span class="number">2</span>&#125;;</span><br><span class="line">        delete(h(ishandle(h)));</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">%======================================================================</span></span><br><span class="line">    <span class="keyword">otherwise</span></span><br><span class="line">    <span class="comment">%======================================================================</span></span><br><span class="line">        error(<span class="string">'Unknown action string'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mychgcon</span><span class="params">(obj,evt,xSPM)</span></span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line">xSPM2.swd   = xSPM.swd;</span><br><span class="line"><span class="keyword">try</span>, xSPM2.units = xSPM.units; <span class="keyword">end</span></span><br><span class="line">xSPM2.Ic    = getfield(get(obj,<span class="string">'UserData'</span>),<span class="string">'Ic'</span>);</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isempty</span>(xSPM2.Ic) || all(xSPM2.Ic == <span class="number">0</span>), xSPM2 = rmfield(xSPM2,<span class="string">'Ic'</span>); <span class="keyword">end</span></span><br><span class="line">xSPM2.Im    = xSPM.Im;</span><br><span class="line">xSPM2.pm    = xSPM.pm;</span><br><span class="line">xSPM2.Ex    = xSPM.Ex;</span><br><span class="line">xSPM2.title = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">if</span> ~<span class="built_in">isempty</span>(xSPM.thresDesc)</span><br><span class="line">    td = regexp(xSPM.thresDesc,<span class="string">'p\D?(?&lt;u&gt;[\.\d]+) \((?&lt;thresDesc&gt;\S+)\)'</span>,<span class="string">'names'</span>);</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isempty</span>(td)</span><br><span class="line">        td = regexp(xSPM.thresDesc,<span class="string">'\w=(?&lt;u&gt;[\.\d]+)'</span>,<span class="string">'names'</span>);</span><br><span class="line">        td.thresDesc = <span class="string">'none'</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> strcmp(td.thresDesc,<span class="string">'unc.'</span>), td.thresDesc = <span class="string">'none'</span>; <span class="keyword">end</span></span><br><span class="line">    xSPM2.thresDesc = td.thresDesc;</span><br><span class="line">    xSPM2.u     = str2double(td.u);</span><br><span class="line">    xSPM2.k     = xSPM.k;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">hReg = spm_XYZreg(<span class="string">'FindReg'</span>,spm_figure(<span class="string">'GetWin'</span>,<span class="string">'Interactive'</span>));</span><br><span class="line">xyz  = spm_XYZreg(<span class="string">'GetCoords'</span>,hReg);</span><br><span class="line">[hReg,xSPM,SPM] = spm_results_ui(<span class="string">'setup'</span>,xSPM2);</span><br><span class="line">spm_XYZreg(<span class="string">'SetCoords'</span>,xyz,hReg);</span><br><span class="line">assignin(<span class="string">'base'</span>,<span class="string">'hReg'</span>,hReg);</span><br><span class="line">assignin(<span class="string">'base'</span>,<span class="string">'xSPM'</span>,xSPM);</span><br><span class="line">assignin(<span class="string">'base'</span>,<span class="string">'SPM'</span>,SPM);</span><br><span class="line"><span class="built_in">figure</span>(spm_figure(<span class="string">'GetWin'</span>,<span class="string">'Interactive'</span>));</span><br></pre></td></tr></table></figure><h2 id="spm_roi_extend.m">spm_ROI_extend.m</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[xY, XYZmm, j]</span> = <span class="title">spm_ROI_extend</span><span class="params">(xY, XYZmm,Input_VOI_path)</span></span></span><br><span class="line"><span class="comment">% Region of Interest specification</span></span><br><span class="line"><span class="comment">% FORMAT xY = spm_ROI(xY)</span></span><br><span class="line"><span class="comment">% xY     - VOI structure</span></span><br><span class="line"><span class="comment">%    xY.def      - VOI definition [sphere, box, mask, cluster, all]</span></span><br><span class="line"><span class="comment">%    xY.rej      - cell array of disabled VOI definition options</span></span><br><span class="line"><span class="comment">%    xY.xyz      - centre of VOI &#123;mm&#125;</span></span><br><span class="line"><span class="comment">%    xY.spec     - VOI definition parameters</span></span><br><span class="line"><span class="comment">%    xY.str      - description of the VOI</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% FORMAT [xY, XYZmm, j] = spm_ROI(xY, XYZmm)</span></span><br><span class="line"><span class="comment">% XYZmm  - [3xm] locations of voxels &#123;mm&#125;</span></span><br><span class="line"><span class="comment">%          If an image filename, an spm_vol structure or a NIfTI object is</span></span><br><span class="line"><span class="comment">%          given instead, XYZmm will be initialised to all voxels within</span></span><br><span class="line"><span class="comment">%          the field of view of that image.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% XYZmm  - [3xn] filtered locations of voxels &#123;mm&#125; (m&gt;=n) within VOI xY</span></span><br><span class="line"><span class="comment">% j      - [1xn] indices of input locations XYZmm within VOI xY</span></span><br><span class="line"><span class="comment">%__________________________________________________________________________</span></span><br><span class="line"><span class="comment">% Copyright (C) 2008 Wellcome Trust Centre for Neuroimaging</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">% Karl Friston, Guillaume Flandin</span></span><br><span class="line"><span class="comment">% $Id: spm_ROI.m 3960 2010-06-30 17:41:24Z ged $</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> nargin &lt; <span class="number">2</span> &amp;&amp; nargout &gt; <span class="number">1</span></span><br><span class="line">    error(<span class="string">'Too many output arguments.'</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%Input_VOI_path = 'D:\FMRI_ROOT\YANTAI\ANALYSIS\first_level_dcm_w_whole\MASK\HG\HG_Resliced_NiftiPairs\NiftiPairs_Resliced_HG.img';</span></span><br><span class="line"><span class="keyword">try</span>, xY; <span class="keyword">catch</span>, xY = []; <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Specify ROI</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"><span class="keyword">if</span> ~isfield(xY,<span class="string">'def'</span>)</span><br><span class="line">    def        = &#123;<span class="string">'sphere'</span>,<span class="string">'box'</span>,<span class="string">'cluster'</span>,<span class="string">'mask'</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> isfield(xY,<span class="string">'rej'</span>)</span><br><span class="line">        <span class="keyword">if</span> ~isfield(xY,<span class="string">'M'</span>)</span><br><span class="line">            xY.rej = &#123;xY.rej&#123;:&#125; <span class="string">'cluster'</span>&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> isfield(xY,<span class="string">'M'</span>)</span><br><span class="line">            xY.rej = &#123;&#125;;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            xY.rej = &#123;<span class="string">'cluster'</span>&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    [q, <span class="built_in">i</span>] = setdiff(def,xY.rej);</span><br><span class="line">    def    = def(<span class="built_in">sort</span>(<span class="built_in">i</span>));</span><br><span class="line">    xY.def     = <span class="string">'mask'</span>; <span class="comment">%======'sphere','box','cluster','mask'======================================================</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-ROI parameters</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">switch</span> lower(xY.def)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'sphere'</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> ~isfield(xY,<span class="string">'xyz'</span>) || <span class="built_in">isempty</span>(xY.xyz)</span><br><span class="line">        xY.xyz = spm_input(<span class="string">'sphere centre [x y z] &#123;mm&#125;'</span>,...</span><br><span class="line">            <span class="string">'!+0'</span>,<span class="string">'r'</span>,<span class="string">'0 0 0'</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> ~isfield(xY,<span class="string">'spec'</span>)</span><br><span class="line">        xY.spec = spm_input(<span class="string">'sphere radius (mm)'</span>,<span class="string">'!+0'</span>,<span class="string">'r'</span>,<span class="number">0</span>,<span class="number">1</span>,[<span class="number">0</span>,Inf]);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    xY.str = sprintf(<span class="string">'%0.1fmm sphere'</span>,xY.spec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'box'</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> ~isfield(xY,<span class="string">'xyz'</span>) || <span class="built_in">isempty</span>(xY.xyz)</span><br><span class="line">        xY.xyz = spm_input(<span class="string">'box centre [x y z] &#123;mm&#125;'</span>,...</span><br><span class="line">            <span class="string">'!+0'</span>,<span class="string">'r'</span>,<span class="string">'0 0 0'</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> ~isfield(xY,<span class="string">'spec'</span>)</span><br><span class="line">        xY.spec = spm_input(<span class="string">'box dimensions [x y z] &#123;mm&#125;'</span>,...</span><br><span class="line">            <span class="string">'!+0'</span>,<span class="string">'r'</span>,<span class="string">'0 0 0'</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">length</span>(xY.spec) &lt; <span class="number">3</span></span><br><span class="line">        xY.spec = xY.spec(<span class="number">1</span>)*[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    xY.str = sprintf(<span class="string">'%0.1f x %0.1f x %0.1f mm box'</span>,xY.spec);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mask'</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> ~isfield(xY,<span class="string">'spec'</span>)</span><br><span class="line">        xY.spec = spm_vol([Input_VOI_path,<span class="string">',1'</span>]);<span class="comment">%===========================================================</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> ~isstruct(xY.spec)</span><br><span class="line">            xY.spec = spm_vol(xY.spec);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    str    = spm_str_manip(xY.spec.fname,<span class="string">'a30x'</span>);</span><br><span class="line">    xY.str = sprintf(<span class="string">'image mask: %s'</span>,str); </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'cluster'</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> ~isfield(xY,<span class="string">'xyz'</span>) || <span class="built_in">isempty</span>(xY.xyz)</span><br><span class="line">        xY.xyz = spm_input(<span class="string">'seed voxel [x y z] &#123;mm&#125;'</span>,...</span><br><span class="line">            <span class="string">'!+0'</span>,<span class="string">'r'</span>,<span class="string">'0 0 0'</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> ~isfield(xY,<span class="string">'M'</span>)</span><br><span class="line">        xY.M = spm_input(<span class="string">'affine transformation matrix'</span>,...</span><br><span class="line">            <span class="string">'!+0'</span>,<span class="string">'r'</span>,<span class="string">'0 0 0'</span>,[<span class="number">4</span> <span class="number">4</span>]);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    xY.spec = [];</span><br><span class="line">    xY.str  = sprintf(<span class="string">'cluster (seed voxel: %0.1f %0.1f %0.1f)'</span>,xY.xyz);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'all'</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    xY.str  = <span class="string">'all'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">otherwise</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    error(<span class="string">'Unknown VOI type.'</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> nargin &lt; <span class="number">2</span>, <span class="keyword">return</span>; <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-'Estimate' ROI</span></span><br><span class="line"><span class="comment">%==========================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Argument check</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> ischar(XYZmm) &amp;&amp; <span class="built_in">isempty</span>(XYZmm)</span><br><span class="line">    XYZmm = spm_select(<span class="number">1</span>,<span class="string">'image'</span>,<span class="string">'Specify Image'</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> ischar(XYZmm), XYZmm = spm_vol(XYZmm); <span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> isa(XYZmm,<span class="string">'nifti'</span>)</span><br><span class="line">    XYZmm    = struct(<span class="string">'dim'</span>,<span class="built_in">size</span>(XYZmm.dat), <span class="string">'mat'</span>,XYZmm.mat);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> isstruct(XYZmm) <span class="comment">% spm_vol</span></span><br><span class="line">    [R,C,P]  = <span class="built_in">ndgrid</span>(<span class="number">1</span>:XYZmm.dim(<span class="number">1</span>),<span class="number">1</span>:XYZmm.dim(<span class="number">2</span>),<span class="number">1</span>:XYZmm.dim(<span class="number">3</span>));</span><br><span class="line">    RCP      = [R(:)';C(:)';P(:)'];</span><br><span class="line">    clear R C P</span><br><span class="line">    RCP(<span class="number">4</span>,:) = <span class="number">1</span>;</span><br><span class="line">    XYZmm    = XYZmm.mat(<span class="number">1</span>:<span class="number">3</span>,:)*RCP;    </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isempty</span>(XYZmm), XYZmm = <span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">0</span>); <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Filter location of voxels</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">Q          = <span class="built_in">ones</span>(<span class="number">1</span>,<span class="built_in">size</span>(XYZmm,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> lower(xY.def)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'sphere'</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="built_in">j</span>      = <span class="built_in">find</span>(sum((XYZmm - xY.xyz*Q).^<span class="number">2</span>) &lt;= xY.spec^<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'box'</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="built_in">j</span>      = <span class="built_in">find</span>(all(<span class="built_in">abs</span>(XYZmm - xY.xyz*Q) &lt;= xY.spec(:)*Q/<span class="number">2</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mask'</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    XYZ    = xY.spec.mat \ [XYZmm; Q];</span><br><span class="line">    <span class="built_in">j</span>      = <span class="built_in">find</span>(spm_sample_vol(xY.spec, XYZ(<span class="number">1</span>,:), XYZ(<span class="number">2</span>,:), XYZ(<span class="number">3</span>,:),<span class="number">0</span>) &gt; <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'cluster'</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    [x <span class="built_in">i</span>]  = spm_XYZreg(<span class="string">'NearestXYZ'</span>,xY.xyz,XYZmm);</span><br><span class="line">    XYZ    = <span class="built_in">round</span>(xY.M \ [XYZmm; Q]);</span><br><span class="line">    A      = spm_clusters(XYZ);</span><br><span class="line">    <span class="built_in">j</span>      = <span class="built_in">find</span>(A == A(<span class="built_in">i</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'all'</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="built_in">j</span>      = <span class="number">1</span>:<span class="built_in">size</span>(XYZmm,<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">otherwise</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    error(<span class="string">'Unknown VOI type.'</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">XYZmm      = XYZmm(:,<span class="built_in">j</span>);</span><br><span class="line"><span class="keyword">if</span> strcmpi(xY.def,<span class="string">'mask'</span>) &amp;&amp; ~<span class="built_in">isempty</span>(XYZmm), xY.xyz = <span class="built_in">mean</span>(XYZmm,<span class="number">2</span>); <span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="createvoi">createVOI</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createVOI</span><span class="params">(spm_mat_path,Input_u)</span></span></span><br><span class="line"><span class="comment">% 功能： 使用特定的Mask抽取VOI。</span></span><br><span class="line"><span class="comment">% spm_mat_path : SPM.mat的完整路径，需要是做完FirstLevel之后的SPM.mat;</span></span><br><span class="line"><span class="comment">% Input_u : 抽取时间序列时使用的P值，一般默认是0.001，当抽取失败的时候，，适当调大可以确保成功；</span></span><br><span class="line"><span class="comment">% -----------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">% 配置信息：</span></span><br><span class="line"><span class="comment">% contrast_name ： First_Level时候设置的contrast,这里的顺序很重要，因为程序中使用数字表示每个contrast的；</span></span><br><span class="line"><span class="comment">% InputMask ： appying mask : 0 none ; 1 contrast ; 2 image ;默认是整数 0 </span></span><br><span class="line"><span class="comment">% InputthresDesc : p value adjustment to control: 'FWE' or 'none'</span></span><br><span class="line"><span class="comment">% Input_k : extend threshold &#123;voxel&#125;  0 ; 默认是0</span></span><br><span class="line"><span class="comment">% xx_mask_path : 抽取的VOI使用的mask的绝对路径</span></span><br><span class="line"><span class="comment">% VOI_Mask ：抽取的VOI使用的mask的绝对路径</span></span><br><span class="line"><span class="comment">% Input_is ： adjust_contrst 这里选择那个F-All的,整数，1 是dont adjust, 2 是F-All，3个数字分别对应三个Mask的adjust_contrst。</span></span><br><span class="line">contrast_name = &#123;<span class="string">'F-All'</span>,<span class="string">'JX'</span>,<span class="string">'DW'</span>,<span class="string">'RL'</span>,<span class="string">'ZR'</span>&#125;;</span><br><span class="line">InputMask = <span class="number">0</span>;  <span class="comment">%appying mask : 0 none ; 1 contrast ; 2 image ============================================================================</span></span><br><span class="line">InputthresDesc = <span class="string">'none'</span>;  <span class="comment">%p value adjustment to control: 'FWE' or 'none'=================================================================</span></span><br><span class="line">Input_k = <span class="number">0</span>; <span class="comment">% extend threshold &#123;voxel&#125;  0 ===============================================================================================</span></span><br><span class="line">HG_mask_path = <span class="string">'D:\FMRI_ROOT\YANTAI\ANALYSIS\first_level_dcm_w_whole\MASK\HG\HG_Resliced_NiftiPairs\NiftiPairs_Resliced_HG.img'</span>;</span><br><span class="line">MFG_mask_path = <span class="string">'D:\FMRI_ROOT\YANTAI\ANALYSIS\first_level_dcm_w_whole\MASK\MFG\MFG_Resliced_NiftiPairs\NiftiPairs_Resliced_MFG.img'</span>;</span><br><span class="line">STG_mask_path = <span class="string">'D:\FMRI_ROOT\YANTAI\ANALYSIS\first_level_dcm_w_whole\MASK\STG\STG_Resliced_NiftiPairs\NiftiPairs_Resliced_STG.img'</span>;</span><br><span class="line">VOI_Mask = &#123;HG_mask_path,MFG_mask_path,STG_mask_path&#125;;</span><br><span class="line">Input_is = &#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;; <span class="comment">%adjust_contrst 这里选择那个F-All的,整数，1 是dont adjust, 2 是F-All.</span></span><br><span class="line">empty_bit = []; <span class="comment">% 占位符，没有用处</span></span><br><span class="line"><span class="comment">% 配置结束</span></span><br><span class="line"><span class="comment">% ----------------------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">2</span>:<span class="built_in">size</span>(contrast_name,<span class="number">2</span>)</span><br><span class="line">    Ic = <span class="built_in">j</span>;  <span class="comment">% 要使用的Contrast的编号，这里1 : F-All  2: JX 3: DW 4:RL 5:ZR</span></span><br><span class="line">    VOI_Names = &#123;[contrast_name&#123;Ic&#125;,<span class="string">'_HG'</span>],[contrast_name&#123;Ic&#125;,<span class="string">'_MFG'</span>],[contrast_name&#123;Ic&#125;,<span class="string">'_STG'</span>,]&#125;; <span class="comment">%Input_VOIName : 抽取的VOI的名称</span></span><br><span class="line">    [SPM,xSPM] = spm_getSPM_extend(spm_mat_path,Ic,InputMask,InputthresDesc,Input_u,Input_k);</span><br><span class="line">    [hReg,xSPM,SPM] = spm_result_ui_extend(<span class="string">'Setup'</span>,xSPM);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">size</span>(VOI_Mask,<span class="number">2</span>)</span><br><span class="line">        [Y xY] = spm_regions_extend(xSPM,SPM,hReg,empty_bit,VOI_Names&#123;<span class="built_in">i</span>&#125;,Input_is&#123;<span class="built_in">i</span>&#125;,VOI_Mask&#123;<span class="built_in">i</span>&#125;);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    clear SPM;</span><br><span class="line">    clear xSPM;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="createvois-创建多个被试的roi">createVOIs, 创建多个被试的ROI</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 创建多个被试的VOI；</span></span><br><span class="line"><span class="comment">% </span></span><br><span class="line">first_level_path = <span class="string">'D:\FMRI_ROOT\YANTAI\ANALYSIS\first_level_dcm_w_whole\';</span></span><br><span class="line"><span class="string">cd(first_level_path);</span></span><br><span class="line"><span class="string">dir_str = dir('</span><span class="number">2016</span>*<span class="string">');</span></span><br><span class="line"><span class="string">Input_u = 0.001; % P值；抽取不成功时，调大P值可以成功</span></span><br><span class="line"><span class="string">for i = 1:size(dir_str,1)</span></span><br><span class="line"><span class="string">    spm_mat_path = [first_level_path,dir_str(i).name,'</span>\SPM.mat'];</span><br><span class="line">    createVOI(spm_mat_path);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="create_dcm">create_dcm</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DCM</span> = <span class="title">create_dcm</span><span class="params">(subject_path)</span></span></span><br><span class="line"><span class="comment">%功能： 定义DCM模型，需要先做完抽取VOI，在FirstLevel文件夹下面VOI_开头的文件；</span></span><br><span class="line"><span class="comment">%subject_path : First_Level 被试目录， eg.D:\FMRI_ROOT\YANTAI\ANALYSIS\first_level_dcm_w_whole\20160716002\</span></span><br><span class="line"><span class="comment">%condition_name : SPM.mat 设计矩阵中定义的条件，这里用来给生成的DCM命名。</span></span><br><span class="line"><span class="comment">%---------------------------------------------------------------</span></span><br><span class="line"><span class="comment">%-配置----------------------------------------------------------</span></span><br><span class="line">condition_name = &#123;<span class="string">'JX'</span>,<span class="string">'DW'</span>,<span class="string">'RL'</span>,<span class="string">'ZR'</span>&#125;;</span><br><span class="line"><span class="comment">%Input_a : DCM模型矩阵，需要更改模型的时候，修改这个矩阵</span></span><br><span class="line"><span class="comment">%Input_b : 调节输入</span></span><br><span class="line"><span class="comment">%Input_c : 外界输入</span></span><br><span class="line"><span class="comment">%-配置结束------------------------------------------------------</span></span><br><span class="line">cd(subject_path);</span><br><span class="line">spmmatfile = [subject_path,<span class="string">'SPM.mat'</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">size</span>(condition_name,<span class="number">2</span>)  <span class="comment">%每次循环创建一个condition条件下的DCM模型</span></span><br><span class="line">    name = condition_name&#123;<span class="built_in">i</span>&#125;; <span class="comment">% 生成的DCM模型的名称；</span></span><br><span class="line">    condition_mask = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>];</span><br><span class="line">    condition_mask(<span class="built_in">i</span>) = <span class="number">1</span>; <span class="comment">% 使用哪个condition作为</span></span><br><span class="line">    TE = <span class="number">0.04</span>; <span class="comment">%  TE </span></span><br><span class="line">    Input_a = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]; <span class="comment">% 定义DCM模型的连接矩阵</span></span><br><span class="line">    Input_b = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]; <span class="comment">% 定义调节参数</span></span><br><span class="line">    Input_c = [<span class="number">1</span>;<span class="number">0</span>;<span class="number">0</span>]; <span class="comment">% 定义输入参数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 获得VOI</span></span><br><span class="line">    <span class="comment">%------------------------------------------------</span></span><br><span class="line">    filter = [<span class="string">'VOI_'</span>,condition_name&#123;<span class="built_in">i</span>&#125;,<span class="string">'_*'</span>];</span><br><span class="line">    VOIs_path = dir(filter);</span><br><span class="line">    VOIs = cell(<span class="built_in">size</span>(VOIs_path,<span class="number">1</span>),<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>: <span class="built_in">size</span>(VOIs_path,<span class="number">1</span>)</span><br><span class="line">        VOIs&#123;<span class="built_in">j</span>&#125; = [subject_path,VOIs_path(<span class="built_in">j</span>).name];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">%-------------------------------------------------</span></span><br><span class="line">    DCM = spm_dcm_specify_extend(spmmatfile,name,VOIs,condition_mask,TE,Input_a,Input_b,Input_c);</span><br><span class="line">    clear name;</span><br><span class="line">    clear VOIs;</span><br><span class="line">    clear condition_mask;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="create_dcms-定义多个被试的dcm模型">create_dcms, 定义多个被试的DCM模型</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%配置：</span></span><br><span class="line">first_level_path = <span class="string">'D:\FMRI_ROOT\YANTAI\ANALYSIS\first_level_dcm_w_whole\';</span></span><br><span class="line"><span class="string">cd(first_level_path);</span></span><br><span class="line"><span class="string">dir_str = dir('</span><span class="number">2016</span>*<span class="string">');</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">for i = 1:size(dir_str,1)</span></span><br><span class="line"><span class="string">    subject_path = [first_level_path,dir_str(i).name,'</span>\<span class="string">'];</span></span><br><span class="line"><span class="string">    create_dcm(subject_path);</span></span><br><span class="line"><span class="string">end</span></span><br></pre></td></tr></table></figure><h2 id="批量估计dcm模型">批量估计DCM模型</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 估计DCM模型</span></span><br><span class="line">first_level_path = <span class="string">'D:\FMRI_ROOT\YANTAI\ANALYSIS\first_level_dcm_w_whole\';</span></span><br><span class="line"><span class="string">cd(first_level_path);</span></span><br><span class="line"><span class="string">dir_path = dir('</span><span class="number">2016</span>*<span class="string">');</span></span><br><span class="line"><span class="string">for i = 1: size(dir_path,1)</span></span><br><span class="line"><span class="string">    subject_path = [first_level_path,dir_path(i).name];</span></span><br><span class="line"><span class="string">    cd(subject_path);</span></span><br><span class="line"><span class="string">    dcm_models_path = dir('</span>DCM*<span class="string">');</span></span><br><span class="line"><span class="string">    for j = 1:size(dcm_models_path,1)</span></span><br><span class="line"><span class="string">       dcm_model_path =  [subject_path,'</span>\<span class="string">',dcm_models_path(j).name];</span></span><br><span class="line"><span class="string">       spm_dcm_estimate(dcm_model_path);</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line"><span class="string">end</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 认知神经科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fMRI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPM预处理中的常用操作</title>
      <link href="/hexoblog/2017/03/20/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/SPM%E9%A2%84%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/hexoblog/2017/03/20/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/SPM%E9%A2%84%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>一些数据处理当中用的到的功能函数。 <a id="more"></a></p><h2 id="比较多幅图像是否配准">比较多幅图像是否配准</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check_img</span><span class="params">(imgs)</span></span></span><br><span class="line"><span class="comment">% -------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">% 功能：比较多幅图像</span></span><br><span class="line"><span class="comment">% 调用：check_img(imgs)</span></span><br><span class="line"><span class="comment">% 参数：</span></span><br><span class="line"><span class="comment">%   imgs: cell类型的图像</span></span><br><span class="line"><span class="comment">% 示例：</span></span><br><span class="line"><span class="comment">%   c1_img = 'D:\FMRI_ROOT\YANTAI\ANALYSIS\pre_processing\20160713001\t1_mprage_sag_p2_0026\run1\c1s20160713001-193508-00001-00176-1.img';</span></span><br><span class="line"><span class="comment">%   c2_img = 'D:\FMRI_ROOT\YANTAI\ANALYSIS\pre_processing\20160713001\t1_mprage_sag_p2_0026\run1\c2s20160713001-193508-00001-00176-1.img';</span></span><br><span class="line"><span class="comment">%   c3_img = 'D:\FMRI_ROOT\YANTAI\ANALYSIS\pre_processing\20160713001\t1_mprage_sag_p2_0026\run1\c3s20160713001-193508-00001-00176-1.img';</span></span><br><span class="line"><span class="comment">%   func_img = 'D:\FMRI_ROOT\YANTAI\ANALYSIS\pre_processing\20160713001\ep2d_bold_moco_p2_rest_0006\f20160713001-190315-00238-00238-1.img';</span></span><br><span class="line"><span class="comment">%   imgs = &#123;c1_img,c2_img,c3_img,func_img&#125;;</span></span><br><span class="line"><span class="comment">%   check_img(imgs);</span></span><br><span class="line"><span class="comment">% -------------------------------------------------------------------------</span></span><br><span class="line">spm_jobman(<span class="string">'initcfg'</span>)</span><br><span class="line">matlabbatch&#123;<span class="number">1</span>&#125;.spm.util.checkreg.data = imgs;</span><br><span class="line">spm_jobman(<span class="string">'run'</span>,matlabbatch);</span><br></pre></td></tr></table></figure><h2 id="批量复制文件夹结构">批量复制文件夹结构</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy_structure</span><span class="params">(origin_path,destination_path,fileFilter,varargin)</span></span></span><br><span class="line"><span class="comment">% -------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">% 功能： 复制目录结构 或者 复制文件</span></span><br><span class="line"><span class="comment">% 调用1：copy_structure(origin_path,destination_path,filter)</span></span><br><span class="line"><span class="comment">% 调用2：copy_structure(origin_path,destination_path,fileFilter,subExpIDFilter)</span></span><br><span class="line"><span class="comment">% 调用3：copy_structure(origin_path,destination_path,fileFilter,subExpIDFilter，runExpIDFilter)</span></span><br><span class="line"><span class="comment">% 参数：</span></span><br><span class="line"><span class="comment">%   origin_path : 要复制的目录结构的绝对路径</span></span><br><span class="line"><span class="comment">%   destination_path : 新文件夹绝对路径</span></span><br><span class="line"><span class="comment">%   subExpIDFilter ：子一级目录通配符</span></span><br><span class="line"><span class="comment">%   runExpIDFilter : 子二级目录通配符</span></span><br><span class="line"><span class="comment">%   fileFilter: 过滤器，决定拷贝哪些文件</span></span><br><span class="line"><span class="comment">% 示例：</span></span><br><span class="line"><span class="comment">%   copy_structure(origin_path,destination_path,'s4w*')</span></span><br><span class="line"><span class="comment">%   copy_structure(origin_path,destination_path,'s4w*','20160916001*')</span></span><br><span class="line"><span class="comment">%   copy_structure(origin_path,destination_path,'s4w*','20160916001*','ep2d_bold_moco_p2_rest_0006*')</span></span><br><span class="line"><span class="comment">% 说明： subExpIDFilter默认值为'2016*';runExpIDFilter 默认值为 'ep2d*'</span></span><br><span class="line"><span class="comment">% --------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> nargin &lt; <span class="number">4</span></span><br><span class="line">   subExpIDFilter = <span class="string">'2016*'</span>;<span class="comment">% 被试文件夹通配符 </span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    subExpIDFilter = varargin&#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> nargin &lt; <span class="number">5</span></span><br><span class="line">    runExpIDFilter = <span class="string">'ep2d*'</span>;<span class="comment">% RUN文件夹通配符</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    runExpIDFilter = varargin&#123;<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%fileFilter = 'w*';</span></span><br><span class="line">cd(origin_path);</span><br><span class="line">subExpID=dir(subExpIDFilter); </span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">size</span>(subExpID,<span class="number">1</span>)</span><br><span class="line">    mkdir([destination_path,subExpID(<span class="built_in">i</span>).name]);</span><br><span class="line">    cd([origin_path,subExpID(<span class="built_in">i</span>).name]);</span><br><span class="line">    runExpID=dir(runExpIDFilter); </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:<span class="built_in">size</span>(runExpID,<span class="number">1</span>)</span><br><span class="line">        mkdir([destination_path,subExpID(<span class="built_in">i</span>).name,<span class="string">'\',runExpID(j).name]);</span></span><br><span class="line"><span class="string">        cd([origin_path,subExpID(i).name,'</span>\<span class="string">',runExpID(j).name]);</span></span><br><span class="line"><span class="string">        if nargin &gt; 2</span></span><br><span class="line"><span class="string">            copyfile(fileFilter,[destination_path,subExpID(i).name,'</span>\<span class="string">',runExpID(j).name],'</span>f');</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="从多标签mask生成单标签mask">从多标签mask生成单标签mask</h3><p>注意本函数依赖marsbar, 需要将marsbar工具包setpath之后才能使用。 <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create_masks_from_multiple_labels_img</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">% -------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">% 功能： 从多标签图像创建多个Mask</span></span><br><span class="line"><span class="comment">% 参数：</span></span><br><span class="line"><span class="comment">%   multiple_label_img_path ：多标签图像路径</span></span><br><span class="line"><span class="comment">%   multiple_label_path : 标签路径，名称为ROI，包含ID，Nom_C,Nom_L,ID是标签，整数，剩下的是名称</span></span><br><span class="line"><span class="comment">%   save_path ： 生成Mask的保存路径</span></span><br><span class="line"><span class="comment">%   P ： 提供重新采样的参数，需要随便一张被试的图像，Mask会按照该图像的规格重新采样</span></span><br><span class="line"></span><br><span class="line">aal = <span class="string">'C:\mazcx\matlabtoolbox\spm8\toolbox\wfu_pickatlas\MNI_atlas_templates\TD_label_extended_modified.img'</span>;</span><br><span class="line">aal_label = <span class="string">'C:\mazcx\matlabtoolbox\spm8\toolbox\wfu_pickatlas\MNI_atlas_templates\TD_label_extended_modified_List.mat'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">multiple_label_img_path = aal;</span><br><span class="line">multiple_label_path = aal_label;</span><br><span class="line">save_path = <span class="string">'D:\FMRI_ROOT\YANTAI\DESIGN\MASK\TDLabels\';</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">P = '</span>D:\FMRI_ROOT\YANTAI\ANALYSIS\pre_processing\<span class="number">20160911002</span>\ep2d_bold_moco_p2_rest_0006\wraf20160911002<span class="number">-182754</span><span class="number">-00008</span><span class="number">-00008</span><span class="number">-1.</span>img';</span><br><span class="line">roi_space = spm_vol(P);</span><br><span class="line"><span class="comment">% ROI names</span></span><br><span class="line">load(multiple_label_path);</span><br><span class="line">marsbar(<span class="string">'on'</span>);</span><br><span class="line"><span class="comment">% Make ROIs</span></span><br><span class="line">vol = spm_vol(multiple_label_img_path);</span><br><span class="line"><span class="keyword">for</span> r = <span class="number">1</span>:<span class="built_in">length</span>(ROI)</span><br><span class="line">  nom = ROI(r).Nom_L;</span><br><span class="line">  func = sprintf(<span class="string">'img == %d'</span>, ROI(r).ID); </span><br><span class="line">  o = maroi_image(struct(<span class="string">'vol'</span>, vol, <span class="string">'binarize'</span>,<span class="number">1</span>,...</span><br><span class="line"> <span class="string">'func'</span>, func, <span class="string">'descrip'</span>, nom, ...</span><br><span class="line"> <span class="string">'label'</span>, nom));</span><br><span class="line">  cd(save_path);</span><br><span class="line">  <span class="comment">%saveroi(maroi_matrix(o), fullfile(roi_path,['MNI_' nom '_roi.mat']));</span></span><br><span class="line">  mars_rois2img(maroi_matrix(o),[<span class="string">'MNI_'</span> nom <span class="string">'.img'</span>],roi_space);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h2 id="mask乘以激活之后再做成mask就是每个被试不同的mask">mask乘以激活之后再做成mask,就是每个被试不同的mask</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create_mask_use_T</span><span class="params">(input_img,output_img,f)</span></span></span><br><span class="line"><span class="comment">% 制作的mask乘以相应的激活之后再做成Mask</span></span><br><span class="line"><span class="comment">% STG_mask_path = 'D:\FMRI_ROOT\YANTAI\DESIGN\MASK\NiftiPairs_Resliced_STG.mn.img';</span></span><br><span class="line"><span class="comment">% spmT_path = 'D:\FMRI_ROOT\YANTAI\ANALYSIS\first_level\20160911002\spmT_0017.img';</span></span><br><span class="line"><span class="comment">% input_img = &#123;STG_mask_path; spmT_path&#125;; % 一个mask , 一个spmT图像</span></span><br><span class="line"><span class="comment">% output_img = 'd:\aaa.img';</span></span><br><span class="line"><span class="comment">%------------</span></span><br><span class="line">P = input_img;</span><br><span class="line">Q = output_img;</span><br><span class="line"><span class="comment">%f = 'i1.*(i2&gt;3.0987)';</span></span><br><span class="line">dmtx = <span class="number">0</span>;</span><br><span class="line">mask = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">type</span> = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">hold</span> = <span class="number">0</span>;</span><br><span class="line">flags = &#123;dmtx,mask,<span class="built_in">type</span>,<span class="built_in">hold</span>&#125;;</span><br><span class="line">[Q,Vo] = spm_imcalc_extend(P,Q,f,flags);</span><br></pre></td></tr></table></figure><h2 id="将同一个被试不同run的头动文件合并在一起">将同一个被试不同RUN的头动文件合并在一起</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 将多个rp*头动文件，合成一个头动文件</span></span><br><span class="line">pre_processing = <span class="string">'D:\FMRI_ROOT\YANTAI\ANALYSIS\pre_processing\';</span></span><br><span class="line"><span class="string">cd(pre_processing);</span></span><br><span class="line"><span class="string">subjects = dir('</span><span class="number">2016</span>*<span class="string">');</span></span><br><span class="line"><span class="string">for i = 1: size(subjects,1)</span></span><br><span class="line"><span class="string">   cd([pre_processing,subjects(i).name]);</span></span><br><span class="line"><span class="string">   SubRunID = dir('</span>ep2d*<span class="string">');</span></span><br><span class="line"><span class="string">   rps = ones(272*4,6);</span></span><br><span class="line"><span class="string">   for j = 1:size(SubRunID,1)</span></span><br><span class="line"><span class="string">       cd([pre_processing,subjects(i).name,'</span>\<span class="string">',SubRunID(j).name]);</span></span><br><span class="line"><span class="string">       file = dir('</span>rp*<span class="string">');</span></span><br><span class="line"><span class="string">       filename = file(1).name;</span></span><br><span class="line"><span class="string">       a = load(filename);</span></span><br><span class="line"><span class="string">       rps(272*(j-1)+1:272*j,1:6) = a;</span></span><br><span class="line"><span class="string">   end</span></span><br><span class="line"><span class="string">    cd([pre_processing,subjects(i).name]);</span></span><br><span class="line"><span class="string">    save('</span>rp_all.txt',<span class="string">'rps'</span>,<span class="string">'-ascii'</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="提取图像某个点的值并绘制时间序列曲线">提取图像某个点的值并绘制时间序列曲线</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Y</span> = <span class="title">extract_time_series</span><span class="params">(V,XYZ)</span></span></span><br><span class="line"><span class="comment">% -------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">% 功能：提取图像某个点的值并绘制时间序列曲线</span></span><br><span class="line"><span class="comment">% 调用：Y = plot_time_series(V,XYZ)</span></span><br><span class="line"><span class="comment">% 参数： </span></span><br><span class="line"><span class="comment">%   XYZ ：三维坐标，图像中的点</span></span><br><span class="line"><span class="comment">%   V : 存放图像路径的cell</span></span><br><span class="line"><span class="comment">% 示例：</span></span><br><span class="line"><span class="comment">%   XYZ = [13;48;2];</span></span><br><span class="line"><span class="comment">%   V = &#123;'D:\FMRI_ROOT\YANTAI\ANALYSIS\pre_processing\20160911002\ep2d_bold_moco_p2_rest_0006\af20160911002-182750-00006-00006-1.img',</span></span><br><span class="line"><span class="comment">%    'D:\FMRI_ROOT\YANTAI\ANALYSIS\pre_processing\20160911002\ep2d_bold_moco_p2_rest_0006\af20160911002-182750-00006-00006-1.img'&#125;;</span></span><br><span class="line"><span class="comment">%   Y = plot_time_series(V,XYZ)</span></span><br><span class="line"><span class="comment">% -------------------------------------------------------------------------</span></span><br><span class="line">Y = spm_get_data(V,XYZ);</span><br></pre></td></tr></table></figure><h2 id="使用xjview批量找到激活的峰值并保存">使用xjview批量找到激活的峰值并保存</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">spmT_filepath = <span class="string">'D:\FMRI_ROOT\YANTAI\ANALYSIS\first_level\20160911002\spmT_0020.hdr'</span>;</span><br><span class="line">xjview(spmT_filepath);</span><br><span class="line"><span class="comment">%显示出激活图像</span></span><br><span class="line"><span class="comment">% 找到峰值</span></span><br><span class="line">h = spm_mip_ui(<span class="string">'FindMIPax'</span>);</span><br><span class="line"><span class="comment">% loc     - String defining jump: 'dntmv' - don't move</span></span><br><span class="line"><span class="comment">%                                 'nrvox' - nearest suprathreshold voxel</span></span><br><span class="line"><span class="comment">%                                 'nrmax' - nearest local maxima</span></span><br><span class="line"><span class="comment">%                                 'glmax' - global maxima</span></span><br><span class="line">loc = <span class="string">'glmax'</span>;</span><br><span class="line">xyz = spm_mip_ui(<span class="string">'Jump'</span>,h,loc);</span><br></pre></td></tr></table></figure><h2 id="求若干个图像的平均图像">求若干个图像的平均图像</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mean_img</span><span class="params">(input_img,output_img)</span></span></span><br><span class="line"><span class="comment">% -------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">% 功能：求若干个图像的平均图像</span></span><br><span class="line"><span class="comment">% 调用：mean_img(input_img,output_img)</span></span><br><span class="line"><span class="comment">% 参数：</span></span><br><span class="line"><span class="comment">%   input_img : cell类型的输入图像，绝对路径</span></span><br><span class="line"><span class="comment">%   output_img : 输出图像的绝对路径</span></span><br><span class="line"><span class="comment">% 示例：</span></span><br><span class="line"><span class="comment">%   input_img = &#123; 'd:\fmri_root\YANTAI\ANALYSIS\mean_smooth4\DW10\s4wraf20161104002-181316-00074-00074-1.img,1'</span></span><br><span class="line"><span class="comment">%                 'd:\fmri_root\YANTAI\ANALYSIS\mean_smooth4\DW11\s4wraf20161104002-181208-00040-00040-1.img,1'</span></span><br><span class="line"><span class="comment">%                 'd:\fmri_root\YANTAI\ANALYSIS\mean_smooth4\DW20\s4wraf20161104002-181822-00227-00227-1.img,1'</span></span><br><span class="line"><span class="comment">%                 'd:\fmri_root\YANTAI\ANALYSIS\mean_smooth4\DW21\s4wraf20161104002-181640-00176-00176-1.img,1'&#125;;</span></span><br><span class="line"><span class="comment">%   output_img = 'd:\out.img';</span></span><br><span class="line"><span class="comment">% mean_img(input_img,output_img)</span></span><br><span class="line"><span class="comment">% 说明：修改matlabbatch&#123;1&#125;.spm.util.imcalc.expression可以完成不同的计算任务</span></span><br><span class="line"><span class="comment">% -------------------------------------------------------------------------</span></span><br><span class="line">[path,name,exit] = fileparts(output_img) ;</span><br><span class="line">spm_jobman(<span class="string">'initcfg'</span>)</span><br><span class="line"><span class="comment">%-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">% Job configuration created by cfg_util (rev $Rev: 4252 $)</span></span><br><span class="line"><span class="comment">%-----------------------------------------------------------------------</span></span><br><span class="line">matlabbatch&#123;<span class="number">1</span>&#125;.spm.util.imcalc.input = input_img;</span><br><span class="line">matlabbatch&#123;<span class="number">1</span>&#125;.spm.util.imcalc.output = [name,exit];</span><br><span class="line">matlabbatch&#123;<span class="number">1</span>&#125;.spm.util.imcalc.outdir = &#123;path&#125;;</span><br><span class="line">matlabbatch&#123;<span class="number">1</span>&#125;.spm.util.imcalc.expression = <span class="string">'(i1+i2+i3+i4)/4'</span>;</span><br><span class="line">matlabbatch&#123;<span class="number">1</span>&#125;.spm.util.imcalc.options.dmtx = <span class="number">0</span>;</span><br><span class="line">matlabbatch&#123;<span class="number">1</span>&#125;.spm.util.imcalc.options.mask = <span class="number">0</span>;</span><br><span class="line">matlabbatch&#123;<span class="number">1</span>&#125;.spm.util.imcalc.options.interp = <span class="number">1</span>;</span><br><span class="line">matlabbatch&#123;<span class="number">1</span>&#125;.spm.util.imcalc.options.dtype = <span class="number">4</span>;</span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">spm_jobman(<span class="string">'run'</span>,matlabbatch);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">'mean_img successful !'</span>);</span><br><span class="line">clear matlabbatch;</span><br></pre></td></tr></table></figure><h2 id="求若干个图像的平均图像一种速度更快的实现方式">求若干个图像的平均图像(一种速度更快的实现方式)</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Q</span> = <span class="title">mean_img2</span><span class="params">(input_img,output_img)</span></span></span><br><span class="line"><span class="comment">% -------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">% 功能：计算四个图像的平均值</span></span><br><span class="line"><span class="comment">% 调用：Q = mean_img2(input_img,output_img)</span></span><br><span class="line"><span class="comment">% 参数：</span></span><br><span class="line"><span class="comment">%   input_img: cell类型的输入图像的绝对路径</span></span><br><span class="line"><span class="comment">%   output_img: 输出图像的绝对路径</span></span><br><span class="line"><span class="comment">% 示例：</span></span><br><span class="line"><span class="comment">% input_img = &#123;'D:\FMRI_ROOT\YANTAI\ANALYSIS\pre_processing\20160911002\ep2d_bold_moco_p2_rest_0006\s4wraf20160911002-182750-00006-00006-1.img'</span></span><br><span class="line"><span class="comment">%                 'D:\FMRI_ROOT\YANTAI\ANALYSIS\pre_processing\20160911002\ep2d_bold_moco_p2_rest_0006\s4wraf20160911002-182752-00007-00007-1.img'</span></span><br><span class="line"><span class="comment">%                 'D:\FMRI_ROOT\YANTAI\ANALYSIS\pre_processing\20160911002\ep2d_bold_moco_p2_rest_0006\s4wraf20160911002-182754-00008-00008-1.img'</span></span><br><span class="line"><span class="comment">%                 'D:\FMRI_ROOT\YANTAI\ANALYSIS\pre_processing\20160911002\ep2d_bold_moco_p2_rest_0006\s4wraf20160911002-182756-00009-00009-1.img'&#125;;</span></span><br><span class="line"><span class="comment">% output_img = 'd:\out.img';</span></span><br><span class="line"><span class="comment">% Q = mean_img2(input_img,output_img)</span></span><br><span class="line"><span class="comment">% -------------------------------------------------------------------------</span></span><br><span class="line">P = input_img;</span><br><span class="line">Q = output_img;</span><br><span class="line">f = <span class="string">'(i1+i2+i3+i4)/4'</span>;</span><br><span class="line">dmtx = <span class="number">0</span>;</span><br><span class="line">mask = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">type</span> = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">hold</span> = <span class="number">0</span>;</span><br><span class="line">flags = &#123;dmtx,mask,<span class="built_in">type</span>,<span class="built_in">hold</span>&#125;;</span><br><span class="line"></span><br><span class="line">[Q,Vo] = spm_imcalc_extend(P,Q,f,flags);</span><br></pre></td></tr></table></figure><h2 id="绘制一个run的时间序列">绘制一个RUN的时间序列</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Y</span> = <span class="title">plot_time_series_run</span><span class="params">(XYZ,run_dir,file_filter)</span></span></span><br><span class="line"><span class="comment">% -------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">% 功能 ： 绘制一个RUN的时间序列</span></span><br><span class="line"><span class="comment">% 调用：Y = plot_time_series_run(run_dir,file_filter)</span></span><br><span class="line"><span class="comment">% 参数：</span></span><br><span class="line"><span class="comment">%   XYZ : 图像中的某个点</span></span><br><span class="line"><span class="comment">%   run_dir : run文件夹路径</span></span><br><span class="line"><span class="comment">%   file_filter : 文件过滤器，e.g.w*.img</span></span><br><span class="line"><span class="comment">%   Y：提取的数据</span></span><br><span class="line"><span class="comment">% -------------------------------------------------------------------------</span></span><br><span class="line">V = cell(<span class="number">272</span>,<span class="number">1</span>);</span><br><span class="line">cd(run_dir);</span><br><span class="line">files = dir(file_filter);</span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:<span class="built_in">size</span>(files,<span class="number">1</span>)</span><br><span class="line">    V&#123;k&#125; = [run_dir,<span class="string">'\',files(k).name];</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">Y = spm_get_data(V,XYZ);</span></span><br><span class="line"><span class="string">plot(Y);</span></span><br></pre></td></tr></table></figure><h2 id="绘制被试的头动图像">绘制被试的头动图像</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">plothm</span><span class="params">(file_path,save_name)</span></span></span><br><span class="line"><span class="comment">% -------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">% 功能：根据头动文件画头动图</span></span><br><span class="line"><span class="comment">% 调用：plothm(file_path,save_name)</span></span><br><span class="line"><span class="comment">% 参数：</span></span><br><span class="line"><span class="comment">%   file_path : rp*头动文件绝对路径</span></span><br><span class="line"><span class="comment">%   save_name : 生成图像的名称</span></span><br><span class="line"><span class="comment">% 示例：</span></span><br><span class="line"><span class="comment">%   file_path = 'D:\FMRI_ROOT\YANTAI\ANALYSIS\pre_processing\20160716002\ep2d_bold_moco_p2_rest_0016\rp_af20160716002-183602-00006-00006-1.txt';</span></span><br><span class="line"><span class="comment">%   save_name = 'd:\realign_run1.png'</span></span><br><span class="line"><span class="comment">% plothm(file_path,save_name)</span></span><br><span class="line"><span class="comment">% 说明：需要事先打开SPM的Graph窗口；save_name如果只有名称，则保存在Matlab当前工作目录下，如果提供了绝对路径，则保存为绝对路径指定的地方。</span></span><br><span class="line"><span class="comment">% -------------------------------------------------------------------------</span></span><br><span class="line">Params = load(file_path);</span><br><span class="line">fg=spm_figure(<span class="string">'FindWin'</span>,<span class="string">'Graphics'</span>);</span><br><span class="line"><span class="keyword">if</span> ~<span class="built_in">isempty</span>(fg),</span><br><span class="line">    <span class="comment">% display results</span></span><br><span class="line">    <span class="comment">% translation and rotation over time series</span></span><br><span class="line">    <span class="comment">%-------------------------------------------------------------------</span></span><br><span class="line">    spm_figure(<span class="string">'Clear'</span>,<span class="string">'Graphics'</span>);</span><br><span class="line">    ax=axes(<span class="string">'Position'</span>,[<span class="number">0.1</span> <span class="number">0.65</span> <span class="number">0.8</span> <span class="number">0.2</span>],<span class="string">'Parent'</span>,fg,<span class="string">'Visible'</span>,<span class="string">'off'</span>);</span><br><span class="line">    set(get(ax,<span class="string">'Title'</span>),<span class="string">'String'</span>,<span class="string">'Image realignment'</span>,<span class="string">'FontSize'</span>,<span class="number">16</span>,<span class="string">'FontWeight'</span>,<span class="string">'Bold'</span>,<span class="string">'Visible'</span>,<span class="string">'on'</span>);</span><br><span class="line">    ax=axes(<span class="string">'Position'</span>,[<span class="number">0.1</span> <span class="number">0.35</span> <span class="number">0.8</span> <span class="number">0.2</span>],<span class="string">'Parent'</span>,fg,<span class="string">'XGrid'</span>,<span class="string">'on'</span>,<span class="string">'YGrid'</span>,<span class="string">'on'</span>);</span><br><span class="line">    <span class="built_in">plot</span>(Params(:,<span class="number">1</span>:<span class="number">3</span>),<span class="string">'Parent'</span>,ax)</span><br><span class="line">    s = [<span class="string">'x translation'</span>;<span class="string">'y translation'</span>;<span class="string">'z translation'</span>];</span><br><span class="line">    <span class="comment">%text([2 2 2], Params(2, 1:3), s, 'Fontsize',10,'Parent',ax)</span></span><br><span class="line">    <span class="built_in">legend</span>(ax, s, <span class="number">0</span>)</span><br><span class="line">    set(get(ax,<span class="string">'Title'</span>),<span class="string">'String'</span>,<span class="string">'translation'</span>,<span class="string">'FontSize'</span>,<span class="number">16</span>,<span class="string">'FontWeight'</span>,<span class="string">'Bold'</span>);</span><br><span class="line">    set(get(ax,<span class="string">'Xlabel'</span>),<span class="string">'String'</span>,<span class="string">'image'</span>);</span><br><span class="line">    set(get(ax,<span class="string">'Ylabel'</span>),<span class="string">'String'</span>,<span class="string">'mm'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ax=axes(<span class="string">'Position'</span>,[<span class="number">0.1</span> <span class="number">0.05</span> <span class="number">0.8</span> <span class="number">0.2</span>],<span class="string">'Parent'</span>,fg,<span class="string">'XGrid'</span>,<span class="string">'on'</span>,<span class="string">'YGrid'</span>,<span class="string">'on'</span>);</span><br><span class="line">    <span class="built_in">plot</span>(Params(:,<span class="number">4</span>:<span class="number">6</span>)*<span class="number">180</span>/<span class="built_in">pi</span>,<span class="string">'Parent'</span>,ax)</span><br><span class="line">    s = [<span class="string">'pitch'</span>;<span class="string">'roll '</span>;<span class="string">'yaw  '</span>];</span><br><span class="line">    <span class="comment">%text([2 2 2], Params(2, 4:6)*180/pi, s, 'Fontsize',10,'Parent',ax)</span></span><br><span class="line">    <span class="built_in">legend</span>(ax, s, <span class="number">0</span>)</span><br><span class="line">    set(get(ax,<span class="string">'Title'</span>),<span class="string">'String'</span>,<span class="string">'rotation'</span>,<span class="string">'FontSize'</span>,<span class="number">16</span>,<span class="string">'FontWeight'</span>,<span class="string">'Bold'</span>);</span><br><span class="line">    set(get(ax,<span class="string">'Xlabel'</span>),<span class="string">'String'</span>,<span class="string">'image'</span>);</span><br><span class="line">    set(get(ax,<span class="string">'Ylabel'</span>),<span class="string">'String'</span>,<span class="string">'degrees'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% print realigment parameters</span></span><br><span class="line">    spm_print(save_name);</span><br><span class="line">    print(fg,save_name,<span class="string">'-dpng'</span>);<span class="comment">% 打印出PNG图片，还可以输出其他的格式，参考Matlab的print函数。</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><h2 id="批量保存xjview中的slice_view图像">批量保存xjview中的slice_view图像</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">save_slice_view</span><span class="params">(file_path,save_path)</span></span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">% 功能：保存激活图像的slice_view图像</span></span><br><span class="line"><span class="comment">% 调用：save_slice_view(file_path,save_path)</span></span><br><span class="line"><span class="comment">% 参数：</span></span><br><span class="line"><span class="comment">%   file_path : spmT图像</span></span><br><span class="line"><span class="comment">%   save_path : 保存的绝对路径，包含文件名</span></span><br><span class="line"><span class="comment">% 示例：</span></span><br><span class="line"><span class="comment">%   file_path = 'D:\FMRI_ROOT\YANTAI\ANALYSIS\first_level\20160911002\spmT_0020.hdr';</span></span><br><span class="line"><span class="comment">%   save_path = 'd:\aaa.png';</span></span><br><span class="line"><span class="comment">%   save_slice_view(file_path,save_path)</span></span><br><span class="line"><span class="comment">% -------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%file_path = 'D:\FMRI_ROOT\YANTAI\ANALYSIS\first_level\20160911002\spmT_0020.hdr';</span></span><br><span class="line">my_xjview(file_path);</span><br><span class="line">hObject = spm_mip_ui(<span class="string">'FindMIPax'</span>);</span><br><span class="line">eventdata = [];</span><br><span class="line">handles = guidata(hObject);</span><br><span class="line"><span class="keyword">global</span> sliceview</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(~isfield(sliceview, <span class="string">'fig'</span>) || ~ishandle(sliceview.fig))</span><br><span class="line">    sliceview.viewtype = <span class="string">'t'</span>;    </span><br><span class="line">    sliceview.row = <span class="number">6</span>;</span><br><span class="line">    sliceview.col = <span class="number">8</span>;</span><br><span class="line">    sliceview.spacing = <span class="number">4</span>;</span><br><span class="line">    sliceview.page = <span class="number">1</span>;</span><br><span class="line">    sliceview.data = &#123;&#123;&#125;,&#123;&#125;,&#123;&#125;&#125;; <span class="comment">% t,s,c</span></span><br><span class="line">    sliceview.slices = &#123;[],[],[]&#125;;<span class="comment">% t,s,c</span></span><br><span class="line">    sliceview.colormap = <span class="string">''</span>;</span><br><span class="line">    sliceview.fig = <span class="built_in">figure</span>(<span class="string">'color'</span>,<span class="string">'k'</span>, <span class="string">'unit'</span>,<span class="string">'normalized'</span>,<span class="string">'position'</span>,[<span class="number">0.1</span> <span class="number">0.1</span> <span class="number">.6</span> <span class="number">.8</span>],<span class="string">'toolbar'</span>,<span class="string">'none'</span>, <span class="string">'name'</span>, <span class="string">'xjView slice view'</span>, <span class="string">'NumberTitle'</span>,<span class="string">'off'</span>);</span><br><span class="line">    sliceview.ax = axes(<span class="string">'Visible'</span>,<span class="string">'on'</span>,<span class="string">'DrawMode'</span>,<span class="string">'fast'</span>,<span class="string">'Parent'</span>,sliceview.fig,...</span><br><span class="line">    <span class="string">'YDir'</span>,<span class="string">'normal'</span>,<span class="string">'Ydir'</span>,<span class="string">'normal'</span>,<span class="string">'XTick'</span>,[],<span class="string">'YTick'</span>,[], <span class="string">'position'</span>, [<span class="number">0.15</span> <span class="number">0.05</span> <span class="number">.8</span> <span class="number">.9</span>]);</span><br><span class="line">    <span class="comment">%handles.sliceview.d  = image([],'Tag','Transverse','Parent',handles.sliceview.ax);</span></span><br><span class="line">    set(sliceview.ax,<span class="string">'XTick'</span>,[],<span class="string">'YTick'</span>,[]);</span><br><span class="line">    axis equal</span><br><span class="line">    set(sliceview.ax,<span class="string">'color'</span>,<span class="string">'k'</span>);</span><br><span class="line">    <span class="comment">%setcolormap(colormp)</span></span><br><span class="line">    width = <span class="number">0.05</span>;</span><br><span class="line">    height = <span class="number">0.025</span>;</span><br><span class="line">    step = <span class="number">0.025</span>;</span><br><span class="line">    labeloffset = step/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">slicegraph = <span class="built_in">figure</span>(sliceview.fig);</span><br><span class="line"></span><br><span class="line">viewtype =    sliceview.viewtype;   </span><br><span class="line">row =         sliceview.row;</span><br><span class="line">col =         sliceview.col;</span><br><span class="line">spacing =     sliceview.spacing;</span><br><span class="line">page =        sliceview.page;</span><br><span class="line">slice_fig = sliceview.fig;</span><br><span class="line">ax = sliceview.ax;</span><br><span class="line"><span class="comment">%d = handles.sliceview.d;</span></span><br><span class="line"></span><br><span class="line">[slicedata, colormp, slices] = cuixu_getSliceViewData(viewtype,row,col, spacing, page);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isempty</span>(slices)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ii=<span class="number">1</span>:<span class="built_in">length</span>(slices)</span><br><span class="line">    <span class="keyword">if</span>(viewtype == <span class="string">'s'</span>)</span><br><span class="line">        postmp = <span class="built_in">find</span>(slices(ii) - sliceview.slices&#123;<span class="number">2</span>&#125; == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isempty</span>(postmp))</span><br><span class="line">            sliceview.data&#123;<span class="number">2</span>&#125;&#123;<span class="keyword">end</span>+<span class="number">1</span>&#125; = slicedata&#123;ii&#125;;</span><br><span class="line">            sliceview.slices&#123;<span class="number">2</span>&#125;(<span class="keyword">end</span>+<span class="number">1</span>) = slices(ii);</span><br><span class="line">        <span class="keyword">end</span>   </span><br><span class="line">    <span class="keyword">elseif</span>(viewtype == <span class="string">'t'</span>)</span><br><span class="line">        postmp = <span class="built_in">find</span>(slices(ii) - sliceview.slices&#123;<span class="number">1</span>&#125; == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isempty</span>(postmp))</span><br><span class="line">            sliceview.data&#123;<span class="number">1</span>&#125;&#123;<span class="keyword">end</span>+<span class="number">1</span>&#125; = slicedata&#123;ii&#125;;</span><br><span class="line">            sliceview.slices&#123;<span class="number">1</span>&#125;(<span class="keyword">end</span>+<span class="number">1</span>) = slices(ii);</span><br><span class="line">        <span class="keyword">end</span>    </span><br><span class="line">    <span class="keyword">elseif</span>(viewtype == <span class="string">'c'</span>)</span><br><span class="line">        postmp = <span class="built_in">find</span>(slices(ii) - sliceview.slices&#123;<span class="number">3</span>&#125; == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isempty</span>(postmp))</span><br><span class="line">            sliceview.data&#123;<span class="number">3</span>&#125;&#123;<span class="keyword">end</span>+<span class="number">1</span>&#125; = slicedata&#123;ii&#125;;</span><br><span class="line">            sliceview.slices&#123;<span class="number">3</span>&#125;(<span class="keyword">end</span>+<span class="number">1</span>) = slices(ii);</span><br><span class="line">        <span class="keyword">end</span>   </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%slice_fig = figure('color','k', 'unit','normalized','position',[0.1 0.1 .6 .8],'toolbar','none');</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">length</span>(<span class="built_in">size</span>(slicedata&#123;<span class="number">1</span>&#125;)) == <span class="number">3</span>)</span><br><span class="line">    [nx, ny, nz] = <span class="built_in">size</span>(slicedata&#123;<span class="number">1</span>&#125;);</span><br><span class="line">    slicedatafinal = <span class="built_in">zeros</span>(nx*row, ny*col, nz );</span><br><span class="line">    <span class="keyword">for</span> ii=<span class="number">1</span>:<span class="built_in">length</span>(slicedata)</span><br><span class="line">        slicedatafinal(nx*(<span class="built_in">floor</span>((ii<span class="number">-1</span>)/col))+<span class="number">1</span>:nx*(<span class="number">1</span>+<span class="built_in">floor</span>((ii<span class="number">-1</span>)/col)), ny*(<span class="built_in">mod</span>(ii<span class="number">-1</span>,col))+<span class="number">1</span>:ny*(<span class="built_in">mod</span>(ii<span class="number">-1</span>,col)+<span class="number">1</span>), :) = slicedata&#123;ii&#125;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    [nx, ny] = <span class="built_in">size</span>(slicedata&#123;<span class="number">1</span>&#125;);</span><br><span class="line">    slicedatafinal = <span class="built_in">zeros</span>(nx*row, ny*col );</span><br><span class="line">    <span class="keyword">for</span> ii=<span class="number">1</span>:<span class="built_in">length</span>(slicedata)</span><br><span class="line">        slicedatafinal(nx*(<span class="built_in">floor</span>((ii<span class="number">-1</span>)/col))+<span class="number">1</span>:nx*(<span class="number">1</span>+<span class="built_in">floor</span>((ii<span class="number">-1</span>)/col)), ny*(<span class="built_in">mod</span>(ii<span class="number">-1</span>,col))+<span class="number">1</span>:ny*(<span class="built_in">mod</span>(ii<span class="number">-1</span>,col)+<span class="number">1</span>)) = slicedata&#123;ii&#125;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">    delete(handles.sliceview.d)</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">    [];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">handles.sliceview.d  = image(slicedatafinal,<span class="string">'Tag'</span>,<span class="string">'Transverse'</span>,<span class="string">'Parent'</span>,sliceview.ax);</span><br><span class="line"></span><br><span class="line"><span class="comment">% put slice positions</span></span><br><span class="line"><span class="keyword">for</span> ii=<span class="number">1</span>:<span class="built_in">length</span>(slicedata)</span><br><span class="line">    <span class="comment">%text(nx*(floor((ii-1)/col))+1:nx*(1+floor((ii-1)/col)), ny*(mod(ii-1,col))+1:ny*(mod(ii-1,col)+1), num2str(slices(ii)), 'color', 'w');</span></span><br><span class="line">    text(ny*(<span class="built_in">mod</span>(ii<span class="number">-1</span>,col))+<span class="number">1</span>, nx*(<span class="built_in">floor</span>((ii<span class="number">-1</span>)/col))+<span class="number">1</span>+<span class="number">20</span>, num2str(slices(ii)), <span class="string">'color'</span>, <span class="string">'w'</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">set(sliceview.ax,<span class="string">'XTick'</span>,[],<span class="string">'YTick'</span>,[]);</span><br><span class="line">axis(sliceview.ax, <span class="string">'equal'</span>);</span><br><span class="line">set(sliceview.ax,<span class="string">'color'</span>,<span class="string">'k'</span>);</span><br><span class="line">guidata(hObject, handles);</span><br><span class="line"></span><br><span class="line"><span class="comment">%print(handles.figure,'bbb','-dpng');  % 保存主窗口图像</span></span><br><span class="line">print(slicegraph,save_path,<span class="string">'-dpng'</span>);  <span class="comment">% 保存slice_view图像</span></span><br><span class="line">close(slicegraph);</span><br><span class="line">close(handles.<span class="built_in">figure</span>);</span><br><span class="line">clc;</span><br></pre></td></tr></table></figure><h2 id="获得图像的头信息">获得图像的头信息</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P = &#123;<span class="string">'D:\FMRI_ROOT\YANTAI\ANALYSIS\pre_processing\20160911002\ep2d_bold_moco_p2_rest_0006\af20160911002-182750-00006-00006-1.img'</span>,</span><br><span class="line">    <span class="string">'D:\FMRI_ROOT\YANTAI\ANALYSIS\pre_processing\20160911002\ep2d_bold_moco_p2_rest_0006\af20160911002-182750-00006-00006-1.img'</span>&#125;;</span><br><span class="line">header = spm_vol(P);</span><br></pre></td></tr></table></figure><h2 id="获得图像某个坐标的值">获得图像某个坐标的值</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 获得图像某个坐标的值</span></span><br><span class="line">V = &#123;<span class="string">'D:\FMRI_ROOT\YANTAI\ANALYSIS\first_level\20160911002\beta_0001.img'</span>&#125;;</span><br><span class="line">XYZ = [<span class="number">13</span>;<span class="number">48</span>;<span class="number">2</span>];</span><br><span class="line">Y = spm_get_data(V,XYZ);</span><br></pre></td></tr></table></figure><h2 id="批量做图像的平滑处理">批量做图像的平滑处理</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">smooth</span><span class="params">(filter,pres)</span></span></span><br><span class="line"><span class="comment">% -------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">% 功能： 平滑图像</span></span><br><span class="line"><span class="comment">% 调用：smooth(filter,pres)</span></span><br><span class="line"><span class="comment">% 参数：</span></span><br><span class="line"><span class="comment">%   filter : 控制处理的被试数量，例如'20161001*';</span></span><br><span class="line"><span class="comment">%   pres : 生成的平滑之后的图像的前缀，例如's';</span></span><br><span class="line"><span class="comment">% 示例：</span></span><br><span class="line"><span class="comment">%   filter = '20161003*';</span></span><br><span class="line"><span class="comment">%   pres = 's';</span></span><br><span class="line"><span class="comment">%   smooth(filter,pres);</span></span><br><span class="line"><span class="comment">% 说明：平滑之后的图像与输入图像在同一文件夹，前缀不同</span></span><br><span class="line"><span class="comment">% -------------------------------------------------------------------------</span></span><br><span class="line">clc;</span><br><span class="line">warning(<span class="string">'off'</span>);</span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%需要修改的变量，修改此处可以处理多个被试的数据</span></span><br><span class="line"><span class="comment">%filter = '2016*';</span></span><br><span class="line"><span class="comment">% 输入： wraf*开头的图像文件</span></span><br><span class="line"><span class="comment">% 输出： 平滑之后的文件(与输入文件在同一文件夹中，前缀不一样)</span></span><br><span class="line"><span class="comment">%-------------------------------</span></span><br><span class="line"><span class="comment">% 配置参数：</span></span><br><span class="line"><span class="comment">% filter : 控制处理的被试数量</span></span><br><span class="line"><span class="comment">% pres : 输出图像的前缀</span></span><br><span class="line"><span class="comment">% pre_processing_path ： wraf*开头的图像文件的绝对路径</span></span><br><span class="line"><span class="comment">% run_num ： 每个RUN的文件数量(删除TR之后的数量)</span></span><br><span class="line"><span class="comment">% runExpID : RUN文件夹名称，这里是'ep2d*'</span></span><br><span class="line"><span class="comment">% filenames = dir('wraf*.img'); 输入图像以wraf开头</span></span><br><span class="line"><span class="comment">% matlabbatch&#123;1&#125;.spm.spatial.smooth.fwhm = [4 4 4]; 控制平滑核大小</span></span><br><span class="line"><span class="comment">% matlabbatch&#123;1&#125;.spm.spatial.smooth.prefix = 's4';输出文件的前缀</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%预处理文件夹，整个预处理过程保存在这里</span></span><br><span class="line">pre_processing_path = &#123;<span class="string">'D:\FMRI_ROOT\YANTAI\ANALYSIS\pre_processing\'&#125;;</span></span><br><span class="line"><span class="string">%删除空TR后每个run文件的数量</span></span><br><span class="line"><span class="string">run_num = 272;</span></span><br><span class="line"><span class="string">%开始处理    </span></span><br><span class="line"><span class="string">cd(pre_processing_path&#123;1&#125;);</span></span><br><span class="line"><span class="string">subExpID = dir(filter); %====================================</span></span><br><span class="line"><span class="string">for i=1:size(subExpID,1)</span></span><br><span class="line"><span class="string">    cd([pre_processing_path&#123;1&#125;,subExpID(i).name]);</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">diary smooth_output.txt; % 重定向控制台输出到文件</span></span><br><span class="line"><span class="string">tic;  %开始计时   </span></span><br><span class="line"><span class="string">    %2.获得run的功能像文件</span></span><br><span class="line"><span class="string">    cd([pre_processing_path&#123;1&#125;,subExpID(i).name]);</span></span><br><span class="line"><span class="string">    runExpID=dir('</span>ep2d*<span class="string">');</span></span><br><span class="line"><span class="string">    for j=1:size(runExpID,1)</span></span><br><span class="line"><span class="string">        cd ([pre_processing_path&#123;1&#125;,subExpID(i).name,'</span>\<span class="string">',runExpID(j).name]);</span></span><br><span class="line"><span class="string">        filenames = dir('</span>wraf*.img');</span><br><span class="line">        funcFilenames = cell(run_num,<span class="number">1</span>);<span class="comment">%每个run的文件集合</span></span><br><span class="line">        <span class="keyword">for</span> k=<span class="number">1</span>:<span class="built_in">size</span>(filenames,<span class="number">1</span>)</span><br><span class="line">            funcFilenames&#123;k&#125; = [pre_processing_path&#123;<span class="number">1</span>&#125;,subExpID(<span class="built_in">i</span>).name,<span class="string">'\',runExpID(j).name,'</span>\<span class="string">',filenames(k).name,'</span>,<span class="number">1</span>'];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">         </span><br><span class="line">        funcFilenames = &#123;funcFilenames&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">%%================================batch-begin===================================================%%</span></span><br><span class="line">        spm_jobman(<span class="string">'initcfg'</span>)</span><br><span class="line">        </span><br><span class="line">        matlabbatch&#123;<span class="number">1</span>&#125;.spm.spatial.smooth.data = funcFilenames&#123;<span class="number">1</span>&#125;;</span><br><span class="line">        matlabbatch&#123;<span class="number">1</span>&#125;.spm.spatial.smooth.fwhm = [<span class="number">4</span> <span class="number">4</span> <span class="number">4</span>];</span><br><span class="line">        matlabbatch&#123;<span class="number">1</span>&#125;.spm.spatial.smooth.dtype = <span class="number">0</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">1</span>&#125;.spm.spatial.smooth.im = <span class="number">0</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">1</span>&#125;.spm.spatial.smooth.prefix = pres;</span><br><span class="line">        <span class="comment">%%================================batch-end===================================================%%</span></span><br><span class="line">        spm_jobman(<span class="string">'run'</span>,matlabbatch);</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'smooth successful !'</span>);</span><br><span class="line">        clear matlabbatch</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">toc</span><br><span class="line">diary off ;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="图像计算函数的拓展针对fmri图像">图像计算函数的拓展(针对fMRI图像)</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[Q,Vo]</span> = <span class="title">spm_imcalc_extend</span><span class="params">(P,Q,f,flags,varargin)</span></span></span><br><span class="line"><span class="comment">% Perform algebraic functions on images</span></span><br><span class="line"><span class="comment">% FORMAT Q = spm_imcalc_ui(P,Q,f,flags)</span></span><br><span class="line"><span class="comment">% P             - matrix of input image filenames</span></span><br><span class="line"><span class="comment">%                 [user prompted to select files if arg missing or empty]</span></span><br><span class="line"><span class="comment">% Q             - name of output image</span></span><br><span class="line"><span class="comment">%                 [user prompted to enter filename if arg missing or empty]</span></span><br><span class="line"><span class="comment">% f             - expression to be evaluated</span></span><br><span class="line"><span class="comment">%                 [user prompted to enter expression if arg missing or empty]</span></span><br><span class="line"><span class="comment">% flags         - cell vector of flags: &#123;dmtx,mask,type,hold&#125;</span></span><br><span class="line"><span class="comment">% dmtx          - Read images into data matrix?</span></span><br><span class="line"><span class="comment">%                 [defaults (missing or empty) to 0 - no]</span></span><br><span class="line"><span class="comment">% mask          - implicit zero mask?</span></span><br><span class="line"><span class="comment">%                 [defaults (missing or empty) to 0]</span></span><br><span class="line"><span class="comment">% type          - data type for output image (see spm_type)</span></span><br><span class="line"><span class="comment">%                 [defaults (missing or empty) to 4 - 16 bit signed shorts]</span></span><br><span class="line"><span class="comment">% hold          - interpolation hold (see spm_slice_vol)</span></span><br><span class="line"><span class="comment">%                 [defaults (missing or empty) to 0 - nearest neighbour]</span></span><br><span class="line"><span class="comment">% Q (output)    - full pathname of image written</span></span><br><span class="line"><span class="comment">% Vo            - structure containing information on output image (see spm_vol)</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%_______________________________________________________________________</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% spm_imcalc_ui uses spm_imcalc as an engine to perform user-specified</span></span><br><span class="line"><span class="comment">% algebraic manipulations on a set of images, with the result being</span></span><br><span class="line"><span class="comment">% written out as an image. The user is prompted to supply images to</span></span><br><span class="line"><span class="comment">% work on, a filename for the output image, and the expression to</span></span><br><span class="line"><span class="comment">% evaluate. The expression should be a standard matlab expression,</span></span><br><span class="line"><span class="comment">% within which the images should be referred to as i1, i2, i3,... etc.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% If the dmtx flag is set, then images are read into a data matrix X</span></span><br><span class="line"><span class="comment">% (rather than into seperate variables i1, i2, i3,...). The data matrix</span></span><br><span class="line"><span class="comment">% should be referred to as X, and contains images in rows.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% Computation is plane by plane, so in data-matrix mode, X is a NxK</span></span><br><span class="line"><span class="comment">% matrix, where N is the number of input images [prod(size(Vi))], and K</span></span><br><span class="line"><span class="comment">% is the number of voxels per plane [prod(Vi(1).dim(1:2))].</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% For data types without a representation of NaN, implicit zero masking</span></span><br><span class="line"><span class="comment">% assummes that all zero voxels are to be treated as missing, and</span></span><br><span class="line"><span class="comment">% treats them as NaN. NaN's are written as zero (by spm_write_plane),</span></span><br><span class="line"><span class="comment">% for data types without a representation of NaN.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% With images of different sizes and orientations, the size and</span></span><br><span class="line"><span class="comment">% orientation of the first is used for the output image. A warning is</span></span><br><span class="line"><span class="comment">% given in this situation. Images are sampled into this orientation</span></span><br><span class="line"><span class="comment">% using the interpolation specified by the hold parameter.  [default -</span></span><br><span class="line"><span class="comment">% nearest neighbour]</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% The image Q is written to current working directory unless a valid</span></span><br><span class="line"><span class="comment">% full pathname is given.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% Example expressions (f):</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%        i) Mean of six images (select six images)</span></span><br><span class="line"><span class="comment">%           f = '(i1+i2+i3+i4+i5+i6)/6'</span></span><br><span class="line"><span class="comment">%       ii) Make a binary mask image at threshold of 100</span></span><br><span class="line"><span class="comment">%           f = 'i1&gt;100'</span></span><br><span class="line"><span class="comment">%      iii) Make a mask from one image and apply to another</span></span><br><span class="line"><span class="comment">%           f = 'i2.*(i1&gt;100)'</span></span><br><span class="line"><span class="comment">%                 - here the first image is used to make the mask, which is</span></span><br><span class="line"><span class="comment">%                   applied to the second image</span></span><br><span class="line"><span class="comment">%       iv) Sum of n images</span></span><br><span class="line"><span class="comment">%           f = 'i1 + i2 + i3 + i4 + i5 + ...'</span></span><br><span class="line"><span class="comment">%        v) Sum of n images (when reading data into a data-matrix - use dmtx arg)</span></span><br><span class="line"><span class="comment">%           f = 'sum(X)'</span></span><br><span class="line"><span class="comment">% </span></span><br><span class="line"><span class="comment">% Parameters can be passed as arguments to override internal defaults</span></span><br><span class="line"><span class="comment">% (for hold, mask &amp; type), or to pre-specify images (P), output</span></span><br><span class="line"><span class="comment">% filename (Q), or expression (f). Pass empty matrices for arguments</span></span><br><span class="line"><span class="comment">% not to be set.</span></span><br><span class="line"><span class="comment">% E.g.  Q = spm_imcalc_ui(&#123;&#125;,'test','',&#123;[],[],[],1&#125;)</span></span><br><span class="line"><span class="comment">%       ... pre-specifies the output filename as 'test.img' in the current</span></span><br><span class="line"><span class="comment">% working directory, and sets the interpolation hold to tri-linear.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% Further, if calling spm_imcalc directly, additional variables for use in</span></span><br><span class="line"><span class="comment">% the computation can be passed at the end of the argument list. These</span></span><br><span class="line"><span class="comment">% should be referred to by the names of the arguments passed in the</span></span><br><span class="line"><span class="comment">% expression to be evaluated. E.g. if c is a 1xn vector of weights, then</span></span><br><span class="line"><span class="comment">% for n images, using the (dmtx) data-matrix version, the weighted sum can</span></span><br><span class="line"><span class="comment">% be computed using:</span></span><br><span class="line"><span class="comment">%       Vi= spm_vol(spm_select(inf,'image'));</span></span><br><span class="line"><span class="comment">%       Vo= Vi(1);</span></span><br><span class="line"><span class="comment">%       Vo.fname = 'output.img';</span></span><br><span class="line"><span class="comment">%       Vo.pinfo(1:2) = Inf;</span></span><br><span class="line"><span class="comment">%       Q = spm_imcalc(Vi,Vo,'c*X',&#123;1&#125;,c)</span></span><br><span class="line"><span class="comment">% Here we've pre-specified the expression and passed the vector c as an</span></span><br><span class="line"><span class="comment">% additional variable (you'll be prompted to select the n images).</span></span><br><span class="line"><span class="comment">%__________________________________________________________________________</span></span><br><span class="line"><span class="comment">% Copyright (C) 2008 Wellcome Trust Centre for Neuroimaging</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% John Ashburner &amp; Andrew Holmes</span></span><br><span class="line"><span class="comment">% $Id: spm_imcalc_ui.m 3691 2010-01-20 17:08:30Z guillaume $</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-GUI setup</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">SVNid = <span class="string">'$Rev: 3691 $'</span>;</span><br><span class="line"><span class="comment">%[Finter,Fgraph,CmdLine] = spm('FnUIsetup','ImCalc',0);</span></span><br><span class="line">spm(<span class="string">'FnBanner'</span>,mfilename,SVNid);</span><br><span class="line"><span class="comment">%-Condition arguments</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> nargin&lt;<span class="number">4</span>, flags=&#123;&#125;; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> nargin&lt;<span class="number">3</span>, f=<span class="string">''</span>; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> nargin&lt;<span class="number">2</span>, Q=<span class="string">''</span>; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> nargin&lt;<span class="number">1</span>, P=&#123;&#125;; <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%if isempty(P), P = %spm_select(Inf,'image','Select images to work on'); end</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isempty</span>(P), error(<span class="string">'no input images specified'</span>), <span class="keyword">end</span></span><br><span class="line"><span class="comment">%if isempty(Q), Q = %spm_input('Output filename',1,'s'); end</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isempty</span>(f), f = spm_input(<span class="string">'Evaluated Function'</span>,<span class="number">2</span>,<span class="string">'s'</span>); <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">length</span>(flags)&lt;<span class="number">4</span>, <span class="built_in">hold</span>=[]; <span class="keyword">else</span> <span class="built_in">hold</span>=flags&#123;<span class="number">4</span>&#125;; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isempty</span>(<span class="built_in">hold</span>), <span class="built_in">hold</span>=<span class="number">0</span>; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">length</span>(flags)&lt;<span class="number">3</span>, <span class="built_in">type</span>=[]; <span class="keyword">else</span> <span class="built_in">type</span>=flags&#123;<span class="number">3</span>&#125;; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isempty</span>(<span class="built_in">type</span>), <span class="built_in">type</span>=<span class="number">4</span>; <span class="keyword">end</span>, <span class="keyword">if</span> ischar(<span class="built_in">type</span>), <span class="built_in">type</span>=spm_type(<span class="built_in">type</span>); <span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">length</span>(flags)&lt;<span class="number">2</span>, mask=[]; <span class="keyword">else</span> mask=flags&#123;<span class="number">2</span>&#125;; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isempty</span>(mask), mask=<span class="number">0</span>; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">length</span>(flags)&lt;<span class="number">1</span>, dmtx=[]; <span class="keyword">else</span> dmtx=flags&#123;<span class="number">1</span>&#125;; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isempty</span>(dmtx), dmtx=<span class="number">0</span>; <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%spm('FigName','ImCalc: working',Finter,CmdLine);</span></span><br><span class="line"><span class="comment">%spm('Pointer','Watch')</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Map input files</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">Vi = spm_vol(char(P));</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isempty</span>(Vi), error(<span class="string">'no input images specified'</span>), <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Check for consistency of image dimensions and orientation / voxel size</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">length</span>(Vi)&gt;<span class="number">1</span> &amp;&amp; any(any(diff(<span class="built_in">cat</span>(<span class="number">1</span>,Vi.dim),<span class="number">1</span>,<span class="number">1</span>),<span class="number">1</span>))</span><br><span class="line">    warning([<span class="string">'images don''t all have same dimensions'</span>,...</span><br><span class="line">        <span class="string">' - using those of 1st image'</span>]);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> any(any(any(diff(<span class="built_in">cat</span>(<span class="number">3</span>,Vi.mat),<span class="number">1</span>,<span class="number">3</span>),<span class="number">3</span>)))</span><br><span class="line">    warning([<span class="string">'images don''t all have same orientation &amp; voxel size'</span>,...</span><br><span class="line">        <span class="string">' - using 1st image'</span>]);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-Work out filename for output image</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">[p n e] = spm_fileparts(Q);</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isempty</span>(p), p = pwd; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> ~exist(p,<span class="string">'dir'</span>)</span><br><span class="line">    warning(<span class="string">'Invalid directory: writing to current directory'</span>)</span><br><span class="line">    p = pwd;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Vo = struct(<span class="string">'fname'</span>,   fullfile(p, [n, e]),...</span><br><span class="line">            <span class="string">'dim'</span>,     Vi(<span class="number">1</span>).dim(<span class="number">1</span>:<span class="number">3</span>),...</span><br><span class="line">            <span class="string">'dt'</span>,      [<span class="built_in">type</span> spm_platform(<span class="string">'bigend'</span>)],...</span><br><span class="line">            <span class="string">'mat'</span>,     Vi(<span class="number">1</span>).mat,...</span><br><span class="line">            <span class="string">'descrip'</span>, <span class="string">'spm - algebra'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%-Call spm_imcalc to handle computations</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">args = &#123;dmtx,mask,<span class="built_in">hold</span>&#125;;</span><br><span class="line">Vo   = spm_imcalc(Vi,Vo,f,args);</span><br><span class="line"></span><br><span class="line"><span class="comment">%-End</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">%spm('Pointer');</span></span><br><span class="line"><span class="comment">%spm('FigName','ImCalc: done',Finter,CmdLine);</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 认知神经科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fMRI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多被试多RUN批量预处理(SPM)</title>
      <link href="/hexoblog/2017/03/20/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/%E5%A4%9A%E8%A2%AB%E8%AF%95%E5%A4%9ARUN%E6%89%B9%E9%87%8F%E9%A2%84%E5%A4%84%E7%90%86(SPM)/"/>
      <url>/hexoblog/2017/03/20/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/%E5%A4%9A%E8%A2%AB%E8%AF%95%E5%A4%9ARUN%E6%89%B9%E9%87%8F%E9%A2%84%E5%A4%84%E7%90%86(SPM)/</url>
      
        <content type="html"><![CDATA[<p>使用SPM处理多个被试多个RUN的数据。代码涉及到的文件夹结构如下： <a id="more"></a></p><p>├─20160911002 被试文件夹 │ ├─ep2d_bold_moco_p2_rest_0006 第一个RUN │ ├─ep2d_bold_moco_p2_rest_0011 第二个RUN │ ├─ep2d_bold_moco_p2_rest_0016 第三个RUN │ ├─ep2d_bold_moco_p2_rest_0021 第四个RUN │ └─t1_mprage_sag_p2_0026 被试的结构像 │ ├─run1 │ ├─run2 │ ├─run3 │ └─run4 ├─20160916001 │ ├─ep2d_bold_moco_p2_rest_0006 │ ├─ep2d_bold_moco_p2_rest_0011 │ ├─ep2d_bold_moco_p2_rest_0016 │ ├─ep2d_bold_moco_p2_rest_0021 │ └─t1_mprage_sag_p2_0026 │ ├─run1 │ ├─run2 │ ├─run3 │ └─run4</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pre_processing</span><span class="params">(filter)</span></span></span><br><span class="line"><span class="comment">% -------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">% 功能： 数据预处理，包括 1.slice timing; 2. realign； 3.配准；4.分割；5.标准化；6.平滑</span></span><br><span class="line"><span class="comment">% 调用： pre_processing(filter)</span></span><br><span class="line"><span class="comment">% 参数：</span></span><br><span class="line"><span class="comment">%   filter:控制处理的被试，例如'20161001*'    </span></span><br><span class="line"><span class="comment">% 示例：</span></span><br><span class="line"><span class="comment">%   filter = ‘20161001*’;</span></span><br><span class="line"><span class="comment">%   pre_processing(filter);</span></span><br><span class="line"><span class="comment">% 说明：输入图像需要满足预定的文件夹结构，该结构为使用SPM8 Batch进行格式转换默认生成的结构</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line">clc;</span><br><span class="line">warning(<span class="string">'off'</span>);</span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%需要修改的变量，修改此处可以处理多个被试的数据</span></span><br><span class="line"><span class="comment">%filter = '20161024002*';</span></span><br><span class="line"><span class="comment">% 输入： 经过格式转换之后的img,hdr图像</span></span><br><span class="line"><span class="comment">% 输出： 预处理之后的图像和预处理的结果文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 配置参数：</span></span><br><span class="line"><span class="comment">% filter : 控制处理的被试数量</span></span><br><span class="line"><span class="comment">% img_hdr_path ：img,hdr文件存放的绝对路径</span></span><br><span class="line"><span class="comment">% pre_processing_path ： wraf*开头的图像文件的绝对路径</span></span><br><span class="line"><span class="comment">% delete_filenameID ：预处理开始之前需要删除的TR。</span></span><br><span class="line"><span class="comment">% run_num ： 每个RUN的文件数量(删除TR之后的数量)</span></span><br><span class="line"><span class="comment">% innerMatlab_path ： SPM8工具箱中灰质，白质，脑脊液文件的路径，这个在分割的时候会用到，在不同电脑间移植的时候需要修改。</span></span><br><span class="line"><span class="comment">% runExpID : RUN文件夹名称，这里是'ep2d*'</span></span><br><span class="line"><span class="comment">% filenames = dir('wraf*.img'); 输入图像以wraf开头</span></span><br><span class="line"><span class="comment">% matlabbatch&#123;1&#125;.spm.spatial.smooth.fwhm = [4 4 4]; 控制平滑核大小</span></span><br><span class="line"><span class="comment">% matlabbatch&#123;1&#125;.spm.spatial.smooth.prefix = 's4';输出文件的前缀</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%转换完格式的文件存放的文件夹</span></span><br><span class="line">img_hdr_path = &#123;<span class="string">'D:\FMRI_ROOT\YANTAI\ANALYSIS\img_hdr\'&#125;;</span></span><br><span class="line"><span class="string">%预处理文件夹，整个预处理过程保存在这里</span></span><br><span class="line"><span class="string">pre_processing_path = &#123;'</span>D:\FMRI_ROOT\YANTAI\ANALYSIS\pre_processing\<span class="string">'&#125;;</span></span><br><span class="line"><span class="string">%要删除掉的TR</span></span><br><span class="line"><span class="string">delete_filenameID = &#123;'</span>*<span class="number">-00001</span><span class="number">-00001</span>-*<span class="string">','</span>*<span class="number">-00002</span><span class="number">-00002</span>-*<span class="string">','</span>*<span class="number">-00003</span><span class="number">-00003</span>-*<span class="string">','</span>*<span class="number">-00004</span><span class="number">-00004</span>-*<span class="string">','</span>*<span class="number">-00005</span><span class="number">-00005</span>-*<span class="string">'&#125;;</span></span><br><span class="line"><span class="string">%删除空TR后每个run文件的数量</span></span><br><span class="line"><span class="string">run_num = 272;</span></span><br><span class="line"><span class="string">%内部路径，根据SPM8安装路径修改</span></span><br><span class="line"><span class="string">innerMatlab_path = &#123;</span></span><br><span class="line"><span class="string">                   '</span>C:\mazcx\matlabtoolbox\spm8\tpm\csf.nii,<span class="number">1</span>'</span><br><span class="line">                   <span class="string">'C:\mazcx\matlabtoolbox\spm8\tpm\grey.nii,1'</span></span><br><span class="line">                   <span class="string">'C:\mazcx\matlabtoolbox\spm8\tpm\white.nii,1'</span></span><br><span class="line">                    &#125;;</span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%预处理部分，主要内容：</span></span><br><span class="line"><span class="comment">%1. 将格式转换后的文件复制一份到预处理文件夹</span></span><br><span class="line"><span class="comment">%2. 删除掉多余的TR，只剩下需要的TR</span></span><br><span class="line"><span class="comment">%3. 在结构像文件中新建4个run，把结构像复制到每个run下,配准的时候每个run都是用自己对应run的结构像</span></span><br><span class="line"><span class="comment">%4. 以每个run为单位，运行预处理的batch文件</span></span><br><span class="line"><span class="comment">%5. 控制处理的文件夹主要需要修改的变量：</span></span><br><span class="line"><span class="comment">%  把代码中带=============注释的改成被试文件夹名称</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%将数据拷贝到预处理文件夹</span></span><br><span class="line">cd(img_hdr_path&#123;<span class="number">1</span>&#125;);</span><br><span class="line">copyfile(filter,pre_processing_path&#123;<span class="number">1</span>&#125;); <span class="comment">%====================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%删除多余的TR</span></span><br><span class="line">cd(pre_processing_path&#123;<span class="number">1</span>&#125;);</span><br><span class="line">subExpID=dir (filter);     <span class="comment">%被试文件夹==================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">size</span>(subExpID,<span class="number">1</span>)</span><br><span class="line">     cd ([pre_processing_path&#123;<span class="number">1</span>&#125;,subExpID(<span class="built_in">i</span>).name]);</span><br><span class="line">     runExpID = dir(<span class="string">'ep2d*'</span>); <span class="comment">%run 文件夹++++++++++++++++++++++++</span></span><br><span class="line">     <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:<span class="built_in">size</span>(runExpID,<span class="number">1</span>)</span><br><span class="line">         cd ([pre_processing_path&#123;<span class="number">1</span>&#125;,subExpID(<span class="built_in">i</span>).name,<span class="string">'\',runExpID(j).name]);</span></span><br><span class="line"><span class="string">         for k = 1:size(delete_filenameID,2)</span></span><br><span class="line"><span class="string">             delete(cell2mat(delete_filenameID(k)));</span></span><br><span class="line"><span class="string">         end</span></span><br><span class="line"><span class="string">     end</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">%复制4个run的结构像</span></span><br><span class="line"><span class="string">cd(pre_processing_path&#123;1&#125;);</span></span><br><span class="line"><span class="string">subExpID = dir(filter);   %=========================</span></span><br><span class="line"><span class="string">for i=1:size(subExpID,1)</span></span><br><span class="line"><span class="string">    cd([pre_processing_path&#123;1&#125;,subExpID(i).name]);</span></span><br><span class="line"><span class="string">    t1ExpID = dir('</span>t1*<span class="string">');</span></span><br><span class="line"><span class="string">    cd(t1ExpID.name);</span></span><br><span class="line"><span class="string">    mkdir('</span>run1');</span><br><span class="line">    copyfile(<span class="string">'s*'</span>,[pre_processing_path&#123;<span class="number">1</span>&#125;,subExpID(<span class="built_in">i</span>).name,<span class="string">'\',t1ExpID.name,'</span>\run1\<span class="string">']);</span></span><br><span class="line"><span class="string">    mkdir('</span>run2');</span><br><span class="line">    copyfile(<span class="string">'s*'</span>,[pre_processing_path&#123;<span class="number">1</span>&#125;,subExpID(<span class="built_in">i</span>).name,<span class="string">'\',t1ExpID.name,'</span>\run2\<span class="string">']);</span></span><br><span class="line"><span class="string">    mkdir('</span>run3');</span><br><span class="line">    copyfile(<span class="string">'s*'</span>,[pre_processing_path&#123;<span class="number">1</span>&#125;,subExpID(<span class="built_in">i</span>).name,<span class="string">'\',t1ExpID.name,'</span>\run3\<span class="string">']);</span></span><br><span class="line"><span class="string">    mkdir('</span>run4');</span><br><span class="line">    copyfile(<span class="string">'s*'</span>,[pre_processing_path&#123;<span class="number">1</span>&#125;,subExpID(<span class="built_in">i</span>).name,<span class="string">'\',t1ExpID.name,'</span>\run4\<span class="string">']);</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">%开始预处理    </span></span><br><span class="line"><span class="string">cd(pre_processing_path&#123;1&#125;);</span></span><br><span class="line"><span class="string">subExpID = dir(filter); %====================================</span></span><br><span class="line"><span class="string">for i=1:size(subExpID,1)</span></span><br><span class="line"><span class="string">    cd([pre_processing_path&#123;1&#125;,subExpID(i).name]);</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">diary pre_processing_output.txt; % 重定向控制台输出到文件</span></span><br><span class="line"><span class="string">tic;  %开始计时   </span></span><br><span class="line"><span class="string">    %1. 获得4个结构像文件</span></span><br><span class="line"><span class="string">    t1ExpID = dir('</span>t1*<span class="string">');</span></span><br><span class="line"><span class="string">    cd([pre_processing_path&#123;1&#125;,subExpID(i).name,'</span>\<span class="string">',t1ExpID(1).name]);%切换到t1像</span></span><br><span class="line"><span class="string">    runID = dir('</span>run*<span class="string">');</span></span><br><span class="line"><span class="string">    data3D_filenames=cell(4,1);%4个run的结构像文件</span></span><br><span class="line"><span class="string">    for j=1:size(runID,1)</span></span><br><span class="line"><span class="string">        cd([pre_processing_path&#123;1&#125;,subExpID(i).name,'</span>\<span class="string">',t1ExpID(1).name,'</span>\<span class="string">',runID(j).name])</span></span><br><span class="line"><span class="string">        filenames = dir('</span>s*.img');</span><br><span class="line">        data3D_filenames&#123;<span class="built_in">j</span>&#125; = [pre_processing_path&#123;<span class="number">1</span>&#125;,subExpID(<span class="built_in">i</span>).name,<span class="string">'\',t1ExpID(1).name,'</span>\<span class="string">',runID(j).name,'</span>\<span class="string">',filenames(1).name,'</span>,<span class="number">1</span>'];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">%2.获得run的功能像文件</span></span><br><span class="line">    cd([pre_processing_path&#123;<span class="number">1</span>&#125;,subExpID(<span class="built_in">i</span>).name]);</span><br><span class="line">    runExpID=dir(<span class="string">'ep2d*'</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:<span class="built_in">size</span>(runExpID,<span class="number">1</span>)</span><br><span class="line">        cd ([pre_processing_path&#123;<span class="number">1</span>&#125;,subExpID(<span class="built_in">i</span>).name,<span class="string">'\',runExpID(j).name]);</span></span><br><span class="line"><span class="string">        filenames = dir('</span>f*.img');</span><br><span class="line">        funcFilenames = cell(run_num,<span class="number">1</span>);<span class="comment">%每个run的文件集合</span></span><br><span class="line">        <span class="keyword">for</span> k=<span class="number">1</span>:<span class="built_in">size</span>(filenames,<span class="number">1</span>)</span><br><span class="line">            funcFilenames&#123;k&#125; = [pre_processing_path&#123;<span class="number">1</span>&#125;,subExpID(<span class="built_in">i</span>).name,<span class="string">'\',runExpID(j).name,'</span>\<span class="string">',filenames(k).name,'</span>,<span class="number">1</span>'];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">         </span><br><span class="line">        funcFilenames = &#123;funcFilenames&#125;;</span><br><span class="line">        data3D_filename = &#123; data3D_filenames&#123;<span class="built_in">j</span>&#125; &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">%%================================batch-begin===================================================%%</span></span><br><span class="line">        spm_jobman(<span class="string">'initcfg'</span>)</span><br><span class="line">        matlabbatch&#123;<span class="number">1</span>&#125;.spm.temporal.st.scans = funcFilenames;</span><br><span class="line">        matlabbatch&#123;<span class="number">1</span>&#125;.spm.temporal.st.nslices = <span class="number">33</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">1</span>&#125;.spm.temporal.st.tr = <span class="number">2</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">1</span>&#125;.spm.temporal.st.ta = <span class="number">1.93939393939394</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">1</span>&#125;.spm.temporal.st.so = [<span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">9</span> <span class="number">11</span> <span class="number">13</span> <span class="number">15</span> <span class="number">17</span> <span class="number">19</span> <span class="number">21</span> <span class="number">23</span> <span class="number">25</span> <span class="number">27</span> <span class="number">29</span> <span class="number">31</span> <span class="number">33</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">10</span> <span class="number">12</span> <span class="number">14</span> <span class="number">16</span> <span class="number">18</span> <span class="number">20</span> <span class="number">22</span> <span class="number">24</span> <span class="number">26</span> <span class="number">28</span> <span class="number">30</span> <span class="number">32</span>];</span><br><span class="line">        matlabbatch&#123;<span class="number">1</span>&#125;.spm.temporal.st.refslice = <span class="number">33</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">1</span>&#125;.spm.temporal.st.prefix = <span class="string">'a'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">2</span>&#125;.spm.spatial.realign.estwrite.data&#123;<span class="number">1</span>&#125;(<span class="number">1</span>) = cfg_dep;</span><br><span class="line">        matlabbatch&#123;<span class="number">2</span>&#125;.spm.spatial.realign.estwrite.data&#123;<span class="number">1</span>&#125;(<span class="number">1</span>).tname = <span class="string">'Session'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">2</span>&#125;.spm.spatial.realign.estwrite.data&#123;<span class="number">1</span>&#125;(<span class="number">1</span>).tgt_spec&#123;<span class="number">1</span>&#125;(<span class="number">1</span>).name = <span class="string">'filter'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">2</span>&#125;.spm.spatial.realign.estwrite.data&#123;<span class="number">1</span>&#125;(<span class="number">1</span>).tgt_spec&#123;<span class="number">1</span>&#125;(<span class="number">1</span>).value = <span class="string">'image'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">2</span>&#125;.spm.spatial.realign.estwrite.data&#123;<span class="number">1</span>&#125;(<span class="number">1</span>).tgt_spec&#123;<span class="number">1</span>&#125;(<span class="number">2</span>).name = <span class="string">'strtype'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">2</span>&#125;.spm.spatial.realign.estwrite.data&#123;<span class="number">1</span>&#125;(<span class="number">1</span>).tgt_spec&#123;<span class="number">1</span>&#125;(<span class="number">2</span>).value = <span class="string">'e'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">2</span>&#125;.spm.spatial.realign.estwrite.data&#123;<span class="number">1</span>&#125;(<span class="number">1</span>).sname = <span class="string">'Slice Timing: Slice Timing Corr. Images (Sess 1)'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">2</span>&#125;.spm.spatial.realign.estwrite.data&#123;<span class="number">1</span>&#125;(<span class="number">1</span>).src_exbranch = substruct(<span class="string">'.'</span>,<span class="string">'val'</span>, <span class="string">'&#123;&#125;'</span>,&#123;<span class="number">1</span>&#125;, <span class="string">'.'</span>,<span class="string">'val'</span>, <span class="string">'&#123;&#125;'</span>,&#123;<span class="number">1</span>&#125;, <span class="string">'.'</span>,<span class="string">'val'</span>, <span class="string">'&#123;&#125;'</span>,&#123;<span class="number">1</span>&#125;);</span><br><span class="line">        matlabbatch&#123;<span class="number">2</span>&#125;.spm.spatial.realign.estwrite.data&#123;<span class="number">1</span>&#125;(<span class="number">1</span>).src_output = substruct(<span class="string">'()'</span>,&#123;<span class="number">1</span>&#125;, <span class="string">'.'</span>,<span class="string">'files'</span>);</span><br><span class="line">        matlabbatch&#123;<span class="number">2</span>&#125;.spm.spatial.realign.estwrite.eoptions.quality = <span class="number">0.9</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">2</span>&#125;.spm.spatial.realign.estwrite.eoptions.sep = <span class="number">4</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">2</span>&#125;.spm.spatial.realign.estwrite.eoptions.fwhm = <span class="number">5</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">2</span>&#125;.spm.spatial.realign.estwrite.eoptions.rtm = <span class="number">1</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">2</span>&#125;.spm.spatial.realign.estwrite.eoptions.interp = <span class="number">2</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">2</span>&#125;.spm.spatial.realign.estwrite.eoptions.wrap = [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>];</span><br><span class="line">        matlabbatch&#123;<span class="number">2</span>&#125;.spm.spatial.realign.estwrite.eoptions.weight = <span class="string">''</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">2</span>&#125;.spm.spatial.realign.estwrite.roptions.which = [<span class="number">2</span> <span class="number">1</span>];</span><br><span class="line">        matlabbatch&#123;<span class="number">2</span>&#125;.spm.spatial.realign.estwrite.roptions.interp = <span class="number">4</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">2</span>&#125;.spm.spatial.realign.estwrite.roptions.wrap = [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>];</span><br><span class="line">        matlabbatch&#123;<span class="number">2</span>&#125;.spm.spatial.realign.estwrite.roptions.mask = <span class="number">1</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">2</span>&#125;.spm.spatial.realign.estwrite.roptions.prefix = <span class="string">'r'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">3</span>&#125;.spm.spatial.coreg.estimate.ref(<span class="number">1</span>) = cfg_dep;</span><br><span class="line">        matlabbatch&#123;<span class="number">3</span>&#125;.spm.spatial.coreg.estimate.ref(<span class="number">1</span>).tname = <span class="string">'Reference Image'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">3</span>&#125;.spm.spatial.coreg.estimate.ref(<span class="number">1</span>).tgt_spec&#123;<span class="number">1</span>&#125;(<span class="number">1</span>).name = <span class="string">'filter'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">3</span>&#125;.spm.spatial.coreg.estimate.ref(<span class="number">1</span>).tgt_spec&#123;<span class="number">1</span>&#125;(<span class="number">1</span>).value = <span class="string">'image'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">3</span>&#125;.spm.spatial.coreg.estimate.ref(<span class="number">1</span>).tgt_spec&#123;<span class="number">1</span>&#125;(<span class="number">2</span>).name = <span class="string">'strtype'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">3</span>&#125;.spm.spatial.coreg.estimate.ref(<span class="number">1</span>).tgt_spec&#123;<span class="number">1</span>&#125;(<span class="number">2</span>).value = <span class="string">'e'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">3</span>&#125;.spm.spatial.coreg.estimate.ref(<span class="number">1</span>).sname = <span class="string">'Realign: Estimate &amp; Reslice: Mean Image'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">3</span>&#125;.spm.spatial.coreg.estimate.ref(<span class="number">1</span>).src_exbranch = substruct(<span class="string">'.'</span>,<span class="string">'val'</span>, <span class="string">'&#123;&#125;'</span>,&#123;<span class="number">2</span>&#125;, <span class="string">'.'</span>,<span class="string">'val'</span>, <span class="string">'&#123;&#125;'</span>,&#123;<span class="number">1</span>&#125;, <span class="string">'.'</span>,<span class="string">'val'</span>, <span class="string">'&#123;&#125;'</span>,&#123;<span class="number">1</span>&#125;, <span class="string">'.'</span>,<span class="string">'val'</span>, <span class="string">'&#123;&#125;'</span>,&#123;<span class="number">1</span>&#125;);</span><br><span class="line">        matlabbatch&#123;<span class="number">3</span>&#125;.spm.spatial.coreg.estimate.ref(<span class="number">1</span>).src_output = substruct(<span class="string">'.'</span>,<span class="string">'rmean'</span>);</span><br><span class="line">        matlabbatch&#123;<span class="number">3</span>&#125;.spm.spatial.coreg.estimate.source = data3D_filename; <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line">        matlabbatch&#123;<span class="number">3</span>&#125;.spm.spatial.coreg.estimate.other = &#123;<span class="string">''</span>&#125;;</span><br><span class="line">        matlabbatch&#123;<span class="number">3</span>&#125;.spm.spatial.coreg.estimate.eoptions.cost_fun = <span class="string">'nmi'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">3</span>&#125;.spm.spatial.coreg.estimate.eoptions.sep = [<span class="number">4</span> <span class="number">2</span>];</span><br><span class="line">        matlabbatch&#123;<span class="number">3</span>&#125;.spm.spatial.coreg.estimate.eoptions.tol = [<span class="number">0.02</span> <span class="number">0.02</span> <span class="number">0.02</span> <span class="number">0.001</span> <span class="number">0.001</span> <span class="number">0.001</span> <span class="number">0.01</span> <span class="number">0.01</span> <span class="number">0.01</span> <span class="number">0.001</span> <span class="number">0.001</span> <span class="number">0.001</span>];</span><br><span class="line">        matlabbatch&#123;<span class="number">3</span>&#125;.spm.spatial.coreg.estimate.eoptions.fwhm = [<span class="number">7</span> <span class="number">7</span>];</span><br><span class="line">        matlabbatch&#123;<span class="number">4</span>&#125;.spm.spatial.preproc.data = data3D_filename ; <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line">        matlabbatch&#123;<span class="number">4</span>&#125;.spm.spatial.preproc.output.GM = [<span class="number">0</span> <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line">        matlabbatch&#123;<span class="number">4</span>&#125;.spm.spatial.preproc.output.WM = [<span class="number">0</span> <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line">        matlabbatch&#123;<span class="number">4</span>&#125;.spm.spatial.preproc.output.CSF = [<span class="number">0</span> <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line">        matlabbatch&#123;<span class="number">4</span>&#125;.spm.spatial.preproc.output.biascor = <span class="number">1</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">4</span>&#125;.spm.spatial.preproc.output.cleanup = <span class="number">1</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">4</span>&#125;.spm.spatial.preproc.opts.tpm = innerMatlab_path; <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line">        matlabbatch&#123;<span class="number">4</span>&#125;.spm.spatial.preproc.opts.ngaus = [<span class="number">2</span></span><br><span class="line">                                                         <span class="number">2</span></span><br><span class="line">                                                         <span class="number">2</span></span><br><span class="line">                                                         <span class="number">4</span>];</span><br><span class="line">        matlabbatch&#123;<span class="number">4</span>&#125;.spm.spatial.preproc.opts.regtype = <span class="string">'mni'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">4</span>&#125;.spm.spatial.preproc.opts.warpreg = <span class="number">1</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">4</span>&#125;.spm.spatial.preproc.opts.warpco = <span class="number">25</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">4</span>&#125;.spm.spatial.preproc.opts.biasreg = <span class="number">0.0001</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">4</span>&#125;.spm.spatial.preproc.opts.biasfwhm = <span class="number">60</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">4</span>&#125;.spm.spatial.preproc.opts.samp = <span class="number">3</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">4</span>&#125;.spm.spatial.preproc.opts.msk = &#123;<span class="string">''</span>&#125;;</span><br><span class="line">        matlabbatch&#123;<span class="number">5</span>&#125;.spm.spatial.normalise.write.subj.matname(<span class="number">1</span>) = cfg_dep;</span><br><span class="line">        matlabbatch&#123;<span class="number">5</span>&#125;.spm.spatial.normalise.write.subj.matname(<span class="number">1</span>).tname = <span class="string">'Parameter File'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">5</span>&#125;.spm.spatial.normalise.write.subj.matname(<span class="number">1</span>).tgt_spec&#123;<span class="number">1</span>&#125;(<span class="number">1</span>).name = <span class="string">'filter'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">5</span>&#125;.spm.spatial.normalise.write.subj.matname(<span class="number">1</span>).tgt_spec&#123;<span class="number">1</span>&#125;(<span class="number">1</span>).value = <span class="string">'mat'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">5</span>&#125;.spm.spatial.normalise.write.subj.matname(<span class="number">1</span>).tgt_spec&#123;<span class="number">1</span>&#125;(<span class="number">2</span>).name = <span class="string">'strtype'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">5</span>&#125;.spm.spatial.normalise.write.subj.matname(<span class="number">1</span>).tgt_spec&#123;<span class="number">1</span>&#125;(<span class="number">2</span>).value = <span class="string">'e'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">5</span>&#125;.spm.spatial.normalise.write.subj.matname(<span class="number">1</span>).sname = <span class="string">'Segment: Norm Params Subj-&gt;MNI'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">5</span>&#125;.spm.spatial.normalise.write.subj.matname(<span class="number">1</span>).src_exbranch = substruct(<span class="string">'.'</span>,<span class="string">'val'</span>, <span class="string">'&#123;&#125;'</span>,&#123;<span class="number">4</span>&#125;, <span class="string">'.'</span>,<span class="string">'val'</span>, <span class="string">'&#123;&#125;'</span>,&#123;<span class="number">1</span>&#125;, <span class="string">'.'</span>,<span class="string">'val'</span>, <span class="string">'&#123;&#125;'</span>,&#123;<span class="number">1</span>&#125;);</span><br><span class="line">        matlabbatch&#123;<span class="number">5</span>&#125;.spm.spatial.normalise.write.subj.matname(<span class="number">1</span>).src_output = substruct(<span class="string">'()'</span>,&#123;<span class="number">1</span>&#125;, <span class="string">'.'</span>,<span class="string">'snfile'</span>, <span class="string">'()'</span>,&#123;<span class="string">':'</span>&#125;);</span><br><span class="line">        matlabbatch&#123;<span class="number">5</span>&#125;.spm.spatial.normalise.write.subj.resample(<span class="number">1</span>) = cfg_dep;</span><br><span class="line">        matlabbatch&#123;<span class="number">5</span>&#125;.spm.spatial.normalise.write.subj.resample(<span class="number">1</span>).tname = <span class="string">'Images to Write'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">5</span>&#125;.spm.spatial.normalise.write.subj.resample(<span class="number">1</span>).tgt_spec&#123;<span class="number">1</span>&#125;(<span class="number">1</span>).name = <span class="string">'filter'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">5</span>&#125;.spm.spatial.normalise.write.subj.resample(<span class="number">1</span>).tgt_spec&#123;<span class="number">1</span>&#125;(<span class="number">1</span>).value = <span class="string">'image'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">5</span>&#125;.spm.spatial.normalise.write.subj.resample(<span class="number">1</span>).tgt_spec&#123;<span class="number">1</span>&#125;(<span class="number">2</span>).name = <span class="string">'strtype'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">5</span>&#125;.spm.spatial.normalise.write.subj.resample(<span class="number">1</span>).tgt_spec&#123;<span class="number">1</span>&#125;(<span class="number">2</span>).value = <span class="string">'e'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">5</span>&#125;.spm.spatial.normalise.write.subj.resample(<span class="number">1</span>).sname = <span class="string">'Realign: Estimate &amp; Reslice: Resliced Images (Sess 1)'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">5</span>&#125;.spm.spatial.normalise.write.subj.resample(<span class="number">1</span>).src_exbranch = substruct(<span class="string">'.'</span>,<span class="string">'val'</span>, <span class="string">'&#123;&#125;'</span>,&#123;<span class="number">2</span>&#125;, <span class="string">'.'</span>,<span class="string">'val'</span>, <span class="string">'&#123;&#125;'</span>,&#123;<span class="number">1</span>&#125;, <span class="string">'.'</span>,<span class="string">'val'</span>, <span class="string">'&#123;&#125;'</span>,&#123;<span class="number">1</span>&#125;, <span class="string">'.'</span>,<span class="string">'val'</span>, <span class="string">'&#123;&#125;'</span>,&#123;<span class="number">1</span>&#125;);</span><br><span class="line">        matlabbatch&#123;<span class="number">5</span>&#125;.spm.spatial.normalise.write.subj.resample(<span class="number">1</span>).src_output = substruct(<span class="string">'.'</span>,<span class="string">'sess'</span>, <span class="string">'()'</span>,&#123;<span class="number">1</span>&#125;, <span class="string">'.'</span>,<span class="string">'rfiles'</span>);</span><br><span class="line">        matlabbatch&#123;<span class="number">5</span>&#125;.spm.spatial.normalise.write.roptions.preserve = <span class="number">0</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">5</span>&#125;.spm.spatial.normalise.write.roptions.bb = [<span class="number">-90</span> <span class="number">-126</span> <span class="number">-72</span></span><br><span class="line">                                                                  <span class="number">90</span> <span class="number">90</span> <span class="number">108</span>];</span><br><span class="line">        matlabbatch&#123;<span class="number">5</span>&#125;.spm.spatial.normalise.write.roptions.vox = [<span class="number">3</span> <span class="number">3</span> <span class="number">3</span>];</span><br><span class="line">        matlabbatch&#123;<span class="number">5</span>&#125;.spm.spatial.normalise.write.roptions.interp = <span class="number">1</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">5</span>&#125;.spm.spatial.normalise.write.roptions.wrap = [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>];</span><br><span class="line">        matlabbatch&#123;<span class="number">5</span>&#125;.spm.spatial.normalise.write.roptions.prefix = <span class="string">'w'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">6</span>&#125;.spm.spatial.smooth.data(<span class="number">1</span>) = cfg_dep;</span><br><span class="line">        matlabbatch&#123;<span class="number">6</span>&#125;.spm.spatial.smooth.data(<span class="number">1</span>).tname = <span class="string">'Images to Smooth'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">6</span>&#125;.spm.spatial.smooth.data(<span class="number">1</span>).tgt_spec&#123;<span class="number">1</span>&#125;(<span class="number">1</span>).name = <span class="string">'filter'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">6</span>&#125;.spm.spatial.smooth.data(<span class="number">1</span>).tgt_spec&#123;<span class="number">1</span>&#125;(<span class="number">1</span>).value = <span class="string">'image'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">6</span>&#125;.spm.spatial.smooth.data(<span class="number">1</span>).tgt_spec&#123;<span class="number">1</span>&#125;(<span class="number">2</span>).name = <span class="string">'strtype'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">6</span>&#125;.spm.spatial.smooth.data(<span class="number">1</span>).tgt_spec&#123;<span class="number">1</span>&#125;(<span class="number">2</span>).value = <span class="string">'e'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">6</span>&#125;.spm.spatial.smooth.data(<span class="number">1</span>).sname = <span class="string">'Normalise: Write: Normalised Images (Subj 1)'</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">6</span>&#125;.spm.spatial.smooth.data(<span class="number">1</span>).src_exbranch = substruct(<span class="string">'.'</span>,<span class="string">'val'</span>, <span class="string">'&#123;&#125;'</span>,&#123;<span class="number">5</span>&#125;, <span class="string">'.'</span>,<span class="string">'val'</span>, <span class="string">'&#123;&#125;'</span>,&#123;<span class="number">1</span>&#125;, <span class="string">'.'</span>,<span class="string">'val'</span>, <span class="string">'&#123;&#125;'</span>,&#123;<span class="number">1</span>&#125;, <span class="string">'.'</span>,<span class="string">'val'</span>, <span class="string">'&#123;&#125;'</span>,&#123;<span class="number">1</span>&#125;);</span><br><span class="line">        matlabbatch&#123;<span class="number">6</span>&#125;.spm.spatial.smooth.data(<span class="number">1</span>).src_output = substruct(<span class="string">'()'</span>,&#123;<span class="number">1</span>&#125;, <span class="string">'.'</span>,<span class="string">'files'</span>);</span><br><span class="line">        matlabbatch&#123;<span class="number">6</span>&#125;.spm.spatial.smooth.fwhm = [<span class="number">6</span> <span class="number">6</span> <span class="number">6</span>];</span><br><span class="line">        matlabbatch&#123;<span class="number">6</span>&#125;.spm.spatial.smooth.dtype = <span class="number">0</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">6</span>&#125;.spm.spatial.smooth.im = <span class="number">0</span>;</span><br><span class="line">        matlabbatch&#123;<span class="number">6</span>&#125;.spm.spatial.smooth.prefix = <span class="string">'s'</span>;</span><br><span class="line">        <span class="comment">%%================================batch-end===================================================%%</span></span><br><span class="line">        spm_jobman(<span class="string">'run'</span>,matlabbatch);</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'pre_processing successful !'</span>);</span><br><span class="line">        clear matlabbatch</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">toc</span><br><span class="line">diary off ;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 认知神经科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fMIRI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认知神经科学系列目录</title>
      <link href="/hexoblog/2017/03/09/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6%E7%B3%BB%E5%88%97%E7%9B%AE%E5%BD%95/"/>
      <url>/hexoblog/2017/03/09/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6%E7%B3%BB%E5%88%97%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>the outline of a series of article about neuroscience. <a id="more"></a> ## start ### 神经科学的常用探测方法 1.主要介绍目前比较有效的几种设备。</p><h3 id="数据格式和常用软件">数据格式和常用软件</h3><ol style="list-style-type: decimal"><li>介绍常用的数据格式和常用的数据处理软件</li></ol><h3 id="功能磁共振成像原理">功能磁共振成像原理</h3><h3 id="fmri数据预处理和统计分析">FMRI数据预处理和统计分析</h3><h3 id="常用的分析数据的方法">常用的分析数据的方法</h3><ol style="list-style-type: decimal"><li>MVPA</li><li>功能连接</li><li>有效连接</li><li>signal change</li><li>RSA</li></ol><h3 id="常用的看图工具和画图工具">常用的看图工具和画图工具</h3>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 认知神经科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> neuroscience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于连接信息的脑信息解码研究</title>
      <link href="/hexoblog/2017/03/09/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/%E5%9F%BA%E4%BA%8E%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%84%91%E4%BF%A1%E6%81%AF%E8%A7%A3%E7%A0%81%E7%A0%94%E7%A9%B6/"/>
      <url>/hexoblog/2017/03/09/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/%E5%9F%BA%E4%BA%8E%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%84%91%E4%BF%A1%E6%81%AF%E8%A7%A3%E7%A0%81%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<p>基于连接信息的脑信息解码研究 <a id="more"></a> aaa</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 认知神经科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 解码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于贝叶斯网络和隐性知识的AU识别研究</title>
      <link href="/hexoblog/2017/03/08/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/%E5%9F%BA%E4%BA%8E%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BD%91%E7%BB%9C%E5%92%8C%E9%9A%90%E6%80%A7%E7%9F%A5%E8%AF%86%E7%9A%84AU%E8%AF%86%E5%88%AB%E7%A0%94%E7%A9%B6/"/>
      <url>/hexoblog/2017/03/08/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/%E5%9F%BA%E4%BA%8E%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BD%91%E7%BB%9C%E5%92%8C%E9%9A%90%E6%80%A7%E7%9F%A5%E8%AF%86%E7%9A%84AU%E8%AF%86%E5%88%AB%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<p>贝叶斯网络 人脸检测 AU识别 <a id="more"></a></p><h2 id="au">AU</h2><p>AU是一种描述面部运动状态的机制，是Ekman和Friesen[1]首先提出来的。他们在实验中观察人类面部表情的产生和面部肌肉运动的关系，发现肌肉的运动是产生各种不同表情的关键因素。于是，Ekman和Friesen将不同的肌肉运动状态记作不同的AU，然后通过AU或者AU组合分解表情。 FACS是由美国心理学家Ekman和Friesen在研究了脸部肌肉运动和人类面部表情控制之间的关系后所提出来的。Ekman和Friesen通过研究比较人类的各种表情动作，发现几乎所有的表情都与面部肌肉的收缩运动有关系。根据这一特点, 二人将人脸划分成大约46个AU,每个AU表示一个独立的面部肌肉运动状态。 2002年，Ekman等人又给出了FACS的一个新版本FACS+。FACS+共包含55个AU。其中41个描述表情变化的肌肉运动，剩余的14个描述头部和眼睛的运动。新的FACS对AU的描述更加符合人类视觉对面部动作的感知规则，是目前已知的最好的描述面部运动的编码系统。 <img src="2017-03-08_192703.png" alt="au_up"> <img src="2017-03-08_192709.png" alt="au_bottome"> <img src="2017-03-08_192713.png" alt="au_combine"></p><p>AU识别的主要步骤： <img src="2017-03-08_192952.png" alt="AU_process"></p><h2 id="人脸检测">人脸检测</h2><p>人脸检测就是要在给定的图像中检测到人脸所在的区域，并将该区域提取出来，处理成统一的格式的过程。人脸检测技术是进行许多人工智能问题研究的前提条件和关键环节，一个完善的人脸检测系统要求能够适应各种复杂条件下的图像，能够处理遮挡，角度，清晰度变化等带来的影响。 基于统计的方法是目前应用较多，发展迅速的一类方法。LDA，PCA，ICA，SVM等都是基于统计的方法。基于统计的方法的优点是对各种条件的变化有比较高的鲁棒性，但是这些算法通常比较复杂。 ## 特征提取 肌肉运动可以从不同的角度表示，这就产生了不同的特征提取方法。一种角度是从静态来看，肌肉的某种运动状态必然对应一种特征。另外一种是从动态来看，肌肉的运动方向和位置也能标识出AU ### 基于几何特征的方法 基于几何特征的特征提取方法主要包含2个关键问题：一是如何选择特征点以及提取什么样的特征，二是如何准确有效的定位跟踪特征点。 一般情况下，特征点应该选择有明显形变或与其他部位易于区分的部位，如嘴巴、眉毛、眼睛、鼻子的边缘点。实验表明，这些关键点信息含量高，易于提取，受光照、头部运动等影响较小，能够取得较好的识别效果。 特征点的精确定位和动态跟踪十分重要，对后续的识别影响很大。现有的定位方法主要有基于先验规则的方法，Snake，ASM，AAM等。 AAM改进了ASM算法，加入的纹理特征。AAM是包含了图像的形状信息和纹理信息的统计模型，具有强大的建模能力，近年来被广泛应用于图像分析。 后来，许多专家学者改进了AAM算法，使它的应用范围更加广泛。例如，Gallou和Guier使用像素的角度信息替代原本的灰度信息，得到对光照和姿态变化有很好鲁棒性的新算法</p><h3 id="基于外貌特征的方法">基于外貌特征的方法</h3><p>基于外貌特征的提取算法通过获取像素之间的梯度、纹理和相关性等信息作为AU识别的依据。常用的基于外貌特征的方法有很多，KPCA、PCA、ICA、LFA、FLD、LBP、Harr、Garor等都是基于外貌特征的特征提取算法。该类算法通常受光照、肤色、图像质量的影响较大，首先需要进行灰度归一化等处理。归一化处理主要的目的是消除这些变化对算法的影响。 Bazzo提出一种在差分图像上提取Garbor特征的新算法，实现了对不同种族，包含微小头部运动的人脸图像的较高的AU识别率</p><h3 id="基于混合特征的方法">基于混合特征的方法</h3><p>不同的特征提取方法都有各自的优势和劣势，所以很自然的研究人员就想到将不同的特征提取算法结合起来，发挥优势，减少劣势，于是出现了各种各样的混合特征的提取算法。 外貌特征反映人脸像素信息，信息详细丰富，但是受姿态、光照、遮挡等影响较大；几何特征反映人脸形变信息，信息量较小，但不容易受影响。将二者结合，也能提高识别效果。在混合使用特征方面。</p><h2 id="主动外观模型">主动外观模型</h2><h2 id="am_tools-工具箱">am_tools 工具箱</h2><p>Am_tools是由Tim Cootes开发的特征提取工具箱[57]。它实现了常用的特征提取算法，并提供命令行工具和API供其他研究者使用。利用该工具箱可以方便的实现建立表观模型(am_build_apm)，建立主动外观模型（am_build_aam）,产生和编辑三角剖分（am_tri_editor）,利用模型产生图像(am_make_image)。am_tools实现了所有AAM算法中用到的算法，并提供了友好的交互方式控制各个参数，分析比较实验结果 Am_tools工具包含四个主要的文件夹，images,points,models,win_bin.其中image是存放图像数据的，points是存放图像上的特征点的数据的，models存放的描述模型的数据文件，以上这三个文件夹构成AAM算法的实验材料。Win_bin里面存放的是各种算法工具，这些算法都是编辑好并经过优化的。下面几张图列举了使用am_tools观察的几个算法处理过程。 <img src="2017-03-08_194255.png" alt="aa"></p><h2 id="贝叶斯网络">贝叶斯网络</h2><p>贝叶斯网是一种基于概率论的图结构。概率的贝叶斯解释认为概率是事件发生的合理信度，可以根据相关的经验给出一个事件的先验概率，这样就可以将已有的经验带入推理当中，提高推理的准确性。</p><h2 id="贝叶斯推理">贝叶斯推理</h2><p>联合概率的推理问题是一个及其复杂的问题，因为其困难度会随着变量的个数指数级增长。贝叶斯网络是联合概率的分解表示，它在一定程度上简化了推理算法，降低了推理过程中算法的复杂度。</p><h2 id="bnt工具箱">BNT工具箱</h2><p>BNT其实是一个贝叶斯网相关算法的实现集合。BNT中实现了大部分相关算法，非常适合基于MATLAB的编程者引用。使用它，能够大大提高编程效率。</p><h2 id="表情数据库">表情数据库</h2><h3 id="jaffe数据库">JAFFE数据库</h3><p>该数据库是在基本表情识别中最常见的数据库。包含的6种基本表情和中性表情。 <img src="2017-03-08_194634.png" alt="jaffe"> ### Yale Face 数据库 该数据库共包含165幅图像，它是面部图像种类最齐全的数据库。 <img src="2017-03-08_194717.png" alt="yele"> ### MMI表情库 MMI表情数据库是记录面部行为最为全面的数据库，包括19-62岁之间的50个人的正面和侧面人脸图像。 <img src="2017-03-08_194800.png" alt="mmi"> ### AAI表情库 AAI表情数据库记录的全部都是自发表情，该数据库记录了60个成年人对童年经历描述时产生的自发表情，每个人持续30-60分钟。 ### CK表情库 CK表情数据库是在AU识别领域使用最为广泛的数据库，目前为止一共有三个版本</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 认知神经科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于视频的车牌识别和流量统计</title>
      <link href="/hexoblog/2017/03/08/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/%E5%9F%BA%E4%BA%8E%E8%A7%86%E9%A2%91%E7%9A%84%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%AB%E5%92%8C%E6%B5%81%E9%87%8F%E7%BB%9F%E8%AE%A1/"/>
      <url>/hexoblog/2017/03/08/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/%E5%9F%BA%E4%BA%8E%E8%A7%86%E9%A2%91%E7%9A%84%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%AB%E5%92%8C%E6%B5%81%E9%87%8F%E7%BB%9F%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>基于视频的车牌识别和流量统计</p><a id="more"></a><h2 id="车流量统计功能">车流量统计功能</h2><ol style="list-style-type: decimal"><li>读取视频数据</li><li>针对读入的每帧图像，转换成灰度图像；<code>cvCvtColor(frame, pFrImg, CV_BGR2GRAY);</code></li><li>做高斯滤波，平滑图像；<code>cvSmooth(pFrameMat, pFrameMat, CV_GAUSSIAN, 3, 0, 0);</code></li><li>背景差分，当前图像和北京图像做差；<code>cvAbsDiff(pFrameMat, pBkMat, pFrMat);</code></li><li>二值化前景图，（前面的是灰度图像，现在是二值图像，只有黑白两色，背景是黑色，运动物体是白色）</li><li>更新背景;<code>cvRunningAvg(pFrameMat, pBkMat, 0.1, 0);</code></li></ol><p>上面的步骤完成运动物体的检测，现在视频流被处理成黑白两色，运动的车辆是白色，背景是黑色。下面使用撞线检测的方法检测是否有车辆通过。</p><ol style="list-style-type: decimal"><li>统计一个固定区域的像素平均值，当有车辆经过时，这个地方的像素均值急剧增大，当它过去的时候，像素均值急剧减少，通过捕捉这个变化，确定是否有车通过。</li><li>针对连续通过的车辆，从时间和中间的变化来判断</li><li>针对多个车道，初始的时候有一个检测车道的方法，把车道的数据存储起来，分别对每个车道统计； 针对跨越车道的车辆，就是一半在这个车道，一半在另外一个车道的， 采用两个车道合并的数据，看统一时间相邻的车道是否有宽度合并起来约为一辆车的，计算为一辆车。</li><li>每当检测出有车辆经过的时候，捕捉这辆车的车牌位置的彩色高清截图，保存下来。</li></ol><h2 id="车牌识别功能">车牌识别功能</h2><ol style="list-style-type: decimal"><li>输入是上面保存的图片</li><li>在HSV空间判断像素的颜色，提取颜色特征</li><li>提取图像的纹理特征。</li><li>在颜色特征和纹理特征的基础上，粗定位车牌的位置</li><li>精细搜索，定位车牌的位置，保存车牌图片，用于后面的识别。</li></ol><p>上面的步骤完成车牌的定位，此时每辆车的车牌图像已经被保存下来了，下面是最关键的文字识别。识别采用的是模版匹配的方法，即我们预先有所有字母和数字和所有省份缩写的模版。</p><ol style="list-style-type: decimal"><li>分割图像（依据连通域和字符的宽度和高度）</li><li>针对分割出来的每个字符(汉字，数字，字母)， 计算和模版图片的相似度，取相似度最高的作为输出</li><li>对ODQ，2Z，5S，8B，等相似字符进行二次检测</li><li></li></ol><h2 id="hsv二值化">HSV二值化：</h2><p>HSV颜色空间：比较适合用来分割不同的颜色。 车牌一般为黄色和蓝色，我们使用HSV颜色空间来寻找车牌的位置</p><h2 id="纹理二值化">纹理二值化</h2><h2 id="模版匹配">模版匹配：</h2><p>模版匹配是寻找目标图像的方法之一，它通过在输入图像上滑动图像块对实际的图像块和输入图像进行匹配。 我们使用预定义的字母模版匹配车牌上分割下来的字母和数字，以识别牌照上的字母和数字。</p><h2 id="背景差分">背景差分</h2><p>根据前N帧图像的灰度值进行区间统计从而得到一个具有统计意义的初始背景。 当前的最新图像与背景做差，即可求得背景差图，然后根据一定的方法对图进行二值化，就能获得运动物体。 图像二值化的一个关键是阈值的选取，目前采用的方法有最大类间方差法，一维交叉熵阈值法，二维交叉熵阈值法。 背景的更新使用的是OPENCV实现的一个滑动平均的方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cvRunningAvg( <span class="keyword">const</span> CvArr* image, CvArr* acc, <span class="keyword">double</span> alpha, <span class="keyword">const</span> CvArr* mask=<span class="literal">NULL</span> );</span><br></pre></td></tr></table></figure><p>可以通过设置alpha的值来更新背景，alpha越大，背景更新的越快。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 认知神经科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 车牌识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>circos入门教程</title>
      <link href="/hexoblog/2017/01/03/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/circos%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
      <url>/hexoblog/2017/01/03/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/circos%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="circos.png" alt="circos"> <a id="more"></a> ## circos简介 <a href="http://circos.ca/" target="_blank" rel="noopener">circos</a>是设计用来专门绘制基因图的，但是其应用并不仅仅局限于此，它能胜任任何需要绘制环状图像的地方。 例如在认知神经科学中表示脑区之间的连接。本教程旨在实现绘制以下图像： <img src="example1.png" alt="example1"> 该图主要由几个部分组成： 1 chromosome（染色体）； 2 label（标签）；3 links（连接）; 4 间隔 我们要实现这样一个任务： 用chromosome表示脑区，用chromosome长度表示与脑区的关联量，例如脑区体素数量; 用links表示脑区之间的连接,用links线的颜色和粗细以及层次表示连接的强度（例如，连接越强，颜色越鲜艳，线越粗，越靠上层）; 用间隔表示分组，例如分成大脑和小脑。</p><h2 id="circos安装">circos安装</h2><p>circos是运行在perl环境下的跨平台的工具包，只要安装好perl环境，直接解压缩circos的代码就能运行。 ### 安装perl环境 Linux下可以直接安装perl,windows最好使用集成环境，例如<a href="http://strawberryperl.com/releases.html" target="_blank" rel="noopener">Strawberry Perl</a> Strawberry Perl windows 7 旗舰版 64位安装包下载地址: <a href="http://strawberryperl.com/download/5.24.0.1/strawberry-perl-5.24.0.1-64bit.msi" class="uri" target="_blank" rel="noopener">http://strawberryperl.com/download/5.24.0.1/strawberry-perl-5.24.0.1-64bit.msi</a> 安装过程和普通的Windows程序没有区别，一路下一步就可以。 <img src="StrawberryPerlInstall.png" alt="StrawberryPerlInstall"> 安装完成后，打开CMD，输入<code>perl -v</code>, 出现版本信息就证明安装成功了。 <img src="StrawberryPerlInstall.png" alt="StrawberryPerlInstallCMD"></p><h3 id="下载circos">下载circos</h3><p>circos主程序：http://circos.ca/distribution/circos-0.69-3.tgz circos示例程序：http://circos.ca/distribution/circos-tutorials-0.67.tgz</p><p>下载完后解压缩到任意位置（需要解压缩两次，推荐用7z）,切换到<code>bin</code>目录下，键入<code>circos</code>: 如果出现missing …是因为有些circos需要的模块没有安装。</p><h3 id="安装perl模块">安装perl模块</h3><p>在CMD键入<code>cpan</code>命令，进入cpan环境 <img src="cpanCMD.png" alt="cpanCMD"> 输入<code>install 模块名</code> 就会完成自动下载安装过程。 模块名可以从上面的报错信息中找到。 丢失的模块全部完后，可以按照一下方法做一个测试。</p><p>在bin文件夹下面新建一个test文件夹，test内新建一个名称为helloword.conf的文件。 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"># MINIMUM CIRCOS CONFIGURATION</span><br><span class="line">#</span><br><span class="line"># The 'hello world' Circos tutorial. Only required</span><br><span class="line"># configuration elements are included.</span><br><span class="line">#</span><br><span class="line"># Common optional elements are commented out.</span><br><span class="line"></span><br><span class="line"># Defines unit length for ideogram and tick spacing, referenced</span><br><span class="line"># using "u" prefix, e.g. 10u</span><br><span class="line">#chromosomes_units           = 1000000</span><br><span class="line"></span><br><span class="line"># Show all chromosomes in karyotype file. By default, this is</span><br><span class="line"># true. If you want to explicitly specify which chromosomes</span><br><span class="line"># to draw, set this to 'no' and use the 'chromosomes' parameter.</span><br><span class="line"># chromosomes_display_default = yes</span><br><span class="line"></span><br><span class="line"># Chromosome name, size and color definition</span><br><span class="line">karyotype = data/karyotype/karyotype.human.txt</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ideogram</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">spacing</span>&gt;</span></span><br><span class="line"># spacing between ideograms</span><br><span class="line">default = 0.05r</span><br><span class="line"><span class="tag">&lt;/<span class="name">spacing</span>&gt;</span></span><br><span class="line"></span><br><span class="line"># ideogram position, thickness and fill</span><br><span class="line">radius           = 0.20r</span><br><span class="line">thickness        = 100p</span><br><span class="line">fill             = yes</span><br><span class="line"></span><br><span class="line">#stroke_thickness = 1</span><br><span class="line">#stroke_color     = black</span><br><span class="line"></span><br><span class="line"># ideogram labels</span><br><span class="line"># &lt;&lt;include ideogram.label.conf&gt;&gt;</span><br><span class="line"></span><br><span class="line"># ideogram cytogenetic bands, if defined in the karyotype file</span><br><span class="line"># &lt;&lt;include bands.conf&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">ideogram</span>&gt;</span></span><br><span class="line"></span><br><span class="line"># image size, background color, angular position</span><br><span class="line"># of first ideogram, transparency levels, output</span><br><span class="line"># file and directory</span><br><span class="line">#</span><br><span class="line"># it is best to include these parameters from etc/image.conf</span><br><span class="line"># and override any using param* syntax</span><br><span class="line">#</span><br><span class="line"># e.g.</span><br><span class="line"># <span class="tag">&lt;<span class="name">image</span>&gt;</span></span><br><span class="line"># &lt;&lt;include etc/image.conf&gt;&gt;</span><br><span class="line"># radius* = 500</span><br><span class="line"># <span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">image</span>&gt;</span></span><br><span class="line">&lt;&lt;include etc/image.conf&gt;&gt; # included from Circos distribution</span><br><span class="line"><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line"></span><br><span class="line"># RGB/HSV color definitions, color lists, location of fonts,</span><br><span class="line"># fill patterns</span><br><span class="line">&lt;&lt;include etc/colors_fonts_patterns.conf&gt;&gt; # included from Circos distribution</span><br><span class="line"></span><br><span class="line"># debugging, I/O an dother system parameters</span><br><span class="line">&lt;&lt;include etc/housekeeping.conf&gt;&gt; # included from Circos distribution</span><br><span class="line"></span><br><span class="line"># <span class="tag">&lt;<span class="name">ticks</span>&gt;</span> blocks to define ticks, tick labels and grids</span><br><span class="line">#</span><br><span class="line"># requires that chromosomes_units be defined</span><br><span class="line">#</span><br><span class="line"># &lt;&lt;include ticks.conf&gt;&gt;</span><br></pre></td></tr></table></figure></p><p>然后在CMD输入命令<code>perl circos -conf test\helloword.conf</code>,会有类似下面的输出 <img src="perlcircos.png" alt="perlcircos"> 默认会在当前目录下生成circos.png 和 circos,svg两个文件 <img src="circos_example.png" alt="circos"></p><p>至此，完成了circos的安装，生成了一个最简单的图像。</p><h2 id="circos基本概念">circos基本概念</h2><h3 id="组织结构">组织结构</h3><p>circos 生成图像所需要的所有内容都保存在一个配置文件中，例如 helloword.conf 这个配置文件以XML的格式来组织。 - <code>&lt;ideogram&gt;&lt;/ideagram&gt;</code> 标签内定义chromosome的相关属性，例如radius，thickness，fill，<spacing>，<labels>，<bands> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;ideogram&gt;</span><br><span class="line"></span><br><span class="line">&lt;spacing&gt;</span><br><span class="line"># spacing between ideograms</span><br><span class="line">default = 0.05r</span><br><span class="line">&lt;/spacing&gt;</span><br><span class="line"></span><br><span class="line"># ideogram position, thickness and fill</span><br><span class="line">radius           = 0.20r</span><br><span class="line">thickness        = 100p</span><br><span class="line">fill             = yes</span><br><span class="line"></span><br><span class="line">#stroke_thickness = 1</span><br><span class="line">#stroke_color     = black</span><br><span class="line"></span><br><span class="line"># ideogram labels</span><br><span class="line"># &lt;&lt;include ideogram.label.conf&gt;&gt;</span><br><span class="line"></span><br><span class="line"># ideogram cytogenetic bands, if defined in the karyotype file</span><br><span class="line"># &lt;&lt;include bands.conf&gt;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/ideogram&gt;</span><br></pre></td></tr></table></figure></bands></labels></spacing></p><ul><li><p><code>&lt;image&gt;&lt;/image&gt;</code>标签内定义生成的图像的一些属性，例如生成路径，文件名等 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;image&gt;</span><br><span class="line">&lt;&lt;include etc/image.conf&gt;&gt;</span><br><span class="line"># generated image path</span><br><span class="line">dir*   = D:\FMRI_ROOT\YIYU\CONN\PNG</span><br><span class="line"></span><br><span class="line"># generated image name</span><br><span class="line">file*= 1.png</span><br><span class="line">&lt;/image&gt;</span><br></pre></td></tr></table></figure></p></li><li><p><code>&lt;links&gt;&lt;/links&gt;</code> 标签内可定义若干<link>标签，每一对都是一组连接 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;links&gt;</span><br><span class="line">#ribbon           = yes</span><br><span class="line">#flat             = yes</span><br><span class="line">&lt;link&gt;</span><br><span class="line">file          = links1000.data.txt # links 文件路径</span><br><span class="line">radius        = 0.99r</span><br><span class="line">color         = red</span><br><span class="line"></span><br><span class="line"># Curves look best when this value is small (e.g. 0.1r or 0r)</span><br><span class="line">bezier_radius = 0.1r</span><br><span class="line">thickness     = 2</span><br><span class="line"></span><br><span class="line"># These parameters have default values. To unset them</span><br><span class="line"># use &apos;undef&apos;</span><br><span class="line">#crest                = undef</span><br><span class="line">#bezier_radius_purity = undef</span><br><span class="line"></span><br><span class="line"># Limit how many links to read from file and draw</span><br><span class="line">record_limit  = 40000</span><br><span class="line"></span><br><span class="line">#&lt;rule&gt;</span><br><span class="line">#condition  = var(intrachr) &amp;&amp; abs(var(pos1)-var(pos2)) &lt; 10Mb</span><br><span class="line">#show       = no</span><br><span class="line">#color = red</span><br><span class="line">#&lt;/rule&gt;</span><br><span class="line"></span><br><span class="line">&lt;/link&gt;</span><br><span class="line"></span><br><span class="line">&lt;/links&gt;</span><br></pre></td></tr></table></figure></p></li><li><p><code>karyotype</code> 定义染色体文件路径 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">karyotype   = brainnetome.data.txt</span><br></pre></td></tr></table></figure></p></li></ul><h3 id="染色体文件">染色体文件</h3><p>染色体文件在配置文件中用关键字<code>karyotype = data.txt</code>指明。染色体就是环上要显示的实体。数据格式如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b    parent    ID   label    start    end    color   options</span><br><span class="line"></span><br><span class="line">chr  -         hs1   g1      0        100     red     thickness=3</span><br><span class="line">chr  -         hs2   g2      0        88      blue    color=blue,thickness=5</span><br></pre></td></tr></table></figure></p><p>b 是circos中的保留关键字，可以是chr，代表该行定义的是染色体，可以是band，代表该行定义的是band. band就是染色体上一条染色带。 parent 定义该行的父元素，-表示没有父元素。 ID 该行的标识符，通过ID可以唯一的找到该行 label 将来显示在图像中的该染色体的名字 start 起始位置 end 终止位置 color 定义显示时的颜色 options 可选，前面的字段都是必须的，这里额外添加需要的内容，格式为<code>key1=value1,key2=value2,key3=value3</code></p><p>注意 start end 可以用来控制染色体显示时候的相对比例，例如，如果希望所有的染色体都一样长，可以全部设为 0 1 或者全部设为0 100； 如果希望染色体体积越大越长，则可以start设置为0，end设置为每个染色体的体积。（这里体积只是举例，可以为染色体的任意一个属性）</p><h3 id="连接文件">连接文件</h3><p>连接文件在<code>&lt;links&gt;&lt;link&gt; file = link.data.txt&lt;/link&gt;&lt;links&gt;</code>中定义，它有两种格式： 第一种： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ID1 start1 end1 ID2 start2 end2 options    定义ID1到ID2的连接</span><br><span class="line"></span><br><span class="line">hs1  0       1   hs2   0    1   color=red,thickness=2，z=100</span><br><span class="line">hs1  1       2   hs3   0    1</span><br></pre></td></tr></table></figure></p><p>第二种： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b1 ID1 start1 end1</span><br><span class="line">b1 ID2 start2 end2  # 两行定义一个由ID1到ID2的连接</span><br></pre></td></tr></table></figure></p><p>这里的ID都是指karyotype文件中定义的ID。 所以，要实现连接的变化，只需要在定义的每个连接后面定义好相应的颜色，线宽，层次就可以了。</p><h3 id="颜色">颜色</h3><p>默认的颜色定义在<code>etc\colors.conf</code>中，默认的颜色定义已经能够满足大部分的要求，使用的时候只需要指定其中的名称即可。 也可以定义自己的颜色文件，在<code>etc\colors.conf</code>添加<code>&lt;&lt;include colors.me.conf&gt;&gt;</code>,然后在etc下新建文件<code>colors.me.conf</code> 颜色文件的定义格式是： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">colorname = R,G,B</span><br><span class="line">black=0,0,0</span><br><span class="line">white=255,255,255</span><br></pre></td></tr></table></figure></p><h3 id="显示配置选项">显示配置选项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&lt;image&gt;</span><br><span class="line">&lt;&lt;include etc/image.conf&gt;&gt;</span><br><span class="line"># generated image path</span><br><span class="line">dir*   = D:\FMRI_ROOT\YIYU\CONN\PNG # 图像生成路径</span><br><span class="line"></span><br><span class="line"># generated image name</span><br><span class="line">file*= 1.png # 生成图像名称</span><br><span class="line">&lt;/image&gt;</span><br><span class="line"></span><br><span class="line">&lt;ideogram&gt;</span><br><span class="line">show_label       = yes # 是否显示label</span><br><span class="line">label_font       = default</span><br><span class="line">label_radius     = dims(ideogram,radius) + 0.025r  #控制labels的位置</span><br><span class="line">label_with_tag   = no</span><br><span class="line">label_size       = 20 # labels的大小</span><br><span class="line">label_parallel   = no  # 控制labels是否水平显示，label较长时应该设为no</span><br><span class="line">label_case       = upper # 控制labels的大小写</span><br><span class="line">label_format     = eval(sprintf(&quot;%s&quot;,var(label)))  # 控制labels的格式</span><br><span class="line"></span><br><span class="line">radius           = 0.70r #染色体的半径</span><br><span class="line">thickness        = 100p #染色体线的厚度</span><br><span class="line">fill             = yes</span><br><span class="line">fill_color       = black</span><br><span class="line">stroke_thickness = 2 # 中间线的颜色和宽度</span><br><span class="line">stroke_color     = blue</span><br><span class="line"></span><br><span class="line">&lt;ticks&gt;</span><br><span class="line">show_ticks          = no # 是否显示染色体上的刻度</span><br><span class="line">show_tick_labels    = yes</span><br><span class="line">&lt;/ticks&gt;</span><br><span class="line"></span><br><span class="line">&lt;bands&gt;</span><br><span class="line">show_bands            = yes # 是否显示bands</span><br><span class="line">fill_bands            = no</span><br><span class="line">band_stroke_thickness = 2</span><br><span class="line">band_stroke_color     = white</span><br><span class="line">band_transparency     = 0</span><br><span class="line"></span><br><span class="line">max_ideograms* = 250 # 显示的染色体的最大数目</span><br><span class="line">max_links* = 35000 # 显示的连接的最大数目</span><br><span class="line"></span><br><span class="line">&lt;links&gt;</span><br><span class="line">#ribbon           = yes</span><br><span class="line">#flat             = yes</span><br><span class="line">&lt;link&gt;</span><br><span class="line">file          = links1000.data.txt # 连接数据文件</span><br><span class="line">radius        = 0.99r # 连接的大小</span><br><span class="line">color         = red # 连接的颜色</span><br><span class="line"></span><br><span class="line"># Curves look best when this value is small (e.g. 0.1r or 0r)</span><br><span class="line">bezier_radius = 0.1r</span><br><span class="line">thickness     = 2 # 线的宽度</span><br><span class="line"></span><br><span class="line"># These parameters have default values. To unset them</span><br><span class="line"># use &apos;undef&apos;</span><br><span class="line">#crest                = undef</span><br><span class="line">#bezier_radius_purity = undef</span><br><span class="line"></span><br><span class="line"># Limit how many links to read from file and draw</span><br><span class="line">record_limit  = 40000</span><br><span class="line"></span><br><span class="line">#&lt;rule&gt;  # 可以用条件语句控制连接的格式</span><br><span class="line">#condition  = var(intrachr) &amp;&amp; abs(var(pos1)-var(pos2)) &lt; 10Mb</span><br><span class="line">#show       = no</span><br><span class="line">#color = red</span><br><span class="line">#&lt;/rule&gt;</span><br><span class="line"></span><br><span class="line">&lt;/link&gt;</span><br><span class="line"></span><br><span class="line">&lt;/links&gt;</span><br><span class="line"></span><br><span class="line">&lt;/bands&gt;</span><br><span class="line">&lt;/ideogram&gt;</span><br></pre></td></tr></table></figure><h2 id="circos实例">circos实例</h2><p>要生成的图像： <img src="example2.png" alt="example2"> 所需文件： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test\me\circos.conf</span><br><span class="line">test\me\ideogram.conf</span><br><span class="line">test\me\ideogram.label.conf</span><br><span class="line">test\me\ideogram.position.conf</span><br><span class="line">test\me\links.me.conf</span><br><span class="line">test\me\ticks.conf</span><br><span class="line">test\me\bands.conf</span><br><span class="line">test\me\brainnetome.data.txt</span><br><span class="line">test\me\links50.data.txt</span><br><span class="line">etc\colors.me.conf</span><br></pre></td></tr></table></figure></p><p>链接: https://pan.baidu.com/s/1eSebD9w 密码: nham</p><p>CMD中键入命令<code>perl circos -conf test\me\circos.conf</code>,OK . <img src="ok.png" alt="ok"></p><p>其中colors.me.conf是自己根据colorbar生成的颜色，用来实现不同的颜色代表不同的强度值的目的。 该颜色主题用红色代表最大值，用蓝色表示最小值，值又大变小的过程 对应着 颜色由暖变冷的过程。 下面贴上生成colors.me.conf的matlab代码： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">% 生成color bar 原始数据集</span><br><span class="line">% colorname1 R G B</span><br><span class="line">% colorname2 R G B</span><br><span class="line">% 产生颜色的种类</span><br><span class="line">color_num = 60;</span><br><span class="line">colors_unit = jet(color_num);</span><br><span class="line">colors = colors_unit * 255;</span><br><span class="line">fid=fopen(&apos;D:\FMRI_ROOT\TOOLS\circos-0.69-3\etc\colors.me.conf&apos;,&apos;w+&apos;);</span><br><span class="line">for i =1:size(colors,1)</span><br><span class="line">    fprintf(fid,[&apos;mecolor&apos;,num2str(size(colors,1)-i+1),&apos;=&apos;,num2str(colors(i,1)),&apos;,&apos;,num2str(colors(i,2)),&apos;,&apos;,num2str(colors(i,3)),&apos;\n&apos;]);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">fclose(fid);</span><br><span class="line"></span><br><span class="line">colormap(colors_unit);</span><br><span class="line">colorbar();</span><br></pre></td></tr></table></figure></p><p>brainnetome.data.txt部分内容: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">chr - SFG_L_7_1 SFG_L_7_1 0 100 chr0</span><br><span class="line">chr - SFG_R_7_1 SFG_R_7_1 0 100 chr1</span><br><span class="line">chr - SFG_L_7_2 SFG_L_7_2 0 100 chr2</span><br><span class="line">chr - SFG_R_7_2 SFG_R_7_2 0 100 chr3</span><br><span class="line">chr - SFG_L_7_3 SFG_L_7_3 0 100 chr4</span><br><span class="line">chr - SFG_R_7_3 SFG_R_7_3 0 100 chr5</span><br><span class="line">chr - SFG_L_7_4 SFG_L_7_4 0 100 chr6</span><br></pre></td></tr></table></figure></p><p>colors.me.conf部分内容： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mecolor6=221,0,0</span><br><span class="line">mecolor5=204,0,0</span><br><span class="line">mecolor4=187,0,0</span><br><span class="line">mecolor3=170,0,0</span><br><span class="line">mecolor2=153,0,0</span><br><span class="line">mecolor1=136,0,0</span><br></pre></td></tr></table></figure></p><h2 id="生成带分组的图形">生成带分组的图形</h2><p>先看一个示例 <img src="aal2.png" alt="aal"></p><p>要想在染色体中间加入分割，可以在<code>ideogram.conf</code>文件中添加如下语句： <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">spacing</span>&gt;</span></span><br><span class="line">default = 0.001r  # 每个染色体的间隔</span><br><span class="line">break   = 0.01r</span><br><span class="line">axis_break_at_edge = yes</span><br><span class="line">axis_break         = yes</span><br><span class="line"><span class="tag">&lt;<span class="name">pairwise</span> <span class="attr">Cingulum_Ant_L</span> <span class="attr">Caudate_R</span>&gt;</span></span><br><span class="line">   spacing = 10r</span><br><span class="line"><span class="tag">&lt;/<span class="name">pairwise</span>&gt;</span>   # 定义相邻的两个染色体的间隔</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">pairwise</span> <span class="attr">Temporal_Pole_Mid_L</span> <span class="attr">Calcarine_R</span>&gt;</span></span><br><span class="line">   spacing = 10r</span><br><span class="line"><span class="tag">&lt;/<span class="name">pairwise</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">spacing</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这里需要注意的是，定义两个相邻的染色体之间的间隔的时候，如果用r为单位，是相对于default的倍数。 如果default设置成0，则无论多少倍都是0，这时候设置的特定的两个染色体的间隔也不会出现任何效果。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 认知神经科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> circos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_Matplolib使用技巧</title>
      <link href="/hexoblog/2016/07/11/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_Matplolib%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/hexoblog/2016/07/11/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_Matplolib%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<div class="figure"><img src="matplotlib.png" alt="matplotlib"><p class="caption">matplotlib</p></div><a id="more"></a><p>　　Matplotlib是一个使用Python实现的画图函数库。它可以以Python脚本，或者IPython Shell的形式被被使用。它是最著名的python绘图库，它提供了一整套和Matlab相似的命令API，十分适合交互式的进行制图。而且也可以方便的将它作为绘图控件，嵌入到GUI程序中去。它的文档相当完备，并且Gallery页面中有上百幅缩略图，打开之后都有源程序。因此如果你需要绘制某种类型的图，只需要在这个页面中浏览/复制/粘贴一下，基本上都能搞定。 　　Matplotlib官方网站：<a href="http://matplotlib.org/" class="uri" target="_blank" rel="noopener">http://matplotlib.org/</a> 　　Gallery页面地址：<a href="http://matplotlib.org/gallery.html" class="uri" target="_blank" rel="noopener">http://matplotlib.org/gallery.html</a></p><h2 id="pyplot">pyplot</h2><p>　　pyplot是一个仿照MATLAB画图的接口设计的一个画图的库，接口的函数名称和使用规则都和MATLAB类似。</p><h3 id="引入">引入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><h3 id="画线">画线</h3><p><code>plt.plot(x,y,commond)</code> x表示横坐标的取值，y表示纵坐标的取值，commond是可选的控制参数。如果只传递一个参数，例如plot(a), a被认为是纵坐标，横坐标为从0开始的自然数 0,1,2,3,… 还可以以两个或者三个参数为一组传递参数进入plot,这样可以一次画多条线段，<code>plot(x1,y1,x2,y2,x3,y3)</code></p><blockquote><p>commond的取值： b- : 蓝色直线 ro : 红色圆点 r– : 红色虚线 bs : 蓝色实心方框 g^ : 绿色实心三角</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line">plt.plot([<span class="number">8</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>])</span><br><span class="line">plt.plot([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>],<span class="string">'go'</span>)</span><br><span class="line">plt.plot([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>],<span class="string">'r--'</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>],<span class="string">'r^'</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>],<span class="string">'rs'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><div class="figure"><img src="output_3_0.png" alt="png"><p class="caption">png</p></div><h3 id="控制样式">控制样式</h3><ol style="list-style-type: decimal"><li>设置横坐标和纵坐标的取值范围：plt.axis([xmin.xmax,ymin,ymax])</li><li><p>设置线宽：<code>plt.plot(x,y,linewidth = 2)</code> 或者使用set方法：<code>line, = plot(x,y,'-')</code> <code>line.set_antialiased(False)</code> <code>plt.setp(lines, color='r', linewidth=2.0)</code> 要查看所有可以设置的属性，可以使用<code>plt.setp(lines)</code></p></li><li><p>设置坐标标识：</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.xlable(<span class="string">'x轴说明'</span>,fontsize=<span class="number">14</span>,color=<span class="string">'red'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'y轴说明'</span>)</span><br><span class="line">plt.title(<span class="string">'图表标题'</span>)</span><br><span class="line">plt.text(<span class="string">'图表中说明性文字'</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>) <span class="comment">#是否显示网格线</span></span><br></pre></td></tr></table></figure><p>每个设置都有更多的选项可以控制显示的各个方面，详细的属性信息参考<a href="http://matplotlib.org/users/text_props.html#text-properties" target="_blank" rel="noopener">Text properties and layout</a>,关于图表上数学公式的书写，参考<a href="http://matplotlib.org/users/usetex.html#usetex-tutorial" target="_blank" rel="noopener">Text rendering With LaTeX</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">mu, sigma = <span class="number">100</span>, <span class="number">15</span></span><br><span class="line">x = mu + sigma * np.random.randn(<span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># the histogram of the data</span></span><br><span class="line">n, bins, patches = plt.hist(x, <span class="number">50</span>, normed=<span class="number">1</span>, facecolor=<span class="string">'g'</span>, alpha=<span class="number">0.75</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">'Smarts'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Probability'</span>)</span><br><span class="line">plt.title(<span class="string">'Histogram of IQ'</span>)</span><br><span class="line">plt.text(<span class="number">60</span>, <span class="number">.025</span>, <span class="string">r'$\mu=100,\ \sigma=15$'</span>)</span><br><span class="line">plt.axis([<span class="number">40</span>, <span class="number">160</span>, <span class="number">0</span>, <span class="number">0.03</span>])</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><div class="figure"><img src="output_5_0.png" alt="png"><p class="caption">png</p></div><h3 id="同时画多个图">同时画多个图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(<span class="number">1</span>)  <span class="comment">#创建图对象，括号里面的数字是这个图的标识</span></span><br><span class="line">plt.subplot(<span class="number">211</span>) <span class="comment"># 创建子图，括号里的数字是numrows, numcols, fignum，这里这个子图所在的位置是第二行，第一列，在上面创建的那个figure1中。</span></span><br><span class="line">plt.plot(x1,y1)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">221</span>)</span><br><span class="line">plt.plot(x2,y2)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(t)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.exp(-t) * np.cos(<span class="number">2</span>*np.pi*t)</span><br><span class="line"></span><br><span class="line">t1 = np.arange(<span class="number">0.0</span>, <span class="number">5.0</span>, <span class="number">0.1</span>)</span><br><span class="line">t2 = np.arange(<span class="number">0.0</span>, <span class="number">5.0</span>, <span class="number">0.02</span>)</span><br><span class="line"></span><br><span class="line">plt.figure(<span class="number">2</span>)</span><br><span class="line">plt.subplot(<span class="number">211</span>)</span><br><span class="line">plt.plot(t1, f(t1), <span class="string">'bo'</span>, t2, f(t2), <span class="string">'k'</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">212</span>)</span><br><span class="line">plt.plot(t2, np.cos(<span class="number">2</span>*np.pi*t2), <span class="string">'r--'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><div class="figure"><img src="output_7_0.png" alt="png"><p class="caption">png</p></div><h3 id="图例">图例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.patches <span class="keyword">as</span> mpatches</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">line_up, = plt.plot([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], label=<span class="string">'Line 2'</span>)</span><br><span class="line">line_down, = plt.plot([<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>], label=<span class="string">'Line 1'</span>)</span><br><span class="line">plt.legend([line_up, line_down], [<span class="string">'Line AA'</span>, <span class="string">'Line BB'</span>])</span><br></pre></td></tr></table></figure><p>&lt;matplotlib.legend.Legend at 0xb95ce10&gt;</p><div class="figure"><img src="output_9_1.png" alt="png"><p class="caption">png</p></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.lines <span class="keyword">as</span> mlines</span><br><span class="line">blue_line = mlines.Line2D([], [], color=<span class="string">'blue'</span>, marker=<span class="string">'*'</span>,</span><br><span class="line">                          markersize=<span class="number">15</span>, label=<span class="string">'Blue stars'</span>)</span><br><span class="line">plt.legend(handles=[blue_line])</span><br></pre></td></tr></table></figure><p>&lt;matplotlib.legend.Legend at 0xc4013c8&gt;</p><div class="figure"><img src="output_10_1.png" alt="png"><p class="caption">png</p></div><h3 id="各种图">各种图</h3><h4 id="基本图表plot">基本图表(plot)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">t = np.arange(<span class="number">0.0</span>, <span class="number">2.0</span>, <span class="number">0.01</span>)</span><br><span class="line">s = np.sin(<span class="number">2</span>*np.pi*t)</span><br><span class="line">plt.plot(t, s)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">'time (s)'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'voltage (mV)'</span>)</span><br><span class="line">plt.title(<span class="string">'About as simple as it gets, folks'</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><div class="figure"><img src="output_12_0.png" alt="png"><p class="caption">png</p></div><h4 id="多个子图绘制在一起subplot">多个子图绘制在一起(subplot)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Simple demo with multiple subplots.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x1 = np.linspace(<span class="number">0.0</span>, <span class="number">5.0</span>)</span><br><span class="line">x2 = np.linspace(<span class="number">0.0</span>, <span class="number">2.0</span>)</span><br><span class="line"></span><br><span class="line">y1 = np.cos(<span class="number">2</span> * np.pi * x1) * np.exp(-x1)</span><br><span class="line">y2 = np.cos(<span class="number">2</span> * np.pi * x2)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot(x1, y1, <span class="string">'yo-'</span>)</span><br><span class="line">plt.title(<span class="string">'A tale of 2 subplots'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Damped oscillation'</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot(x2, y2, <span class="string">'r.-'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'time (s)'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Undamped'</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><div class="figure"><img src="output_14_0.png" alt="png"><p class="caption">png</p></div><h4 id="直方图hist">直方图(hist)</h4><ul><li>下面这个程序展示了如何使用hist函数绘制直方图和如何绘制一条拟合直方图的曲线。 <code>n, bins, patches = hist(x,num_bins)</code> x 构建直方图的数据，x = [n_samples,] num_bins 要分成的组数，最后生成的直方图有num_bins个方框。 n 每个直方的值 bins 每个直方的起始位置 patches :Silent list of individual patches used to create the histogram or list of such list if multiple input datasets.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Demo of the histogram (hist) function with a few features.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">In addition to the basic histogram, this demo shows a few optional features:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    * Setting the number of data bins</span></span><br><span class="line"><span class="string">    * The ``normed`` flag, which normalizes bin heights so that the integral of</span></span><br><span class="line"><span class="string">      the histogram is 1. The resulting histogram is a probability density.</span></span><br><span class="line"><span class="string">    * Setting the face color of the bars</span></span><br><span class="line"><span class="string">    * Setting the opacity (alpha value).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.mlab <span class="keyword">as</span> mlab</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># example data</span></span><br><span class="line">mu = <span class="number">100</span>  <span class="comment"># mean of distribution</span></span><br><span class="line">sigma = <span class="number">15</span>  <span class="comment"># standard deviation of distribution</span></span><br><span class="line">x = mu + sigma * np.random.randn(<span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">num_bins = <span class="number">50</span></span><br><span class="line"><span class="comment"># the histogram of the data</span></span><br><span class="line">n, bins, patches = plt.hist(x, num_bins, normed=<span class="number">1</span>, facecolor=<span class="string">'green'</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"><span class="comment"># add a 'best fit' line</span></span><br><span class="line">y = mlab.normpdf(bins, mu, sigma)</span><br><span class="line">plt.plot(bins, y, <span class="string">'r--'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Smarts'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Probability'</span>)</span><br><span class="line">plt.title(<span class="string">r'Histogram of IQ: $\mu=100$, $\sigma=15$'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Tweak spacing to prevent clipping of ylabel</span></span><br><span class="line">plt.subplots_adjust(left=<span class="number">0.15</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><div class="figure"><img src="output_16_0.png" alt="png"><p class="caption">png</p></div><h4 id="饼状图pie">饼状图(pie)</h4><p><code>plt.pie(size,explode,labels,colors)</code> size: 绘制图的数据 explode: 分割出来显示的某个数据 lables:文字说明 colors: 饼状图对应部分的颜色</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># The slices will be ordered and plotted counter-clockwise.</span></span><br><span class="line">labels = <span class="string">'Frogs'</span>, <span class="string">'Hogs'</span>, <span class="string">'Dogs'</span>, <span class="string">'Logs'</span></span><br><span class="line">sizes = [<span class="number">15</span>, <span class="number">30</span>, <span class="number">45</span>, <span class="number">10</span>]</span><br><span class="line">colors = [<span class="string">'yellowgreen'</span>, <span class="string">'gold'</span>, <span class="string">'lightskyblue'</span>, <span class="string">'lightcoral'</span>]</span><br><span class="line">explode = (<span class="number">0.1</span>, <span class="number">0</span>, <span class="number">0.2</span>, <span class="number">0</span>)  <span class="comment"># only "explode" the 2nd slice (i.e. 'Hogs')</span></span><br><span class="line"></span><br><span class="line">plt.pie(sizes, explode=explode, labels=labels, colors=colors,</span><br><span class="line">        autopct=<span class="string">'%1.1f%%'</span>, shadow=<span class="literal">True</span>, startangle=<span class="number">90</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><div class="figure"><img src="output_18_0.png" alt="png"><p class="caption">png</p></div><h4 id="表格">表格</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.table(cellText=data,rowLabels=rows,colLabels=columns,loc=<span class="string">'bottom'</span>,bbox=[<span class="number">0.25</span>, <span class="number">-0.5</span>, <span class="number">0.5</span>, <span class="number">0.3</span>])</span><br></pre></td></tr></table></figure><p>cellText: 表格中的数据 [n_rows,n_colums] rowLabels: 行标签 collabels: 列标签 loc: 相对于图表的位置，top,right,left,bottom bbox: 边距</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Demo of table function to display a table within a plot.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">data = [[  <span class="number">100</span>,  <span class="number">200</span>,   <span class="number">300</span>  ],</span><br><span class="line">        [  <span class="number">200</span>,  <span class="number">100</span>,   <span class="number">50</span>   ],</span><br><span class="line">        [  <span class="number">40</span>,   <span class="number">200</span>,  <span class="number">100</span>   ],</span><br><span class="line">        [  <span class="number">100</span>,   <span class="number">200</span>,  <span class="number">300</span>  ]]</span><br><span class="line">y = np.array(data)</span><br><span class="line">y = y.reshape(<span class="number">1</span>,<span class="number">-1</span>)</span><br><span class="line">columns = (<span class="string">'Freeze'</span>, <span class="string">'Wind'</span>, <span class="string">'Flood'</span>, <span class="string">'Quake'</span>, <span class="string">'Hail'</span>)</span><br><span class="line">rows = [<span class="string">'%d year'</span> % x <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">50</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a table at the bottom of the axes</span></span><br><span class="line">the_table = plt.table(cellText=data,</span><br><span class="line">                      rowLabels=rows,</span><br><span class="line">                      colLabels=columns,</span><br><span class="line">                      loc=<span class="string">'bottom'</span>,</span><br><span class="line">                      bbox=[<span class="number">0.25</span>, <span class="number">-0.5</span>, <span class="number">0.5</span>, <span class="number">0.3</span>])</span><br><span class="line"></span><br><span class="line">plt.plot([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><div class="figure"><img src="output_20_0.png" alt="png"><p class="caption">png</p></div><h4 id="极坐标下绘图">极坐标下绘图</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ax = plt.subplot(211, projection=&apos;polar&apos;)</span><br><span class="line">ax.plot(theta, r, color=&apos;r&apos;, linewidth=3)</span><br></pre></td></tr></table></figure><p>projection=‘polar’ 指定是极坐标 theta： 横坐标 r: 纵坐标</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Demo of a line plot on a polar axis.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r = np.arange(<span class="number">0</span>, <span class="number">3.0</span>, <span class="number">0.01</span>)</span><br><span class="line">theta = <span class="number">2</span> * np.pi * r</span><br><span class="line"></span><br><span class="line">ax = plt.subplot(<span class="number">211</span>, projection=<span class="string">'polar'</span>)</span><br><span class="line">ax.plot(theta, r, color=<span class="string">'r'</span>, linewidth=<span class="number">3</span>)</span><br><span class="line">ax.set_rmax(<span class="number">2.0</span>)</span><br><span class="line">ax.grid(<span class="literal">True</span>)</span><br><span class="line">ax.set_title(<span class="string">"A line plot on a polar axis"</span>, va=<span class="string">'bottom'</span>)</span><br><span class="line"></span><br><span class="line">ax2 = plt.subplot(<span class="number">212</span>)</span><br><span class="line">ax2.plot(theta,r,color=<span class="string">'g'</span>,linewidth=<span class="number">2</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><div class="figure"><img src="output_22_0.png" alt="png"><p class="caption">png</p></div><h3 id="颜色colormaps">颜色（Colormaps）</h3><h3 id="动画animation">动画（animation）</h3><ul><li><code>import matplotlib.animation as animation</code></li><li><code>animation.FuncAnimation(fig1, update_line, num, fargs=(data, l), interval=200, blit=True,repeat=False)</code></li><li><code>FuncAnimation</code>是根据自定义函数生成动画的一个接口，</li><li><code>fig1</code> 是画布，用<code>plt.figure()</code>生成</li><li><code>uodate_line</code> 是更新图像的函数，一般返回的是一个<code>2D</code>或者<code>3D</code>的<code>line</code>对象，<code>FuncAnimation</code>会自动循环调用该函数设置图像显示的line,以达到动画的效果。</li><li><code>num</code>是传入<code>update_line</code>的第一个参数，该参数会从0开始每次递增1，直到结束。</li><li><code>fargs</code>可以传入额外的参数，这里我的<code>update_line</code>有三个参数，第一个是<code>num</code>,第二个和第三个就是靠指定<code>fargs</code>参数传入进去的，通过fargs传递的参数不会自动递增。</li><li><code>interval</code> 指定调用<code>update_line</code>的间隔，就是动画间隔</li><li><code>repeat</code> 设置动画播放完后是否重复</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.animation <span class="keyword">as</span> animation</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_line</span><span class="params">(num, data, line)</span>:</span></span><br><span class="line">    xxdata = data</span><br><span class="line">    yydata = <span class="number">4</span> * data + num</span><br><span class="line">    line.set_xdata(xxdata)</span><br><span class="line">    line.set_ydata(yydata)</span><br><span class="line">    <span class="keyword">return</span> line,</span><br><span class="line"></span><br><span class="line">fig1 = plt.figure()</span><br><span class="line">data = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">l, = plt.plot([], [], <span class="string">'r-'</span>)</span><br><span class="line">plt.xlim(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">plt.ylim(<span class="number">1</span>,<span class="number">30</span>)</span><br><span class="line">plt.xlabel(<span class="string">'x'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'y'</span>)</span><br><span class="line">plt.title(<span class="string">'test'</span>)</span><br><span class="line">line_ani = animation.FuncAnimation(fig1, update_line, <span class="number">25</span>, fargs=(data, l),</span><br><span class="line">                                   interval=<span class="number">200</span>, blit=<span class="literal">True</span>,repeat=<span class="literal">False</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><div class="figure"><img src="output_25_0.png" alt="png"><p class="caption">png</p></div><h3 id="配色">配色</h3><p>不同种类的颜色，渐变色等的搭配，可以从<a href="http://colorbrewer2.org" target="_blank" rel="noopener">这里</a>生成。</p><h2 id="统计绘图seaborn">统计绘图(seaborn)</h2><p>需要各种带有统计量的图形的时候，一种选择是自己计算各种统计量，然后使用Matplotlib手动绘制，另外一种方法就是使用专门用来绘制统计图形的工具，好处是不需要自己计算各种统计量，只需要传入原始的数据，工具包会自己计算需要的统计量。一个比较流行的统计绘图工具是<a href="http://seaborn.pydata.org/" target="_blank" rel="noopener">seaborn</a>.</p><h3 id="箱线图">箱线图</h3><p>反应数据分布规律的一种图形，可以把数据的中位数，四分位数等都显示在一张图上。使用来观察数据分布的较好方法。图形类似下面这样。</p><div class="figure"><img src="boxplot.png"></div><p><code>seaborn</code>自带的函数支持<code>pandas.DataFrame</code>格式的数据，所以使用起来非常方便。但是如果想要把两个DataFrame每一列的数据作为对比，制作成箱线图，<code>seaborn</code>并没有提供这样的方法，需要修改DataFrame的格式，使之符合要求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotBox</span><span class="params">(self,dflist,palette=<span class="string">"Set3"</span>,rotation=<span class="number">45</span>)</span>:</span></span><br><span class="line">       <span class="string">"""</span></span><br><span class="line"><span class="string">       绘制箱线图</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       Parameters</span></span><br><span class="line"><span class="string">       ----------</span></span><br><span class="line"><span class="string">       dflist : list of pandas.DataFrame, each of the DataFrame as a class and will be plot together</span></span><br><span class="line"><span class="string">       pallette : pallette in sns</span></span><br><span class="line"><span class="string">       rotation : x_lable rotation to show whole word</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       """</span></span><br><span class="line">       sdata =pd.Series()</span><br><span class="line">       sxx = pd.Series()</span><br><span class="line">       slabel = pd.Series()</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> range(len(dflist)):</span><br><span class="line">           pdd = dflist[i]</span><br><span class="line">           columns = pdd.columns.values</span><br><span class="line">           ds = pd.Series([i+<span class="number">1</span>]*(pdd.shape[<span class="number">0</span>]*pdd.shape[<span class="number">1</span>]))</span><br><span class="line">           slabel = slabel.append(ds)</span><br><span class="line">           <span class="keyword">for</span> cc <span class="keyword">in</span> columns:</span><br><span class="line">               sdata = sdata.append(pdd[cc])</span><br><span class="line">               sxx = sxx.append(pd.Series([cc]*len(pdd[cc])))</span><br><span class="line"></span><br><span class="line">       snsdata = pd.DataFrame(&#123;<span class="string">"y"</span>:sdata.values,<span class="string">"x"</span>:sxx.values,<span class="string">"label"</span>:slabel&#125;)</span><br><span class="line">       sns.set(style=<span class="string">"ticks"</span>)</span><br><span class="line">       ax = sns.boxplot(data=snsdata,x=<span class="string">'x'</span>,y=<span class="string">'y'</span>,hue=<span class="string">'label'</span>,palette=palette)</span><br><span class="line">       ax.set_xticklabels(ax.xaxis.get_ticklabels(), rotation=rotation)</span><br><span class="line">       sns.despine(offset=<span class="number">10</span>, trim=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="矩阵可视化">矩阵可视化</h3><p>把矩阵的值作为颜色的取值，可视化的表示出矩阵的情况。图形类似下面这样：</p><div class="figure"><img src="heatmap.jpg"></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">sns.set(context=<span class="string">"paper"</span>, font=<span class="string">"monospace"</span>,palette=<span class="string">"Set3"</span>)</span><br><span class="line">f, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line"><span class="comment"># Draw the heatmap using seaborn</span></span><br><span class="line">sns.heatmap(matrix, vmax=<span class="number">.8</span>,square=<span class="literal">True</span>,annot=<span class="literal">True</span>, fmt=<span class="string">".1f"</span>,linewidths=<span class="number">.5</span>)</span><br><span class="line">ax.set_xticklabels(ax.xaxis.get_ticklabels(), rotation=<span class="number">90</span>)</span><br><span class="line">ax.set_yticklabels(ax.yaxis.get_ticklabels(), rotation=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="牛逼的绘图">牛逼的绘图</h2><p>http://www.bugman123.com/index.html</p><h2 id="参考文献">参考文献</h2><ol style="list-style-type: decimal"><li>https://www.zhihu.com/question/21664179</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bootsharp学习笔记</title>
      <link href="/hexoblog/2016/06/30/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF_bootsharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/hexoblog/2016/06/30/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF_bootsharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="bootstrap.png" alt="bootstrap"> <a id="more"></a> # 简介</p><p>Bootstrap 是一个用于快速开发 Web 应用程序和网站的前端框架。Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的。 Bootstrap，来自 Twitter，是目前最受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的，它简洁灵活，使得 Web 开发更加快捷。</p><h1 id="安装">安装</h1><p>从 http://getbootstrap.com/ 上下载 Bootstrap 的最新版本。 - • <code>Download Bootstrap</code>：下载 Bootstrap。点击该按钮，您可以下载 Bootstrap CSS、JavaScript 和字体的预编译的压缩版本。不包含文档和最初的源代码文件。 - • <code>Download Source</code>：下载源代码。点击该按钮，您可以直接从 from 上得到最新的 Bootstrap LESS 和 JavaScript 源代码。</p><h1 id="使用">使用</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>在线尝试 Bootstrap 实例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"/bootstrap/css/bootstrap.min.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/scripts/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/bootstrap/js/bootstrap.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解释说明： 1. Bootstrap 使用了一些 HTML5 元素和 CSS 属性。为了让这些正常工作，您需要使用 HTML5 文档类型（Doctype）。因此，请在使用 Bootstrap 项目的开头包含下面的代码段。 <code>&lt;!DOCTYPE html&gt;</code> 2. bootstrap 不需要任何安装部署 和 开发环境，只需要包含以下几个文件： <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"/bootstrap/css/bootstrap.min.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/scripts/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/bootstrap/js/bootstrap.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>就可以使用bootstrap的各种效果了。 3. Bootstrap 3 的设计目标是移动设备优先，然后才是桌面设备。 为了让 Bootstrap 开发的网站对移动设备友好，确保适当的绘制和触屏缩放，需要在网页的 head 之中添加 viewport meta 标签，如下所示： <code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</code> 注释： - <code>initial-scale=1.0</code> 确保网页加载时，以 1:1 的比例呈现，不会有任何的缩放。 - 在移动设备浏览器上，通过为 <code>viewport meta</code> 标签添加 <code>user-scalable=no</code> 可以禁用其缩放（zooming）功能。通常情况下，<code>maximum-scale=1.0</code> 与 <code>user-scalable=no</code> 一起使用。这样禁用缩放功能后，用户只能滚动屏幕，就能让您的网站看上去更像原生应用的感觉。 - 移动设备通常使用的meta标签：<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;&gt;</code></p><h2 id="响应式图像">响应式图像</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"img-responsive"</span> <span class="attr">alt</span>=<span class="string">"Responsive image"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过添加为<code>img</code>标签添加<code>class=&quot;img-responsive&quot;</code>可以使图像的响应式布局更友好。 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.img-responsive &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  height: auto;</span><br><span class="line">  max-width: 100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Bootstrap 的css中的<code>img-responsive</code>是这样写的，保证了响应式布局。从这里可以看出，bootstrap做的事情其实就是定义了一些css类的样式，你只要包含这些文件，就能直接使用这些样式，而这些样式是经过精心设计的，保证了满足响应式布局的需要。</p><h2 id="网格系统">网格系统</h2><p>Bootstrap 响应式的网格系统可以根据设备大小进行灵活的适应，保证内容的显示效果。 Bootstrap的网格系统将屏幕分为12列，在定义每一列的时候，可以指定一个数字，代表占用几列，bootstrap 自动用相应的比例显示他们。 <code>&lt;div class=&quot;container&quot;&gt;...&lt;/div&gt;</code> 元素被添加，确保居中和最大宽度。 一旦添加了容器，接下来您需要考虑以行为单位。添加<code>&lt;div class=&quot;row&quot;&gt;...&lt;/div&gt;</code>，并在行内添加列 <code>&lt;div class=&quot;col-md-6&quot;&gt;&lt;/div&gt;</code>。 有两个列，每个列由 6 个单元组成，即 6+6=12。 在大型设备显示时修改布局： <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-6 col-lg-4"</span>&gt;</span>....<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-6 col-lg-8"</span>&gt;</span>....<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这样，当在middle设备上显示时，会显示col-md-6这个Class，在large设备上显示时，会显示col-g-4这个Class。 所以，在中型设备上，两列宽度是1：1，在大型设备上，两列宽度是2：3. <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-sm-3 col-md-6 col-lg-4"</span>&gt;</span>....<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-sm-9 col-md-6 col-lg-8"</span>&gt;</span>....<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>同理，如果这样设置，就能实现在小型、中型、大型设备上以不同的比例显示列。</p><p>响应式的列重置： <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-xs-6 col-sm-3"</span></span></span><br><span class="line">&lt;div class="col-xs-6 col-sm-3"</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clearfix visible-xs"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-xs-6 col-sm-3"</span></span></span><br><span class="line">&lt;div class="col-xs-6 col-sm-3"</span><br></pre></td></tr></table></figure></p><p>当屏幕足够大时，四列同宽（3:3:3:3），显示在同一行；当不够宽时，分两行显示，第一行显示前两列，第二行显示后两列。宽度是（6：6） 偏移列： <code>&lt;div class=&quot;col-xs-6 col-md-offset-3&quot;</code>偏移3列，占据6列，右边还剩3列，所以这句的效果就是 居中。 嵌套： <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-3"</span></span></span><br><span class="line">       &lt;div class="col-md-9"</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-6"</span></span></span><br><span class="line">   &lt;div class="col-md-6"</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-6"</span></span></span><br><span class="line">    &lt;div class="col-md-6"</span><br></pre></td></tr></table></figure></p><p>这样就能嵌套出这样的一个表格： <img src="1.png" alt="1"></p><p>列排序： 1. <code>&lt;div class=&quot;col-md-4 col-md-push-8&quot;</code> 2. <code>&lt;div class=&quot;col-md-8 col-md-pull-4&quot;</code> 第一列占四列，第二列占8列，这样显示出来是左变窄，右边宽的一个布局。我们可以通过col-md-push-8 和col-md-pull-4 改变这两列的显示顺序，形成左边宽，右边窄的布局。Push-8 的意思就是将占8行的列提前，pull-4的意思就是将占4行的列退后。</p><h2 id="响应式表格">响应式表格</h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bootsharp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JQuery EasyUI 学习笔记</title>
      <link href="/hexoblog/2016/06/30/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF_jQuery-EasyUI-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/hexoblog/2016/06/30/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF_jQuery-EasyUI-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="easyUI0.png" alt="easyUI0.png"> <a id="more"></a></p><h1 id="安装">安装</h1><p>下载<a href="http://www.jeasyui.com/index.php" target="_blank" rel="noopener">jquery EasyUI</a> 安装包 <img src="easyUI.png" alt="easyUI"> 解压缩之后的目录结构为 <img src="structure.png" alt="structure"> 要使用easyui只需要在HTML页面包含 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"themes/default/easyui.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"jquery.easyui.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>指定下载的文件的位置就可以直接使用里面定义好的控件了。</p><h1 id="主要内容">主要内容</h1><ol style="list-style-type: decimal"><li><p>网格系统 表头： <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>第一列<span class="tag">&lt;/<span class="name">td</span>&gt;</span>  <span class="tag">&lt;<span class="name">td</span>&gt;</span>第二列<span class="tag">&lt;/<span class="name">td</span>&gt;</span>  <span class="tag">&lt;<span class="name">td</span>&gt;</span>第三列<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>表体: <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>第一列<span class="tag">&lt;/<span class="name">td</span>&gt;</span>  <span class="tag">&lt;<span class="name">td</span>&gt;</span>第二列<span class="tag">&lt;/<span class="name">td</span>&gt;</span>  <span class="tag">&lt;<span class="name">td</span>&gt;</span>第三列<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br></pre></td></tr></table></figure></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jquery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP读写XLS</title>
      <link href="/hexoblog/2016/06/23/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_PHP%E8%AF%BB%E5%86%99XLS/"/>
      <url>/hexoblog/2016/06/23/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_PHP%E8%AF%BB%E5%86%99XLS/</url>
      
        <content type="html"><![CDATA[<p><img src="phpexcel.png" alt="phpexcel"> <a id="more"></a></p><h2 id="php实现读取和生成xls文件">PHP实现读取和生成XLS文件</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">read_xls</span><span class="params">()</span></span>&#123;</span><br><span class="line">       $file = <span class="string">"D:/TaskHistory/123/template.xls"</span>;</span><br><span class="line">       vendor(<span class="string">"PHPEXCEL\PHPExcel"</span>);</span><br><span class="line">       vendor(<span class="string">"PHPEXCEL\PHPExcel\IOFactory"</span>);</span><br><span class="line">       $excel = <span class="keyword">new</span> \PHPExcel();</span><br><span class="line">       date_default_timezone_set(<span class="string">'Asia/ShangHai'</span>);</span><br><span class="line">       <span class="keyword">if</span> (!file_exists($file)) &#123;</span><br><span class="line">           <span class="keyword">exit</span>(<span class="string">"not found 31excel5.xls.\n"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       $reader = \PHPExcel_IOFactory::createReader(<span class="string">'Excel5'</span>); <span class="comment">//设置以Excel5格式(Excel97-2003工作簿)</span></span><br><span class="line">       $PHPExcel = $reader-&gt;load($file); <span class="comment">// 载入excel文件</span></span><br><span class="line">       $sheet = $PHPExcel-&gt;getSheet(<span class="number">0</span>); <span class="comment">// 读取第一个工作表</span></span><br><span class="line">       $highestRow = $sheet-&gt;getHighestRow(); <span class="comment">// 取得总行数</span></span><br><span class="line">       $highestColumm = $sheet-&gt;getHighestColumn(); <span class="comment">// 取得总列数</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">/** 循环读取每个单元格的数据 */</span></span><br><span class="line">       <span class="keyword">for</span> ($row = <span class="number">1</span>; $row &lt;= $highestRow; $row++)&#123;<span class="comment">//行数是以第1行开始</span></span><br><span class="line">           <span class="keyword">for</span> ($column = <span class="string">'A'</span>; $column &lt;= $highestColumm; $column++) &#123;<span class="comment">//列数是以A列开始</span></span><br><span class="line">               $value =  $sheet-&gt;getCell($column.$row)-&gt;getValue();</span><br><span class="line">               $dataset[$row<span class="number">-1</span>][] = $sheet-&gt;getCell($column.$row)-&gt;getValue();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       dump($dataset);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">write_xls</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       $file = <span class="string">"D:/TaskHistory/123/bak.xls"</span>;</span><br><span class="line">       vendor(<span class="string">"PHPEXCEL\PHPExcel"</span>);</span><br><span class="line">       vendor(<span class="string">"PHPEXCEL\PHPExcel\IOFactory"</span>);</span><br><span class="line">       $product = D(<span class="string">'product'</span>);</span><br><span class="line">       $data = $product-&gt;Relation(<span class="keyword">true</span>)-&gt;select();</span><br><span class="line">       $objPHPExcel = <span class="keyword">new</span> \PHPExcel();</span><br><span class="line">       <span class="comment">/*以下是一些设置 ，什么作者  标题啊之类的*/</span></span><br><span class="line">       $objPHPExcel-&gt;getProperties()-&gt;setCreator(<span class="string">"转弯的阳光"</span>)</span><br><span class="line">           -&gt;setLastModifiedBy(<span class="string">"转弯的阳光"</span>)</span><br><span class="line">           -&gt;setTitle(<span class="string">"数据EXCEL导出"</span>)</span><br><span class="line">           -&gt;setSubject(<span class="string">"数据EXCEL导出"</span>)</span><br><span class="line">           -&gt;setDescription(<span class="string">"备份数据"</span>)</span><br><span class="line">           -&gt;setKeywords(<span class="string">"excel"</span>)</span><br><span class="line">           -&gt;setCategory(<span class="string">"result file"</span>);</span><br><span class="line">           <span class="comment">//设置标题</span></span><br><span class="line">           $objPHPExcel-&gt;setActiveSheetIndex(<span class="number">0</span>)</span><br><span class="line">                       -&gt;setCellValue(<span class="string">'A'</span> . <span class="number">1</span>, <span class="string">'品种'</span>)</span><br><span class="line">                       -&gt;setCellValue(<span class="string">'B'</span> . <span class="number">1</span>, <span class="string">'材质'</span>)</span><br><span class="line">                       -&gt;setCellValue(<span class="string">'C'</span> . <span class="number">1</span>, <span class="string">'规格'</span>)</span><br><span class="line">                       -&gt;setCellValue(<span class="string">'D'</span> . <span class="number">1</span>, <span class="string">'宽'</span>)</span><br><span class="line">                       -&gt;setCellValue(<span class="string">'E'</span> . <span class="number">1</span>, <span class="string">'长'</span>)</span><br><span class="line">                       -&gt;setCellValue(<span class="string">'F'</span> . <span class="number">1</span>, <span class="string">'生产厂家'</span>)</span><br><span class="line">                       -&gt;setCellValue(<span class="string">'G'</span> . <span class="number">1</span>, <span class="string">'交货地点'</span>)</span><br><span class="line">                       -&gt;setCellValue(<span class="string">'H'</span> . <span class="number">1</span>, <span class="string">'交货仓库'</span>)</span><br><span class="line">                       -&gt;setCellValue(<span class="string">'I'</span> . <span class="number">1</span>, <span class="string">'价格（元/吨）'</span>)</span><br><span class="line">                       -&gt;setCellValue(<span class="string">'G'</span> . <span class="number">1</span>, <span class="string">'重量（吨）'</span>)</span><br><span class="line">                       -&gt;setCellValue(<span class="string">'K'</span> . <span class="number">1</span>, <span class="string">'计重方式'</span>)</span><br><span class="line">                       -&gt;setCellValue(<span class="string">'L'</span> . <span class="number">1</span>, <span class="string">'备注'</span>);</span><br><span class="line">           <span class="keyword">foreach</span> ($data <span class="keyword">as</span> $k =&gt; $v) &#123;</span><br><span class="line">               $num = $k + <span class="number">2</span>;</span><br><span class="line">               $objPHPExcel-&gt;setActiveSheetIndex(<span class="number">0</span>)</span><br><span class="line">                   <span class="comment">//Excel的第A列，uid是你查出数组的键值，下面以此类推</span></span><br><span class="line">                   -&gt;setCellValue(<span class="string">'A'</span> . $num, $v[<span class="string">'product_id'</span>])</span><br><span class="line">                   -&gt;setCellValue(<span class="string">'B'</span> . $num, $v[<span class="string">'product_name'</span>])</span><br><span class="line">                   -&gt;setCellValue(<span class="string">'C'</span> . $num, $v[<span class="string">'product_price'</span>]);</span><br><span class="line">               <span class="comment">//这里添加要加入进去的数据，我没写完</span></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       $objPHPExcel-&gt;getActiveSheet()-&gt;setTitle(<span class="string">'User'</span>);</span><br><span class="line">       $objPHPExcel-&gt;setActiveSheetIndex(<span class="number">0</span>);</span><br><span class="line">       header(<span class="string">'Content-Type: application/vnd.ms-excel'</span>);</span><br><span class="line">       header(<span class="string">'Content-Disposition: attachment;filename="'</span> . $file . <span class="string">'.xls"'</span>);</span><br><span class="line">       header(<span class="string">'Cache-Control: max-age=0'</span>);</span><br><span class="line">       $objWriter = \PHPExcel_IOFactory::createWriter($objPHPExcel, <span class="string">'Excel5'</span>);</span><br><span class="line">       $objWriter-&gt;save(<span class="string">'php://output'</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark环境下的Kmeans-Python实现</title>
      <link href="/hexoblog/2016/06/23/%E6%8A%80%E6%9C%AF/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE_Spark%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84Kmeans-Python%E5%AE%9E%E7%8E%B0/"/>
      <url>/hexoblog/2016/06/23/%E6%8A%80%E6%9C%AF/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE_Spark%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84Kmeans-Python%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="spark.png" alt="spark"> <a id="more"></a> <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#设置应用名称，显示在spark监控页面上</span><br><span class="line">sc = <span class="type">SparkContext</span>(appName=<span class="string">"MySparkApplication"</span>)</span><br><span class="line"></span><br><span class="line">#读取数据,data文件夹下有<span class="number">6</span>个数据文件，这样写能全部读取，需要注意的是，在其他worker的相同路径下也需要有这些文件</span><br><span class="line">lines = sc.textFile(<span class="string">"/home/fei/sparkcode/data/"</span>)</span><br><span class="line"></span><br><span class="line">#原来的数据使用<span class="type">TAB</span>分割的，现在把它转换成python中list形式</span><br><span class="line">data = lines.map(lambda x:x.split('\t'))</span><br><span class="line"></span><br><span class="line">#定义一个函数，将源文件中用字母数字表示的天数化成数字，转换后的格式为天数<span class="number">0</span><span class="number">-48</span>，网站<span class="number">0</span><span class="number">-9</span>。</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dayToNum</span></span>(data):</span><br><span class="line">    list1 = []</span><br><span class="line">    list1.append(data[<span class="number">0</span>])</span><br><span class="line">    strs = data[<span class="number">1</span>]</span><br><span class="line">    day = (int(strs[<span class="number">1</span>])<span class="number">-1</span>)*<span class="number">7</span> + int(strs[<span class="number">3</span>])<span class="number">-1</span></span><br><span class="line">    list1.append(day)</span><br><span class="line">    sitestr = data[<span class="number">2</span>]</span><br><span class="line">    site = int(sitestr[<span class="number">1</span>:])<span class="number">-1</span></span><br><span class="line">    list1.append(site)</span><br><span class="line">    list1.append(int(data[<span class="number">3</span>]))</span><br><span class="line">    <span class="keyword">return</span> list1</span><br><span class="line"></span><br><span class="line">#使用定义的函数转换data中的数据</span><br><span class="line">data2 = data.map(dayToNum)</span><br><span class="line"></span><br><span class="line">#合并相同用户的数据，一个用户占一条记录</span><br><span class="line">data4 = data3.reduceByKey(lambda v1,v2:list(map(lambda x: x[<span class="number">0</span>]+x[<span class="number">1</span>], zip(v2, v1))))</span><br><span class="line">#保存合并后的数据，从这个数据能够知道有多少个用户，该用户<span class="number">7</span>周对<span class="number">10</span>个网站的点击情况是什么，保存下来便于以后需要直接处理</span><br><span class="line">data4.saveAsTextFile(<span class="string">"/home/fei/combinedData"</span>)</span><br><span class="line">#为kmeans聚类准备数据</span><br><span class="line">data5 = data4.map(lambda x:np.array(x[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">#设置kmeans参数：<span class="type">K</span>=<span class="number">100</span>，initializationMode=<span class="string">"k-means||"</span></span><br><span class="line">k = <span class="number">100</span></span><br><span class="line">mode = <span class="string">"k-means||"</span></span><br><span class="line"></span><br><span class="line">#开始kmeans聚类</span><br><span class="line">model = <span class="type">KMeans</span>.train(data5,k,initializationMode=mode)</span><br><span class="line">#保存聚类结果</span><br><span class="line">output = open('/home/fei/kmeans_result.txt', 'w')</span><br><span class="line">output.write(<span class="string">"Final centers: "</span> + str(model.clusterCenters))</span><br><span class="line">output.write(<span class="string">"Final centers: "</span> + str(model.clusterCenters))</span><br><span class="line">output.close()</span><br><span class="line"></span><br><span class="line">#输出聚类结果</span><br><span class="line">print(<span class="string">"Final centers: "</span> + str(model.clusterCenters))</span><br><span class="line">print(<span class="string">"Total Cost: "</span> + str(model.computeCost(data5)))</span><br><span class="line"></span><br><span class="line">#聚类完成后，预测每个用户的聚类类别<span class="type">ID</span>：#reduceByKey会对相同key的记录进行reduce，这里将类别作为key,便于依据类别分别处理</span><br><span class="line">belongs= data5.map(lambda x:(model.predict(x),(list)(x)))</span><br><span class="line"></span><br><span class="line">#为线性回归准备训练数据</span><br><span class="line">data6 = belongs.map(lambda x: (x[<span class="number">0</span>],np.array(x[<span class="number">1</span>]).reshape(<span class="number">8</span>,<span class="number">7</span>,<span class="number">10</span>))).cache()</span><br><span class="line">data00 = data6.map(lambda x:x[<span class="number">1</span>]).map(lambda x:x[:,<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line">data_train = data00.map(lambda x : <span class="type">LabeledPoint</span>(x[<span class="number">6</span>],x[:<span class="number">6</span>]))</span><br><span class="line"></span><br><span class="line">#开始训练</span><br><span class="line">model = <span class="type">LinearRegressionWithSGD</span>.train(data_train)</span><br><span class="line"></span><br><span class="line">#预测并保存预测结果</span><br><span class="line">result = model.predict(data[<span class="number">1</span>][<span class="number">1</span>:<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line">result.saveAsTextFile('/home/fei/lines')</span><br><span class="line"></span><br><span class="line">#停止程序</span><br><span class="line">sc.stop()</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>改进PHP的var_dump()方法使之适应显示从数据库中查出来的数据</title>
      <link href="/hexoblog/2016/06/23/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_%E6%94%B9%E8%BF%9BPHP%E7%9A%84var-dump-%E6%96%B9%E6%B3%95%E4%BD%BF%E4%B9%8B%E9%80%82%E5%BA%94%E6%98%BE%E7%A4%BA%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%9F%A5%E5%87%BA%E6%9D%A5%E7%9A%84%E6%95%B0%E6%8D%AE/"/>
      <url>/hexoblog/2016/06/23/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_%E6%94%B9%E8%BF%9BPHP%E7%9A%84var-dump-%E6%96%B9%E6%B3%95%E4%BD%BF%E4%B9%8B%E9%80%82%E5%BA%94%E6%98%BE%E7%A4%BA%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%9F%A5%E5%87%BA%E6%9D%A5%E7%9A%84%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p>改进PHP的var_dump使之拥有良好的显示格式。 <a id="more"></a> <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * array(7) &#123;</span></span><br><span class="line"><span class="comment">[0] =&gt; array(32) &#123;</span></span><br><span class="line"><span class="comment">["order_id"] =&gt; string(2) "34"</span></span><br><span class="line"><span class="comment">["shipping_time"] =&gt; string(1) "0"</span></span><br><span class="line"><span class="comment">["created_at"] =&gt; string(10) "1433565988"</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">[1] =&gt; array(32) &#123;</span></span><br><span class="line"><span class="comment">["order_id"] =&gt; string(2) "35"</span></span><br><span class="line"><span class="comment">["shipping_time"] =&gt; string(1) "0"</span></span><br><span class="line"><span class="comment">["created_at"] =&gt; string(10) "1433573933"</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">[2] =&gt; array(32) &#123;</span></span><br><span class="line"><span class="comment">["order_id"] =&gt; string(2) "36"</span></span><br><span class="line"><span class="comment">["order_sn"] =&gt; string(9) "BJA000036"</span></span><br><span class="line"><span class="comment">["wx_trade_no"] =&gt; string(32) "wx712cd30713b968c114336440083628"</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> * 形如上面这样的数组，使用var_dump()函数打印的时候会打印出所有的数据项，尤其是在数据库字段较多的情况下，</span></span><br><span class="line"><span class="comment"> * 不便于找到自己感兴趣的数据。</span></span><br><span class="line"><span class="comment"> * 本方法改进了var_dump()方法，可以指定要打印的键。例如想看从order表中查处的order_id和city_id,</span></span><br><span class="line"><span class="comment"> * 可以这样使用：du($order,['order_id','city_id'])</span></span><br><span class="line"><span class="comment"> * 输出如下格式：</span></span><br><span class="line"><span class="comment"> *array[7] &#123;</span></span><br><span class="line"><span class="comment">[0] =&gt;array[32] &#123;</span></span><br><span class="line"><span class="comment">[order_id] =&gt; string(2) : 34</span></span><br><span class="line"><span class="comment">[city_id] =&gt; string(1) : 0</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">[1] =&gt;array[32] &#123;</span></span><br><span class="line"><span class="comment">[order_id] =&gt; string(2) : 35</span></span><br><span class="line"><span class="comment">[city_id] =&gt; string(1) : 0</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">[2] =&gt;array[32] &#123;</span></span><br><span class="line"><span class="comment">[order_id] =&gt; string(2) : 36</span></span><br><span class="line"><span class="comment">[city_id] =&gt; string(1) : 0</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">[3] =&gt;array[32] &#123;</span></span><br><span class="line"><span class="comment">[order_id] =&gt; string(2) : 37</span></span><br><span class="line"><span class="comment">[city_id] =&gt; string(1) : 0</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $data 要显示结构的变量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $keys 要显示的键，为空则显示所有的键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $echo 是否输出结果到浏览器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">du</span><span class="params">($data,$keys=<span class="string">''</span>,$echo=true)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $message = <span class="string">""</span>;</span><br><span class="line">    $message .= gettype($data) . <span class="string">"["</span> . count($data) . <span class="string">"] &#123;"</span> . <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">    <span class="keyword">foreach</span> ($data <span class="keyword">as</span> $cc =&gt; $c) &#123;</span><br><span class="line">        $message .= <span class="string">" ["</span> . $cc . <span class="string">"] =&gt;"</span> . gettype($c) . <span class="string">"["</span> . count($c) . <span class="string">"] &#123;"</span> . <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">        <span class="keyword">foreach</span> ($c <span class="keyword">as</span> $key =&gt; $value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">empty</span>($keys)) &#123;</span><br><span class="line">                $message .= <span class="string">"  ["</span> . $key . <span class="string">"]"</span> . <span class="string">" =&gt; "</span> . gettype($value) . <span class="string">"("</span> . strlen($value) . <span class="string">")"</span> . <span class="string">" : "</span>.$value;</span><br><span class="line">                $message .= <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (in_array($key, $keys)) &#123;</span><br><span class="line">                $message .= <span class="string">"  ["</span> . $key . <span class="string">"]"</span> . <span class="string">" =&gt; "</span> . gettype($value) . <span class="string">"("</span> . strlen($value) . <span class="string">")"</span> . <span class="string">" : "</span>.$value;</span><br><span class="line">                $message .= <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        $message .= <span class="string">"  &#125;"</span>;</span><br><span class="line">        $message .= <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    $message .= <span class="string">"&#125;"</span>;</span><br><span class="line">    <span class="keyword">if</span> ($echo) &#123;</span><br><span class="line">        <span class="keyword">echo</span> $message;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $a = str_replace(<span class="string">"&lt;br&gt;"</span>,<span class="string">"\r\n"</span>,$message);</span><br><span class="line">        $a = str_replace(<span class="string">" "</span>,<span class="string">"  "</span>,$a);</span><br><span class="line">        <span class="keyword">return</span> $a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中英文对照</title>
      <link href="/hexoblog/2016/06/22/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/%E4%B8%AD%E8%8B%B1%E6%96%87%E5%AF%B9%E7%85%A7/"/>
      <url>/hexoblog/2016/06/22/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/%E4%B8%AD%E8%8B%B1%E6%96%87%E5%AF%B9%E7%85%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="机构">机构</h1><ol style="list-style-type: decimal"><li>The Chinese Academy of Sciences –中国科学院</li><li>National Aeronautics and Space Administration(NASA) –美国国家航空航天局</li><li>NASA Jet Propulsion Laboratory (NASA-JPL) – 美国国家航空航天局喷气推进实验室</li><li>University of Zurich – 苏黎世大学</li></ol><h1 id="杂志">杂志</h1><ol style="list-style-type: decimal"><li>科学杂志 –Science url:http://www.sciencemag.org/journals</li></ol><h1 id="fmri">FMRI</h1><p>VOI – Volume of Interest</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 认知神经科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_手写数字识别</title>
      <link href="/hexoblog/2016/06/20/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/"/>
      <url>/hexoblog/2016/06/20/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>MINIST 数据文件（http://yann.lecun.com/exdb/mnist/） <a id="more"></a> 数据读取参考教程（http://blog.csdn.net/dream_angel_z/article/details/50739817）</p><h1 id="读取数据保存成图片">读取数据保存成图片</h1><p>读取MINIST原始数据格式的工具函数，来源：http://blog.csdn.net/dream_angel_z/article/details/50739817 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Thu Feb 25 14:40:06 2016</span></span><br><span class="line"><span class="string">load MNIST dataset</span></span><br><span class="line"><span class="string">@author: liudiwei</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataUtils</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    MNIST数据集加载</span></span><br><span class="line"><span class="string">    输出格式为：numpy.array()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    使用方法如下</span></span><br><span class="line"><span class="string">    from data_util import DataUtils</span></span><br><span class="line"><span class="string">    def main():</span></span><br><span class="line"><span class="string">        trainfile_X = '../dataset/MNIST/train-images.idx3-ubyte'</span></span><br><span class="line"><span class="string">        trainfile_y = '../dataset/MNIST/train-labels.idx1-ubyte'</span></span><br><span class="line"><span class="string">        testfile_X = '../dataset/MNIST/t10k-images.idx3-ubyte'</span></span><br><span class="line"><span class="string">        testfile_y = '../dataset/MNIST/t10k-labels.idx1-ubyte'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        train_X = DataUtils(filename=trainfile_X).getImage()</span></span><br><span class="line"><span class="string">        train_y = DataUtils(filename=trainfile_y).getLabel()</span></span><br><span class="line"><span class="string">        test_X = DataUtils(testfile_X).getImage()</span></span><br><span class="line"><span class="string">        test_y = DataUtils(testfile_y).getLabel()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        #以下内容是将图像保存到本地文件中</span></span><br><span class="line"><span class="string">        #path_trainset = "../dataset/MNIST/imgs_train"</span></span><br><span class="line"><span class="string">        #path_testset = "../dataset/MNIST/imgs_test"</span></span><br><span class="line"><span class="string">        #if not os.path.exists(path_trainset):</span></span><br><span class="line"><span class="string">        #    os.mkdir(path_trainset)</span></span><br><span class="line"><span class="string">        #if not os.path.exists(path_testset):</span></span><br><span class="line"><span class="string">        #    os.mkdir(path_testset)</span></span><br><span class="line"><span class="string">        #DataUtils(outpath=path_trainset).outImg(train_X, train_y)</span></span><br><span class="line"><span class="string">        #DataUtils(outpath=path_testset).outImg(test_X, test_y)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        return train_X, train_y, test_X, test_y</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filename=None, outpath=None)</span>:</span></span><br><span class="line">        self._filename = filename</span><br><span class="line">        self._outpath = outpath</span><br><span class="line"></span><br><span class="line">        self._tag = <span class="string">'&gt;'</span></span><br><span class="line">        self._twoBytes = <span class="string">'II'</span></span><br><span class="line">        self._fourBytes = <span class="string">'IIII'</span></span><br><span class="line">        self._pictureBytes = <span class="string">'784B'</span></span><br><span class="line">        self._labelByte = <span class="string">'1B'</span></span><br><span class="line">        self._twoBytes2 = self._tag + self._twoBytes</span><br><span class="line">        self._fourBytes2 = self._tag + self._fourBytes</span><br><span class="line">        self._pictureBytes2 = self._tag + self._pictureBytes</span><br><span class="line">        self._labelByte2 = self._tag + self._labelByte</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getImage</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        将MNIST的二进制文件转换成像素特征数据</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        binfile = open(self._filename, <span class="string">'rb'</span>) <span class="comment">#以二进制方式打开文件</span></span><br><span class="line">        buf = binfile.read()</span><br><span class="line">        binfile.close()</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        numMagic,numImgs,numRows,numCols=struct.unpack_from(self._fourBytes2,\</span><br><span class="line">                                                                    buf,\</span><br><span class="line">                                                                    index)</span><br><span class="line">        index += struct.calcsize(self._fourBytes)</span><br><span class="line">        images = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numImgs):</span><br><span class="line">            imgVal = struct.unpack_from(self._pictureBytes2, buf, index)</span><br><span class="line">            index += struct.calcsize(self._pictureBytes2)</span><br><span class="line">            imgVal = list(imgVal)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(imgVal)):</span><br><span class="line">                <span class="keyword">if</span> imgVal[j] &gt; <span class="number">1</span>:</span><br><span class="line">                    imgVal[j] = <span class="number">1</span></span><br><span class="line">            images.append(imgVal)</span><br><span class="line">        <span class="keyword">return</span> np.array(images)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLabel</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        将MNIST中label二进制文件转换成对应的label数字特征</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        binFile = open(self._filename,<span class="string">'rb'</span>)</span><br><span class="line">        buf = binFile.read()</span><br><span class="line">        binFile.close()</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        magic, numItems= struct.unpack_from(self._twoBytes2, buf,index)</span><br><span class="line">        index += struct.calcsize(self._twoBytes2)</span><br><span class="line">        labels = [];</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(numItems):</span><br><span class="line">            im = struct.unpack_from(self._labelByte2,buf,index)</span><br><span class="line">            index += struct.calcsize(self._labelByte2)</span><br><span class="line">            labels.append(im[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> np.array(labels)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">outImg</span><span class="params">(self, arrX, arrY)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        根据生成的特征和数字标号，输出png的图像</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m, n = np.shape(arrX)</span><br><span class="line">        <span class="comment">#每张图是28*28=784Byte</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            img = np.array(arrX[i])</span><br><span class="line">            img = img.reshape(<span class="number">28</span>,<span class="number">28</span>)</span><br><span class="line">            outfile = str(i) + <span class="string">"_"</span> +  str(arrY[i]) + <span class="string">".png"</span></span><br><span class="line">            <span class="comment">#plt.imshow(img, cmap = 'binary') #将图像黑白显示</span></span><br><span class="line">            <span class="comment">#plt.savefig(self._outpath + "/" + outfile)</span></span><br><span class="line">            plt.imsave(self._outpath + <span class="string">"/"</span> + outfile, img, cmap=plt.cm.gray)</span><br></pre></td></tr></table></figure></p><p>读取数据并保存成图片输出到本地 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> data_utils <span class="keyword">import</span> DataUtils</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">'utf8'</span>) <span class="comment">#主要是解决编码不一致问题，没有问题这句可以不加</span></span><br><span class="line"></span><br><span class="line">trainfile_X = <span class="string">'D:/train-images.idx3-ubyte'</span></span><br><span class="line">trainfile_y = <span class="string">'D:/train-labels.idx1-ubyte'</span></span><br><span class="line">testfile_X = <span class="string">'D:/t10k-images.idx3-ubyte'</span></span><br><span class="line">testfile_y = <span class="string">'D:/t10k-labels.idx1-ubyte'</span></span><br><span class="line"></span><br><span class="line">train_X = DataUtils(filename=trainfile_X).getImage()</span><br><span class="line">train_y = DataUtils(filename=trainfile_y).getLabel()</span><br><span class="line">test_X = DataUtils(testfile_X).getImage()</span><br><span class="line">test_y = DataUtils(testfile_y).getLabel()</span><br><span class="line"></span><br><span class="line"><span class="comment">#以下内容是将图像保存到本地文件中</span></span><br><span class="line">path_trainset = <span class="string">"D:\imgs_train"</span></span><br><span class="line">path_testset = <span class="string">"D:\imgs_test"</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path_trainset):</span><br><span class="line">    os.mkdir(path_trainset)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path_testset):</span><br><span class="line">    os.mkdir(path_testset)</span><br><span class="line">DataUtils(outpath=path_trainset).outImg(train_X, train_y)</span><br><span class="line">DataUtils(outpath=path_testset).outImg(test_X, test_y)</span><br></pre></td></tr></table></figure></p><p>程序执行完成后会在本地保存好60000张训练图片和10000张测试图片 <img src="train_image.png" alt="train_image"> <img src="test_image.png" alt="test_image"></p><h1 id="加载数据">加载数据</h1><p>下面以这些图片作为原始数据，开始手写数字识别。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scikit-learn </tag>
            
            <tag> 手写数字识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_学习路线</title>
      <link href="/hexoblog/2016/06/20/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
      <url>/hexoblog/2016/06/20/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<p>机器学习的入门资料。 <a id="more"></a> # 参考资料 1. 路线图<a href="http://machinelearningmastery.com/machine-learning-roadmap-your-self-study-guide-to-machine-learning/" target="_blank" rel="noopener">The Missing Roadmap to Self-Study Machine Learning</a></p><ol start="2" style="list-style-type: decimal"><li>机器学习入门资源<a href="http://www.jianshu.com/p/fe2900cfae7b" target="_blank" rel="noopener">简书</a></li></ol><h1 id="我的路径">我的路径</h1><ol style="list-style-type: decimal"><li><p>看一遍介绍Python语法的书，掌握基本的python语法。</p></li><li><p>在官网学习Numpy,掌握基本的操作。</p></li><li><p>自学scikit-learn,掌握其中涉及到的算法 和 Python的一些使用方法。</p></li><li><p>拿一些有数据集有解题思路有程序的例子自己理解一下。</p></li><li><p>去各个算法网站找一些历年的比赛题自己做一下。</p></li><li><p>参加各个算法网站的比赛，熟悉什么情况下应该使用什么算法。</p></li></ol><h1 id="深度学习">深度学习</h1><h2 id="深度学习资料">深度学习资料</h2><ol style="list-style-type: decimal"><li><p>An NIT Press Book,<a href="http://www.deeplearningbook.org/" target="_blank" rel="noopener">Deep Learning</a> 该书有开源的电子版本，原书是英文的，现在也有了中文的电子版，也是开源的。但是可能质量不如纸质版的出版书。<a href="https://github.com/exacity/deeplearningbook-chinese" class="uri" target="_blank" rel="noopener">https://github.com/exacity/deeplearningbook-chinese</a></p></li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_范数</title>
      <link href="/hexoblog/2016/06/16/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E8%8C%83%E6%95%B0/"/>
      <url>/hexoblog/2016/06/16/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E8%8C%83%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>监督学习的一般过程是训练一个模型，根据给出的X计算出y, 然后最小化计算出来的y与真实的y之间的误差。 如果仅仅考虑最小化这个误差，很容易使这个误差为0，就是所有的训练数据都得到了正确的y.但是真实的情况是 训练数据中往往存在噪声，这些噪声和y并没有关系，当训练好的模型应用到模型没有见过的测试数据上时，效果会很差， 这就是过拟合(overfitting)。范数就是一种为了减小过拟合现象引入的参数。常用的范数有L0,L1,L2,核范数等。 <a id="more"></a></p><h1 id="l0-范数">L0 范数</h1><p>L0范数是指 向量（模型参数组成的向量）中非0元素的个数。L0范数也可以用来实现稀疏，但是不如L1范数应用广泛。</p><h1 id="l1范数lasso">L1范数（Lasso）</h1><p>L1范数是指 向量中各个元素绝对值之和。可以用来实现稀疏，使用L1范数会使求的的参数很多为0，这样就可以实现稀疏。 稀疏可以用来做特征选择。那些系数为0的参数代表的特征就去掉了。</p><h1 id="l2范数-ridge">L2范数 （Ridge）</h1><p>L2范数是指 向量各元素的平方和然后求平方根。L2范数可以使得参数很小，接近于0，但是不是0（L1范数参数是0）防止过拟合，提升模型的泛化能力。</p><blockquote><p>L2范数的作用 有利于处理ill-condition的情况，所谓的ill-condition,就是X变化很小的时候，y的变化很大。因为X都是存在误差的，这样如果X矩阵是ill-condition的， 推测出的结果就不可信。参考资料（http://blog.csdn.net/zouxy09/article/details/24971995/）</p></blockquote><h1 id="核范数">核范数</h1><p>核范数是指 矩阵奇异值的和</p><p>参考资料：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[1] http://fastml.com/large-scale-l1-feature-selection-with-vowpal-wabbit/</span><br><span class="line"></span><br><span class="line">[2] http://www.stat.purdue.edu/~vishy/introml/notes/Optimization.pdf</span><br><span class="line"></span><br><span class="line">[3] http://www.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf</span><br><span class="line"></span><br><span class="line">[4] GradientDescent, Wolfe<span class="string">'s Condition and Logistic Regression</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[5] http://nm.mathforcollege.com/mws/gen/04sle/mws_gen_sle_spe_adequacy.pdf</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 范数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同时使用多个分类器(Scikit-Learn)</title>
      <link href="/hexoblog/2016/06/16/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_Scikit-Learn-ManyClassifier/"/>
      <url>/hexoblog/2016/06/16/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_Scikit-Learn-ManyClassifier/</url>
      
        <content type="html"><![CDATA[<p>scikit-learn里面实现的所有分类器都遵循类似的形式，所以我们使用一个循环语句就可以很方便的应用多种分类器在同一个数据集上。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_20newsgroups</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> HashingVectorizer</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest, chi2</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectFromModel</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> RidgeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> SGDClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Perceptron</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> PassiveAggressiveClassifier</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> LinearSVC</span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> BernoulliNB, MultinomialNB</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> NearestCentroid</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.utils.extmath <span class="keyword">import</span> density</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">categories = [</span><br><span class="line">        <span class="string">'alt.atheism'</span>,</span><br><span class="line">        <span class="string">'talk.religion.misc'</span>,</span><br><span class="line">        <span class="string">'comp.graphics'</span>,</span><br><span class="line">        <span class="string">'sci.space'</span>,</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">data_train = fetch_20newsgroups(subset=<span class="string">'train'</span>,categories=categories,shuffle=<span class="literal">True</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">data_test = fetch_20newsgroups(subset=<span class="string">'test'</span>,categories=categories,shuffle=<span class="literal">True</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">categories = data_train.target_names </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">size_mb</span><span class="params">(docs)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sum(len(s.encode(<span class="string">'utf-8'</span>)) <span class="keyword">for</span> s <span class="keyword">in</span> docs) / <span class="number">1e6</span></span><br><span class="line"></span><br><span class="line">data_train_size_mb = size_mb(data_train.data)</span><br><span class="line">data_test_size_mb = size_mb(data_test.data)</span><br><span class="line"><span class="comment">#print the size and categoies</span></span><br><span class="line">print(<span class="string">"%d documents - %0.3fMB (training set)"</span> % (</span><br><span class="line">    len(data_train.data), data_train_size_mb))</span><br><span class="line">print(<span class="string">"%d documents - %0.3fMB (test set)"</span> % (</span><br><span class="line">    len(data_test.data), data_test_size_mb))</span><br><span class="line">print(<span class="string">"%d categories"</span> % len(categories))</span><br><span class="line">print()</span><br><span class="line"></span><br><span class="line">y_train, y_test = data_train.target, data_test.target</span><br><span class="line">vectorizer = TfidfVectorizer(sublinear_tf=<span class="literal">True</span>, max_df=<span class="number">0.5</span>,stop_words=<span class="string">'english'</span>)</span><br><span class="line">X_train = vectorizer.fit_transform(data_train.data)</span><br><span class="line">X_test = vectorizer.transform(data_test.data)</span><br><span class="line">feature_names = vectorizer.get_feature_names()</span><br><span class="line">feature_names = np.asarray(feature_names)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">benchmark</span><span class="params">(clf)</span>:</span></span><br><span class="line">    print(<span class="string">'-'</span> * <span class="number">80</span>)</span><br><span class="line">    print(<span class="string">"Training: "</span>)</span><br><span class="line">    print(clf)</span><br><span class="line">    t0 = time()</span><br><span class="line">    clf.fit(X_train, y_train)</span><br><span class="line">    train_time = time() - t0</span><br><span class="line">    print(<span class="string">"train time: %0.3fs"</span> % train_time)</span><br><span class="line"></span><br><span class="line">    t0 = time()</span><br><span class="line">    pred = clf.predict(X_test)</span><br><span class="line">    test_time = time() - t0</span><br><span class="line">    print(<span class="string">"test time:  %0.3fs"</span> % test_time)</span><br><span class="line"></span><br><span class="line">    score = metrics.accuracy_score(y_test, pred)</span><br><span class="line">    print(<span class="string">"accuracy:   %0.3f"</span> % score)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> hasattr(clf, <span class="string">'coef_'</span>):</span><br><span class="line">        print(<span class="string">"dimensionality: %d"</span> % clf.coef_.shape[<span class="number">1</span>])</span><br><span class="line">        print(<span class="string">"density: %f"</span> % density(clf.coef_))</span><br><span class="line">        </span><br><span class="line">    clf_descr = str(clf).split(<span class="string">'('</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> clf_descr, score, train_time, test_time</span><br><span class="line"></span><br><span class="line">results = []</span><br><span class="line"><span class="keyword">for</span> clf, name <span class="keyword">in</span> (</span><br><span class="line">        (RidgeClassifier(tol=<span class="number">1e-2</span>, solver=<span class="string">"sag"</span>), <span class="string">"Ridge Classifier"</span>),</span><br><span class="line">        (Perceptron(n_iter=<span class="number">50</span>), <span class="string">"Perceptron"</span>),</span><br><span class="line">        (PassiveAggressiveClassifier(n_iter=<span class="number">50</span>), <span class="string">"Passive-Aggressive"</span>),</span><br><span class="line">        (KNeighborsClassifier(n_neighbors=<span class="number">10</span>), <span class="string">"kNN"</span>),</span><br><span class="line">        (LinearSVC(loss=<span class="string">'l2'</span>, penalty=<span class="string">'l2'</span>,dual=<span class="literal">False</span>, tol=<span class="number">1e-3</span>), <span class="string">"Liblinear model with l2"</span>),</span><br><span class="line">        (LinearSVC(loss=<span class="string">'l2'</span>, penalty=<span class="string">'l1'</span>,dual=<span class="literal">False</span>, tol=<span class="number">1e-3</span>), <span class="string">"Liblinear model with l1"</span>),</span><br><span class="line">        (SGDClassifier(alpha=<span class="number">.0001</span>, n_iter=<span class="number">50</span>,penalty=<span class="string">'l2'</span>), <span class="string">"SGD model with l2"</span>),</span><br><span class="line">        (SGDClassifier(alpha=<span class="number">.0001</span>, n_iter=<span class="number">50</span>,penalty=<span class="string">'l1'</span>), <span class="string">"SGD model with l1"</span>),        </span><br><span class="line">        (SGDClassifier(alpha=<span class="number">.0001</span>, n_iter=<span class="number">50</span>,penalty=<span class="string">"elasticnet"</span>),<span class="string">"SGD model with Elastic-Net penalty"</span> ),       </span><br><span class="line">        (NearestCentroid(), <span class="string">"NearestCentroid without threshold"</span>),</span><br><span class="line">        (MultinomialNB(alpha=<span class="number">.01</span>),<span class="string">"MultinomialNB"</span>),</span><br><span class="line">        (BernoulliNB(alpha=<span class="number">.01</span>),<span class="string">"BernoulliNB"</span>),</span><br><span class="line">        (RandomForestClassifier(n_estimators=<span class="number">100</span>), <span class="string">"Random forest"</span>),</span><br><span class="line">        (Pipeline([(<span class="string">'feature_selection'</span>, SelectFromModel(LinearSVC(penalty=<span class="string">"l1"</span>, dual=<span class="literal">False</span>, tol=<span class="number">1e-3</span>))),(<span class="string">'classification'</span>, LinearSVC())]),<span class="string">"LinearSVC with L1-based feature selection"</span>),</span><br><span class="line">        ):</span><br><span class="line">    print(<span class="string">'='</span> * <span class="number">80</span>)</span><br><span class="line">    print(name)</span><br><span class="line">    results.append(benchmark(clf))</span><br><span class="line"></span><br><span class="line"><span class="comment"># make some plots</span></span><br><span class="line"></span><br><span class="line">indices = np.arange(len(results))</span><br><span class="line"></span><br><span class="line">results = [[x[i] <span class="keyword">for</span> x <span class="keyword">in</span> results] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line">clf_names, score, training_time, test_time = results</span><br><span class="line">training_time = np.array(training_time) / np.max(training_time)</span><br><span class="line">test_time = np.array(test_time) / np.max(test_time)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>, <span class="number">8</span>))</span><br><span class="line">plt.title(<span class="string">"Score"</span>)</span><br><span class="line">plt.barh(indices, score, <span class="number">.2</span>, label=<span class="string">"score"</span>, color=<span class="string">'r'</span>)</span><br><span class="line">plt.barh(indices + <span class="number">.3</span>, training_time, <span class="number">.2</span>, label=<span class="string">"training time"</span>, color=<span class="string">'g'</span>)</span><br><span class="line">plt.barh(indices + <span class="number">.6</span>, test_time, <span class="number">.2</span>, label=<span class="string">"test time"</span>, color=<span class="string">'b'</span>)</span><br><span class="line">plt.yticks(())</span><br><span class="line">plt.legend(loc=<span class="string">'best'</span>)</span><br><span class="line">plt.subplots_adjust(left=<span class="number">.25</span>)</span><br><span class="line">plt.subplots_adjust(top=<span class="number">.95</span>)</span><br><span class="line">plt.subplots_adjust(bottom=<span class="number">.05</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, c <span class="keyword">in</span> zip(indices, clf_names):</span><br><span class="line">    plt.text(<span class="number">-.3</span>, i, c)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line">2034 documents - 3.980MB (training set)</span><br><span class="line">1353 documents - 2.867MB (test set)</span><br><span class="line">4 categories</span><br><span class="line">()</span><br><span class="line">================================================================================</span><br><span class="line">Ridge Classifier</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">Training: </span><br><span class="line">RidgeClassifier(alpha=1.0, class_weight=None, copy_X=True, fit_intercept=True,</span><br><span class="line">        max_iter=None, normalize=False, random_state=None, solver=&apos;sag&apos;,</span><br><span class="line">        tol=0.01)</span><br><span class="line">train time: 0.125s</span><br><span class="line">test time:  0.016s</span><br><span class="line">accuracy:   0.897</span><br><span class="line">dimensionality: 33810</span><br><span class="line">density: 1.000000</span><br><span class="line">================================================================================</span><br><span class="line">Perceptron</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">Training: </span><br><span class="line">Perceptron(alpha=0.0001, class_weight=None, eta0=1.0, fit_intercept=True,</span><br><span class="line">      n_iter=50, n_jobs=1, penalty=None, random_state=0, shuffle=True,</span><br><span class="line">      verbose=0, warm_start=False)</span><br><span class="line">train time: 0.093s</span><br><span class="line">test time:  0.000s</span><br><span class="line">accuracy:   0.885</span><br><span class="line">dimensionality: 33810</span><br><span class="line">density: 0.240158</span><br><span class="line">================================================================================</span><br><span class="line">Passive-Aggressive</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">Training: </span><br><span class="line">PassiveAggressiveClassifier(C=1.0, class_weight=None, fit_intercept=True,</span><br><span class="line">              loss=&apos;hinge&apos;, n_iter=50, n_jobs=1, random_state=None,</span><br><span class="line">              shuffle=True, verbose=0, warm_start=False)</span><br><span class="line">train time: 0.125s</span><br><span class="line">test time:  0.000s</span><br><span class="line">accuracy:   0.902</span><br><span class="line">dimensionality: 33810</span><br><span class="line">density: 0.698994</span><br><span class="line">================================================================================</span><br><span class="line">kNN</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">Training: </span><br><span class="line">KNeighborsClassifier(algorithm=&apos;auto&apos;, leaf_size=30, metric=&apos;minkowski&apos;,</span><br><span class="line">           metric_params=None, n_jobs=1, n_neighbors=10, p=2,</span><br><span class="line">           weights=&apos;uniform&apos;)</span><br><span class="line">train time: 0.000s</span><br><span class="line">test time:  0.187s</span><br><span class="line">accuracy:   0.858</span><br><span class="line">================================================================================</span><br><span class="line">Liblinear model with l2</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">Training: </span><br><span class="line">LinearSVC(C=1.0, class_weight=None, dual=False, fit_intercept=True,</span><br><span class="line">     intercept_scaling=1, loss=&apos;l2&apos;, max_iter=1000, multi_class=&apos;ovr&apos;,</span><br><span class="line">     penalty=&apos;l2&apos;, random_state=None, tol=0.001, verbose=0)</span><br><span class="line">train time: 0.171sC:\Anaconda2\lib\site-packages\sklearn\svm\classes.py:197: DeprecationWarning: loss=&apos;l2&apos; has been deprecated in favor of loss=&apos;squared_hinge&apos; as of 0.16. Backward compatibility for the loss=&apos;l2&apos; will be removed in 1.0</span><br><span class="line">  DeprecationWarning)</span><br><span class="line">C:\Anaconda2\lib\site-packages\sklearn\svm\classes.py:197: DeprecationWarning: loss=&apos;l2&apos; has been deprecated in favor of loss=&apos;squared_hinge&apos; as of 0.16. Backward compatibility for the loss=&apos;l2&apos; will be removed in 1.0</span><br><span class="line">  DeprecationWarning)</span><br><span class="line"></span><br><span class="line">test time:  0.000s</span><br><span class="line">accuracy:   0.900</span><br><span class="line">dimensionality: 33810</span><br><span class="line">density: 1.000000</span><br><span class="line">================================================================================</span><br><span class="line">Liblinear model with l1</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">Training: </span><br><span class="line">LinearSVC(C=1.0, class_weight=None, dual=False, fit_intercept=True,</span><br><span class="line">     intercept_scaling=1, loss=&apos;l2&apos;, max_iter=1000, multi_class=&apos;ovr&apos;,</span><br><span class="line">     penalty=&apos;l1&apos;, random_state=None, tol=0.001, verbose=0)</span><br><span class="line">train time: 0.203s</span><br><span class="line">test time:  0.000s</span><br><span class="line">accuracy:   0.873</span><br><span class="line">dimensionality: 33810</span><br><span class="line">density: 0.005553</span><br><span class="line">================================================================================</span><br><span class="line">SGD model with l2</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">Training: </span><br><span class="line">SGDClassifier(alpha=0.0001, average=False, class_weight=None, epsilon=0.1,</span><br><span class="line">       eta0=0.0, fit_intercept=True, l1_ratio=0.15,</span><br><span class="line">       learning_rate=&apos;optimal&apos;, loss=&apos;hinge&apos;, n_iter=50, n_jobs=1,</span><br><span class="line">       penalty=&apos;l2&apos;, power_t=0.5, random_state=None, shuffle=True,</span><br><span class="line">       verbose=0, warm_start=False)</span><br><span class="line">train time: 0.094s</span><br><span class="line">test time:  0.000s</span><br><span class="line">accuracy:   0.902</span><br><span class="line">dimensionality: 33810</span><br><span class="line">density: 0.671813</span><br><span class="line">================================================================================</span><br><span class="line">SGD model with l1</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">Training: </span><br><span class="line">SGDClassifier(alpha=0.0001, average=False, class_weight=None, epsilon=0.1,</span><br><span class="line">       eta0=0.0, fit_intercept=True, l1_ratio=0.15,</span><br><span class="line">       learning_rate=&apos;optimal&apos;, loss=&apos;hinge&apos;, n_iter=50, n_jobs=1,</span><br><span class="line">       penalty=&apos;l1&apos;, power_t=0.5, random_state=None, shuffle=True,</span><br><span class="line">       verbose=0, warm_start=False)</span><br><span class="line">train time: 0.327s</span><br><span class="line">test time:  0.000s</span><br><span class="line">accuracy:   0.883</span><br><span class="line">dimensionality: 33810</span><br><span class="line">density: 0.020475</span><br><span class="line">================================================================================</span><br><span class="line">SGD model with Elastic-Net penalty</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">Training: </span><br><span class="line">SGDClassifier(alpha=0.0001, average=False, class_weight=None, epsilon=0.1,</span><br><span class="line">       eta0=0.0, fit_intercept=True, l1_ratio=0.15,</span><br><span class="line">       learning_rate=&apos;optimal&apos;, loss=&apos;hinge&apos;, n_iter=50, n_jobs=1,</span><br><span class="line">       penalty=&apos;elasticnet&apos;, power_t=0.5, random_state=None, shuffle=True,</span><br><span class="line">       verbose=0, warm_start=False)</span><br><span class="line">train time: 0.499s</span><br><span class="line">test time:  0.000s</span><br><span class="line">accuracy:   0.899</span><br><span class="line">dimensionality: 33810</span><br><span class="line">density: 0.188191</span><br><span class="line">================================================================================</span><br><span class="line">NearestCentroid without threshold</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">Training: </span><br><span class="line">NearestCentroid(metric=&apos;euclidean&apos;, shrink_threshold=None)</span><br><span class="line">train time: 0.016s</span><br><span class="line">test time:  0.000s</span><br><span class="line">accuracy:   0.855</span><br><span class="line">================================================================================</span><br><span class="line">MultinomialNB</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">Training: </span><br><span class="line">MultinomialNB(alpha=0.01, class_prior=None, fit_prior=True)</span><br><span class="line">train time: 0.015s</span><br><span class="line">test time:  0.000s</span><br><span class="line">accuracy:   0.900</span><br><span class="line">dimensionality: 33810</span><br><span class="line">density: 1.000000</span><br><span class="line">================================================================================</span><br><span class="line">BernoulliNB</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">Training: </span><br><span class="line">BernoulliNB(alpha=0.01, binarize=0.0, class_prior=None, fit_prior=True)</span><br><span class="line">train time: 0.000s</span><br><span class="line">test time:  0.016s</span><br><span class="line">accuracy:   0.884</span><br><span class="line">dimensionality: 33810</span><br><span class="line">density: 1.000000</span><br><span class="line">================================================================================</span><br><span class="line">Random forest</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">Training: </span><br><span class="line">RandomForestClassifier(bootstrap=True, class_weight=None, criterion=&apos;gini&apos;,</span><br><span class="line">            max_depth=None, max_features=&apos;auto&apos;, max_leaf_nodes=None,</span><br><span class="line">            min_samples_leaf=1, min_samples_split=2,</span><br><span class="line">            min_weight_fraction_leaf=0.0, n_estimators=100, n_jobs=1,</span><br><span class="line">            oob_score=False, random_state=None, verbose=0,</span><br><span class="line">            warm_start=False)</span><br><span class="line">train time: 2.730s</span><br><span class="line">test time:  0.094s</span><br><span class="line">accuracy:   0.842</span><br><span class="line">================================================================================</span><br><span class="line">LinearSVC with L1-based feature selection</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">Training: </span><br><span class="line">Pipeline(steps=[(&apos;feature_selection&apos;, SelectFromModel(estimator=LinearSVC(C=1.0, class_weight=None, dual=False, fit_intercept=True,</span><br><span class="line">     intercept_scaling=1, loss=&apos;squared_hinge&apos;, max_iter=1000,</span><br><span class="line">     multi_class=&apos;ovr&apos;, penalty=&apos;l1&apos;, random_state=None, tol=0.001,</span><br><span class="line">     verbose=0),</span><br><span class="line">        prefit=False, thresho...ax_iter=1000,</span><br><span class="line">     multi_class=&apos;ovr&apos;, penalty=&apos;l2&apos;, random_state=None, tol=0.0001,</span><br><span class="line">     verbose=0))])</span><br><span class="line">train time: 0.218s</span><br><span class="line">test time:  0.016s</span><br><span class="line">accuracy:   0.880</span><br></pre></td></tr></table></figure><div class="figure"><img src="many_classfier.png" alt="many_classfier"><p class="caption">many_classfier</p></div><p>上面是使用稀疏矩阵存放特征的一个例子，当然普通的特征也是可以这样做的，例如，可以将上面的数据换成手写数字识别的数据。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iris = load_iris()</span><br><span class="line">X, y = iris.data, iris.target</span><br><span class="line">X_train = X</span><br><span class="line">X_test = X</span><br><span class="line"></span><br><span class="line">y_train = y</span><br><span class="line">y_test = y</span><br></pre></td></tr></table></figure></p><div class="figure"><img src="many_classfier2.png" alt="many_classfier2"><p class="caption">many_classfier2</p></div>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scikit-learn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo的使用01-搭建</title>
      <link href="/hexoblog/2016/06/13/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/Hexo/Hexo%E7%9A%84%E4%BD%BF%E7%94%A801-%E6%90%AD%E5%BB%BA/"/>
      <url>/hexoblog/2016/06/13/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/Hexo/Hexo%E7%9A%84%E4%BD%BF%E7%94%A801-%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>hexo是一个快速、简洁且高效的博客框架，它使用渲染引擎渲染markdown文本，生成静态网页。任何可以托管静态网页的空间都可以部署hexo博客。目前流行的组合是<code>hexo + git + github</code>. 可以实现像管理代码的版本那样管理自己的文档。</p><a id="more"></a><h2 id="安装">安装</h2><p>Hexo的安装和部署十分简单，它是基于<code>Node.js</code>的，所以首先确保安装了<code>Node.js</code>.在系统环境中<code>npm</code>命令是可以使用的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><h2 id="配置">配置</h2><p>Hexo分成了两个层级，Hexo应用层面的配置，配置文件在博客根目录的<code>_config.yml</code>,另外一个是主题配置文件，在<code>themes\[主题名]\_config.yml</code>中。主题的配置参考你使用的主题的相关的文档配置。 网站的配置参考：https://hexo.io/zh-cn/docs/configuration.html</p><h2 id="添加rss订阅功能">添加RSS订阅功能</h2><blockquote><p>安装 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm isntall hexo-generator-feed --save</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>配置 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在博客配置文件 _config.yml 中添加</span><br><span class="line"><span class="comment">#添加RSS订阅</span></span><br><span class="line">feed:</span><br><span class="line"><span class="built_in">type</span>: atom</span><br><span class="line">path: atom.xml</span><br><span class="line"><span class="built_in">limit</span>: 20</span><br></pre></td></tr></table></figure></p></blockquote><p>在主题配置文件中 _config.yml 中添加 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rss: /atom.xml</span><br></pre></td></tr></table></figure></p><h2 id="next主题的配置">nexT主题的配置</h2><p><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">nexT</a>是一个界面简洁，干净的主题，很流行。</p><h3 id="修改网页背景颜色">修改网页背景颜色</h3><p><strong>主题颜色</strong></p><p>打开hexo/themes/next/source/css/_variables/base.styl找到Colors代码段，如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// Colors</span><br><span class="line">// colors for use across theme.</span><br><span class="line">// --------------------------------------------------</span><br><span class="line">  $whitesmoke   = #f5f5f5</span><br><span class="line">  $gainsboro    = #eee  //这个是边栏头像外框的颜色，</span><br><span class="line">  $gray-lighter = #ddd  //文章中插入图片边框颜色</span><br><span class="line">  $grey-light   = #ccc  //文章之间分割线、下划线颜色</span><br><span class="line">  $grey         = #bbb  //页面选中圆点颜色</span><br><span class="line">  $grey-dark    = #999</span><br><span class="line">  $grey-dim     = #666 //侧边栏目录字体颜色</span><br><span class="line">  $black-light  = #555 //修改文章字体颜色</span><br><span class="line">  $black-dim    = #333</span><br><span class="line">  $black-deep   = #495a80  //修改主题的颜色，这里我已经改成老蓝色了。</span><br><span class="line">  $red          = #ff2a2a</span><br><span class="line">  $blue-bright  = #87daff</span><br><span class="line">  $blue         = #0684bd</span><br><span class="line">  $blue-deep    = #262a30</span><br><span class="line">  $orange       = #F39D01 //浏览文章时，目录选中的颜色</span><br></pre></td></tr></table></figure></p><p><strong>主题背景</strong></p><p>打开hexo/themes/next/source/css/_schemes/Pisces/index.styl(Pisces为NexT提供的三种主题之一，根据使用的主题选择）修改body{}内的值，如下： 背景颜色直接更改即可：body { background: #F0F0F0; } 添加背景：body { background: url（‘/images/background.jpg’); }(将背景图片放到hexo/source/images中即可。</p><p><strong>内容背景</strong></p><p>修改博客背景颜色 /themes/next/source/css/_schemes/Pisces/_layout.styl <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.content-wrap &#123;</span><br><span class="line">  background: #222222;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="添加disqus评论支持">添加disqus评论支持</h3><p>https://disqus.com 是一个国际上使用最广泛的评论系统，可以方便的安装在任何网站之上。nexT主题自带了DISQUS评论代码，只需要在配置文件中填上子集的short_name就可以了。 <strong>disqus帐号的申请和使用</strong> 首先到disqus的官方网站申请一个帐号，登陆。 <img src="2017-05-02_195454.png"> 选择<code>add disqus to site</code>, 在网页的最下端选择<code>get start</code> <img src="2017-05-02_195700.png"> 选择第二个，我要简历一个网站， <img src="2017-05-02_195752.png"> 填写网站的相关信息，其中<code>Website Name</code>是唯一的，也就是NexT主题中填入的shor_name.</p><p>设置成功之后的样子： <img src="2017-05-02_195947.png"></p><h2 id="maupassant主题配置">maupassant主题配置</h2><p>另外一个比较简洁的主题，风格类似nexT. https://github.com/tufu9441/maupassant-hexo</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工具 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Python处理fMRI数据</title>
      <link href="/hexoblog/2016/06/12/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/%E4%BD%BF%E7%94%A8Python%E5%A4%84%E7%90%86fMRI%E6%95%B0%E6%8D%AE/"/>
      <url>/hexoblog/2016/06/12/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/%E4%BD%BF%E7%94%A8Python%E5%A4%84%E7%90%86fMRI%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p>Python是一种解释型、面向对象、动态数据类型的高级程序设计语言。目前主流的算法基本上都有Python的实现版本，所以能够使用Python处理fMRI数据对于直接使用多种多样的机器学习算法是十分有帮助的。 本文主要涉及的内容有Python,Scikit-lean,nibabel,nilean等。 <a id="more"></a> ## Python 安装Python环境，Windows下使用建议使用Anaconda,一个类似matlab界面的Python环境。 <a href="https://www.continuum.io/downloads" target="_blank" rel="noopener">Anaconda</a> 安装完成后，打开<code>cmd</code>键入<code>spyder</code>打开软件 <img src="spyder.png" alt="spyder"> ## scikit-learn scikit-learn是一个很有名的机器学习库，设计了一系列的通用接口以使不同的机器学习算法符合相似的流程。里面实现了大部分目前流行的机器学习算法，而且文档良好，更新速度很快。 &gt;安装 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install scikit-learn</span><br></pre></td></tr></table></figure></p><blockquote><p>卸载 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove scikit-learn</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>更新 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update scikit-learn</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="nibabel">NiBabel</h2><p>NiBabel是一个读写常见的神经影像数据的Python语言的程序包，可以实现读取和生成大部分常见的神经影像数据格式。 &gt;安装 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install nibabel</span><br></pre></td></tr></table></figure></p><blockquote><p>测试是否成功安装 在Python控制台键入<code>import nibabel</code>没有报错信息证明安装成功</p></blockquote><h3 id="神经影像数据格式">神经影像数据格式</h3><p>使用fMRI得到的原始数据一般是.IMA结尾的数据，每个TR一个文件，我们可以使用<a href="">mricron</a>的<code>dcm2niigui.exe</code>转换成.nii结尾的4D文件格式 ### 读取数据 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> nibabel <span class="keyword">as</span> nib </span><br><span class="line"></span><br><span class="line">img = nib.load(<span class="string">"image.nii"</span>)</span><br></pre></td></tr></table></figure></p><p>以上代码将image.nii文件读取到<code>img</code>中，<code>img</code>是<code>nibabel.nifti1.Nifti1Image</code>类型的。 一个<code>nibabel.nifti1.Nifti1Image</code>类型的数据包含三个主要的部分 - image data array 存放图像数据的矩阵 - an affine array 定义了图像数据在参考空间的位置 - image metadata 存放图像的一些属性信息，采集设备名称，体素的大小，扫描层数等等。 &gt;image data array 虽然存储了每个体素的取值信息，但是并没有存储位置信息。也就是说我们并不知道某个体素来自由大脑哪个具体的位置 &gt;affine数组定义了一个从image data array 到标准的参考空间的映射，每个体素经过这个数组映射后都会到一个标准的参考空间，在那个空间中，我们精确的知道每个体素所处的位置。 &gt;结构像和功能像扫描的区域和方向均有所差异，所以都需要使用affine数组映射到参考空间，以确定体素在真实大脑中的位置 ### 显示数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">img_array = img.get_data() //get image data array</span><br><span class="line">affine_array = img.affine //get the affine array</span><br><span class="line">img_head = img.header; //get image metadata</span><br><span class="line"></span><br><span class="line">//获取其他一些信息的方法</span><br><span class="line">img.shape // 获得维数信息</span><br><span class="line">img.get_data_dtype() // 获得数据类型</span><br><span class="line">img_head.get_data_dtype() // 获得头信息的数据类型</span><br><span class="line">img_head.get_data_shape() // 获得维数信息</span><br><span class="line">img_head.get_zooms() //获得体素大小</span><br></pre></td></tr></table></figure><h2 id="nilearn">Nilearn</h2><p><code>Nilearn</code>是一个<code>Python</code>实现的适用于处理<code>Neuro-Image</code>数据的机器学习工具包，它可以和<code>scikit-learn</code>很好的结合，用很少的代码就能将大部分机器学习方法用来处理神经影像数据。</p><h3 id="实验和数据介绍">实验和数据介绍</h3><p>该工具包中大部分说明都是使用<code>The Haxby 2001 experiment</code>的实验数据，这里我们介绍一下该实验的相关信息和采集的数据的结构。 #### 实验内容 实验一个选取了六个被试，每个被试的实验内容都有一样。每个被试在实验的时候观看一些图片，使用功能核磁共振获取被试此时大脑的激活信息，利用获得的信息看是否能够分类被试看到的图片的种类。 给被试看的图片分为八类 - 人脸 - 猫 - 房屋 - 椅子 - 剪刀 - 鞋 - 瓶子 - 毫无意义的照片（使用随机噪声生成的图片）</p><h4 id="数据结构">数据结构</h4><blockquote><ul><li>数据的获取可以使用内建的方法 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> nilearn <span class="keyword">import</span> datasets</span><br><span class="line">haxby_dataset = datasets.fetch_haxby()</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>haxby_dataset的结构是这样的 <img src="haxy_database.png" alt="haxy_database"> &gt;- <code>anat</code> 是被试1的结构像，<code>T1</code>像，是<code>124X256X256</code>的，是一个<code>3D</code>图像，是被试在静息态的扫描图像 &gt;- <code>func</code> 是被试1的功能图像，就是被试在实验过程中做任务的时候扫描的图像，是<code>40X64X64X1452</code>的，是个4D的图像，前三维是一次<code>TR</code>扫描到的图像，是三维的，最后一维<strong>1452</strong>代表被试1的功能像一共扫描了<code>1452</code>个<code>TR</code>，也就是有<code>1452</code>个功能图像。 &gt;- <code>mask</code> 是感兴趣的脑区的一个掩膜，想要留下的部分都是1，不需要的部分都是0，是一个和原来图像一样大的矩阵，这个mask是应用到功能像上的，所以它的大小是<code>40X64X64</code> &gt;- <code>session_target</code>是一个文本文件，里面一共<strong>1452</strong>行，每一行代表一个TR，表示该TR进行的时候被试受到的刺激的类型。</p><blockquote><p>使用内建方法获得的数据只有一个被试的数据，不过该数据集已经公开，完整数据可以去网站下载。</p></blockquote><h3 id="解码实验">解码实验</h3><p>使用fMRI测量得到的大脑状态信息(这里表现为一个<code>40X64X64X1452</code>的矩阵)，解码出被试所受刺激的种类(这里是图片的八种类别)。 基本思路是：从原始数据中用一定的策略提取有用的特征作为输入，session_target中的信息作为输出，训练一个分类器，尽可能的根据输入的特征得出正确的分类结果。 特征选择可以使用的方法： - 选择感兴趣的脑区 - 使用统计方法，计算体素T值和F值，只选择那些有显著变化的体素 - 使用无监督的降维方法，例如PCA</p><p>分类器可以选择的方法： - 线性的支持向量机 - LDA，ICA - 决策树 - 神经网络</p><p>以下分成四个部分介绍分析的过程： - 特征选择 - 数据准备 - 模型训练和测试 - 结果分析和可视化显示</p><h4 id="特征选择">特征选择</h4><h5 id="使用mask">使用mask</h5><p>这里我们选择使用mask的方法降低特征的数量。mask一般定位在某一个或几个脑区，感兴趣的脑区是根据以前的相关研究确定的，比如研究视觉刺激，就找大脑皮层处理视觉的相关区域。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> nilearn.input_data <span class="keyword">import</span> NiftiMasker</span><br><span class="line"><span class="comment">#模版文件的路径</span></span><br><span class="line">mask_vt_filename = haxby_dataset.mask_vt[<span class="number">0</span>]</span><br><span class="line"><span class="comment">#加载模版并标准化</span></span><br><span class="line">nifti_masker = NiftiMasker(mask_img=mask_vt_filename, standardize=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#功能像4D文件</span></span><br><span class="line">func_filename = haxby_dataset.func[<span class="number">0</span>]</span><br><span class="line"><span class="comment">#应用mask，并将数据合适转换成（n_sample,n_features）的形式</span></span><br><span class="line">fmri_vt_masked = nifti_masker.fit_transform(func_filename)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;fmri_vt_masked</span><br><span class="line">&gt;&gt;&gt;(<span class="number">1452L</span>, <span class="number">577L</span>)</span><br></pre></td></tr></table></figure></p><blockquote><p>功能像文件本来是<code>40*64*64*1452</code>的，如果不做特征选择，直接转换成(n_samples,n_features)的形式,应该是<code>1452*163840</code>的规模，显然特征数量太大了。 应用完<code>mask</code>之后，现在<code>fmri_masked</code>是<code>1452*577</code>的，特征一下少了很多。 我们推测，mask文件中应该有577个1，其余的都是0， &gt; <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import nibabel as nib</span><br><span class="line">mask_v4 = nib.load(&apos;mask4_vt.nii.gz&apos;)</span><br><span class="line">mask_v4data = mask_v4.get_data()</span><br><span class="line">import numpy as np </span><br><span class="line">print np.sum(mask_v4data)</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><blockquote><p>输出<code>577.0</code>,所以经过mask之后的特征变成了577维。</p></blockquote></blockquote><h5 id="使用f检验">使用F检验</h5><p>这里我们使用数据提供的一个比较大的mask先选择一个比较大的感兴趣的区域<code>hsxby2001\mask.nii.gz</code>，然后使用F检验找出影响程度最大的前577个特征，与上面直接使用一个小的mask的分类结果做对比。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> nilearn.input_data <span class="keyword">import</span> NiftiMasker</span><br><span class="line"><span class="comment">#模版文件的路径</span></span><br><span class="line">mask_filename = haxby_dataset.mask</span><br><span class="line"><span class="comment">#加载模版并标准化</span></span><br><span class="line">nifti_masker = NiftiMasker(mask_img=mask_filename, standardize=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#功能像4D文件</span></span><br><span class="line">func_filename = haxby_dataset.func[<span class="number">0</span>]</span><br><span class="line"><span class="comment">#应用mask，并将数据合适转换成（n_sample,n_features）的形式</span></span><br><span class="line">fmri_masked = nifti_masker.fit_transform(func_filename)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;fmri_masked</span><br><span class="line">&gt;&gt;&gt;(<span class="number">1452L</span>, <span class="number">39912L</span>)</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line">svc = SVC(kernel=<span class="string">'linear'</span>)</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest, f_classif</span><br><span class="line">feature_selection = SelectKBest(f_classif, k=<span class="number">577</span>) <span class="comment">#选择排名前577的特征</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line">anova_svc = Pipeline([(<span class="string">'anova'</span>, feature_selection), (<span class="string">'svc'</span>, svc)])</span><br></pre></td></tr></table></figure><blockquote><p>此处的<code>anova_svc</code>相当于下面的<code>svc</code>,只不过<code>anova_svc</code>会首先执行特征选择过程，再把特征选择的结果送入SVM分类器，<code>anova_svc</code>和<code>svc</code>的使用在形式上完全一样，都是<code>.fit(X,y)</code>,<code>.predict(X)</code>的形式。</p></blockquote><h4 id="数据准备">数据准备</h4><p>在这一步，我们要对数据的组织格式进行处理，使之符合<code>scikit-learn</code>的输入格式。 &gt;<code>scikit-learn</code>训练器的输入格式一般为train_data,target_data;train_data的格式为(n_samples,n_features)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#实验包含八类，这里我们只选择其中的两类数据进行实验</span></span><br><span class="line"><span class="comment">#加载target数据</span></span><br><span class="line">labels = np.recfromcsv(haxby_dataset.session_target[<span class="number">0</span>], delimiter=<span class="string">" "</span>)</span><br><span class="line">target = labels[<span class="string">'labels'</span>]</span><br><span class="line">condition_mask = np.logical_or(labels[<span class="string">'labels'</span>] == <span class="string">b'face'</span>,</span><br><span class="line">                               labels[<span class="string">'labels'</span>] == <span class="string">b'cat'</span>)</span><br><span class="line">target_data = target[condition_mask]</span><br><span class="line"><span class="comment">#使用mask的特征</span></span><br><span class="line">train_data = fmri_vt_masked[condition_mask]</span><br><span class="line"><span class="comment">#使用F检验的特征</span></span><br><span class="line">train_f_data = fmri_masked[condition_mask]</span><br></pre></td></tr></table></figure><blockquote><p>现在我们准备好了数据，<code>train_data</code>是<code>216*577</code>的，<code>target_data</code>是<code>216*1</code>的，正好能对应上。</p></blockquote><h4 id="模型训练和测试">模型训练和测试</h4><p>实际的模型训练和测试中，常使用交叉验证的方式来保证可靠性。所谓的交叉验证，就是使用一部分数据训练模型，使用另外一部分测试准确率；然后反过来。每次训练数据和测试数据都是互斥的，没有交集。 <code>scikit-learn</code>提供了接口，我们可以很方便的实现交叉验证。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用SVM分类和预测</span></span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line">svc = SVC(kernel=<span class="string">'linear'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> KFold</span><br><span class="line">cv = KFold(n=len(train_data), n_folds=<span class="number">5</span>)</span><br><span class="line"><span class="comment">#使用mask</span></span><br><span class="line">cv_scores = [] <span class="comment">#存储每次测试的准确率</span></span><br><span class="line"><span class="keyword">for</span> train, test <span class="keyword">in</span> cv:</span><br><span class="line">    svc.fit(train_data[train], target_data[train])</span><br><span class="line">    prediction = svc.predict(train_data[test])</span><br><span class="line">    cv_scores.append( np.sum(prediction == target_data[test]) / float(np.size(target_data[test])) )</span><br><span class="line"></span><br><span class="line">classification_accuracy = np.mean(cv_scores) <span class="comment">#计算平均的分类准确率</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;cv_scores</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">0.72727272727272729</span>,</span><br><span class="line"> <span class="number">0.46511627906976744</span>,</span><br><span class="line"> <span class="number">0.72093023255813948</span>,</span><br><span class="line"> <span class="number">0.58139534883720934</span>,</span><br><span class="line"> <span class="number">0.7441860465116279</span>]</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;classification_accuracy</span><br><span class="line">&gt;&gt;&gt;<span class="number">0.64778012684989428</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用F检验</span></span><br><span class="line">cv_f_scores = []</span><br><span class="line"><span class="keyword">for</span> train, test <span class="keyword">in</span> cv:</span><br><span class="line">    anova_svc.fit(train_f_data[train], target_data[train])</span><br><span class="line">    y_pred = anova_svc.predict(train_f_data[test])</span><br><span class="line">    cv_f_scores.append(np.sum(y_pred == target_data[test]) / float(np.size(target_data[test])))</span><br><span class="line"></span><br><span class="line">classification_f_accuracy = np.mean(cv_f_scores) <span class="comment">#计算平均的分类准确率</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;cv_f_scores</span><br><span class="line">&gt;&gt;&gt;Out[<span class="number">133</span>]: </span><br><span class="line">[<span class="number">0.59090909090909094</span>,</span><br><span class="line"> <span class="number">0.39534883720930231</span>,</span><br><span class="line"> <span class="number">0.76744186046511631</span>,</span><br><span class="line"> <span class="number">0.65116279069767447</span>,</span><br><span class="line"> <span class="number">0.55813953488372092</span>]</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;classification_f_accuracy</span><br><span class="line">&gt;&gt;&gt;<span class="number">0.59260042283298098</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#计算change level</span></span><br><span class="line"><span class="keyword">from</span> sklearn.dummy <span class="keyword">import</span> DummyClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> cross_val_score</span><br><span class="line"></span><br><span class="line">null_cv_scores = cross_val_score(DummyClassifier(), train_data, target_data, cv=cv)  </span><br><span class="line">null_accuracy = np.mean(null_cv_scores)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;null_cv_scores</span><br><span class="line">&gt;&gt;&gt;array([ <span class="number">0.54545455</span>,  <span class="number">0.48837209</span>,  <span class="number">0.48837209</span>,  <span class="number">0.34883721</span>,  <span class="number">0.55813953</span>])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;null_accuracy</span><br><span class="line">&gt;&gt;&gt;<span class="number">0.48583509513742068</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> cv_scores,classification_accuracy</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> cv_f_scores,classification_f_accuracy</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> null_cv_scores,null_accuracy</span><br></pre></td></tr></table></figure></p><p>可以看到，简单的使用F检验的结果并没有使用先验的小mask获得的准确率高，但是F检验获得的分类准确率也显著高于chance level. #### 结果分析和可视化显示 获得模型参数 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Retrieve the SVC discriminating weights</span></span><br><span class="line">coef_ = svc.coef_</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reverse masking thanks to the Nifti Masker</span></span><br><span class="line">coef_img = nifti_masker.inverse_transform(coef_)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save the coefficients as a Nifti image</span></span><br><span class="line">coef_img.to_filename(<span class="string">'haxby_svc_weights.nii'</span>)</span><br></pre></td></tr></table></figure></p><blockquote><p><code>svc.coef_</code>是SVM模型的参数，从中可以看出各个特征对分类结果的贡献的大小。</p></blockquote><p>显示图像 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create the figure</span></span><br><span class="line"><span class="keyword">from</span> nilearn <span class="keyword">import</span> image</span><br><span class="line"><span class="keyword">from</span> nilearn.plotting <span class="keyword">import</span> plot_stat_map, show</span><br><span class="line"><span class="keyword">import</span> nibabel <span class="keyword">as</span> nib</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the mean image because we have no anatomic data</span></span><br><span class="line">mean_img = image.mean_img(func_filename)</span><br><span class="line">weight_img = nib.load(<span class="string">'haxby_svc_weights.nii'</span>)</span><br><span class="line">plot_stat_map(weight_img, mean_img, title=<span class="string">'SVM weights'</span>)</span><br><span class="line">show()</span><br></pre></td></tr></table></figure></p><p><img src="svm_weights.png" alt="svm_weights"> &gt; 从该图像中，我们能够看到那些对分类结果影响较大的体素，这些地方很可能就是大脑内专门负责这两个不同的类别的区分任务的。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 认知神经科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fMRI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo的使用02-同步</title>
      <link href="/hexoblog/2016/06/12/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/Hexo/Hexo%E7%9A%84%E4%BD%BF%E7%94%A802-%E5%90%8C%E6%AD%A5/"/>
      <url>/hexoblog/2016/06/12/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/Hexo/Hexo%E7%9A%84%E4%BD%BF%E7%94%A802-%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p>Hexo生成的博客在Public文件夹中。我们使用命令<code>hexo d</code>部署的时候，是吧该文件夹下的内容上传到了github的以用户名为仓库名的master分支上。 由于生成之后的文件是HTML格式的，不便于再编辑，所以存一份markdown格式的源代码也是很有必要的。在GitHub新建一个仓库hexoblog,使用这个仓库 存储Hexo的源代码。Coding.net与GitHub高度相似，不同的是它的Pages读取的是用户名为仓库名的gh-pages分支的代码，而不是master分支的代码，所以master分支正好可以用来 存储Hexo的源代码。</p><a id="more"></a><p>具体配置过程 <img src="home.png" alt="home"> <code>.git</code>中的<code>conf</code>文件中这样配置 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">repositoryformatversion = 0</span><br><span class="line">filemode = <span class="literal">false</span></span><br><span class="line">bare = <span class="literal">false</span></span><br><span class="line">logallrefupdates = <span class="literal">true</span></span><br><span class="line">symlinks = <span class="literal">false</span></span><br><span class="line">ignorecase = <span class="literal">true</span></span><br><span class="line">hideDotFiles = dotGitOnly</span><br><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">url = https://username:password@git.coding.net/username/username.git</span><br><span class="line">url = https://github.com/username/hexoblog.git</span><br><span class="line">fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch <span class="string">"master"</span>]</span><br><span class="line">remote = origin</span><br><span class="line">merge = refs/heads/master</span><br></pre></td></tr></table></figure></p><p><code>.gitignore</code>文件中这样配置 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.<span class="built_in">log</span></span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure></p><p><code>.deploy_git</code>文件夹中是执行<code>hexo d</code>提交的内容，在hexo配置文件<code>_config.yml</code>中这样配置 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line"> - <span class="built_in">type</span>: git</span><br><span class="line">   repo: https://username:password@git.coding.net/username/username.git</span><br><span class="line">   branch: coding-pages</span><br><span class="line">   message:</span><br><span class="line"> - <span class="built_in">type</span>: git</span><br><span class="line">   repo: https://username:password@github.com/username/username.github.io.git</span><br><span class="line">   branch: master</span><br><span class="line">   message:</span><br></pre></td></tr></table></figure></p><p>这样就可以实现生成的网站和网站源代码分别维护了。需要发布网站的时候，执行<code>hexo d</code> 需要备份博客数据的时候执行<code>git commit -a -m</code>和<code>git push origin master</code>。 &gt;<strong>注意</strong>：把以上的username换成你自己的用户名，password换成自己的密码</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工具 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows手工修改路由表</title>
      <link href="/hexoblog/2016/06/12/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%BB%9C%E8%BD%AF%E4%BB%B6/Windows%E6%89%8B%E5%B7%A5%E4%BF%AE%E6%94%B9%E8%B7%AF%E7%94%B1%E8%A1%A8/"/>
      <url>/hexoblog/2016/06/12/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%BB%9C%E8%BD%AF%E4%BB%B6/Windows%E6%89%8B%E5%B7%A5%E4%BF%AE%E6%94%B9%E8%B7%AF%E7%94%B1%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>当电脑开启VPN后，局域网内远程桌面连接就会失效，因为此时电脑所有网络都走VPN连接，走VPN后不再是一个局域网的地址了。要解决这个问题，可以手工控制路由表，实现远程桌面连接。 <a id="more"></a> 例如，有A，B两台电脑在同一个局域网。B通过A的本地连接的IP地址可以远程到A，这时候A拨号上网之后获得一个新的IP，B能通过这个新的IP连接到A，但是通过本地连接连接不到了。 这时候可以修改A的路由表，让B通过A的本地连接IP地址连接A，这样可以实现A无论上不上外网，B都可以远程到A，不管A的网络环境如何变化。 以管理员身份运行<code>cmd</code> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route add 172.23.0.0 mask 255.255.0.0 172.24.8.1 -p</span><br></pre></td></tr></table></figure></p><!-- more --><p>B 的IP地址所在的子网是 172.23.0. A 的出口网关地址是172.24.8.1 -p 是永久加入路由表，即使机器重启，如果只是临时使用，不用加参数-p</p><h2 id="路由操作常用命令">路由操作常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">route <span class="built_in">print</span> 打印当前路由表</span><br><span class="line">route add  添加一条路由</span><br><span class="line">route delete 删除一条路由</span><br><span class="line">route change 修改一条现有的路由</span><br><span class="line">route /? 查看该命令的帮助文件</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工具 </category>
          
          <category> 网络软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows全局代理软件Proxifier</title>
      <link href="/hexoblog/2016/06/12/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%BB%9C%E8%BD%AF%E4%BB%B6/Windows%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E8%BD%AF%E4%BB%B6Proxifier/"/>
      <url>/hexoblog/2016/06/12/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%BB%9C%E8%BD%AF%E4%BB%B6/Windows%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E8%BD%AF%E4%BB%B6Proxifier/</url>
      
        <content type="html"><![CDATA[<p>Proxifier 是一款功能非常强大的socks5代理服务器，可以让不支持通过代理服务器工作的网络程序能通过HTTPS或SOCKS代理或代理链。支持64位系统，支持Xp，Vista，Win7，支持socks4，socks5，http代理协议，支持TCP，UDP协议，可以指定端口，指定IP，指定程序等运行模式，兼容性非常好。</p><a id="more"></a><h2 id="安装">安装</h2><p><a href="http://www.proxifier.com/" target="_blank" rel="noopener">Proxifier</a></p><h2 id="配置">配置</h2><p>只需要配置代理服务器地址和端口号，Proxifier就可以默认为所有应用程序提供代理 <code>Profile-&gt;Proxy Servers</code>打开代理服务器配置窗口 <img src="proxy_server.png" alt="proxy_server"> <code>Address</code> <code>port</code>填代理服务器的地址和端口号，<code>Protocol</code>选择<code>SOCKS Version 5</code>,然后<code>ok</code></p><h2 id="设置代理规则">设置代理规则</h2><p>实际使用的时候，可能某个应用程序不想使用代理，例如<code>utorrent</code>,可能某些网站不想使用代理，例如学校内网的网站，PT站点等无需认证就能上的站点，可能有的网站需要不同的代理，例如访问国外网站需要一个能翻墙的代理，这些都可以通过配置代理规则来实现。 <code>profile-&gt;Proxification Rules</code>打开代理规则配置窗口 <img src="proxy_rules.png" alt="proxy_rules">hexo 可以按照程序，目标网站，端口三种类型配置代理规则，配置完成后确定即可启用。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工具 </category>
          
          <category> 网络软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校园网多终端上网方案</title>
      <link href="/hexoblog/2016/06/12/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C_%E6%A0%A1%E5%9B%AD%E7%BD%91%E5%A4%9A%E7%BB%88%E7%AB%AF%E4%B8%8A%E7%BD%91%E6%96%B9%E6%A1%88/"/>
      <url>/hexoblog/2016/06/12/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C_%E6%A0%A1%E5%9B%AD%E7%BD%91%E5%A4%9A%E7%BB%88%E7%AB%AF%E4%B8%8A%E7%BD%91%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>现在有不少学校的校园网同一个帐号只能同时在一个或者两个设备登陆，一旦你使用的设备超过这个数量，就会很麻烦，这里介绍两种代理上网的方案，适用于那种有一台电脑常开着的情况。 如果你有一台可以上网的电脑A，如何通过让其他设备都通过A上网呢？最常见的就是在A电脑上开一个热点，其他设备连接这个热点。但是这样做能够使用的范围很小，如果你在一个很大的局域网内，局域网内的机器不需要登陆帐号就可以互相Ping通，那么有更好的方式实现这一点。 <a id="more"></a> ## 使用代理软件 在机器Ａ上下载安装<a href="http://www.ccproxy.com/" target="_blank" rel="noopener">CCProxy</a>,虽然是收费软件，但是可以免费使用，免费版本限制3个用户连接，自己使用的话应该够了。 开启服务器 <img src="start_ccproxy.png" alt="start_ccproxy"> 然后在设置—高级—网络中取消禁止局域网外部用户访问的对勾，确定 <img src="cancel.png" alt="cancel"> 在设置里面的本机局域网IP地址选择自动检测，如果自动检测不能上网，请手动选择机器A能够连接外网的那个IP。 <img src="setting_ip.png" alt="setting_ip"> 保持主机A CCPROXY软件的运行。在主机B上配置ＨＴＴＰ代理或者scoket5代理，代理的地址是A的局域网IP地址，就是B能ping 通的那个IP地址，端口号默认HTTP是808，socket5是1080. 好了，现在主机B就可以上网了。现在的许多智能手机都原生支持HTTP代理，如何设置自行百度。</p><h2 id="搭建vpn">搭建VPN</h2><p>使用代理的好处是配置简单，可以配置自定义的规则，让不同的程序使用不同的网络连接。但是有的程序不支持使用代理连接，这时候可以考虑使用VPN。</p><h3 id="openvpn">openvpn</h3><p>在A上安装OpenVPN以Server方式运行，并将A可以上网的网络适配器共享给OpenVPN的虚拟适配器。 <img src="share_eth0.png" alt="share_eth0"> 在需要上网的手机或者电脑安装OpenVPN，并以Client方式运行，配置文件中填写A的ip地址，这里可以是IPv4，也可以是IPv6.IPv4可以在同一个学校通用，如果是IPv6地址，可以跨越学校，A机器在国内其他高校时，也可以使用。 这是一种使用其他学校校园网资源的方法，例如，可以通过这样的方法下载Ａ所在学校购买的数据库。</p><h3 id="softether">softether</h3><p><a href="https://www.softether.org/" target="_blank" rel="noopener">softether</a>也是一个VPN软件，提供友好的操作界面，客户端可以直接使用Windows自带的VPN连接，支持大部分手机使用自带的VPN连接。而且还支持动态DNS服务，如果Ａ所在地方的IP经常变动，推荐使用这个软件。 通过它还可以建立级联连接，只要双方单向联通，就可以建立一条专用通道，实现互联互通。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apache 配置虚拟主机</title>
      <link href="/hexoblog/2016/06/12/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_Apache-%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA/"/>
      <url>/hexoblog/2016/06/12/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_Apache-%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>Apache支持多个虚拟主机的设置，可以实现在一个IP上部署多个网站的效果。例如，在本机实现每个域名访问一个对应的网站，Apache应该如下配置。</p><a id="more"></a><h2 id="修改http.conf文件">修改<code>http.conf</code>文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory <span class="string">"E:/WebRoot"</span>&gt;</span><br><span class="line">    AllowOverride All</span><br><span class="line">    Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure><p>上面的代码将文件夹<code>W:/WebRoot</code>设置成可访问</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Include <span class="string">"conf/extra/httpd-vhost.conf"</span></span><br></pre></td></tr></table></figure><p>在主配置文件中包含虚拟主机配置文件，虚拟主机的信息在<code>httpd-vhost.conf</code>中配置</p><h2 id="修改httpd-vhost.conf文件">修改<code>httpd-vhost.conf</code>文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">    <span class="comment">##ServerAdmin webmaster@dummy-host.example.com</span></span><br><span class="line">    DocumentRoot <span class="string">"E:/WebRoot"</span></span><br><span class="line">    ServerName localhost</span><br><span class="line">    ServerAlias localhost</span><br><span class="line">    ErrorLog <span class="string">"logs/blog.com-error.log"</span></span><br><span class="line">    CustomLog <span class="string">"logs/blog.com-access.log"</span> common</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure><p>第一个节点是默认节点，所有没有匹配到的域名都会走这个节点，所以一般把这里设置成Web根目录，域名就是localhost,这样以后可以用localhost访问到这个web根目录的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">    <span class="comment">##ServerAdmin webmaster@dummy-host.example.com</span></span><br><span class="line">    DocumentRoot <span class="string">"E:/WebRoot/laravel-5-blog/public/"</span></span><br><span class="line">    ServerName my.blog.com</span><br><span class="line">    ServerAlias my.blog.com</span><br><span class="line">    ErrorLog <span class="string">"logs/blog.com-error.log"</span></span><br><span class="line">    CustomLog <span class="string">"logs/blog.com-access.log"</span> common</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure><p>像上面这样配置，当在浏览器输入my.blog.com的时候，就会访问到E:/WebRoot/laravel-5-blog/public/下，这里需要注意的是，一定要在httpd.conf里面设置了该文件夹的可访问权限，否则是会拒绝访问的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">    ServerAdmin webmaster@dummy-host2.example.com</span><br><span class="line">    DocumentRoot <span class="string">"E:/WebRoot/wordpress/"</span></span><br><span class="line">    ServerName my.wordpress.com</span><br><span class="line">    ErrorLog <span class="string">"logs/wordpress.com-error.log"</span></span><br><span class="line">    CustomLog <span class="string">"logs/wordpress.com-access.log"</span> common</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure><p>上面增加了一个域名为my.wordpress.com的站点。</p><h2 id="修改系统hosts文件">修改系统<code>hosts</code>文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1       my.blog.com</span><br><span class="line">127.0.0.1       my.wordpress.com</span><br></pre></td></tr></table></figure><p>然后就可以在浏览器使用对应的域名访问对应的网站了。这样设置的好处是对于那些路由有特殊要求的框架适应性比较好，不会出现资源找不到情况。另外，如果想在一台服务器上安装多个网站，这也是一个可行的方法。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> apache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>参考文献书写格式</title>
      <link href="/hexoblog/2016/06/12/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%E4%B9%A6%E5%86%99%E6%A0%BC%E5%BC%8F/"/>
      <url>/hexoblog/2016/06/12/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%E4%B9%A6%E5%86%99%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="国标格式">国标格式</h2><blockquote><ul><li>【图书】 作者. 书名[M]. 出版地: 出版社, 出版年.</li><li>【期刊论文】 作者. 论文标题[J]. 来源期刊, 年, 卷(期): 页码.</li><li>【学位论文】 作者. 论文标题[D]. 毕业院校所在地: 院校名称, 毕业年份.</li><li>【会议论文】 作者. 论文标题[C]// 会议论文集名称, 年代: 页码.</li><li>【专利】 申请人(发明人). 专利名称: 国别, 申请号[P]. 公开日.</li><li>【网络文献】 作者. 论文标题[EB/OL]. [检索日期].网址.</li></ul></blockquote><a id="more"></a><h2 id="示例">示例</h2><blockquote><ul><li>[1] 王蔷. 小学英语教学法教程[M]. 北京：高等教育出版社，2003.</li><li>[2] 陶仁骥. 密码学与数学[J]. 自然杂志，1984，7（7）：527-530.</li><li>[3] 华南理工大学. 一种长效矿物钾肥及其制备方法: 中国,200410026621.3[P].2004-03-25.</li><li>[4] 王亚军.整装催化剂及催化转化器若干研究[D].北京:北京理工大学,2000.</li><li>[5] 余晓蔚. 图书馆信息素养课程建设的实践与创新[C]// 全国文献检索课程教学研讨会, 2010: 25-33.</li><li>[6] 信息[EB/OL]. [2013-02-22]. http://baike.baidu.com/view/1527.htm.</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 认知神经科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文献格式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文献检索方法</title>
      <link href="/hexoblog/2016/06/12/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/%E6%96%87%E7%8C%AE%E6%A3%80%E7%B4%A2%E6%96%B9%E6%B3%95/"/>
      <url>/hexoblog/2016/06/12/%E6%8A%80%E6%9C%AF/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6/%E6%96%87%E7%8C%AE%E6%A3%80%E7%B4%A2%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="中国专利检索">中国专利检索</h1><p>专利是一种公开、免费、详细的资料，通常情况下比论文更新及时，了解专利申请情况，有利于把握住研究课题的前沿。 <a id="more"></a> ## 常用的专利检索网站 - <a href="http://www.sipo.gov.cn" target="_blank" rel="noopener">中国知识产权局</a> - <a href="http://www.cnipr.com.cn" target="_blank" rel="noopener">中国知识产权网</a> - <a href="http://www2.soopat.com/Home/IIndex" target="_blank" rel="noopener">SooPAT</a></p><h1 id="西文专利检索">西文专利检索</h1><h2 id="常用的专利检索网站">常用的专利检索网站</h2><ul><li><a href="http://apps.webofknowledge.com/" target="_blank" rel="noopener">Derwent</a></li><li><a href="http://patft.uspto.gov" target="_blank" rel="noopener">美国专业与商标局</a></li><li><a href="http://worldwide.espacenet.com/quickSearch?locale=en_EP" target="_blank" rel="noopener">欧洲Espacenet</a></li><li><a href="http://www.jpo.go.jp" target="_blank" rel="noopener">日本JPO</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 认知神经科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文献检索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Database Configuration Assist 工具创建oracle数据库</title>
      <link href="/hexoblog/2016/06/12/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93_%E4%BD%BF%E7%94%A8Database-Configuration-Assist-%E5%B7%A5%E5%85%B7%E5%88%9B%E5%BB%BAoracle%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/hexoblog/2016/06/12/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93_%E4%BD%BF%E7%94%A8Database-Configuration-Assist-%E5%B7%A5%E5%85%B7%E5%88%9B%E5%BB%BAoracle%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="启动database-configuration-assist-工具在oracle用户下输入dbca如果出现图形化安装界面就说明启动成功了如果提示错误就比较麻烦了第一个方法是先回到root用户下输入xhost-回车然后再回到oracle用户下重新输入dbca如果还打不开图形界面那么就麻烦了要重新装一下昨天装的软件直接输入cd-softdatabase然后ls然后.runinstall重新装一遍有一个界面是提示出现一个错误和一个警告把那两个都打上对勾然后完成安装之后在oracle中接着输入dbca就ok了进入到图形安装界面">启动Database Configuration Assist 工具,在oracle用户下输入dbca，如果出现图形化安装界面就说明启动成功了，如果提示错误，就比较麻烦了，第一个方法是先回到root用户下，输入xhost +，回车，然后再回到oracle用户下，重新输入dbca，如果还打不开图形界面，那么就麻烦了，要重新装一下昨天装的软件，直接输入cd /soft/database/，然后ls，然后./runInstall，重新装一遍，有一个界面是提示出现一个错误和一个警告，把那两个都打上对勾，然后完成安装，之后在oracle中接着输入dbca就Ok了，进入到图形安装界面。</h2><a id="more"></a><h2 id="创建数据库">创建数据库</h2><p><img src="create_database.jpg" alt="create_database"> <img src="create_database2.jpg" alt="create_database2"> ## 选择一般数据库 <img src="create_database3.jpg" alt="create_database3"> ## 给数据库命名要求为：组号+姓名首字母缩写 <img src="create_database3.jpg" alt="create_database4"> ## 选择使用EM配置数据库，使用Database Control管理数据库 <img src="create_database5.jpg" alt="create_database5"> ## 密码统一使用oracle <img src="create_database6.jpg" alt="create_database6"> ## 选择文件系统 <img src="create_database7.jpg" alt="create_database7"> ## 选择数据文件的目录 <img src="create_database8.jpg" alt="create_database8"> ## 指定闪回恢复区 <img src="create_database9.jpg" alt="create_database9"> ## 选择sample Schema <img src="create_database10.jpg" alt="create_database10"> ## 字符集选择如下 <img src="create_database11.jpg" alt="create_database11"> ## database storage 概览 <img src="create_database12.jpg" alt="create_database12"> ## 创建数据库，保存为数据库模板，并生成创建脚本 <img src="create_database13.jpg" alt="create_database13"> ## 数据库配置概览 <img src="create_database14.jpg" alt="create_database14"> ## 模板创建完成及脚本生成 <img src="create_database15_1.jpg" alt="create_database15_1"> <img src="create_database15_2.jpg" alt="create_database15_2"> ## 如下创建过程直至退出 <img src="create_database16_1.jpg" alt="create_database16_1"> <img src="create_database16_2.jpg" alt="create_database16_2"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试_Apache JMeter的使用</title>
      <link href="/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95_Apache-JMeter%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95_Apache-JMeter%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<div class="figure"><img src="jmeter.jpg" alt="jmeter"><p class="caption">jmeter</p></div><a id="more"></a><h2 id="安装">1. 安装</h2><ul><li>安装Java运行环境</li><li><p>下载Apache JMeter安装包 http://jmeter.apache.org/download_jmeter.cgi 下载<code>apache-jmeter-2.12.zip   md5 pgp</code></p></li><li><p>解压至任意文件夹，运行bin里面的jmeter,出现图形界面 Apache JMeter 教程： http://www.ltesting.net/ceshi/open/kyxncsgj/jmeter/</p></li></ul><h2 id="jmeter-录制操作脚本">2.JMeter 录制操作脚本</h2><h3 id="使用badboy-httpwww.badboy.com.au">2.1 使用badboy http://www.badboy.com.au/</h3><ul><li>file-&gt;new 开始录制</li><li>file-&gt;Export to JMeter 导出脚本</li><li>使用Jmeter file-&gt;open 打开脚本，添加Listener后开始测试 ###2.2 使用自带的代理服务器录制脚本</li><li>右击Test Plan Add-&gt;Threads(users)-&gt;Threads Group</li><li>右击Threads Group Add-&gt;Logic Controller-&gt;Recording Controller</li><li>右击WorkBench Add-&gt;Non-test Elements-&gt;HTTP(S) Test Script Recorder</li><li>在Target Controller选择Test Plan-&gt;Thread Group-&gt;Recording Controller</li><li>在Grouping选择Put each group in a new transaction controller</li><li>单击底部的Start开启代理服务器</li><li>IE配置： Internet Options-&gt;Connections-&gt;LAN Settings 在Proxy server下面的方框打钩，Adress: localhost Port:8080 单击OK 在浏览器输入录制的网址，就可以开始录制了。录制完成后，停止代理服务器，取消IE的代理设置即可。</li><li>要访问HTTPS的网站，需要将证书加入到浏览器中， 证书位置：JMeter-&gt;bin目录中的ApacheJMeterTemporaryRootCA.crt FireFox加入办法：Options-&gt;Advanced-&gt;Certificates-&gt;View Certificates-&gt;Import</li><li>数字证书安装参考：http://jmeter.apache.org/usermanual/component_reference.html#HTTP%28S%29_Test_Script_Recorder <strong>在根证书里面加上bin里面自动生成的证书</strong>。</li></ul><h2 id="查看并分析测试结果">3. 查看并分析测试结果</h2><p>通过上一步得到测试脚本后，下一步就是Add-&gt;Listener-&gt;Aggregate Report,Add-&gt;Listener-&gt;View Result in Table等查看测试结果了。 ###3.1 Aggregate Report - Label element(例如HTTP Request) 的名称 - Samples 发出的请求的数量 - Average 平均的响应时间 - Median 所有响应时间的中位数 - 90%Line 90%用户的响应时间 - Min 最小的响应时间 - Max 最大的响应时间 - Error% 出现错误的请求的数量 / 请求的总数 - Throughput 每秒完成的请求数量（Request Per Sencond） - KB/sec 每秒从服务器接收到的数据量 ###3.2 View Result in Table - Sample 请求的序号 - StartTime 请求开始的时间 - ThreadName 本次请求的线程的名称 - Sample Time 请求花费的时间 - Status 请求是否成功 - Bytes 请求返回的数据量</p><h2 id="new-relic在线监测平台">3. New Relic（在线监测平台）</h2><h3 id="配置">3.1 配置</h3><ul><li>注册账户 http://newrelic.com/</li><li>选择最上面的APM，然后选择PHP，安装PHP Agent https://docs.newrelic.com/docs/agents/php-agent/installation/php-agent-installation-redhat-centos</li><li>安装完成之后重启服务器，出现PHP Application，单击进入有监控界面 PHPAplication_NewRelic.png</li></ul><p>参考网站：http://code.tutsplus.com/tutorials/new-relic-jmeter-perfect-performance-testing–net-34978 ###3.2 监测结果分析 参考网址：https://cnodejs.org/topic/53fde58d7c1e2284785cd39e ####3.2.1 Overview 后台统计总图，分为5个部分 - Web transactions response time 网站平均响应时间 - Apdex score 应用性能指数：蓝色表示优异，绿色表示好，黄色表示一般 - Throughput 每分钟请求数 （request per minute） - Transaction 接口的响应时间 - Error rate 引起错误的请求 / 总请求数量 图：image-&gt;New Relic入门-&gt;Overview_NewRelic.png ####3.2.2 Map 系统用到的各个应用之间的关系 和 每个应用的平均响应时间 图：image-&gt;New Relic入门-&gt;Map_NewRelic.png ####3.2.3 Transactions 应用请求的每个URL地址的响应时间。在这里可以看到每个接口的响应时间。 单击某个能看到详细的信息。 图：image-&gt;New Relic入门-&gt;Transactions_NewRelic.png ####3.2.4 Database 数据库的各种操作的平均响应时长 ### browser 参考网站：http://code.tutsplus.com/tutorials/front-end-monitoring-with-new-relic-browser–cms-22424 在每一个展示给用户的页面加载完成的时候，Browser都会捕捉一下信息： - 页面加载完毕花费的时间 - 代码和动作（包括JS，Ajax, 用户与浏览器交互的时间）执行的时间 - 在网络上和服务器上花费的时间 - 浏览器信息，操作系统信息 Overview:概要视图 browser -&gt; Session traces: 跟踪一个真正的用户从开始到结束的经历。监控的信息包括，用户交互，资源加载，iframes,等待Ajax调用的时间，出现的错误和其他相关信息。 在这里，你能看到一个错误发生之前和之后用户做了什么。</p><blockquote><p>Session traces help you understand: How users experience your page load, including time to DOM load, time waiting for Ajax requests to complete, and the user’s interactions with the page How the New Relic metrics reflect your end users’ experiences The sequence of JavaScript and browser events, which take longer than others, and when each event occurs Where bottlenecks occur, and what may be causing them Why one page load may be slower than others, by providing the context for individual events during a session browser -&gt; Page Views: 提供被频繁访问的页面的详细信息 broeser -&gt; Browsers: 查看你的网站在不同浏览器下的表现。</p></blockquote><h3 id="synthetics">Synthetics</h3><p>为你的网站设置定期的测试，当问题出现后立刻通知你。 ### Server 监控服务器 硬盘 内存 网络 CPU使用情况。 Server -&gt; Processes: 显示每个进程的CPU和内存使用情况</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能测试 </tag>
            
            <tag> jmeter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试_Selenium Action</title>
      <link href="/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95_Selenium-Action/"/>
      <url>/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95_Selenium-Action/</url>
      
        <content type="html"><![CDATA[<p>action用于模拟用户与浏览器之间的交互 <a id="more"></a> &gt; - open(url) 打开网页 &gt; - click() 单击 &gt; - clickAndWait() 单击并等待，生成代码时，比上一句多一个<code>$this-waitForPageLoad('3000');</code> &gt; - type( , ) 输入文本 &gt; - select() 选择下拉菜单 &gt; - goBack() 单击浏览器返回按钮 &gt; - close() 模拟单击关闭按钮 &gt; - setSpeed() 设置执行速度 &gt; - pause() 等待指定的时间后继续执行 &gt; - setTinmeout() 指定过期时间</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试_Selenium定位元素的几种方式</title>
      <link href="/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95_Selenium-%E5%AE%9A%E4%BD%8D%E5%85%83%E7%B4%A0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95_Selenium-%E5%AE%9A%E4%BD%8D%E5%85%83%E7%B4%A0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="默认方式">1. 默认方式</h2><p>形如<code>identifier = location</code>的定位方式在HTNL文件中寻找第一个ID等于location的元素，如果没有，则匹配第一个name等于location的元素，也可以直接简写成<code>location</code></p><a id="more"></a><h2 id="通过id定位">2. 通过ID定位</h2><p>形如<code>id = id_name</code>的定位方式在HTML文件中匹配ID等于id_name的元素。 ## 3. 通过name定位 形如<code>name = name_name</code>的定位方式可以匹配文件中第一个name等于name_name的元素。通常，在HTNL中，name与ID不同，name并不一定是唯一的，可能许多不同的元素有相同的name，为了匹配到不同的元素，可以加上不同于其他元素的特征，例如： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">   &lt;form id=&quot;loginForm&quot;&gt;</span><br><span class="line">    &lt;input name=&quot;username&quot; type=&quot;text&quot; /&gt;</span><br><span class="line">    &lt;input name=&quot;password&quot; type=&quot;password&quot; /&gt;</span><br><span class="line">    &lt;input name=&quot;continue&quot; type=&quot;submit&quot; value=&quot;Login&quot; /&gt;</span><br><span class="line">    &lt;input name=&quot;continue&quot; type=&quot;button&quot; value=&quot;Clear&quot; /&gt;</span><br><span class="line">   &lt;/form&gt;</span><br><span class="line"> &lt;/body&gt;</span><br><span class="line"> &lt;html&gt;</span><br></pre></td></tr></table></figure></p><table style="width:24%;"><colgroup><col width="23%"></colgroup><tbody><tr class="odd"><td>&gt; - name = username 定位到第四行 &gt; - name = continue value = clear name = continue clear name = continue type=button 都会定位到第七行。</td></tr><tr class="even"><td>过上面的三种方法，可以独立的测试某个元素，与HTML结构没有关系。所以，当你的网页结构经常变化又希望不要经常改变测试代码的时候，尽量使用上面三种方式就显得十分重要。 # 4. 通过XPath定位 XPath是XML中定位结点的一种方式，因为HTML也可以实现XML接口，所以也可以XPath语法定位HTML元素。 XPath有两种定位方式，绝对定位和相对定位。 - 绝对定位从<code>html</code>元素开始一级一级找到需要的元素，HTML文件很小的改动也可能打破这种层级关系，所以不推荐使用这种定位方式。 - 相对定位是从某一个容易定位的元素开始，以它为参照找到需要的元素，原HTML文件部分改动时，对这种相对关系影响较小，推荐使用这种定位方式。 只有当用以上三种方式不容易定位到需要的元素时，才推荐使用XPath定位。 用上面的HTML举几个例子： 1. xpath = /html/body/form[1] 对定位，定位到第三行form 2. //form[1] 对定位，定位到HTML中第一个form元素 3. xpath=//form<span class="citation">[@id='loginForm']</span> 位到<code>id='loginForm'</code>的form元素 4. xpath=//form<span class="citation">[input/@name='username']</span> 位到有一个<code>name=username</code>的input元素的form中 5. //input<span class="citation">[@name='username']</span> 一个name=username的input元素 6. //form<span class="citation">[@id='loginForm']</span>/input[1] 位到Id=’loginForm’的form中的第一个input元素 7. //input<span class="citation">[@name='continue']</span><span class="citation">[@type='button']</span> 位到name=continue type=button的input元素 8. //form<span class="citation">[@id='loginForm']</span>/input[4] 位到ID=loginForm的form元素中的第四个元素。</td></tr><tr class="odd"><td># 5. 通过超链接定位 合定位带超链接的元素 1. link=www.baidu.com 2. link=首页 果HTML中存在多个href相同的字段，总是返回第一个。 # 6. 通过DOM定位 用JavaScript定位元素的方式： dom=document.getElementById(‘loginForm’) (3) dom=document.forms[‘loginForm’] (3) dom=document.forms[0] (3) document.forms[0].username (4) document.forms[0].elements[‘username’] (4) document.forms[0].elements[0] (4) document.forms[0].elements[3] (7) # 7. 通过CSS样式定位 SS通过选择器将定义的样式与文档中的元素绑定在一起。CSS定位元素的策略也可以在Selenium中使用。</td></tr><tr class="even"><td>css=form#loginForm (3) css=input[name=“username”] (4) css=input.required[type=“text”] (4) css=input.passfield (5) css=#loginForm input[type=“button”] (7) css=#loginForm input:nth-child(2) (5)</td></tr></tbody></table><p>小括号中的数字代码定位到HTML代码的第几行。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis入门</title>
      <link href="/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93_Redis%E5%85%A5%E9%97%A8/"/>
      <url>/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93_Redis%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="安装">1. 安装</h2><ul><li>Windows 平台 下载地址：链接: http://pan.baidu.com/s/1ntkhsxF 密码: 9c27</li></ul><a id="more"></a><p>32位系统选择redisbin_x32.zip,64位系统选择redisbin_x64.zip,解压到任意文件夹，文件结构如下： &gt; redis-server.exe 服务器端程序 &gt; redis-cli.exe 客户端程序，用来连接服务器 &gt; redis-check-dump.exe 本地数据库检查程序 &gt; resdis-benchmark.exe 性能测试工具</p><h2 id="启动服务">2. 启动服务</h2><p><code>redis-server.exe redis.conf</code> ##3. 连接服务器 <code>redis-cli.exe -h 127.0.0.1 -p 6379</code> ##4. 基本操作 - set key value 插入数据 - get key 获取数据 - mget key1 key2 key3 一次获取多个数据 - del key 删除数据 - exits key 判断是否存在 - select 0 选择第一个数据库（默认有0-15共16个数据库） - keys * 查看所有的key</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信发送模板消息的代码</title>
      <link href="/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91_%E5%8F%91%E9%80%81%E6%A8%A1%E6%9D%BF%E6%B6%88%E6%81%AF%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
      <url>/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91_%E5%8F%91%E9%80%81%E6%A8%A1%E6%9D%BF%E6%B6%88%E6%81%AF%E7%9A%84%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>PHP实现的获取模版消息的方法</p><a id="more"></a><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">http_request</span><span class="params">($url,$data=array<span class="params">()</span>)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       $ch = curl_init();</span><br><span class="line">       curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">       curl_setopt($ch, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">       curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, <span class="keyword">FALSE</span>);</span><br><span class="line">       curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, <span class="keyword">FALSE</span>);</span><br><span class="line">       curl_setopt($ch, CURLOPT_POST, <span class="number">1</span>);</span><br><span class="line">       curl_setopt($ch, CURLOPT_POSTFIELDS, $data);</span><br><span class="line">       $output = curl_exec($ch);</span><br><span class="line">       curl_close($ch);</span><br><span class="line">       <span class="keyword">return</span> $output;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getWechate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       $acess_token = <span class="string">"5i8vEVj4OsH7GGDbER778OhfGZTIwZgqecnr1yPrxK-1kfXDSJzEWVRax1sUD-v6CPrSdJI--qXvLgZ_KbFe5rrVNM2zJvWeY__JzKXRP3c"</span>;</span><br><span class="line">       $template=<span class="keyword">array</span>(</span><br><span class="line">           <span class="string">'touser'</span>=&gt;<span class="string">"oN3CtjnmV68ieh-0_6p_kvX14-l4"</span>,</span><br><span class="line">           <span class="string">'template_id'</span>=&gt;<span class="string">"mHFY7Au5sA1a4fv6CoFO-YOAsxirOpMijRa3DmWef-k"</span>,</span><br><span class="line">           <span class="string">'url'</span>=&gt;<span class="string">"http://www.baidu.com"</span>,</span><br><span class="line">           <span class="string">'topcolor'</span>=&gt;<span class="string">"#7B68EE"</span>,</span><br><span class="line">           <span class="string">'data'</span>=&gt;<span class="keyword">array</span>(</span><br><span class="line">               <span class="string">'first'</span>=&gt;<span class="keyword">array</span>(<span class="string">'value'</span>=&gt;urlencode(<span class="string">"您好,您已购买成功"</span>),<span class="string">'color'</span>=&gt;<span class="string">"#743A3A"</span>),</span><br><span class="line">               <span class="string">'tradeDateTime'</span>=&gt;<span class="keyword">array</span>(<span class="string">'value'</span>=&gt;date(<span class="string">"Y-m-d H:i:s"</span>,time()),<span class="string">'color'</span>=&gt;<span class="string">'#743A3A'</span>),</span><br><span class="line">               <span class="string">'orderType'</span>=&gt;<span class="keyword">array</span>(<span class="string">'value'</span>=&gt;urlencode(<span class="string">'货到付款'</span>),<span class="string">'color'</span>=&gt;<span class="string">'#743A3A'</span>),</span><br><span class="line">               <span class="string">'customerInfo'</span>=&gt;<span class="keyword">array</span>(<span class="string">'value'</span>=&gt;urlencode(<span class="string">'似水流年'</span>),<span class="string">'color'</span>=&gt;<span class="string">'#743A3A'</span>),</span><br><span class="line">               <span class="string">'orderItemName'</span>=&gt;<span class="keyword">array</span>(<span class="string">'value'</span>=&gt;urlencode(<span class="string">'订单号码：'</span>),<span class="string">'color'</span>=&gt;<span class="string">'#743A3A'</span>),</span><br><span class="line">               <span class="string">'orderItemData'</span>=&gt;<span class="keyword">array</span>(<span class="string">'value'</span>=&gt;urlencode(<span class="string">'1234567890'</span>),<span class="string">'color'</span>=&gt;<span class="string">'#743A3A'</span>),</span><br><span class="line">               <span class="string">'remark'</span>=&gt;<span class="keyword">array</span>(<span class="string">'value'</span>=&gt;urlencode(<span class="string">'点击查看详情'</span>),<span class="string">'color'</span>=&gt;<span class="string">'#743A3A'</span>),</span><br><span class="line">           )</span><br><span class="line">       );</span><br><span class="line">       $json_template=json_encode($template);</span><br><span class="line">       $url=<span class="string">"https://api.weixin.qq.com/cgi-bin/message/template/send?access_token="</span>.$acess_token;</span><br><span class="line">       $res=<span class="keyword">$this</span>-&gt;http_request($url,urldecode($json_template));</span><br><span class="line">       var_dump($res);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信公众号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信获取地理位置 </title>
      <link href="/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91_%E8%8E%B7%E5%8F%96%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE/"/>
      <url>/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91_%E8%8E%B7%E5%8F%96%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>适用于网页前端的地理位置获取代码</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">wx.config(&#123;</span><br><span class="line">          debug: <span class="literal">false</span>, <span class="comment">// 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span></span><br><span class="line">          appId:getAppId(), <span class="comment">// 必填，公众号的唯一标识</span></span><br><span class="line">          timestamp:getTimestamp(), <span class="comment">// 必填，生成签名的时间戳</span></span><br><span class="line">          nonceStr:getNonceStr2(), <span class="comment">// 必填，生成签名的随机串</span></span><br><span class="line">          signature:getSignature(),<span class="comment">// 必填，签名，见附录1</span></span><br><span class="line">          jsApiList:$jsApiList<span class="comment">// 必填，需要使用的JS接口列表，所有JS接口列表见附录2</span></span><br><span class="line">      &#125;);</span><br><span class="line">      wx.ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          wx.getLocation(</span><br><span class="line">          &#123;</span><br><span class="line">              success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>)</span></span><br><span class="line"><span class="function">              </span>&#123;</span><br><span class="line">                  <span class="keyword">var</span> latitude = res.latitude; <span class="comment">// 纬度，浮点数，范围为90 ~ -90</span></span><br><span class="line">                  <span class="keyword">var</span> longitude = res.longitude; <span class="comment">// 经度，浮点数，范围为180 ~ -180。</span></span><br><span class="line">                  <span class="keyword">var</span> speed = res.speed; <span class="comment">// 速度，以米/每秒计</span></span><br><span class="line">                  <span class="keyword">var</span> accuracy = res.accuracy; <span class="comment">// 位置精度</span></span><br><span class="line">                  $.ajax(</span><br><span class="line">                      &#123;</span><br><span class="line">                          type: <span class="string">"POST"</span>,</span><br><span class="line">                          url : <span class="string">"/store/distance"</span>,</span><br><span class="line">                          data :</span><br><span class="line">                          &#123;</span><br><span class="line">                              order_id : $(<span class="string">"#order_id"</span>).val(),</span><br><span class="line">                              latitude : latitude,</span><br><span class="line">                              longitude : longitude</span><br><span class="line">                          &#125;,</span><br><span class="line">                          dataType : <span class="string">'json'</span></span><br><span class="line">                      &#125;);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">      wx.error(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信公众号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信发送消息PHP SDK</title>
      <link href="/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91_%E5%BE%AE%E4%BF%A1%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AFPHP-SDK/"/>
      <url>/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91_%E5%BE%AE%E4%BF%A1%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AFPHP-SDK/</url>
      
        <content type="html"><![CDATA[<p>一个实现好的PHP SDK，用于微信公众号处理和消息有关的所有事情 <a id="more"></a> <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    方倍工作室</span></span><br><span class="line"><span class="comment">    http://www.cnblogs.com/txw1958/</span></span><br><span class="line"><span class="comment">    CopyRight 2014 All Rights Reserved</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">define(<span class="string">"TOKEN"</span>, <span class="string">"weixin"</span>);</span><br><span class="line"></span><br><span class="line">$wechatObj = <span class="keyword">new</span> wechatCallbackapiTest();</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>($_GET[<span class="string">'echostr'</span>])) &#123;</span><br><span class="line">    $wechatObj-&gt;responseMsg();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    $wechatObj-&gt;valid();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">wechatCallbackapiTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//验证签名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">valid</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $echoStr = $_GET[<span class="string">"echostr"</span>];</span><br><span class="line">        $signature = $_GET[<span class="string">"signature"</span>];</span><br><span class="line">        $timestamp = $_GET[<span class="string">"timestamp"</span>];</span><br><span class="line">        $nonce = $_GET[<span class="string">"nonce"</span>];</span><br><span class="line">        $token = TOKEN;</span><br><span class="line">        $tmpArr = <span class="keyword">array</span>($token, $timestamp, $nonce);</span><br><span class="line">        sort($tmpArr);</span><br><span class="line">        $tmpStr = implode($tmpArr);</span><br><span class="line">        $tmpStr = sha1($tmpStr);</span><br><span class="line">        <span class="keyword">if</span>($tmpStr == $signature)&#123;</span><br><span class="line">            <span class="keyword">echo</span> $echoStr;</span><br><span class="line">            <span class="keyword">exit</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//响应消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">responseMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $postStr = $GLOBALS[<span class="string">"HTTP_RAW_POST_DATA"</span>];</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">empty</span>($postStr))&#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;logger(<span class="string">"R "</span>.$postStr);</span><br><span class="line">            $postObj = simplexml_load_string($postStr, <span class="string">'SimpleXMLElement'</span>, LIBXML_NOCDATA);</span><br><span class="line">            $RX_TYPE = trim($postObj-&gt;MsgType);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//消息类型分离</span></span><br><span class="line">            <span class="keyword">switch</span> ($RX_TYPE)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"event"</span>:</span><br><span class="line">                    $result = <span class="keyword">$this</span>-&gt;receiveEvent($postObj);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"text"</span>:</span><br><span class="line">                    $result = <span class="keyword">$this</span>-&gt;receiveText($postObj);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"image"</span>:</span><br><span class="line">                    $result = <span class="keyword">$this</span>-&gt;receiveImage($postObj);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"location"</span>:</span><br><span class="line">                    $result = <span class="keyword">$this</span>-&gt;receiveLocation($postObj);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"voice"</span>:</span><br><span class="line">                    $result = <span class="keyword">$this</span>-&gt;receiveVoice($postObj);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"video"</span>:</span><br><span class="line">                    $result = <span class="keyword">$this</span>-&gt;receiveVideo($postObj);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"link"</span>:</span><br><span class="line">                    $result = <span class="keyword">$this</span>-&gt;receiveLink($postObj);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    $result = <span class="string">"unknown msg type: "</span>.$RX_TYPE;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;logger(<span class="string">"T "</span>.$result);</span><br><span class="line">            <span class="keyword">echo</span> $result;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">exit</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收事件消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">receiveEvent</span><span class="params">($object)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $content = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">switch</span> ($object-&gt;Event)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"subscribe"</span>:</span><br><span class="line">                $content = <span class="string">"欢迎关注方倍工作室 "</span>;</span><br><span class="line">                $content .= (!<span class="keyword">empty</span>($object-&gt;EventKey))?(<span class="string">"\n来自二维码场景 "</span>.str_replace(<span class="string">"qrscene_"</span>,<span class="string">""</span>,$object-&gt;EventKey)):<span class="string">""</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"unsubscribe"</span>:</span><br><span class="line">                $content = <span class="string">"取消关注"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"SCAN"</span>:</span><br><span class="line">                $content = <span class="string">"扫描场景 "</span>.$object-&gt;EventKey;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"CLICK"</span>:</span><br><span class="line">                <span class="keyword">switch</span> ($object-&gt;EventKey)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"COMPANY"</span>:</span><br><span class="line">                        $content = <span class="keyword">array</span>();</span><br><span class="line">                        $content[] = <span class="keyword">array</span>(<span class="string">"Title"</span>=&gt;<span class="string">"多图文1标题"</span>, <span class="string">"Description"</span>=&gt;<span class="string">""</span>, <span class="string">"PicUrl"</span>=&gt;<span class="string">"http://discuz.comli.com/weixin/weather/icon/cartoon.jpg"</span>, <span class="string">"Url"</span> =&gt;<span class="string">"http://m.cnblogs.com/?u=txw1958"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        $content = <span class="string">"点击菜单："</span>.$object-&gt;EventKey;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"LOCATION"</span>:</span><br><span class="line">                $content = <span class="string">"上传位置：纬度 "</span>.$object-&gt;Latitude.<span class="string">";经度 "</span>.$object-&gt;Longitude;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"VIEW"</span>:</span><br><span class="line">                $content = <span class="string">"跳转链接 "</span>.$object-&gt;EventKey;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"MASSSENDJOBFINISH"</span>:</span><br><span class="line">                $content = <span class="string">"消息ID："</span>.$object-&gt;MsgID.<span class="string">"，结果："</span>.$object-&gt;Status.<span class="string">"，粉丝数："</span>.$object-&gt;TotalCount.<span class="string">"，过滤："</span>.$object-&gt;FilterCount.<span class="string">"，发送成功："</span>.$object-&gt;SentCount.<span class="string">"，发送失败："</span>.$object-&gt;ErrorCount;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                $content = <span class="string">"receive a new event: "</span>.$object-&gt;Event;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(is_array($content))&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">isset</span>($content[<span class="number">0</span>]))&#123;</span><br><span class="line">                $result = <span class="keyword">$this</span>-&gt;transmitNews($object, $content);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">isset</span>($content[<span class="string">'MusicUrl'</span>]))&#123;</span><br><span class="line">                $result = <span class="keyword">$this</span>-&gt;transmitMusic($object, $content);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            $result = <span class="keyword">$this</span>-&gt;transmitText($object, $content);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收文本消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">receiveText</span><span class="params">($object)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $keyword = trim($object-&gt;Content);</span><br><span class="line">        <span class="comment">//多客服人工回复模式</span></span><br><span class="line">        <span class="keyword">if</span> (strstr($keyword, <span class="string">"您好"</span>) || strstr($keyword, <span class="string">"你好"</span>) || strstr($keyword, <span class="string">"在吗"</span>))&#123;</span><br><span class="line">            $result = <span class="keyword">$this</span>-&gt;transmitService($object);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//自动回复模式</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (strstr($keyword, <span class="string">"文本"</span>))&#123;</span><br><span class="line">                $content = <span class="string">"这是个文本消息"</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (strstr($keyword, <span class="string">"单图文"</span>))&#123;</span><br><span class="line">                $content = <span class="keyword">array</span>();</span><br><span class="line">                $content[] = <span class="keyword">array</span>(<span class="string">"Title"</span>=&gt;<span class="string">"单图文标题"</span>,  <span class="string">"Description"</span>=&gt;<span class="string">"单图文内容"</span>, <span class="string">"PicUrl"</span>=&gt;<span class="string">"http://discuz.comli.com/weixin/weather/icon/cartoon.jpg"</span>, <span class="string">"Url"</span> =&gt;<span class="string">"http://m.cnblogs.com/?u=txw1958"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (strstr($keyword, <span class="string">"图文"</span>) || strstr($keyword, <span class="string">"多图文"</span>))&#123;</span><br><span class="line">                $content = <span class="keyword">array</span>();</span><br><span class="line">                $content[] = <span class="keyword">array</span>(<span class="string">"Title"</span>=&gt;<span class="string">"多图文1标题"</span>, <span class="string">"Description"</span>=&gt;<span class="string">""</span>, <span class="string">"PicUrl"</span>=&gt;<span class="string">"http://discuz.comli.com/weixin/weather/icon/cartoon.jpg"</span>, <span class="string">"Url"</span> =&gt;<span class="string">"http://m.cnblogs.com/?u=txw1958"</span>);</span><br><span class="line">                $content[] = <span class="keyword">array</span>(<span class="string">"Title"</span>=&gt;<span class="string">"多图文2标题"</span>, <span class="string">"Description"</span>=&gt;<span class="string">""</span>, <span class="string">"PicUrl"</span>=&gt;<span class="string">"http://d.hiphotos.bdimg.com/wisegame/pic/item/f3529822720e0cf3ac9f1ada0846f21fbe09aaa3.jpg"</span>, <span class="string">"Url"</span> =&gt;<span class="string">"http://m.cnblogs.com/?u=txw1958"</span>);</span><br><span class="line">                $content[] = <span class="keyword">array</span>(<span class="string">"Title"</span>=&gt;<span class="string">"多图文3标题"</span>, <span class="string">"Description"</span>=&gt;<span class="string">""</span>, <span class="string">"PicUrl"</span>=&gt;<span class="string">"http://g.hiphotos.bdimg.com/wisegame/pic/item/18cb0a46f21fbe090d338acc6a600c338644adfd.jpg"</span>, <span class="string">"Url"</span> =&gt;<span class="string">"http://m.cnblogs.com/?u=txw1958"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (strstr($keyword, <span class="string">"音乐"</span>))&#123;</span><br><span class="line">                $content = <span class="keyword">array</span>();</span><br><span class="line">                $content = <span class="keyword">array</span>(<span class="string">"Title"</span>=&gt;<span class="string">"最炫民族风"</span>, <span class="string">"Description"</span>=&gt;<span class="string">"歌手：凤凰传奇"</span>, <span class="string">"MusicUrl"</span>=&gt;<span class="string">"http://121.199.4.61/music/zxmzf.mp3"</span>, <span class="string">"HQMusicUrl"</span>=&gt;<span class="string">"http://121.199.4.61/music/zxmzf.mp3"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                $content = date(<span class="string">"Y-m-d H:i:s"</span>,time()).<span class="string">"\n技术支持 方倍工作室"</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(is_array($content))&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">isset</span>($content[<span class="number">0</span>][<span class="string">'PicUrl'</span>]))&#123;</span><br><span class="line">                    $result = <span class="keyword">$this</span>-&gt;transmitNews($object, $content);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">isset</span>($content[<span class="string">'MusicUrl'</span>]))&#123;</span><br><span class="line">                    $result = <span class="keyword">$this</span>-&gt;transmitMusic($object, $content);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                $result = <span class="keyword">$this</span>-&gt;transmitText($object, $content);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收图片消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">receiveImage</span><span class="params">($object)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $content = <span class="keyword">array</span>(<span class="string">"MediaId"</span>=&gt;$object-&gt;MediaId);</span><br><span class="line">        $result = <span class="keyword">$this</span>-&gt;transmitImage($object, $content);</span><br><span class="line">        <span class="keyword">return</span> $result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收位置消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">receiveLocation</span><span class="params">($object)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $content = <span class="string">"你发送的是位置，纬度为："</span>.$object-&gt;Location_X.<span class="string">"；经度为："</span>.$object-&gt;Location_Y.<span class="string">"；缩放级别为："</span>.$object-&gt;Scale.<span class="string">"；位置为："</span>.$object-&gt;Label;</span><br><span class="line">        $result = <span class="keyword">$this</span>-&gt;transmitText($object, $content);</span><br><span class="line">        <span class="keyword">return</span> $result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收语音消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">receiveVoice</span><span class="params">($object)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">isset</span>($object-&gt;Recognition) &amp;&amp; !<span class="keyword">empty</span>($object-&gt;Recognition))&#123;</span><br><span class="line">            $content = <span class="string">"你刚才说的是："</span>.$object-&gt;Recognition;</span><br><span class="line">            $result = <span class="keyword">$this</span>-&gt;transmitText($object, $content);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            $content = <span class="keyword">array</span>(<span class="string">"MediaId"</span>=&gt;$object-&gt;MediaId);</span><br><span class="line">            $result = <span class="keyword">$this</span>-&gt;transmitVoice($object, $content);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收视频消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">receiveVideo</span><span class="params">($object)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $content = <span class="keyword">array</span>(<span class="string">"MediaId"</span>=&gt;$object-&gt;MediaId, <span class="string">"ThumbMediaId"</span>=&gt;$object-&gt;ThumbMediaId, <span class="string">"Title"</span>=&gt;<span class="string">""</span>, <span class="string">"Description"</span>=&gt;<span class="string">""</span>);</span><br><span class="line">        $result = <span class="keyword">$this</span>-&gt;transmitVideo($object, $content);</span><br><span class="line">        <span class="keyword">return</span> $result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收链接消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">receiveLink</span><span class="params">($object)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $content = <span class="string">"你发送的是链接，标题为："</span>.$object-&gt;Title.<span class="string">"；内容为："</span>.$object-&gt;Description.<span class="string">"；链接地址为："</span>.$object-&gt;Url;</span><br><span class="line">        $result = <span class="keyword">$this</span>-&gt;transmitText($object, $content);</span><br><span class="line">        <span class="keyword">return</span> $result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回复文本消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">transmitText</span><span class="params">($object, $content)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $xmlTpl = <span class="string">"&lt;xml&gt;</span></span><br><span class="line"><span class="string">&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;</span></span><br><span class="line"><span class="string">&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;</span></span><br><span class="line"><span class="string">&lt;CreateTime&gt;%s&lt;/CreateTime&gt;</span></span><br><span class="line"><span class="string">&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;</span></span><br><span class="line"><span class="string">&lt;Content&gt;&lt;![CDATA[%s]]&gt;&lt;/Content&gt;</span></span><br><span class="line"><span class="string">&lt;/xml&gt;"</span>;</span><br><span class="line">        $result = sprintf($xmlTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time(), $content);</span><br><span class="line">        <span class="keyword">return</span> $result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回复图片消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">transmitImage</span><span class="params">($object, $imageArray)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $itemTpl = <span class="string">"&lt;Image&gt;</span></span><br><span class="line"><span class="string">    &lt;MediaId&gt;&lt;![CDATA[%s]]&gt;&lt;/MediaId&gt;</span></span><br><span class="line"><span class="string">&lt;/Image&gt;"</span>;</span><br><span class="line"></span><br><span class="line">        $item_str = sprintf($itemTpl, $imageArray[<span class="string">'MediaId'</span>]);</span><br><span class="line"></span><br><span class="line">        $xmlTpl = <span class="string">"&lt;xml&gt;</span></span><br><span class="line"><span class="string">&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;</span></span><br><span class="line"><span class="string">&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;</span></span><br><span class="line"><span class="string">&lt;CreateTime&gt;%s&lt;/CreateTime&gt;</span></span><br><span class="line"><span class="string">&lt;MsgType&gt;&lt;![CDATA[image]]&gt;&lt;/MsgType&gt;</span></span><br><span class="line"><span class="string">$item_str</span></span><br><span class="line"><span class="string">&lt;/xml&gt;"</span>;</span><br><span class="line"></span><br><span class="line">        $result = sprintf($xmlTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time());</span><br><span class="line">        <span class="keyword">return</span> $result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回复语音消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">transmitVoice</span><span class="params">($object, $voiceArray)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $itemTpl = <span class="string">"&lt;Voice&gt;</span></span><br><span class="line"><span class="string">    &lt;MediaId&gt;&lt;![CDATA[%s]]&gt;&lt;/MediaId&gt;</span></span><br><span class="line"><span class="string">&lt;/Voice&gt;"</span>;</span><br><span class="line"></span><br><span class="line">        $item_str = sprintf($itemTpl, $voiceArray[<span class="string">'MediaId'</span>]);</span><br><span class="line"></span><br><span class="line">        $xmlTpl = <span class="string">"&lt;xml&gt;</span></span><br><span class="line"><span class="string">&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;</span></span><br><span class="line"><span class="string">&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;</span></span><br><span class="line"><span class="string">&lt;CreateTime&gt;%s&lt;/CreateTime&gt;</span></span><br><span class="line"><span class="string">&lt;MsgType&gt;&lt;![CDATA[voice]]&gt;&lt;/MsgType&gt;</span></span><br><span class="line"><span class="string">$item_str</span></span><br><span class="line"><span class="string">&lt;/xml&gt;"</span>;</span><br><span class="line"></span><br><span class="line">        $result = sprintf($xmlTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time());</span><br><span class="line">        <span class="keyword">return</span> $result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回复视频消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">transmitVideo</span><span class="params">($object, $videoArray)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $itemTpl = <span class="string">"&lt;Video&gt;</span></span><br><span class="line"><span class="string">    &lt;MediaId&gt;&lt;![CDATA[%s]]&gt;&lt;/MediaId&gt;</span></span><br><span class="line"><span class="string">    &lt;ThumbMediaId&gt;&lt;![CDATA[%s]]&gt;&lt;/ThumbMediaId&gt;</span></span><br><span class="line"><span class="string">    &lt;Title&gt;&lt;![CDATA[%s]]&gt;&lt;/Title&gt;</span></span><br><span class="line"><span class="string">    &lt;Description&gt;&lt;![CDATA[%s]]&gt;&lt;/Description&gt;</span></span><br><span class="line"><span class="string">&lt;/Video&gt;"</span>;</span><br><span class="line"></span><br><span class="line">        $item_str = sprintf($itemTpl, $videoArray[<span class="string">'MediaId'</span>], $videoArray[<span class="string">'ThumbMediaId'</span>], $videoArray[<span class="string">'Title'</span>], $videoArray[<span class="string">'Description'</span>]);</span><br><span class="line"></span><br><span class="line">        $xmlTpl = <span class="string">"&lt;xml&gt;</span></span><br><span class="line"><span class="string">&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;</span></span><br><span class="line"><span class="string">&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;</span></span><br><span class="line"><span class="string">&lt;CreateTime&gt;%s&lt;/CreateTime&gt;</span></span><br><span class="line"><span class="string">&lt;MsgType&gt;&lt;![CDATA[video]]&gt;&lt;/MsgType&gt;</span></span><br><span class="line"><span class="string">$item_str</span></span><br><span class="line"><span class="string">&lt;/xml&gt;"</span>;</span><br><span class="line"></span><br><span class="line">        $result = sprintf($xmlTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time());</span><br><span class="line">        <span class="keyword">return</span> $result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回复图文消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">transmitNews</span><span class="params">($object, $newsArray)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!is_array($newsArray))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        $itemTpl = <span class="string">"    &lt;item&gt;</span></span><br><span class="line"><span class="string">        &lt;Title&gt;&lt;![CDATA[%s]]&gt;&lt;/Title&gt;</span></span><br><span class="line"><span class="string">        &lt;Description&gt;&lt;![CDATA[%s]]&gt;&lt;/Description&gt;</span></span><br><span class="line"><span class="string">        &lt;PicUrl&gt;&lt;![CDATA[%s]]&gt;&lt;/PicUrl&gt;</span></span><br><span class="line"><span class="string">        &lt;Url&gt;&lt;![CDATA[%s]]&gt;&lt;/Url&gt;</span></span><br><span class="line"><span class="string">    &lt;/item&gt;</span></span><br><span class="line"><span class="string">"</span>;</span><br><span class="line">        $item_str = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">foreach</span> ($newsArray <span class="keyword">as</span> $item)&#123;</span><br><span class="line">            $item_str .= sprintf($itemTpl, $item[<span class="string">'Title'</span>], $item[<span class="string">'Description'</span>], $item[<span class="string">'PicUrl'</span>], $item[<span class="string">'Url'</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        $xmlTpl = <span class="string">"&lt;xml&gt;</span></span><br><span class="line"><span class="string">&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;</span></span><br><span class="line"><span class="string">&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;</span></span><br><span class="line"><span class="string">&lt;CreateTime&gt;%s&lt;/CreateTime&gt;</span></span><br><span class="line"><span class="string">&lt;MsgType&gt;&lt;![CDATA[news]]&gt;&lt;/MsgType&gt;</span></span><br><span class="line"><span class="string">&lt;ArticleCount&gt;%s&lt;/ArticleCount&gt;</span></span><br><span class="line"><span class="string">&lt;Articles&gt;</span></span><br><span class="line"><span class="string">$item_str&lt;/Articles&gt;</span></span><br><span class="line"><span class="string">&lt;/xml&gt;"</span>;</span><br><span class="line"></span><br><span class="line">        $result = sprintf($xmlTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time(), count($newsArray));</span><br><span class="line">        <span class="keyword">return</span> $result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回复音乐消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">transmitMusic</span><span class="params">($object, $musicArray)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $itemTpl = <span class="string">"&lt;Music&gt;</span></span><br><span class="line"><span class="string">    &lt;Title&gt;&lt;![CDATA[%s]]&gt;&lt;/Title&gt;</span></span><br><span class="line"><span class="string">    &lt;Description&gt;&lt;![CDATA[%s]]&gt;&lt;/Description&gt;</span></span><br><span class="line"><span class="string">    &lt;MusicUrl&gt;&lt;![CDATA[%s]]&gt;&lt;/MusicUrl&gt;</span></span><br><span class="line"><span class="string">    &lt;HQMusicUrl&gt;&lt;![CDATA[%s]]&gt;&lt;/HQMusicUrl&gt;</span></span><br><span class="line"><span class="string">&lt;/Music&gt;"</span>;</span><br><span class="line"></span><br><span class="line">        $item_str = sprintf($itemTpl, $musicArray[<span class="string">'Title'</span>], $musicArray[<span class="string">'Description'</span>], $musicArray[<span class="string">'MusicUrl'</span>], $musicArray[<span class="string">'HQMusicUrl'</span>]);</span><br><span class="line"></span><br><span class="line">        $xmlTpl = <span class="string">"&lt;xml&gt;</span></span><br><span class="line"><span class="string">&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;</span></span><br><span class="line"><span class="string">&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;</span></span><br><span class="line"><span class="string">&lt;CreateTime&gt;%s&lt;/CreateTime&gt;</span></span><br><span class="line"><span class="string">&lt;MsgType&gt;&lt;![CDATA[music]]&gt;&lt;/MsgType&gt;</span></span><br><span class="line"><span class="string">$item_str</span></span><br><span class="line"><span class="string">&lt;/xml&gt;"</span>;</span><br><span class="line"></span><br><span class="line">        $result = sprintf($xmlTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time());</span><br><span class="line">        <span class="keyword">return</span> $result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回复多客服消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">transmitService</span><span class="params">($object)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $xmlTpl = <span class="string">"&lt;xml&gt;</span></span><br><span class="line"><span class="string">&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;</span></span><br><span class="line"><span class="string">&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;</span></span><br><span class="line"><span class="string">&lt;CreateTime&gt;%s&lt;/CreateTime&gt;</span></span><br><span class="line"><span class="string">&lt;MsgType&gt;&lt;![CDATA[transfer_customer_service]]&gt;&lt;/MsgType&gt;</span></span><br><span class="line"><span class="string">&lt;/xml&gt;"</span>;</span><br><span class="line">        $result = sprintf($xmlTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time());</span><br><span class="line">        <span class="keyword">return</span> $result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//日志记录</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">logger</span><span class="params">($log_content)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>($_SERVER[<span class="string">'HTTP_APPNAME'</span>]))&#123;   <span class="comment">//SAE</span></span><br><span class="line">            sae_set_display_errors(<span class="keyword">false</span>);</span><br><span class="line">            sae_debug($log_content);</span><br><span class="line">            sae_set_display_errors(<span class="keyword">true</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>($_SERVER[<span class="string">'REMOTE_ADDR'</span>] != <span class="string">"127.0.0.1"</span>)&#123; <span class="comment">//LOCAL</span></span><br><span class="line">            $max_size = <span class="number">10000</span>;</span><br><span class="line">            $log_filename = <span class="string">"log.xml"</span>;</span><br><span class="line">            <span class="keyword">if</span>(file_exists($log_filename) <span class="keyword">and</span> (abs(filesize($log_filename)) &gt; $max_size))&#123;unlink($log_filename);&#125;</span><br><span class="line">            file_put_contents($log_filename, date(<span class="string">'H:i:s'</span>).<span class="string">" "</span>.$log_content.<span class="string">"\r\n"</span>, FILE_APPEND);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信公众号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PhpStorm常用快捷键</title>
      <link href="/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_PhpStorm%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_PhpStorm%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p>PhpStrom的常用快捷键以后都总结在这里 <a id="more"></a> - Ctrl+D 复制一行 - Ctrl+Y 删除一行 - Ctrl+B 跳到变量声明处 - Ctrl+G 跳转到某行 - Ctrl+Q 查看代码的注释 - Ctrl+J 插入活动代码提示 - Alt+Shift+up 交换本行和上一行的位置 - Alt+Shift+dowm 交换本行和下一行的位置 - Ctrl+Shift+up 语句上移一行 - Ctrl+Shift+down 语句下移一行 - Alt+up 上一个方法 - Alt+down 下一个方法 - Alt+left 切换到左侧标签 - Alt+right 切换到右侧标签 - Ctrl+Z 撤销 - Ctrl+Shift+Z 重做 - Ctrl+Shift+N 打开文件 - Ctrl+F 本文件中查找 - Ctrl+Shift+F 在多个文件中查找 - Ctrl+Shift+V 多次粘贴 - Ctrl+ ‘+’ 展开代码块 - Ctrl+ ‘-’ 折叠代码块 - Ctrl+Shift+ ‘+’ 全部展开 - Ctrl+Shift+ ‘-’ 全部折叠 - Alt + F1当前文件的一些选择模式，很有用 - Shift+F6 重命名</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> phpStorm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试_使用Selenium测试UI</title>
      <link href="/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95_%E4%BD%BF%E7%94%A8Selenium%E6%B5%8B%E8%AF%95UI/"/>
      <url>/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95_%E4%BD%BF%E7%94%A8Selenium%E6%B5%8B%E8%AF%95UI/</url>
      
        <content type="html"><![CDATA[<h2 id="安装selenium-server">1. 安装Selenium Server</h2><h3 id="下载server-httpdocs.seleniumhq.orgdownload">1.1 下载Server http://docs.seleniumhq.org/download/</h3><p>选择Selenium Server（formerly the Selenium RC Server）下载。</p><a id="more"></a><h3 id="安装java环境确保java命令可以使用">1.2 安装Java环境，确保Java命令可以使用。</h3><h3 id="开启服务器">1.3 开启服务器</h3><blockquote><p><code>java -jar selenium-server-standalone-xxx.jar</code></p></blockquote><h2 id="安装-phpunit_selenium-package">2. 安装 PHPUnit_Selenium Package</h2><h3 id="在项目的composer.json中的require-dev结点添加phpunitphpunit-selenium-1.2">2.1 在项目的<code>composer.json</code>中的<code>require-dev</code>结点添加：<code>&quot;phpunit/phpunit-selenium&quot;: &quot;&gt;=1.2&quot;</code></h3><h3 id="在项目目录运行-composer-update">2.2 在项目目录运行 <code>composer update</code></h3><h2 id="编写测试用例检测环境是否安装正确">3. 编写测试用例检测环境是否安装正确</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebTest</span> <span class="keyword">extends</span> <span class="title">PHPUnit_Extensions_Selenium2TestCase</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">setUp</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;setBrowser(<span class="string">'firefox'</span>);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;setBrowserUrl(<span class="string">'http://www.example.com/'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testTitle</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;url(<span class="string">'http://www.example.com/'</span>);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;assertEquals(<span class="string">'this is a title'</span>, <span class="keyword">$this</span>-&gt;title());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>网页： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;</span><br><span class="line">this is a title</span><br><span class="line">&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"> this is the body.</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><p>返回 &gt;Time: 2.56 seconds, Memory: 3.25Mb</p><blockquote><p>OK (1 test, 1 assertion)</p></blockquote><p>环境配置成功。</p><h2 id="断言失败时保存网页截图">4. 断言失败时保存网页截图</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require_once</span> <span class="string">'PHPUnit/Extensions/SeleniumTestCase.php'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebTest</span> <span class="keyword">extends</span> <span class="title">PHPUnit_Extensions_SeleniumTestCase</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $captureScreenshotOnFailure = <span class="keyword">TRUE</span>;</span><br><span class="line">    <span class="keyword">protected</span> $screenshotPath = <span class="string">'c:/xampp/htdocs/screenshots'</span>;</span><br><span class="line">    <span class="keyword">protected</span> $screenshotUrl = <span class="string">'http://localhost/screenshots'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">setUp</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;setBrowser(<span class="string">'*firefox'</span>);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;setBrowserUrl(<span class="string">'http://www.example.com/'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testTitle</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;open(<span class="string">'http://www.example.com/'</span>);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;assertTitle(<span class="string">'Example WWW Page'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>你需要确保有screenshots文件夹，这样失败时就会保存网页截图到screenshots目录下。</p><h2 id="录制脚本测试ui">5. 录制脚本测试UI</h2><h3 id="下载火狐插件selenium-ide安装">5.1 下载火狐插件Selenium IDE，安装</h3><p>链接: <code>http://pan.baidu.com/s/1eQ1WkMI</code> 密码: <code>rt1d</code> ### 5.2 打开要测试的网页录制脚本 一个简单的测试页： <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span></span><br><span class="line">this is a title</span><br><span class="line"><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span> = <span class="string">'login'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span> = <span class="string">'user'</span> <span class="attr">type</span> = <span class="string">'text'</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span> = <span class="string">'pass'</span> <span class="attr">type</span> = <span class="string">'password'</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">'submit'</span> <span class="attr">value</span> = <span class="string">'login'</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这里录制一个填写用户名密码的动作。然后在Selenium IDE中File-&gt;Export Test Case As-&gt;Java/Unit4/Remote Control导出，导出之后得到类似这样的代码： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.tests;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.thoughtworks.selenium.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.After;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">qq</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Selenium selenium;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">selenium = <span class="keyword">new</span> DefaultSelenium(<span class="string">"localhost"</span>, <span class="number">4444</span>, <span class="string">"*chrome"</span>, <span class="string">"http://localhost/"</span>);</span><br><span class="line">selenium.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQq</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">selenium.open(<span class="string">"/test/1.html"</span>);</span><br><span class="line">selenium.type(<span class="string">"id=user"</span>, <span class="string">"123456"</span>);</span><br><span class="line">selenium.type(<span class="string">"id=pass"</span>, <span class="string">"12"</span>);</span><br><span class="line">selenium.click(<span class="string">"css=input[type=\"submit\"]"</span>);</span><br><span class="line">selenium.waitForPageToLoad(<span class="string">"30000"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@After</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">selenium.stop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对照这里的代码，写完测试代码： <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require_once</span> <span class="string">'PHPUnit/Extensions/SeleniumTestCase.php'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebTest</span> <span class="keyword">extends</span> <span class="title">PHPUnit_Extensions_SeleniumTestCase</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $captureScreenshotOnFailure = <span class="keyword">TRUE</span>;</span><br><span class="line">    <span class="keyword">protected</span> $screenshotPath = <span class="string">'C:\xampp\htdocs\test\screenshots'</span>;</span><br><span class="line">    <span class="keyword">protected</span> $screenshotUrl = <span class="string">'http://localhost/test/screenshots'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">setUp</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;setBrowser(<span class="string">'*firefox'</span>);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;setBrowserUrl(<span class="string">'http://localhost/'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testTitle</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;setSpeed(<span class="string">'3000'</span>);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;open(<span class="string">'http://localhost/test/1.html'</span>);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;type(<span class="string">"id=user"</span>,<span class="string">"123456"</span>);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;type(<span class="string">"id=pass"</span>,<span class="string">"12"</span>);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;click(<span class="string">"css=input[type=\"submit\"]"</span>);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;assertElementValueEquals(<span class="string">"user"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;assertElementValueEquals(<span class="string">"pass"</span>, <span class="string">"12"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>一般情况下只需要把setUp和Test中的代码对应到测试中即可，通常只需要改一下格式，函数名称都是通用的。 ### 5.3 可用的断言 &gt; - void assertElementValueEquals(string $locator, string $text) &gt; - void assertElementValueNotEquals(string $locator, string $text) &gt; - void assertElementValueContains(string $locator, string $text) &gt; - void assertElementValueNotContains(string $locator, string $text) &gt; - void assertElementContainsText(string $locator, string $text) &gt; - void assertElementNotContainsText(string $locator, string $text) &gt; - void assertSelectHasOption(string $selectLocator, string $option) &gt; - assertSelectNotHasOption(string $selectLocator, string <span class="math inline">\(option) &gt; - assertTextPresent（检查在当前给用户显示的页面上是否有出现指定的文本）、 &gt; - assertTextNotPresent（检查在当前给用户显示的页面上是否没有出现指定的文本）、 ### 5.4 有用的设置 - 调整每个语句的执行速度 `\)</span>this-&gt;setSpeed(‘3000’);<code>- 使UI延长显示</code>sleep(100);`</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UI测试 </tag>
            
            <tag> selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置Apache支持使用HTTPS</title>
      <link href="/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_%E9%85%8D%E7%BD%AEApache%E6%94%AF%E6%8C%81%E4%BD%BF%E7%94%A8HTTPS/"/>
      <url>/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_%E9%85%8D%E7%BD%AEApache%E6%94%AF%E6%8C%81%E4%BD%BF%E7%94%A8HTTPS/</url>
      
        <content type="html"><![CDATA[<h2 id="安装mod_ssl">1. 安装mod_ssl</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum isntall mod_ssl</span><br></pre></td></tr></table></figure><a id="more"></a><p>安装完成后再/etc/httpd/conf.d/下面有一个ssl.conf.打开查看下面两项配置的内容： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SSLCertificateFile /etc/pki/tls/certs/localhost.crt</span><br><span class="line">SSLCertificateKeyFile /etc/pki/tls/private/localhost.key</span><br></pre></td></tr></table></figure></p><h2 id="生成密钥">2. 生成密钥</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/pki/tls/private</span><br><span class="line">rm -f localhost.key</span><br><span class="line">openssl genrsa 1024 &gt; localhost.key</span><br></pre></td></tr></table></figure><h2 id="生成证书">3. 生成证书</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/pki/certs</span><br><span class="line">rm -f localhhost.crt</span><br><span class="line">openssl req -new -x509 -days -key ../private/localhost.key -out localhost.crt</span><br></pre></td></tr></table></figure><p>然后填写证书的各项信息，证书生成。 重启Apache，就可以使用https访问了。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> apache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>短信验证码的实现</title>
      <link href="/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="在云片网1注册账号">1. 在<a href="http://www.yunpian.com/" target="_blank" rel="noopener">云片网</a>注册账号</h2><h2 id="设置">2. 设置</h2><h3 id="找到apikey">2.1 找到APIKEY</h3><h3 id="将自己的ip地址添加到ip白名单">2.2 将自己的IP地址添加到IP白名单</h3><h3 id="选择自己需要的短信模板短信内容要和模板匹配才能成功发送出去">2.3 选择自己需要的短信模板，短信内容要和模板匹配才能成功发送出去。</h3><h2 id="代码实例">3. 代码实例</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* url 为服务的url地址</span></span><br><span class="line"><span class="comment">* query 为请求串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sock_post</span><span class="params">($url,$query)</span></span>&#123;</span><br><span class="line">$data = <span class="string">""</span>;</span><br><span class="line">$info=parse_url($url);</span><br><span class="line">$fp=fsockopen($info[<span class="string">"host"</span>],<span class="number">80</span>,$errno,$errstr,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">if</span>(!$fp)&#123;</span><br><span class="line"><span class="keyword">return</span> $data;</span><br><span class="line">&#125;</span><br><span class="line">$head=<span class="string">"POST "</span>.$info[<span class="string">'path'</span>].<span class="string">" HTTP/1.0\r\n"</span>;</span><br><span class="line">$head.=<span class="string">"Host: "</span>.$info[<span class="string">'host'</span>].<span class="string">"\r\n"</span>;</span><br><span class="line">$head.=<span class="string">"Referer: http://"</span>.$info[<span class="string">'host'</span>].$info[<span class="string">'path'</span>].<span class="string">"\r\n"</span>;</span><br><span class="line">$head.=<span class="string">"Content-type: application/x-www-form-urlencoded\r\n"</span>;</span><br><span class="line">$head.=<span class="string">"Content-Length: "</span>.strlen(trim($query)).<span class="string">"\r\n"</span>;</span><br><span class="line">$head.=<span class="string">"\r\n"</span>;</span><br><span class="line">$head.=trim($query);</span><br><span class="line">$write=fputs($fp,$head);</span><br><span class="line">$header = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">while</span> ($str = trim(fgets($fp,<span class="number">4096</span>))) &#123;</span><br><span class="line">$header.=$str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!feof($fp)) &#123;</span><br><span class="line">$data .= fgets($fp,<span class="number">4096</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> $data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 普通接口发短信</span></span><br><span class="line"><span class="comment">* apikey 为云片分配的apikey</span></span><br><span class="line"><span class="comment">* text 为短信内容</span></span><br><span class="line"><span class="comment">* mobile 为接受短信的手机号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send_sms</span><span class="params">($apikey, $text, $mobile)</span></span>&#123;</span><br><span class="line">$url=<span class="string">"http://yunpian.com/v1/sms/send.json"</span>;</span><br><span class="line">$encoded_text = urlencode(<span class="string">"$text"</span>);</span><br><span class="line">$post_string=<span class="string">"apikey=$apikey&amp;text=$encoded_text&amp;mobile=$mobile"</span>;</span><br><span class="line"><span class="keyword">return</span> sock_post($url, $post_string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 短信验证码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP基本操作</title>
      <link href="/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_PHP%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_PHP%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串的截取">1. 字符串的截取</h2><p>取得<code>https://images.shiliujishi.com/sdlakfjadfosdfji.jpg</code>中的<code>sdlakfjadfosdfji.jpg</code> <a id="more"></a> <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$url = strrchr ( $long_url, <span class="string">'/'</span> ) ;</span><br><span class="line">$url_length = -(strlen($url)<span class="number">-1</span>);</span><br><span class="line">$short_url = substr ($long_url, $url_length);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux主机之间同步文件</title>
      <link href="/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_Linux%E4%B8%BB%E6%9C%BA%E4%B9%8B%E9%97%B4%E5%90%8C%E6%AD%A5%E6%96%87%E4%BB%B6/"/>
      <url>/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_Linux%E4%B8%BB%E6%9C%BA%E4%B9%8B%E9%97%B4%E5%90%8C%E6%AD%A5%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="scp命令">1. scp命令</h2><p>在主机A上操作 ### 1.1 主机A复制文件到主机B &gt; - scp <code>/home/filename</code> <code>root@101.1.1.3:/home</code></p><h3 id="从主机b复制文件到主机a">1.2 从主机B复制文件到主机A</h3><blockquote><ul><li>scp <code>/root/fei/a.txt</code> <code>root@121.42.43.161:/root/fei</code></li></ul></blockquote><a id="more"></a><h3 id="避免每次都需要输入密码">1.3 避免每次都需要输入密码</h3><h4 id="生成密钥">1.3.1 生成密钥</h4><blockquote><p>ssh-keygen -t rsa 查看当前用户目录下.ssh文件夹 -rw——- 1 root root 1671 Sep 28 14:34 id_rsa -rw——- 1 root root 400 Sep 28 14:34 id_rsa.pub</p></blockquote><h4 id="上传密钥到服务器b">1.3.2 上传密钥到服务器B</h4><blockquote><p>scp <code>/root/.ssh/id_rsa.pub</code> <code>10.0.0.2:/root/.ssh/authorized_keys</code> 将本地生成的公钥上传到B，并改名authorized_keys。 4. 写成脚本执行，传送批量文件 1. touch upload.sh 2. vi upload.sh #!/bash/sh scp <code>/root/fei/a.txt</code> <code>10.1.1.3:/root/fei/</code> 3. chmod u+x upload.sh 4. ./upload.sh</p></blockquote><h3 id="上传文件夹">1.4 上传文件夹</h3><blockquote><p>scp -r 添加-r参数即可</p></blockquote><h2 id="rsync-命令">2. rsync 命令</h2><h3 id="安装rsync服务">2.1 安装rsync服务</h3><p>一般都已经安装rsync服务，只需要自己添加配置文件即可。ubuntu 安装方式： <code>sudo apt-get install rsync</code> ###2.2 配置文件（主机A） - touch /etc/rsyncd.conf 创建服务器配置文件 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pid file = /var/run/rsyncd.pid</span><br><span class="line">port = 873</span><br><span class="line">address = 114.215.128.207 (服务器的IP，就是A主机的IP)</span><br><span class="line">uid = root</span><br><span class="line">gid = root</span><br><span class="line">use chroot = yes</span><br><span class="line"><span class="built_in">read</span> only = yes</span><br><span class="line">\<span class="comment">#hosts allow=192.168.1.0/255.255.255.0</span></span><br><span class="line">\<span class="comment">#hosts deny = *</span></span><br><span class="line">max connection = 5</span><br><span class="line">motd file = /etc/rsyncd.motd</span><br><span class="line"><span class="built_in">log</span> file = /var/<span class="built_in">log</span>/rsyncd.log</span><br><span class="line">transfer logging = yes</span><br><span class="line"><span class="built_in">log</span> format = %t %a %m %f %b</span><br><span class="line">syslog facility = local3</span><br><span class="line">timeout = 300</span><br><span class="line"></span><br><span class="line">[<span class="built_in">test</span>]（备份结点）</span><br><span class="line">path = /root/fei（需要备份的路径）</span><br><span class="line">list=yes</span><br><span class="line">ignore errors</span><br><span class="line">auth users = root</span><br><span class="line">secrets file = /etc/rsyncd.secrets</span><br><span class="line">（客户端使用rsync命令时，需要使用这里设定的用户名和密码）</span><br><span class="line">comment = This is <span class="built_in">test</span> data（备份的注释）</span><br><span class="line">exclude = （忽略的文件夹）</span><br></pre></td></tr></table></figure></p><ul><li><p>touch /etc/rsyncd.secrets 创建密码文件 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root:123456(用户名：密码)</span><br></pre></td></tr></table></figure></p></li><li><p>touch /etc/rsyncd.motd 创建服务器信息文件 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">++++++++++++++++</span><br><span class="line">welcome to use rsync service !</span><br><span class="line">(自定义当客户端连接时返回的提示信息)</span><br><span class="line">+++++++++++++++++</span><br></pre></td></tr></table></figure></p></li><li><p>修改权限 chown root.root rsyncd.secrets chmod 600 rsyncd.secrets ### 2.3 启动服务 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rsync --daemon --config = /etc/rsyncd.cond</span><br><span class="line">(如果配置文件就在etc下，可以省略--config)</span><br></pre></td></tr></table></figure></p></li></ul><h3 id="在主机b上访问rsync服务">2.4 在主机B上访问rsync服务</h3><h4 id="查看主机a上提供的备份数据源">2.4.1 查看主机A上提供的备份数据源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync --list-only root@123.234.321.1::</span><br></pre></td></tr></table></figure><p>出现配置文件中定义的欢迎信息说明配置成功。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+++++++++++++++++++</span><br><span class="line">Welcome to use rsync service !</span><br><span class="line">++++++++++++++++++++++++</span><br><span class="line"></span><br><span class="line">test            This is test data</span><br><span class="line">test就是主机A或者说rsync服务器上提供的数据源。如果在数据源的配置文件中加上`list=no`则不会显示在这里</span><br></pre></td></tr></table></figure></p><h4 id="查看数据源的内容">2.4.2 查看数据源的内容</h4><p>-<code>rsync -avzP root@114.215.2.207::test</code>这里会要求输入密码，密码就是在主机A中的rsyncd.secrets文件中保存的密码。 ####2.4.3 把A中的内容同步到B <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rsync -avzP root@114.215.128.207::test test</span><br><span class="line">(同步到本机当前目录的test文件夹下)</span><br><span class="line">rsync -avzP --delete root@114.215.128.207::test test</span><br><span class="line">(加上delete参数A中删除的文件也会在B中删除)</span><br></pre></td></tr></table></figure></p><h4 id="避免每次同步都需要输入密码">2.4.4 避免每次同步都需要输入密码</h4><p>在本地创建密码文件 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch rsyncd.secrets;chmod 600 rsyncd.secrets;echo &apos;password&apos;&gt;rsyncd.secrets</span><br><span class="line">同步时运行</span><br><span class="line">rsync -avzP --delete --password-file=rsyncd.secrets root@114.215.128.207::test test</span><br></pre></td></tr></table></figure></p><h4 id="编写脚本实现同步ls">2.4.5 编写脚本实现同步ls</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">/usr/bin/rsync -avzP --password-file=/root/fei/rsyncd.secrets root@114.215.128.207::test</span><br></pre></td></tr></table></figure><h4 id="定时执行同步脚本实现自动同步">2.4.6 定时执行同步脚本实现自动同步</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">crontab -e (打开定时任务编辑器)</span><br><span class="line">输入一下内容：</span><br><span class="line">`* * * * *　／root/fei/rsync.sh`</span><br><span class="line">(每分钟自动运行rsync.sh)</span><br></pre></td></tr></table></figure><blockquote><p>crontab基本操作 crontab -l 列出当前的定时任务 crontab -r 删除当前的定时任务 crontab -e 编辑当前的定时任务 - 定时的格式： f1 f2 f3 f4 f5 program 其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。program 表示要执行的程序。 当 f1 为 * 时表示每分钟都要执行 program，f2 为 * 时表示每小时都要执行程序，其馀类推 当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b 小时都要执行，其馀类推 当 f1 为 <em>/n 时表示每 n 分钟个时间间隔执行一次，f2 为 </em>/n 表示每 n 小时个时间间隔执行一次，其馀类推 当 f1 为 a, b, c,… 时表示第 a, b, c,… 分钟要执行，f2 为 a, b, c,… 时表示第 a, b, c…个小时要执行，其馀类推 使用者也可以将所有的设定先存放在档案 file 中，用 crontab file 的方式来设定时程表。 当程式在你所指定的时间执行后,系统会寄一封信给你,显示该程式执行的内容,若是你不希望收到这样的信,请在每一行空一格之后加上 &gt; /dev/null 2&gt;&amp;1 即可。</p></blockquote><h4 id="只复制目录结构不复制内容">2.4.7 只复制目录结构，不复制内容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av --include &apos;*/&apos; --exclude &apos;*&apos; source-dir dest-dir</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>介绍Linux常用命令的主要用法 <a id="more"></a> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- 查找某个软件包是否安装：</span><br><span class="line">yum list installed|grep mcrypt</span><br><span class="line">- 查看某个命令的位置</span><br><span class="line">whereis ls</span><br><span class="line">- 检查某个端口是否打开</span><br><span class="line">lsof -i :port</span><br><span class="line">- 查看某个运行的进程</span><br><span class="line">ps -ef|grep httpd</span><br><span class="line">- 查找某个进程</span><br><span class="line">pgrep -l ssh</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lavarel 后台组件frozenode的使用</title>
      <link href="/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_Lavarel-%E5%90%8E%E5%8F%B0%E7%BB%84%E4%BB%B6frozenode%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_Lavarel-%E5%90%8E%E5%8F%B0%E7%BB%84%E4%BB%B6frozenode%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="安装">安装</h2><h2 id="使用">使用</h2><a id="more"></a><h3 id="导航栏配置">导航栏配置</h3><p>administrator.php: uri 后台管理地址 model_config_path 模型地址 setting_config_path 每个子菜单配置文件的地址 menu 导航栏菜单项目 <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">array</span>(</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Package URI</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="string">'uri'</span> =&gt; <span class="string">'eadmin'</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Page title</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="string">'title'</span> =&gt; <span class="string">'PomeMartAdminPanel'</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The path to your model config directory</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="string">'model_config_path'</span> =&gt; app(<span class="string">'path'</span>) . <span class="string">'/config/administrator'</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The path to your settings config directory</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="string">'settings_config_path'</span> =&gt; app(<span class="string">'path'</span>) . <span class="string">'/config/administrator/settings'</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The menu structure of the site. For models, you should either supply the name of a model config file or an array of names of model config</span></span><br><span class="line"><span class="comment"> * files. The same applies to settings config files, except you must prepend 'settings.' to the settings config file name. You can also add</span></span><br><span class="line"><span class="comment"> * custom pages by prepending a view path with 'page.'. By providing an array of names, you can group certain models or settings pages</span></span><br><span class="line"><span class="comment"> * together. Each name needs to either have a config file in your model config path, settings config path with the same name, or a path to a</span></span><br><span class="line"><span class="comment"> * fully-qualified Laravel view. So 'users' would require a 'users.php' file in your model config path, 'settings.site' would require a</span></span><br><span class="line"><span class="comment"> * 'site.php' file in your settings config path, and 'page.foo.test' would require a 'test.php' or 'test.blade.php' file in a 'foo' directory</span></span><br><span class="line"><span class="comment"> * inside your view directory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> array</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * array(</span></span><br><span class="line"><span class="comment"> *'E-Commerce' =&gt; array('collections', 'products', 'product_images', 'orders'),</span></span><br><span class="line"><span class="comment"> *'homepage_sliders',</span></span><br><span class="line"><span class="comment"> *'users',</span></span><br><span class="line"><span class="comment"> *'roles',</span></span><br><span class="line"><span class="comment"> *'colors',</span></span><br><span class="line"><span class="comment"> *'Settings' =&gt; array('settings.site', 'settings.ecommerce', 'settings.social'),</span></span><br><span class="line"><span class="comment"> * 'Analytics' =&gt; array('E-Commerce' =&gt; 'page.ecommerce.analytics'),</span></span><br><span class="line"><span class="comment"> *)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="string">'menu'</span> =&gt; <span class="keyword">array</span></span><br><span class="line">(</span><br><span class="line"><span class="string">'商品'</span> =&gt; <span class="keyword">array</span></span><br><span class="line">(</span><br><span class="line"><span class="string">'products'</span> =&gt; <span class="string">'products'</span>,</span><br><span class="line"><span class="string">'product images'</span> =&gt; <span class="string">'productImages'</span>,</span><br><span class="line"><span class="string">'tags'</span> =&gt; <span class="string">'tags'</span>,</span><br><span class="line"><span class="string">'attributes'</span> =&gt; <span class="string">'attributes'</span>,</span><br><span class="line"><span class="string">'categories'</span> =&gt; <span class="string">'categories'</span>,</span><br><span class="line">            <span class="string">'productDetailImage'</span> =&gt; <span class="string">'productDetailImage'</span>,</span><br><span class="line">            <span class="string">'accounting'</span> =&gt; <span class="string">'accounting'</span>,</span><br><span class="line">            <span class="string">'accounting_withdraw'</span> =&gt; <span class="string">'accounting_withdraw'</span></span><br><span class="line">),</span><br><span class="line"><span class="string">'店铺'</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line"> <span class="string">'stores'</span> =&gt; <span class="string">'stores'</span>,</span><br><span class="line"> <span class="string">'cmsItems'</span> =&gt;<span class="string">'cmsItems'</span>,</span><br><span class="line"> <span class="string">'storePromos'</span> =&gt; <span class="string">'storePromos'</span>,</span><br><span class="line"> <span class="string">'storeOuterlinks'</span> =&gt; <span class="string">'storeOuterlinks'</span>,</span><br><span class="line"> <span class="string">'shares'</span> =&gt; <span class="string">'shares'</span>,</span><br><span class="line">             <span class="string">'themes'</span> =&gt; <span class="string">'themes'</span></span><br><span class="line">),</span><br><span class="line"><span class="string">'优惠券'</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line"><span class="string">'coupons'</span> =&gt; <span class="string">'coupons'</span>,</span><br><span class="line"><span class="string">'couponCreationRules'</span> =&gt; <span class="string">'couponCreationRules'</span>,</span><br><span class="line"><span class="string">'fixedDiscountCoupons'</span> =&gt; <span class="string">'fixedDiscountCoupons'</span>,</span><br><span class="line"><span class="string">'percentageDiscountCoupons'</span> =&gt; <span class="string">'percentageDiscountCoupons'</span>,</span><br><span class="line"><span class="string">'amountOffOverCoupons'</span> =&gt; <span class="string">'amountOffOverCoupons'</span></span><br><span class="line">),</span><br><span class="line"><span class="string">'订单'</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line"><span class="string">'orders'</span> =&gt; <span class="string">'orders'</span>,</span><br><span class="line"><span class="string">'shipments'</span> =&gt; <span class="string">'shipments'</span>,</span><br><span class="line"><span class="string">'trackings'</span> =&gt; <span class="string">'trackings'</span></span><br><span class="line">),</span><br><span class="line"><span class="string">'评价'</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line"><span class="string">'ratings'</span>=&gt;<span class="string">'ratings'</span>,</span><br><span class="line"><span class="string">'productRatings'</span> =&gt; <span class="string">'productRatings'</span></span><br><span class="line">)</span><br><span class="line">),</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The permission option is the highest-level authentication check that lets you define a closure that should return true if the current user</span></span><br><span class="line"><span class="comment"> * is allowed to view the admin section. Any "falsey" response will send the user back to the 'login_path' defined below.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> closure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="string">'permission'</span>=&gt; <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Auth::check() &amp;&amp; Auth::user()-&gt;hasRole(<span class="string">'Admin'</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This determines if you will have a dashboard (whose view you provide in the dashboard_view option) or a non-dashboard home</span></span><br><span class="line"><span class="comment"> * page (whose menu item you provide in the home_page option)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> bool</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="string">'use_dashboard'</span> =&gt; <span class="keyword">false</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * If you want to create a dashboard view, provide the view string here.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="string">'dashboard_view'</span> =&gt; <span class="string">''</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The menu item that should be used as the default landing page of the administrative section</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="string">'home_page'</span> =&gt; <span class="string">'products'</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The route to which the user will be taken when they click the "back to site" button</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="string">'back_to_site_path'</span> =&gt; <span class="string">'/'</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The login path is the path where Administrator will send the user if they fail a permission check</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="string">'login_path'</span> =&gt; <span class="string">'accounts/signin'</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The logout path is the path where Administrator will send the user when they click the logout link</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="string">'logout_path'</span> =&gt; <span class="string">'accounts/signout'</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is the key of the return path that is sent with the redirection to your login_action. Session::get('redirect') will hold the return URL.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="string">'login_redirect_key'</span> =&gt; <span class="string">'redirect'</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Global default rows per page</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> NULL|int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="string">'global_rows_per_page'</span> =&gt; <span class="number">20</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An array of available locale strings. This determines which locales are available in the languages menu at the top right of the Administrator</span></span><br><span class="line"><span class="comment"> * interface.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="string">'locales'</span> =&gt; <span class="keyword">array</span>(<span class="string">'zh-CN'</span>,<span class="string">'en'</span>),</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>accounting.php : <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  model config</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">array</span>(</span><br><span class="line"></span><br><span class="line"><span class="string">'title'</span> =&gt; <span class="string">'财务'</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">'single'</span> =&gt; <span class="string">'财务'</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">'model'</span> =&gt; <span class="string">'PomeMartDomainModel\Entities\Accounting'</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">'columns'</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line"><span class="string">'id'</span>,</span><br><span class="line"><span class="string">'store_id'</span> =&gt; <span class="keyword">array</span> (</span><br><span class="line"><span class="string">'title'</span> =&gt; <span class="string">'店铺ID'</span>,</span><br><span class="line">),</span><br><span class="line"><span class="string">'alipay_account'</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line"><span class="string">'title'</span> =&gt; <span class="string">'支付宝账户'</span>,</span><br><span class="line">),</span><br><span class="line"><span class="string">'total_income'</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line"><span class="string">'title'</span> =&gt; <span class="string">'总收入'</span></span><br><span class="line">),</span><br><span class="line"><span class="string">'balance'</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line"><span class="string">'title'</span> =&gt; <span class="string">'待提金额'</span></span><br><span class="line">),</span><br><span class="line"><span class="string">'last_order_received_on'</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line"><span class="string">'title'</span> =&gt; <span class="string">'上次提取现金的时间'</span>,</span><br><span class="line">)</span><br><span class="line">),</span><br><span class="line"></span><br><span class="line"><span class="string">'edit_fields'</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line">        <span class="string">'store_id'</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line">            <span class="string">'title'</span> =&gt; <span class="string">'店铺ID'</span></span><br><span class="line">        ),</span><br><span class="line">        <span class="string">'alipay_account'</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line">            <span class="string">'title'</span> =&gt; <span class="string">'支付宝账户'</span>,</span><br><span class="line">        ),</span><br><span class="line">        <span class="string">'total_income'</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line">            <span class="string">'title'</span> =&gt; <span class="string">'总收入'</span>,</span><br><span class="line">            <span class="string">'type'</span> =&gt; <span class="string">'number'</span></span><br><span class="line">        ),</span><br><span class="line">        <span class="string">'balance'</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line">            <span class="string">'title'</span> =&gt; <span class="string">'待提取金额'</span></span><br><span class="line">        ),</span><br><span class="line">        <span class="string">'last_order_received_on'</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line">            <span class="string">'title'</span> =&gt; <span class="string">'上次提取现金的时间'</span>,</span><br><span class="line">            <span class="string">'type'</span> =&gt; <span class="string">'datetime'</span></span><br><span class="line"></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">),</span><br><span class="line"></span><br><span class="line"><span class="string">'filters'</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line">        <span class="string">'store_id'</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line">            <span class="string">'title'</span> =&gt; <span class="string">'店铺ID'</span></span><br><span class="line">        ),</span><br><span class="line">        <span class="string">'alipay_account'</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line">            <span class="string">'title'</span> =&gt; <span class="string">'支付宝账户'</span></span><br><span class="line">        )</span><br><span class="line">),</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>里面的model 指定要操作的数据库的表的对应的模型的位置。</p><p>参考文档地址：<a href="http://administrator.frozennode.com/" class="uri" target="_blank" rel="noopener">http://administrator.frozennode.com/</a></p><h2 id="添加按钮执行自定义代码">添加按钮执行自定义代码</h2><p>执行全局操作，没有输入参数 <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'global_actions'</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line">       <span class="comment">//Create Excel Download</span></span><br><span class="line">       <span class="string">'clear_cache'</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line">           <span class="string">'title'</span> =&gt; <span class="string">'Clear Cache'</span>,</span><br><span class="line">           <span class="string">'messages'</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line">               <span class="string">'active'</span> =&gt; <span class="string">'clear cache ...'</span>,</span><br><span class="line">               <span class="string">'success'</span> =&gt; <span class="string">'success!'</span>,</span><br><span class="line">               <span class="string">'error'</span> =&gt; <span class="string">'failed!'</span>,</span><br><span class="line">           ),</span><br><span class="line">           <span class="comment">//the Eloquent query builder is passed to the closure</span></span><br><span class="line">           <span class="string">'action'</span> =&gt; <span class="function"><span class="keyword">function</span><span class="params">($query)</span></span></span><br><span class="line"><span class="function">               </span>&#123;</span><br><span class="line">                   $store = Auth::user()-&gt;store;</span><br><span class="line">                   Cache::forget(<span class="string">'store_'</span>.$store-&gt;store_alias);</span><br><span class="line">                   <span class="keyword">return</span>  <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">       ),</span><br><span class="line">   ),</span><br></pre></td></tr></table></figure></p><p>针对每条数据，执行自定义操作，传入参数$data就是编辑后的数据 <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'actions'</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line">       <span class="comment">//Clearing the site cache</span></span><br><span class="line">       <span class="string">'save_color'</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line">           <span class="string">'title'</span> =&gt; <span class="string">'Save Color'</span>,</span><br><span class="line">           <span class="string">'messages'</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line">               <span class="string">'active'</span> =&gt; <span class="string">'Clearing cache...'</span>,</span><br><span class="line">               <span class="string">'success'</span> =&gt; <span class="string">'Cache cleared!'</span>,</span><br><span class="line">               <span class="string">'error'</span> =&gt; <span class="string">'There was an error while clearing the cache'</span>,</span><br><span class="line">           ),</span><br><span class="line">           <span class="comment">//the settings data is passed to the function and saved if a truthy response is returned</span></span><br><span class="line">           <span class="string">'action'</span> =&gt; <span class="function"><span class="keyword">function</span><span class="params">(&amp;$data)</span></span></span><br><span class="line"><span class="function">               </span>&#123;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">//return true to flash the success message</span></span><br><span class="line">                   <span class="comment">//return false to flash the default error</span></span><br><span class="line">                   <span class="comment">//return a string to show a custom error</span></span><br><span class="line">                   <span class="comment">//return a Response::download() to initiate a file download</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="string">"$data"</span>;</span><br><span class="line">               &#125;</span><br><span class="line">       ),</span><br><span class="line">   ),</span><br></pre></td></tr></table></figure></p><p>====</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> laravel </tag>
            
            <tag> frozenode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP编译less文件-lessphp的使用</title>
      <link href="/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_PHP%E7%BC%96%E8%AF%91less%E6%96%87%E4%BB%B6-lessphp%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_PHP%E7%BC%96%E8%AF%91less%E6%96%87%E4%BB%B6-lessphp%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="用composer安装">用composer安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"require"</span>:&#123;</span><br><span class="line">        <span class="string">"leafo/lessphp"</span>: <span class="string">"0.4.0"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>手动安装 <a href="https://github.com/leafo/lessphp" target="_blank" rel="noopener">lessphp源代码</a> 下载源代码，将其中的lessc.inc.php拷贝到任意文件夹中，使用时include即可。 <a href="http://leafo.net/lessphp/docs/" target="_blank" rel="noopener">lessphp文档地址</a> ##2. 使用 根据变量的不同将style.less编译成不同的css文件 <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'app\lib\lessc.inc.php'</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">lessc</span>;</span><br><span class="line"></span><br><span class="line"> $less = <span class="keyword">new</span> lessc();</span><br><span class="line">        $less-&gt;setVariables(<span class="keyword">array</span>(</span><br><span class="line">            <span class="string">"color-main"</span> =&gt; <span class="string">"#555555"</span>,</span><br><span class="line">            <span class="string">"color-secondary"</span> =&gt; <span class="string">"#222222"</span>,</span><br><span class="line">            <span class="string">"color-contract"</span> =&gt; <span class="string">"#333333"</span></span><br><span class="line">        ));</span><br><span class="line">        $inputFile = <span class="string">"public_html/styles/style.less"</span>;</span><br><span class="line">        $outputFile = <span class="string">"public_html/styles/style.css"</span>;</span><br><span class="line">        $inputString = file_get_contents($inputFile);</span><br><span class="line">        $ouputString =  $less-&gt;compile($inputString);</span><br><span class="line">        <span class="keyword">echo</span> file_put_contents($outputFile,$ouputString);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> less </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>think php note 03</title>
      <link href="/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_think-php-note-03/"/>
      <url>/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_think-php-note-03/</url>
      
        <content type="html"><![CDATA[<h1 id="thinkphp入门教程-取出数据">ThinkPHP入门教程-取出数据</h1><h2 id="配置数据库连接">配置数据库连接</h2><ul><li>本地mysql数据库的配置如下： 数据库用户名：root 密码：空 使用的数据库：test 数据库的信息：只有一张表user,user包含id,name,password三个字段</li><li>在testThinkPHP/Conf/config.php中键入如下代码：</li></ul><a id="more"></a><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">array</span> (</span><br><span class="line">          <span class="comment">//'配置项'=&gt;'配置值'</span></span><br><span class="line">    <span class="string">'DB_TYPE'</span>   =&gt; <span class="string">'mysql'</span>, <span class="comment">// 数据库类型</span></span><br><span class="line">    <span class="string">'DB_PORT'</span>   =&gt; <span class="string">'3306'</span>, <span class="comment">// 端口</span></span><br><span class="line">    <span class="string">'DB_CHARSET'</span> =&gt; <span class="string">'utf8'</span>, <span class="comment">// 数据库编码默认采用utf8</span></span><br><span class="line">    <span class="string">'DB_HOST'</span>   =&gt; <span class="string">"localhost"</span>, <span class="comment">// 服务器地址</span></span><br><span class="line">    <span class="string">'DB_NAME'</span>   =&gt; <span class="string">"test"</span>, <span class="comment">// 数据库名</span></span><br><span class="line">    <span class="string">'DB_USER'</span>   =&gt; <span class="string">"root"</span>, <span class="comment">// 用户名</span></span><br><span class="line">    <span class="string">'DB_PWD'</span>    =&gt; <span class="string">"123456"</span>,  <span class="comment">// 密码</span></span><br><span class="line">    <span class="string">'DB_PREFIX'</span> =&gt; <span class="string">"a_"</span>, <span class="comment">// 数据库表前缀</span></span><br><span class="line">    );</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="定义模型">定义模型</h2><p>在testThinkPHP/Lib/Model/UserMdel.php 中键入如下内容：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Created by PhpStorm.</span></span><br><span class="line"><span class="comment">* User: Administrator</span></span><br><span class="line"><span class="comment">* Date: 2015/7/18</span></span><br><span class="line"><span class="comment">* Time: 17:36</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserModel</span> <span class="keyword">extends</span> <span class="title">Model</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上表示定义了User模型，该模型会自动和数据库中的user数据表相对应</p><h2 id="定义控制器">定义控制器</h2><p>在ThinkPHP/Lib/Action/UserAction.class.php 中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserAction</span> <span class="keyword">extends</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">showUser</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $user = M(<span class="string">'User'</span>);</span><br><span class="line">        $user -&gt;find(<span class="number">1</span> );</span><br><span class="line">        $user_name = $user-&gt;user_name ;</span><br><span class="line">        $password = $user-&gt;password ;</span><br><span class="line">        $tpl = <span class="string">"User:showUser"</span>;</span><br><span class="line">        <span class="keyword">$this</span> -&gt;assign(<span class="string">'username'</span>, $user_name);</span><br><span class="line">        <span class="keyword">$this</span> -&gt;assign(<span class="string">'password'</span>, $password);</span><br><span class="line">        <span class="keyword">$this</span> -&gt;display($tpl );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义视图">定义视图</h2><p>ThinkPHP/Tpl/User/showUser.html 中键入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span> &gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    用户名： <span class="php"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> $username<span class="meta">?&gt;</span></span>  <span class="tag">&lt; <span class="attr">br</span>&gt;</span></span><br><span class="line">    密码： <span class="php"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> $password<span class="meta">?&gt;</span></span> <span class="tag">&lt; <span class="attr">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="查看结果">查看结果</h2><p>在浏览器中输入 localhost/testThinkPHP/?m=User&amp;a=showUser</p><p>至此，我们完成了一个简单的从数据库中读取数据，显示在视图中的过程，下面再完成一个从视图中读取数据，存入数据库的过程，框架的基本功能就算是掌握了。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thinkphp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>think php note 02</title>
      <link href="/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_think-php-note-02/"/>
      <url>/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_think-php-note-02/</url>
      
        <content type="html"><![CDATA[<h1 id="thinkphp入门教程-存入数据">ThinkPHP入门教程-存入数据</h1><h2 id="配置显示输入表单的页面">配置显示输入表单的页面</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">testThinkPHP/Lib/Action/UserAction.class.php</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addUserGet</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span> -&gt;display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="新建模版-testthinkphptpluseradduserget.html">新建模版 <code>testThinkPHP/Tpl/User/addUserGet.html</code></h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span> &gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"&lt;?php echo U('User:addUserPost') ?&gt;"</span> <span class="attr">method</span>= <span class="string">"post"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>= <span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"user_name"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>= <span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>= <span class="string">"submit"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在浏览器输入localhost/testThinkPHP/?m=User$a=addUserGet就可以看到表单输入页面了</p><h2 id="单击submit按钮后表单数据会提交到usermodel的adduserpost方法">单击submit按钮后，表单数据会提交到UserModel的addUserPost()方法</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addUserPost</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $user_name = $_POST[ <span class="string">'user_name'</span>];</span><br><span class="line">    $password = $_POST[ <span class="string">'password'</span>];</span><br><span class="line">    $user = M(<span class="string">'User'</span>);</span><br><span class="line">    $data [<span class="string">'user_name'</span>] = $user_name;</span><br><span class="line">    $data [<span class="string">'password'</span>] = $password;</span><br><span class="line">    $user -&gt;create($data );</span><br><span class="line">    $user -&gt;add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完这个方法，数据库的user数据表中就会新增一条记录，但是要记住，id字段一定是自增的，否则可能会出现插入不进去的情况。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thinkphp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>think php note 01</title>
      <link href="/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_think-php-note-01/"/>
      <url>/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_think-php-note-01/</url>
      
        <content type="html"><![CDATA[<h1 id="thinkphp入门教程-默认的规则">ThinkPHP入门教程-默认的规则</h1><h2 id="url模式">URL模式</h2><p>在testThinkPHP/Conf/config.php中加入 ‘URL_MODEL’ =&gt; 0, //URL模式 此时的URL模式是普通模式 http://serverName/appName/?m=module&amp;a=action&amp;id=1 serverName： localhost appName: testThinkPHP 就是项目文件夹的名字 m = 控制器的名字，例如UserAction.class.php的名字为User a = 控制器方法的名字，想执行showUser方法，就写showUser 后面的参数为传入该方法的参数 所以采用此种方式 访问刚才显示用户名密码的页面的 地址就是： http://localhost/testThinkPHP/?m=User&amp;a=showUser</p><a id="more"></a><p>‘URL_MODEL’ =&gt; 1, //URL模式 这个时候是PATHINFO模式 http://serverName/appName/module/action/id/1/ 这个时候访问显示用户名密码的页面的地址就是： http://localhost/a/index.php/User/showUser</p><p>值得注意的是，设置URL_MODEL只是改变使用系统U函数生成的URL的样式，无论设置成什么模式，几种URL都是可以访问的。 例如，当URL_MODEL = 1 的时候，访问 http://localhost/testThinkPHP/?m=User&amp;a=showUser 依然可以出现显示用户名密码的界面</p><h2 id="模型-控制器-视图默认的映射关系">模型-控制器-视图默认的映射关系</h2><p>testThinkPHP –Lib –Action –UserAction.class.php –Model –UserModel.class.php –Tpl –User –addUserGet.html –addUserPost.html –showUser.html testThinkPHP是项目的主目录，按照这样的文件夹结构，定义了模型User，控制器User，视图组User 控制器User中的方法名称自动对应视图组User中的同方法名称相同的模版文件。</p><p>在这样的默认对应规则下，可以使用User:addUserGet找到模板文件testThinkPHP/Tpl/User/addUserGet.html文件</p><h2 id="配置文件的生效位置">配置文件的生效位置</h2><p>testThinkPHP/Conf/config.php 中返回数组，配置参数就会生效。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thinkphp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sublime Text tricks</title>
      <link href="/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_sublime-Text-tricks/"/>
      <url>/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_sublime-Text-tricks/</url>
      
        <content type="html"><![CDATA[<h1 id="快速注释">快速注释</h1><ul><li>Ctrl + / 单行注释/取消注释 选中行</li><li>Ctrl + Shift + / 多行注释/取消注释 选中行</li></ul><h1 id="快速打开文件">快速打开文件</h1><ul><li>Ctrl + P 输入要打开的文件名前几个字母就可以快速打开文件</li><li>Ctrl+G：跳转到第几行</li></ul><a id="more"></a><h1 id="快捷键">快捷键</h1><p>Ctrl + L 选择整行（按住-继续选择下行） Ctrl + KK 从光标处删除至行尾 Ctrl + Shift+K 删除整行 Ctrl + Shift+D 复制光标所在整行，插入在该行之前 Ctrl + J 合并行（已选择需要合并的多行时） Ctrl + KU 改为大写 Ctrl + KL 改为小写 Ctrl + D 选词 （按住-继续选择下个相同的字符串） Ctrl + M 光标移动至括号内开始或结束的位置 Ctrl + Shift + M 选择括号内的内容（按住-继续选择父括号） Ctrl + / 注释整行（如已选择内容，同“Ctrl+Shift+/”效果） Ctrl + Shift + / 注释已选择内容 Ctrl + Z 撤销 Ctrl + Y 恢复撤销 Ctrl + M 光标跳至对应的括号 Alt + . 闭合当前标签 Ctrl + Shift+A 选择光标位置父标签对儿 Ctrl + Shift+[ 折叠代码 Ctrl + Shift+] 展开代码 Ctrl + KT 折叠属性 Ctrl + K0 展开所有 Ctrl + U 软撤销 Ctrl + T 词互换 Tab 缩进 自动完成 Shift + Tab 去除缩进 ctrl+tab：切换选项卡： Ctrl + Shift+↑ 与上行互换 Ctrl + Shift+↓ 与下行互换 Ctrl + K Backspace 从光标处删除至行首 Ctrl + Enter 光标后插入行 Ctrl + Shift+Enter 光标前插入行 Ctrl + F2 设置书签 F2 下一个书签 Shift + F2 上一个书签 Alt+Shift+数字：分屏显示 Alt+数字：切换打开第N个文件</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sublimeText </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Make phpStorm friendly to laravel</title>
      <link href="/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_Make-phpStorm-friendly-to-laravel/"/>
      <url>/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_Make-phpStorm-friendly-to-laravel/</url>
      
        <content type="html"><![CDATA[<h1 id="phpstorm的个性化设置">phpStorm的个性化设置</h1><ol style="list-style-type: decimal"><li><code>file--&gt;setting</code> 打开设置界面，有两个<code>appearance</code>,第一个设置软件整体的风格，例如可以改成Windows风格</li></ol><a id="more"></a><p><img src="setting_show.png" alt="phpStorm setting show"> <img src="phpStorm_windows_style.png" alt="phpStorm windows style"> 2. 第二个<code>appearance</code>是修改编辑器风格的，我喜欢修改成sublime Text的风格 - 下载主题包：链接: http://pan.baidu.com/s/1nthy0kT 密码: 2ymp - 将里面的XML结尾的文件复制到<code>C:\Users\Seemeloo1\.WebIde70\config\colors</code> 文件夹下，这里的Seemeloo1是用户名，不同的电脑不一样。 - 在主题选择页面找到刚才下载的主题，另存为，然后修改字体大小和其它属性</p><h1 id="安装laravel-ide-helper实现代码自动完成代码提示和跟踪">安装laravel-ide-helper实现代码自动完成、代码提示和跟踪</h1><ol style="list-style-type: decimal"><li><p>在<code>composer.json</code>的<code>require</code>下添加一行 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“barryvdh/laravel-ide-helper”:”1.11.*”</span><br></pre></td></tr></table></figure></p></li><li>执行<code>composer update</code>安装刚才添加的插件</li><li><p>执行<code>php artisan ide-helper:generate</code>,生成代码提示和跟踪需要的文件，现在就可以按住Ctrl单击方法追踪方法来源了。 <img src="ide_helper.png" alt="ide-help"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> laravel </tag>
            
            <tag> phpStorm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>laravel 4 note 01</title>
      <link href="/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_laravel-4-note-01/"/>
      <url>/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_laravel-4-note-01/</url>
      
        <content type="html"><![CDATA[<h1 id="artisan常用命令">artisan常用命令</h1><ul><li><code>php artisan generate:seed page</code> 新建<code>app/database/seeds/PageTableSeeder.php</code>文件，seed文件可以用来随机生成数据填充到数据库。</li><li><code>php artisan generate:view admin._layout.default</code> 新建<code>app/views/admin/_layout/default.blade.php</code>文件，这是模版文件。</li><li><code>php artisan generate:mode article</code> 新建<code>app/models/Article.php</code>文件，这是模型，与数据库操作相关。</li><li><code>php artisan serve</code> 开启Laravel自带的Web服务器，使用地址<code>localhost:8000</code>访问</li><li><code>php artisan migrate</code> 执行数据迁移,该命令会将migration下面改动的文件执行一遍，确保和数据库的一致。</li></ul><a id="more"></a><h1 id="使用composer安装需要的依赖">使用Composer安装需要的依赖</h1><ol style="list-style-type: decimal"><li><p>在<code>composer.json</code>的<code>require</code>或<code>require-dev</code>添加组件名称和版本号 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;edvinaskrucas/notification&quot;: &quot;3.0.1&quot;</span><br></pre></td></tr></table></figure></p></li><li>在项目的根目录下执行<code>composer update</code>命令</li><li><p>在<code>app.php</code>中的<code>providers</code>添加一行 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;Krucas\Notification\NotificationServiceProvider&apos;,</span><br></pre></td></tr></table></figure></p></li><li><p>在<code>aliases</code>中添加一行 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;Notification&apos;      =&gt; &apos;Krucas\Notification\Facades\Notification&apos;,</span><br></pre></td></tr></table></figure></p></li></ol><h1 id="常见错误">常见错误</h1><ol style="list-style-type: decimal"><li>新增的类编译的时候提示找不到该类：执行<code>composer auto-dump</code></li><li>新建文件夹后找不到文件：在<code>composer.json</code>中的<code>autoload</code>的<code>classmap</code>新增一行该文件夹的路径。</li></ol><h1 id="常用方法">常用方法</h1><ol style="list-style-type: decimal"><li><code>Sentry::check()</code> 检查用户是否登陆</li><li><code>Input::get('email')</code> 获取前台通过<code>get</code>方式提交的<code>email</code>字段</li><li><code>Redirect::route('admin.login')</code></li><li><code>Redirect::to('eadmin/products')</code></li><li><code>HTML::link('account/newaccount','register',array('class'=&gt;'default-btn'))</code> Blade模版语法</li><li><code>Form::open(array('url'=&gt;'accounts/sigin'))</code></li></ol><h1 id="eloqyent操作">Eloqyent操作</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立一个Page模型，与数据库中的表user关联</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Page</span> <span class="keyword">extends</span> \<span class="title">Eloquent</span></span>&#123;</span><br><span class="line"><span class="keyword">protected</span> $table=<span class="string">'users'</span>; <span class="comment">//指定使用的数据库，不指定的时候默认为类名称的小写复数形式</span></span><br><span class="line"><span class="keyword">protected</span> $primaryKey=<span class="string">'id'</span>; <span class="comment">//指定主键的名称，不指定默认为id</span></span><br><span class="line"><span class="keyword">protected</span> $timestamps = <span class="keyword">false</span>; <span class="comment">//取消数据库的created_at 和 updated_at两个字段，默认情况下每个数据库都有这两个字段，是框架自动生成和维护的。</span></span><br><span class="line"><span class="keyword">protected</span> $appends = <span class="keyword">array</span>(<span class="string">'a1'</span>,<span class="string">'a2'</span>); <span class="comment">//需要使用但是数据库中没有定义的字段</span></span><br><span class="line"><span class="keyword">protected</span> $hidden = <span class="keyword">array</span>(<span class="string">'h1'</span>,<span class="string">'h2'</span>); <span class="comment">//需要隐藏的字段，隐藏的字段不会出现在查询结果中。</span></span><br><span class="line"><span class="keyword">use</span> <span class="title">SoftDeletingTrait</span>; <span class="comment">//开启软删除功能，默认情况下该功能是不打开的。开启软删除之后，删除数据库的命令不会真正执行，而是更新数据库的deleted_at字段。</span></span><br><span class="line"><span class="comment">//如果要自定义返回的时间戳的格式，可以改写此方法实现</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">getDateFormat</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'U'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to install Laravel framework</title>
      <link href="/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_How-to-install-Laravel-framework/"/>
      <url>/hexoblog/2016/06/11/%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91_How-to-install-Laravel-framework/</url>
      
        <content type="html"><![CDATA[<h2 id="安装composer">安装composer</h2><ol style="list-style-type: decimal"><li>下载composer的Windows安装包，<a href="https://getcomposer.org/download/" target="_blank" rel="noopener">Composer-Setup.exe</a></li><li>运行安装程序，配置<code>php.exe</code>所在的位置 <img src="set_php_path.jpg" alt="php.exe’s path set"> 安装程序会自动从官网下载所需的文件，自动完成安装 <img src="downloading_files.jpg" alt="downloading files"></li></ol><a id="more"></a><ol start="3" style="list-style-type: decimal"><li>安装完成后，打开<code>cmd</code>，键入<code>composer</code>，出现如下提示证明安装成功 <img src="composer_hint.png" alt="composer hint"></li><li>如果因为没有翻墙安装失败，可以使用国内composer镜像安装 <a href="http://pkg.phpcomposer.com/" target="_blank" rel="noopener">composer中国镜像</a></li><li>composer 离线安装方法</li></ol><ul><li>下载需要的文件 百度云：链接: http://pan.baidu.com/s/1qW0VhCC 密码: 2nc1 <img src="file_capture.jpg" alt="file capture"></li><li>将文件解压至任意目录，例如<code>c:\composer\</code></li><li>将<code>bin</code>所在的路径添加到系统的<code>path</code>变量中</li><li>重新打开一个<code>cmd</code>，键入<code>composer</code>测试</li></ul><h2 id="安装laravel框架">安装Laravel框架</h2><ol style="list-style-type: decimal"><li>官方文档 <a href="https://laravel.com/docs/5.2#installation" target="_blank" rel="noopener">官网教程</a></li><li>下载框架安装 百度云： 链接: http://pan.baidu.com/s/1mg84OCo 密码: ev2x 下载完成后，解压文件到Web服务器目录下，文件结构为 <img src="laravel_framework_structure.png" alt="laravel framework structure"></li><li>在该目录下运行 composer install ，安装lavarel框架所需要的依赖包 <img src="composer_install_laravel.png" alt="composer install laravel"> 安装完成后，会在该文件夹下新增一个vender文件夹，这里面是lavarel框架的依赖包。 vender 的结构 <img src="vendor_structure.png" alt="vender structure"></li><li>在项目根目录下键入<code>php artisan serve</code> <img src="php_artisan_serve.png" alt="php artisan serve"> 在浏览器输入<code>localhost:8000</code>出现如下页面，证明安装成功 <img src="install_laravel_successful.png" alt="install laravel successful"></li></ol><h2 id="听听音乐">听听音乐</h2><center><iframe name="iframe_canvas" src="http://douban.fm/partner/baidu/doubanradio" scrolling="no" frameborder="0" width="400" height="200"></iframe></center>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> laravel </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
