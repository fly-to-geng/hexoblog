---
title: 做过的算法题汇总表
toc: true

tags:
  - ACM
date: 2017-04-08 21:52:05
---

在各个不同的平台上做过的算法题目。

<!-- more -->
## [lintcode]

### 二叉树的前序遍历 - C++ [lintcode]
![2017-04-08_220703.png](2017-04-08_220703.png)
http://www.lintcode.com/zh-cn/problem/binary-tree-preorder-traversal/
```C++
/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this->val = val;
 *         this->left = this->right = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param root: The root of binary tree.
     * @return: Preorder in vector which contains node values.
     */
    vector<int> preorderTraversal(TreeNode *root) {
        // write your code here
        vector<int> re;
        if(root == nullptr) return re;
        re.push_back(root->val);
        if(root->left){
            vector<int> ll = preorderTraversal(root->left);
            re.insert(re.end(), ll.begin(), ll.end());
        }
        if(root->right){
            vector<int> rr = preorderTraversal(root->right);
            re.insert(re.end(), rr.begin(), rr.end());
        }
        return re;
    }
};
```

### 二叉树的中序遍历 - C++ [lintcode]
![2017-04-08_220826.png](2017-04-08_220826.png)
http://www.lintcode.com/zh-cn/problem/binary-tree-inorder-traversal/
```C++
/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this->val = val;
 *         this->left = this->right = NULL;
 *     }
 * }
 */
class Solution {
    /**
     * @param root: The root of binary tree.
     * @return: Inorder in vector which contains node values.
     */
public:
    vector<int> inorderTraversal(TreeNode *root) {
        // write your code here
        vector<int> re;
        if(root == nullptr) return re;
        if(root->left){
            vector<int> ll = inorderTraversal(root->left);
            re.insert(re.end(),ll.begin(),ll.end());
        }
        re.push_back(root->val);
        if(root->right){
            vector<int> rr = inorderTraversal(root->right);
            re.insert(re.end(),rr.begin(),rr.end());
        }
        return re;
    }
};
```

### 二叉树的后序遍历 - C++ [lintcode]
![2017-04-08_220852.png](2017-04-08_220852.png)
http://www.lintcode.com/zh-cn/problem/binary-tree-postorder-traversal/
```C++
/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this->val = val;
 *         this->left = this->right = NULL;
 *     }
 * }
 */
class Solution {
    /**
     * @param root: The root of binary tree.
     * @return: Postorder in vector which contains node values.
     */
public:
    vector<int> postorderTraversal(TreeNode *root) {
        // write your code here
        vector<int> re;
        if(root == nullptr) return re;
        if(root->left){
            vector<int> ll = postorderTraversal(root->left);
            re.insert(re.end(),ll.begin(),ll.end());
        }
        if(root->right){
            vector<int> rr = postorderTraversal(root->right);
            re.insert(re.end(),rr.begin(),rr.end());
        }
        re.push_back(root->val);
        return re;
    }
};
```

### 二叉树的最大深度 - C++ [lintcode]
![2017-04-08_220920.png](2017-04-08_220920.png)
http://www.lintcode.com/zh-cn/problem/maximum-depth-of-binary-tree/
```C++
/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this->val = val;
 *         this->left = this->right = NULL;
 *     }
 * }
 */
class Solution {
public:
    /**
     * @param root: The root of binary tree.
     * @return: An integer
     */
    int maxDepth(TreeNode *root) {
        // write your code here
        if(root == nullptr) return 0;
        int maxDL = 1;
        int maxDR = 1;
        if(root->left){
            maxDL += maxDepth(root->left);
        }
        if(root->right){
            maxDR += maxDepth(root->right);
        }
        return max(maxDL,maxDR);
    }
};
```

### 二叉树的最小深度 - C++ [lintcode]
![2017-04-08_220950.png](2017-04-08_220950.png)
http://www.lintcode.com/zh-cn/problem/minimum-depth-of-binary-tree/
```C++
/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this->val = val;
 *         this->left = this->right = NULL;
 *     }
 * }
 */
class Solution {
public:
    /**
     * @param root: The root of binary tree.
     * @return: An integer
     */
    int minDepth(TreeNode *root) {
        // write your code here
        // write your code here
        if(root == nullptr) return 0;
        int maxDL = 1;
        int maxDR = 1;
        if(root->left){
            maxDL += maxDepth(root->left);
        }
        if(root->right){
            maxDR += maxDepth(root->right);
        }
        return min(maxDL,maxDR);
    }
};
```

### 二叉树的层次遍历 II - C++ [lintcode]
![2017-04-08_221012.png](2017-04-08_221012.png)
http://www.lintcode.com/zh-cn/problem/binary-tree-level-order-traversal-ii/
```C++
/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this->val = val;
 *         this->left = this->right = NULL;
 *     }
 * }
 */


class Solution {
    /**
     * @param root : The root of binary tree.
     * @return : buttom-up level order a list of lists of integer
     */
public:
    vector<vector<int>> levelOrderBottom(TreeNode *root) {
        // write your code here
        vector<vector<int>> result;
        vector<TreeNode*> v1,v2;
        if(root == nullptr){
            return result;
        }
        v1.push_back(root);

        while(!v1.empty()){
            // 遍历v1中的所有节点，将下一层节点保存在v2中
            for(int i=0;i<v1.size();i++){
                if(v1[i]->left){
                    v2.push_back(v1[i]->left);
                }
                if(v1[i]->right){
                    v2.push_back(v1[i]->right);
                }
            }
            vector<int> tmp;
            //打印v1
            for(int i=0;i<v1.size();i++){
                tmp.push_back(v1[i]->val);
            }
            result.insert(result.begin(),tmp);
            swap(v1,v2);
            v2.clear();
        }
        return result;
    }
};
```

### 二叉树的锯齿形层次遍历 - C++ [lintcode]
![2017-04-08_221038.png](2017-04-08_221038.png)
http://www.lintcode.com/zh-cn/problem/binary-tree-zigzag-level-order-traversal/
```C++
/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this->val = val;
 *         this->left = this->right = NULL;
 *     }
 * }
 */


class Solution {
    /**
     * @param root: The root of binary tree.
     * @return: A list of lists of integer include
     *          the zigzag level order traversal of its nodes' values
     */
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode *root) {
        // write your code here
        vector<vector<int>> result;
        if(!root) return result;
        vector<TreeNode*> v1,v2;
        v1.push_back(root);
        int level = 1;
        while(!v1.empty()){
            //遍历v1中的节点，把v1中所有节点的下一级节点存储在v2中
            for(int i=0;i<v1.size();i++){
                if(v1[i]->left){
                    v2.push_back(v1[i]->left);
                }
                if(v1[i]->right){
                    v2.push_back(v1[i]->right);
                }
            }
            // 打印v1中的节点,如果level 是奇数，则从左向又打印，
            // 如果level是偶数，则从右向左打印
            vector<int> tmp;
            if(level % 2 == 0){
                for(int i=v1.size()-1;i>=0;i--){
                    tmp.push_back(v1[i]->val);
                }
            }
            if(level % 2 ){
                for(int i=0;i<v1.size();i++){
                    tmp.push_back(v1[i]->val);
                }
            }
            result.push_back(tmp);
            // 更新该更新的数据
            swap(v1,v2);
            v2.clear();
            level++;
        }
        return result;

    }
};
```

### 用栈实现队列 - C++ [lintcode]
![2017-04-08_221207.png](2017-04-08_221207.png)
http://www.lintcode.com/zh-cn/problem/implement-queue-by-two-stacks/
```C++
class MyQueue {
public:
    stack<int> stack1;
    stack<int> stack2;

    MyQueue() {
        // do intialization if necessary
    }

    void push(int element) {
        // write your code here
        stack1.push(element);
    }

    int pop() {
        // write your code here
        if(stack2.empty()){
            if(stack1.empty()){
               return -1;
            }
            while(!stack1.empty()){
                int a = stack1.top();
                stack1.pop();
                stack2.push(a);
            }
        }
        int a = stack2.top();
        stack2.pop();
        return a;
    }

    int top() {
        // write your code here
        if(stack2.empty()){
            if(stack1.empty()){
               return -1;
            }
            while(!stack1.empty()){
                int a = stack1.top();
                stack1.pop();
                stack2.push(a);
            }
        }
        int a = stack2.top();
        return a;
    }
};

```

### 线段树的构造 - C++ [lintcode]
![2017-04-08_221303.png](2017-04-08_221303.png)
http://www.lintcode.com/zh-cn/problem/segment-tree-build/
```C++
/**
 * Definition of SegmentTreeNode:
 * class SegmentTreeNode {
 * public:
 *     int start, end;
 *     SegmentTreeNode *left, *right;
 *     SegmentTreeNode(int start, int end) {
 *         this->start = start, this->end = end;
 *         this->left = this->right = NULL;
 *     }
 * }
 */
class Solution {
public:
    /**
     *@param start, end: Denote an segment / interval
     *@return: The root of Segment Tree
     */
    SegmentTreeNode * build(int start, int end) {
         // write your code here
        if(start > end)
            return nullptr;
        SegmentTreeNode *node = new SegmentTreeNode(start,end);
        if( start < end ) {
            node->left = build(node->start,(node->start+node->end)/2);
            node->right = build((node->start+node->end)/2+1,node->end);
        }
        return node;
    }
};
```

### 线段树的查询 - C++ [lintcode]
![2017-04-08_221333.png](2017-04-08_221333.png)
http://www.lintcode.com/zh-cn/problem/segment-tree-query/
```C++
/**
 * Definition of SegmentTreeNode:
 * class SegmentTreeNode {
 * public:
 *     int start, end, max;
 *     SegmentTreeNode *left, *right;
 *     SegmentTreeNode(int start, int end, int max) {
 *         this->start = start;
 *         this->end = end;
 *         this->max = max;
 *         this->left = this->right = NULL;
 *     }
 * }
 */
class Solution {
public:
    /**
     *@param root, start, end: The root of segment tree and
     *                         an segment / interval
     *@return: The maximum number in the interval [start, end]
     */
    int query(SegmentTreeNode *root, int start, int end) {
        // write your code here
        // 区间比根区间还大的情况
        if(start <= root->start && end >= root->end){
            return root->max;
        }
        //如果左边界已经大于等于又边界  或者  右边界已经大于等于左边界， 则不存在的这样的区域
        //返回不影响计算最大值的数字
        if(start>root->end || end < root->start){
            return 0;
        }

        int ll = query(root->left,start,end);
        int rr = query(root->right,start,end);
        return max(ll,rr);

    }
};
```

### 线段树查询 II - C++ [lintcode]
![2017-04-08_221138.png](2017-04-08_221138.png)
http://www.lintcode.com/zh-cn/problem/segment-tree-query-ii/
```C++
/**
 * Definition of SegmentTreeNode:
 * class SegmentTreeNode {
 * public:
 *     int start, end, count;
 *     SegmentTreeNode *left, *right;
 *     SegmentTreeNode(int start, int end, int count) {
 *         this->start = start;
 *         this->end = end;
 *         this->count = count;
 *         this->left = this->right = NULL;
 *     }
 * }
 */
class Solution {
public:
    /**
     *@param root, start, end: The root of segment tree and
     *                         an segment / interval
     *@return: The count number in the interval [start, end]
     */
    int query(SegmentTreeNode *root, int start, int end) {
        // write your code here
        if(!root||start>end)
            return 0; // 如果数据非法就返回0，表示这个区间没有元素
        if(start<=root->start&&end>=root->end)
            return root->count;  //如果给出的区间比根的区间还大，不用查找，直接返回根区间的元素个数
        int mid = (root->start + root->end)/2;
        if(start>mid)
             return query(root->right,start,end);
        else if(end<mid+1)
             return query(root->left,start,end);
        else
        // 如果跨越分支，应该把两个分支的数据加在一起
             return query(root->left,start,mid)+query(root->right,mid+1,end);
    }
};
```

### 统计前面比自己小的数的个数 - C++ [lintcode]
![2017-04-08_221234.png](2017-04-08_221234.png)
http://www.lintcode.com/zh-cn/problem/count-of-smaller-number-before-itself/
```C++
class Node
{
public:
    Node(int _start, int _end) :
            start(_start), end(_end), left(nullptr), right(nullptr),
            cnt(0) {}

    int start, end;
    Node *left, *right;
    int cnt;
};


class Solution {
public:
    /**
      * @param A: An integer array
      * @return: Count the number of element before this element 'ai' is
      *          smaller than it and return count number array
      */
    vector<int> countOfSmallerNumberII(vector<int> &A) {
        // write your code here
        Node *root = build(0, 20000);
        vector<int> res;

        for (int i = 0; i < A.size(); i++)
        {
            int cnt = query(root, 0, A[i] - 1);
            res.push_back(cnt);
            modify(root, A[i]);
        }

        return res;
    }
private:
    Node *build(int start, int end)
    {
        if (start > end)
        {
            return NULL;
        }
        if (start == end)
        {
            return new Node(start, end);
        }

        int mid = start + ((end - start) >> 1);

        Node *root = new Node(start, end);
        root->left = build(start, mid);
        root->right = build(mid + 1, end);

        return root;
    }

    void modify(Node *root, int idx){
        if (root == NULL)
        {
            return;
        }

        if (root->start == root->end && root->start == idx)
        {
            ++(root->cnt);
            return;
        }

        int mid = root->start + ((root->end - root->start) >> 1);
        if (mid >= idx)
        {
            modify(root->left, idx);
        }
        else
        {
            modify(root->right, idx);
        }

        root->cnt = root->left->cnt + (root->right ? root->right->cnt : 0);
    }

    int query(Node *root, int start, int end)
    {
        if (root->end < start || root->start > end)
        {
            return 0;
        }
        if (root->start >= start && root->end <= end)
        {
            return root->cnt;
        }

        int mid = root->start + ((root->end - root->start) >> 1);
        if (mid >= end)
        {
            return query(root->left, start, end);
        }
        if (mid < start)
        {
            return query(root->right, start, end);
        }

        int leftRes = query(root->left, start, mid);
        int rightRes = query(root->right, mid + 1, end);

        return leftRes + rightRes;
    }
};
```

## [nowcoder]

### 最小的K个数 C++ [nowcoder]
输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。
https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=11047976
```C++
class Solution {
public:
    vector<int> GetLeastNumbers_Solution(vector<int> input, int k) {
        vector<int> result;
        if(k>(int)input.size()) return result;
        sort(input.begin(),input.end());
        for(size_t i=0;i<k;i++){
            result.push_back(input[i]);
        }
        return result;
    }
};
```

### 找出出现的次数超过数组长度的一半的数 C++ [nowcoder]
数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。
https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=11047857
```C++
class Solution {
public:
    int MoreThanHalfNum_Solution(vector<int> numbers) {
    if(numbers.size() == 0) return 0;
    if(numbers.size() == 1) return numbers[0];
    int count = 1;
    int card = numbers[0];
    for(size_t i=1;i<numbers.size();i++){
        if(numbers[i] == card){
            count++;
        }else{
            count--;
            if(count == 0){
                card = numbers[i];
                count = 1;
            }
        }
    }
    int sum = 0;
    for(size_t i=0;i<numbers.size();i++){
        if(numbers[i] == card){
            sum++;
        }
    }
    if(numbers.size()/2 < sum){
        return  card;
    }
    return 0;
}
};
```

### 找到第一个只出现一次的字符 C++ [nowcoder]
在一个字符串(1<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置。如果字符串为空,返回-1
https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=11034739
```C++
class Solution {
public:
    int FirstNotRepeatingChar(string str) {
        // 统计每个字母的个数，只出现一次的第一个字母的位置
        if(str.empty()) return -1;
        vector<int> hash(256,0);
        for(size_t i=0;i<str.size();i++){
            hash[str[i]]++;
        }
        // 之所以这样顺序正确，是因为我们不是按照hash数组的顺序来遍历的
        //而是按照str[i]作为hash数组的下标来遍历的，这一点十分重要
        for(size_t i=0;i<str.size();i++){
            if(1==hash[str[i]]){
                return i;
            }
        }
        return -1;
    }
};
```

### 找到第1500个丑数 C++ [nowcoder]
把只包含素因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。
https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=11033314
```C++
class Solution {
public:
        int GetUglyNumber_Solution(int index) {
        if (index < 7)return index;
        vector<int> res(index);
        res[0] = 1;
        //开始的时候t2,t3,t5都指向开始的1，一旦出现被使用一次的情况，就加1，这样保证
        //不会重复比较，也不会漏掉
        int t2 = 0, t3 = 0, t5 = 0, i;
        for (i = 1; i < index; ++i)
        {
            res[i] = min(res[t2] * 2, min(res[t3] * 3, res[t5] * 5));
            if (res[i] == res[t2] * 2)t2++;
            if (res[i] == res[t3] * 3)t3++;
            if (res[i] == res[t5] * 5)t5++;
        }
        return res[index - 1];
    }
};
```

### 打印所有数字中最小的一个 C++ [nowcoder]
输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。
https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=11021544
```C++
class Solution {
public:
struct NumBit{
    int num;
    NumBit(int n) : num(n) {}
    bool operator<(const struct NumBit & right)const   //重载<运算符
    {
        vector<int> vtmp1;
        int n = this->num;
        int b = 0;
        while(n){
            b = n % 10;
            vtmp1.insert(vtmp1.begin(),b);
            n /= 10;
        }
        vector<int> vtmp2;
        int n2 = right.num;
        int b2 = 0;
        while(n2){
            b2 = n2 % 10;
            vtmp2.insert(vtmp2.begin(),b2);
            n2 /= 10;
        }
        int i = 0;
        int j = 0;
        int ilen = vtmp1.size();
        int jlen = vtmp2.size();
        while( i<ilen || j<jlen ){
            if(i<ilen && j<jlen && vtmp1[i] > vtmp2[j]){
                return false;
            }else if(i<ilen && j<jlen && vtmp1[i] < vtmp2[j]){
                return true;
            }else if(i<ilen && j<jlen && vtmp1[i] == vtmp2[j]){
                i++;
                j++;
            }else if(i==ilen){
                if(vtmp2[j] > vtmp2[0]) return true;
                else if(vtmp2[j] < vtmp2[0]) return false;
                else if(j == jlen){
                    return false;
                }else{
                    j++;
                }
            }else if(j==jlen){
                if(vtmp1[i] > vtmp1[0]) return false;
                else if(vtmp1[i] < vtmp1[0]) return  true;
                else if(i == ilen){
                    return true;
                }else{
                    i++;
                }
            }else{
                break;
            }
        }
        return false;
    }
};
    string Int_to_String(int n)
    {
        ostringstream stream;
        stream<<n;  //n为int类型
        return stream.str();
    }

    // 解题思路： 构成最小的数字，其实质就是从最高位开始，每次都选择最小的数字作为最高位
    // 只需要对原来的数字按照下面的规则排序就可以做到
    // 把两个数字的最高位对齐，例如
    //  3332
    //  332
    // 从左向右比较，如果数字小的排在前面，如果数字相等，比较后面一位。如果其中一个数字没有了，
    // 那么比较另外一个剩下的数字与首数字的关系，如果大于首数字，则该数较大，如果小于该数字，则该数较小
    //如果相等，则指针后移，继续比较下一位，直到结束，如果直到结束都没有比较出大小，可以认为两个数一样大.
    //使用自定义的比较方法之后，直接使用multiset排序，然后拼接在一起就是结果
    string PrintMinNumber(vector<int> numbers) {
       string re;
        multiset<NumBit> s; // 存放每个数字的各位数字
        for(int i=0;i<numbers.size();i++){
            NumBit *tmp = new NumBit(numbers[i]);
            s.insert(s.end(),*tmp);
        }
        while(!s.empty()){
            NumBit t = *s.begin();
            re.append( Int_to_String(t.num));
            s.erase(s.begin(),++s.begin());
        }

        // 每次选择最小的数字放在高位上

        return re;
    }
};
```

### 整数中1出现的次数 C++ [nowcoder]
求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。
https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=11014410
```C++
class Solution {
public:
    int NumberOf1Between1AndN_Solution(int n)
    {
        //整体思路是分别计算当各位，十位，百位..为1的时候其他的位有多少中可能的情况
        //其实就是一个有限制条件的排列组合问题
        float sum = 0;
        int i=0;
        int b = 0;
        int tb = 0;
        float tail = 0; // 结尾的数字
        while(n){
            b = n % 10;
            n /= 10;
            if(i>0){
                tail = tb * pow(10.0,i-1) + tail;
                cout<<"=="<<tail<<endl;
            }

            if(b == 0){
                sum += (n)*pow(10.0,i);
            }
            else if( b == 1){
                sum += (n)*pow(10.0,i) + tail + 1;
            }else{
                sum += (n+1)*pow(10.0,i);
            }
            i++;
            tb = b;
        }
        return sum;
    }
};
```

### 所有和为S的连续正数序列 C++ [nowcoder]
小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!
https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=11007141
```C++
class Solution {
public:
    vector<vector<int> > FindContinuousSequence(int sum) {
    vector<vector<int>> result;
    map<int,vector<int>> m;
    // 连续和等于sum，有两种情况，奇数个和偶数个
    //如果奇数个连续的整数和等于sum, 那么位于中间的那个数一定可以被sum整除
    //如果偶数个连续的整数和等于sum,那么必然有最中间的两个数的和可以被sum整除
    for(int i=sqrt(2*sum);i>=1;i--){
        vector<int> v;
        if(sum % i != 0) continue; // i表示有多少个连续的数字加和成sum,如果sum不能整除i，肯定不可能有解

        if(i % 2 == 0 || i == 1){ //有偶数个数字
            int pair = sum / i ;
            if((pair - 1 ) % 2 == 0){
                cout<<i<<endl;
                int pair1 = (pair - 1) / 2; //找到了位于最中间位置的两个数字
                int pair2 = pair1 + 1;
                int start = pair1 - i + 1; // 最开始的数字
                int end = pair2 + i -1 ; //结尾的数字
                if(start > 0) {
                    for(int a = start;a<=end;a++){
                        v.push_back(a);
                    }
                }
            }
        }else{ // 有奇数个数字
            if(sum % i == 0){
                cout<<i<<endl;
                int mid = sum / i ; //最中间的数字
                if(mid - (i-1)/2 > 0){
                    for(int a = mid - (i-1)/2;a<=mid+(i-1)/2;a++){
                        v.push_back(a);
                    }
                }
            }
        }
        if(!v.empty()){
            m[v[0]] = v;
        }


    }

    for(auto e = m.begin();e!=m.end();e++){
        result.push_back(e->second);
    }
    return result;
}
};
```

### 循环删除整数数列问题 C++ [nowcoder]
每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0...m-1报数....这样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)
https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10998340
```C++
class Solution {
public:
    int LastRemaining_Solution(int n, int m)
    {
        if(n == 0) return -1;
        vector<bool> v(n,true);
        int count = 0; // 记录数过的数字
        int deleted = 0; //记录删除的数字
        int i = 0;
        while(true){
            if(v[i]){
                count++;
            }
            if(count == m){
                v[i] = false;
                cout<<i<<endl;
                count = 0;
                deleted++;
            }
            i++;
            if( i >= n){
                i = i % n ;
            }
            if(deleted == n-1){
                break;
            }
        }
        for(int i=0;i<n;i++){
            if(v[i]){
                return i;
            }
        }
        return -1;
    }
};
```

### 图中是否包含某条路径 C++ [nowcoder]
请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如[a b c e s f c s a d e e]是3*4矩阵，其包含字符串"bcced"的路径，但是矩阵中不包含“abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。
https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10995271
```C++
class Solution {
public:
   bool dfs(char* matrix,char* path,int rows,int cols,int i,int j,char* str,int k){
        int t=i*cols+j;
        if(i<0||i>=rows||j<0||j>=cols||path[t]) return false;
        if(matrix[t]==str[k]){
            path[t]=1;
            if(str[k+1]==0) return true;
            if(dfs(matrix,path,rows,cols,i+1,j,str,k+1)==true) return true;
            if(dfs(matrix,path,rows,cols,i-1,j,str,k+1)==true) return true;
            if(dfs(matrix,path,rows,cols,i,j+1,str,k+1)==true) return true;
            if(dfs(matrix,path,rows,cols,i,j-1,str,k+1)==true) return true;
            path[t]=0;
        }
        return false;
    }
    bool hasPath(char* matrix, int rows, int cols, char* str)
    {
        if(matrix==NULL||str==NULL||str[0]==0||rows<=0||cols<=0) return false;
        int i,j;
        char* path=new char[100000]();
        for(i=0;i<rows;i++){
            for(j=0;j<cols;j++){
                if(dfs(matrix,path,rows,cols,i,j,str,0)==true) {delete[] path;return true;}
            }
        }
        delete[] path;
        return false;
    }

};
```

### 机器人能够达到多少个格子 C++ [nowcoder]
地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？
https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10992716
```C++
class Solution {
public:
    //求数位之和
    int sumS(int a){
        int sum = 0;
        while(a){
            sum += a % 10;
            a = a / 10;
        }
        return sum;
    }
    // 暴力解法时间复杂度太高
    int movingCount(int threshold, int rows, int cols)
    {
        int count = 0;
        if(rows == 1){
             for(int j=0;j<cols;j++){
                    if(sumS(j)<=threshold){
                        count++;
                    }else{
                        break;
                    }
              }
            return count;
        }else if(cols == 1){
              for(int i=0;i<rows;i++){
                    if(sumS(i)<=threshold){
                        count++;
                    }else{
                        break;
                    }
              }
            return count;
        }else{
            for(int i=0;i<rows;i++){
                    for(int j=0;j<cols;j++){
                        if(sumS(i) + sumS(j) <= threshold){
                            count++;
                        }
                    }
            }
            return count;
        }
    }
};
```

### 找到只出现一次的数字 C++ [nowcoder]
Given an array of integers, every element appears twice except for one. Find that single one.
Note:
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10769216
```C++
class Solution {
public:
    int singleNumber(int A[], int n) {
        int result = A[0];
        for(size_t i=1;i<n;i++){
            result ^= A[i];
        }
        return result;
    }
};
```

### 查找数组中未出现的最小正整数 C++ [nowcoder]
请设计一个高效算法，查找数组中未出现的最小正整数。
给定一个整数数组A和数组的大小n，请返回数组中未出现的最小正整数。保证数组大小小于等于500。
测试样例：
[-1,2,3,4],4
返回：1
https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10735711
```C++
class ArrayMex {
public:
    int findArrayMex(vector<int> A, int n) {
        // write code here
        int minValue;
        int intV = 1;
        while(true){
            minValue = intV+1;
            for(int i=0;i<n;i++){
                if(A[i]>=intV){
                    minValue = min(minValue,A[i]);
                }
            }
            if(minValue != intV) return intV;
            else{
               intV++;
            }
        }

    }
};
```

### 数组的单调和 C++ [nowcoder]
现定义数组单调和为所有元素i的f(i)值之和。这里的f(i)函数定义为元素i左边(不包括其自身)小于等于它的数字之和。请设计一个高效算法，计算数组的单调和。
给定一个数组A同时给定数组的大小n，请返回数组的单调和。保证数组大小小于等于500，同时保证单调和不会超过int范围。
测试样例：
[1,3,5,2,4,6],6
返回：27

https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10733959

```C++
class MonoSum {
public:
    int calcMonoSum(vector<int> A, int n) {
        // write code here
        //暴力方法
        int total = 0;
        for(int i=1;i<n;i++){
            int sum = 0;
            for(int j=i-1;j>=0;j--){
                if(A[j]<=A[i]){
                    sum+=A[j];
                }
            }
            total += sum;
        }
        return total;
    }
};
```

### C是否是A和B的混编 C++ [nowcoder]
A、B和C。如果C包含且仅包含来自A和B的所有字符，而且在C中属于A的字符之间保持原来在A中的顺序，属于B的字符之间保持原来在B中的顺序，那么称C是A和B的混编。实现一个函数，判断C是否是A和B的混编。
给定三个字符串A,B和C，及他们的长度。请返回一个bool值，代表C是否是A和B的混编。保证三个串的长度均小于等于100。
测试样例：
"ABC",3,"12C",3,"A12BCC",6
返回：true
https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10731304

```C++
class Mixture {
public:
    bool chkMixture(string A, int n, string B, int m, string C, int v) {
        // 如果A+B的长度！= C的长度，肯定不能交错组成
        if(n+m!=v) return false;
        //用动态规划的方法做，开一个dp[n+1][m+1]的数组，
        //dp[i][j] 表示A[1...i-1] 和B[1...j-1] 能否交错组成C[i+j-1]
        //这里第一行和第一列都表示空串，下标是-1时表示是空串。
        vector<vector<bool>> dp(n+1,vector<bool>(m+1,false));
        // 定义空串可以由空串交错组成
        dp[0][0] = true;
        //初始化第一列，就是B为空串的时候，C能否由A交错组成。注意题目要求相对顺序不能改变
        //所以如果A == C 就是true,否则后面的全部为false;
        for(size_t i=1;i<=n;i++){
            if(A[i-1] == C[i-1]) dp[i][0] = true;
            else break;
        }
        //初始化第一行。就是A为空串的时候，C能否由B交错组成
        for(size_t j=1;j<=m;j++){
            if(B[j-1] == C[j-1]) dp[0][j] = true;
            else break;
        }
        // dp[i][j] 有以下两种情况
        // 1. A[i-1] == C[i+j-1] && dp[i-1][j]
        // 2. B[j-1] == C[i+j-1] && dp[i][j-1]
        //以上任何一个条件成立，就可以交错组成，否则就不能
        for(size_t i=1;i<=n;i++){
            for(size_t j=1;j<=m;j++){
                if(A[i-1] == C[i+j-1] && dp[i-1][j] ||
                         B[j-1] == C[i+j-1] && dp[i][j-1]){
                    dp[i][j] = true;
                }
            }
        }
        return dp[n][m];
    }
};
```

### 字符串交错组成 C++ [nowcoder]
对于三个字符串A，B，C。我们称C由A和B交错组成当且仅当C包含且仅包含A，B中所有字符，且对应的顺序不改变。请编写一个高效算法，判断C串是否由A和B交错组成。
给定三个字符串A,B和C，及他们的长度。请返回一个bool值，代表C是否由A和B交错组成。保证三个串的长度均小于等于100。
测试样例：
"ABC",3,"12C",3,"A12BCC",6
返回：true

https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10730897

```C++
class Mixture {
public:
    bool chkMixture(string A, int n, string B, int m, string C, int v) {
        // 如果A+B的长度！= C的长度，肯定不能交错组成
        if(n+m!=v) return false;
        //用动态规划的方法做，开一个dp[n+1][m+1]的数组，
        //dp[i][j] 表示A[1...i-1] 和B[1...j-1] 能否交错组成C[i+j-1]
        //这里第一行和第一列都表示空串，下标是-1时表示是空串。
        vector<vector<bool>> dp(n+1,vector<bool>(m+1,false));
        // 定义空串可以由空串交错组成
        dp[0][0] = true;
        //初始化第一列，就是B为空串的时候，C能否由A交错组成。注意题目要求相对顺序不能改变
        //所以如果A == C 就是true,否则后面的全部为false;
        for(size_t i=1;i<=n;i++){
            if(A[i-1] == C[i-1]) dp[i][0] = true;
            else break;
        }
        //初始化第一行。就是A为空串的时候，C能否由B交错组成
        for(size_t j=1;j<=m;j++){
            if(B[j-1] == C[j-1]) dp[0][j] = true;
            else break;
        }
        // dp[i][j] 有以下两种情况
        // 1. A[i-1] == C[i+j-1] && dp[i-1][j]
        // 2. B[j-1] == C[i+j-1] && dp[i][j-1]
        //以上任何一个条件成立，就可以交错组成，否则就不能
        for(size_t i=1;i<=n;i++){
            for(size_t j=1;j<=m;j++){
                if(A[i-1] == C[i+j-1] && dp[i-1][j] ||
                         B[j-1] == C[i+j-1] && dp[i][j-1]){
                    dp[i][j] = true;
                }
            }
        }
        return dp[n][m];
    }
};
```

### 最小编辑代价 C++ [nowcoder]
对于两个字符串A和B，我们需要进行插入、删除和修改操作将A串变为B串，定义c0，c1，c2分别为三种操作的代价，请设计一个高效算法，求出将A串变为B串所需要的最少代价。
给定两个字符串A和B，及它们的长度和三种操作代价，请返回将A串变为B串所需要的最小代价。保证两串长度均小于等于300，且三种代价值均小于等于100。
测试样例：
"abc",3,"adc",3,5,3,100
返回：8

https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10728936

```C++
class MinCost {
public:
    int findMinCost(string A, int n, string B, int m, int c0, int c1, int c2) {
        // write code here
        if(c2 >= c0 + c1) c2 = c0 + c1 ;
        //动态规划，开一个dp[n+1][m+1]的数组，dp[i][j] 表示把A[i-1]编辑成B[j-1]的最小编辑代价；
        vector<vector<int>> dp(n+1,vector<int>(m+1,0));
        //初始化第一列，即编辑成空串的代价，想要编辑成空串，代价就是把字符都删除。
        for(size_t i=0;i<=n;i++){
            dp[i][0] = i * c1 ;
        }
        //初始化第一行，将空串编辑成对应字符串的方法就是插入字符
        for(size_t j=0;j<=m;j++){
            dp[0][j] = j * c0 ;
        }
        //求解dp[i][j]
        //dp[i][j]有三种情况； A[i-1]编辑成B[j-1]然后替换最后一个字符，需要注意的是，如果最后一个字符相同，则不用替换，所以为dp[i-1][j-1]+c2 或者 dp[i-1][j-1]
        //将A[i]编辑成B[i-1]然后插入B[i] dp[i][j-1]+c0
        //将A[i]删除一个字符得到A[i-1]  然后将A[i-1]编辑成B[j]  dp[i-1][j] + c1
        for(size_t i=1;i<=n;i++){
            for(size_t j=1;j<=m;j++){
                dp[i][j] = min(dp[i-1][j] + c1,dp[i][j-1] + c0);
                if(A[i-1] == B[j-1]){
                    dp[i][j] = min(dp[i-1][j-1],dp[i][j]);
                }else{
                    dp[i][j] = min(dp[i][j],dp[i-1][j-1]+c2);
                }
            }
        }
        //返回结果
        return dp[n][m];
    }
};
```

### 最大间隔 C++ [nowcoder]
给定一个递增序列，`a1 <a2 <...<an` 。定义这个序列的最大间隔为`d=max{ai+1 - ai }(1≤i<n)`,现在要从`a2 ,a3 ..an-1 `中删除一个元素。问剩余序列的最大间隔最小是多少？
https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10725149
```C++
#include <iostream>
#include <vector>

using namespace std;

int main(){
    int n;
    while(cin>>n){
        if(n<=2) cout<<-1<<endl;
        else{
            vector<int> v(n,0);
            for(size_t i=0;i<n;i++){
               cin>>v[i];
            }
            int maxV = v[1] - v[0];
            //统计原来的最大间隔
            for(size_t i=0;i<n-1;i++){
                maxV = max(maxV,v[i+1]-v[i]);
            }
            //计算删除一个元素之后的最大间隔
            int minV = v[2] - v[0];
            for(size_t i=1;i<n-1;i++){
               minV = min(minV,v[i+1]-v[i-1]) ;
            }
            if(minV <= maxV){
                cout<<maxV<<endl;
            }
            if(minV > maxV){
                cout<<minV<<endl;
            }
        }
    }
    return 0;
}
```

### 搬圆桌 c++ [nowcoder]
现在有一张半径为r的圆桌，其中心位于(x,y)，现在他想把圆桌的中心移到(x1,y1)。每次移动一步，都必须在圆桌边缘固定一个点然后将圆桌绕这个点旋转。问最少需要移动几步。

https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10724077

```C++
#include<iostream>
#include<math.h>

using namespace std;
int main(){
    int r, x, y, x1, y1;
    while (cin>>r>>x>>y>>x1>>y1){
           double distance = sqrt((double)(x-x1) * (x-x1) + (double)(y-y1) * (y-y1));
        //  上取整
        int step = (int)ceil(distance / (2*r));
        cout << step << endl;
    }
    return 0;
}
```

### 裁减网格纸 C++ [nowcoder]
度度熊有一张网格纸，但是纸上有一些点过的点，每个点都在网格点上，若把网格看成一个坐标轴平行于网格线的坐标系的话，每个点可以用一对整数x，y来表示。度度熊必须沿着网格线画一个正方形，使所有点在正方形的内部或者边界。然后把这个正方形剪下来。问剪掉正方形的最小面积是多少。
https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10721856

```C++
#include <iostream>
#include <vector>

using namespace std;

int main(){
    int n;
    while(cin>>n){
       vector<vector<int>> v(n,vector<int>(2,0));
        for(size_t i=0;i<n;i++){
            cin>>v[i][0];
            cin>>v[i][1];
        }
        int x_min=v[0][0]; int x_max=v[0][0];
        int y_min=v[0][1]; int y_max=v[0][1];
        for(size_t i=0;i<n;i++){
            x_min = min(x_min,v[i][0]);
            x_max = max(x_max,v[i][0]);
            y_min = min(y_min,v[i][1]);
            y_max = max(y_max,v[i][1]);
        }
        int x = x_max - x_min;
        int y = y_max - y_min;
        if(x>y){cout<<x*x<<endl;}
        if(x<=y){cout<<y*y<<endl;}
    }

    return 0;
}
```

### 罪犯转移 C++ [nowcoder]
C市现在要转移一批罪犯到D市，C市有n名罪犯，按照入狱时间有顺序，另外每个罪犯有一个罪行值，值越大罪越重。现在为了方便管理，市长决定转移入狱时间连续的c名犯人，同时要求转移犯人的罪行值之和不超过t，问有多少种选择的方式？

https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10720643

```C++
#include <iostream>
#include<vector>
using namespace std;

int main(){
   int n; int t; int c;
    while(cin>>n>>t>>c){
        vector<int> z(n,0);
        for(size_t i=0;i<n;i++){
            cin>>z[i];
        }
        int sum = 0;
        for(size_t i=0;i<c;i++){
            sum += z[i];
        }
        int count = 0;
        for(size_t i=0;i<n-c+1;i++){
            if(sum<=t){count++;}
            sum = sum - z[i] + z[i+c];
        }
        cout<<count<<endl;
    }

    return 0;
 }
```

### 首个重复字符 C++ [nowcoder]
对于一个字符串，请设计一个高效算法，找到第一次重复出现的字符。
给定一个字符串(不一定全为字母)A及它的长度n。请返回第一个重复出现的字符。保证字符串中有重复字符，字符串的长度小于等于500。
测试样例：
"qywyer23tdd",11
返回：y

https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10689361
```C++
class FirstRepeat {
public:
    char findFirstRepeat(string A, int n) {
        // write code here
        map<char,int> m;
        for(int i=0;i<A.size();i++){
           if(m[A[i]]!=0) return A[i];
           else m[A[i]]++;
        }
        return A[0];
    }
};
```

### 棋子翻转
在4x4的棋盘上摆满了黑白棋子，黑白两色的位置和数目随机其中左上角坐标为(1,1),右下角坐标为(4,4),现在依次有一些翻转操作，要对一些给定支点坐标为中心的上下左右四个棋子的颜色进行翻转，请计算出翻转后的棋盘颜色。
给定两个数组A和f,分别为初始棋盘和翻转位置。其中翻转位置共有3个。请返回翻转后的棋盘。
测试样例：
[[0,0,1,1],[1,0,1,0],[0,1,1,0],[0,0,1,0]],[[2,2],[3,3],[4,4]]
返回：[[0,1,1,1],[0,0,1,0],[0,1,1,0],[0,0,1,0]]

https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10681526

```C++
class Flip {
public:
    vector<vector<int> > flipChess(vector<vector<int> > A, vector<vector<int> > f) {
        // write code here
        // f.size() == 3
        auto cow = A.size();
        auto col = A.size();
        for(int i=0;i<f.size();i++){
           int x = f[i][0]-1; //转换成程序中常用的以0开始的坐标
           int y = f[i][1]-1;
            if(x+1<=cow-1){ A[x+1][y] = 1-A[x+1][y];}
            if(x-1>=0){A[x-1][y] = 1- A[x-1][y];}
            if(y-1>=0){A[x][y-1] = 1-A[x][y-1];}
            if(y+1<=col-1){A[x][y+1] = 1-A[x][y+1];}
        }
        return A;
    }
};
```

### 最大差值 C++ [nowcoder]
有一个长为n的数组A，求满足0≤a≤b<n的A[b]-A[a]的最大值。
给定数组A及它的大小n，请返回最大差值。
测试样例：
[10,5],2
返回：0

https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10680737

```C++
class LongestDistance {
public:
    int getDis(vector<int> A, int n) {
        // 暴力方法，计算每一个可能的值，返回其中最大的，自己与自己的可以不计算，都是0
        //时间复杂度O(n^2)
        int maxValue = 0;
        //for(int i=0;i<=n-1;i++){
           // for(int j=i+1;j<=n-1;j++){
           //     maxValue = max(maxValue,A[j]-A[i]);
           // }
        //}
        //但是暴力方法时间复杂度太高了，这样的题还有优化的解法
        //动态规划，开一个和A一样的数组dp,dp[i]表示当a = A[i]的时候最大差值是多少。
        //当i=n-1时，最大差值为0；当i为0 -- n-2时， dp[i] = max( dp[i+1] + A[i+1] - A[i], 0);
        vector<int> dp(n,0);
        maxValue = 0;
        for(int i=n-2;i>=0;i--){
            dp[i] = max(dp[i+1] + A[i+1] - A[i],0);
            maxValue = max(maxValue,dp[i]);
        }
        //返回dp中的最大值
        return maxValue;
    }
};

```

### 直方图内最大矩形 C++ [nowcoder]
有一个直方图，用一个整数数组表示，其中每列的宽度为1，求所给直方图包含的最大矩形面积。比如，对于直方图[2,7,9,4],它所包含的最大矩形的面积为14(即[7,9]包涵的7x2的矩形)。
给定一个直方图A及它的总宽度n，请返回最大矩形面积。保证直方图宽度小于等于500。保证结果在int范围内。
测试样例：
[2,7,9,4,1],5
返回：14

```C++
class MaxInnerRec {
public:
    int countArea(vector<int> A, int n) {
        //对于A中的每一个数字，向前和向后分别搜索，直到找到比它小的数字，计算以
        //当前数字为中心的面积。
        //每次都这样循环，记录其中的最大值返回
        int result = 0;
        for(int i=0;i<=n-1;i++){
            int left = i-1;
            int right = i+1;
            while(left>=0 && A[left]>= A[i]){
                left--;
            }
            while(right<=n-1 && A[right]>=A[i]){
                right++;
            }
            int area = (right-left-1)*A[i];
            result = max(result,area);
        }
        return result;
    }
};

```

### 之字形打印矩阵 C++ [nowcoder]
对于一个矩阵，请设计一个算法，将元素按“之”字形打印。具体见样例。
给定一个整数矩阵mat，以及他的维数nxm，请返回一个数组，其中元素依次为打印的数字。
测试样例：
[[1,2,3],[4,5,6],[7,8,9],[10,11,12]],4,3
返回：[1,2,3,6,5,4,7,8,9,12,11,10]

```c++
class Printer {
public:
    vector<int> printMatrix(vector<vector<int> > mat, int n, int m) {
        // write code here
        vector<int> result;
        int j;
        for(int i=0;i<n;i++){
           if(i%2 == 0){
              j = 0;
              while(j<m){
                  result.push_back(mat[i][j]);
                  j++;
              }
           }
            if(i%2 == 1){
                j = m-1;
                while(j>=0){
                    result.push_back(mat[i][j]);
                    j--;
                }
            }
        }
        return result;
    }
};
```

### 相邻最大差值 c++ [nowcoder]
请设计一个复杂度为O(n)的算法，计算一个未排序数组中排序后相邻元素的最大差值。
给定一个整数数组A和数组的大小n，请返回最大差值。保证数组元素个数大于等于2小于等于500。
测试样例：
[9,3,1,10],4
返回：6

```C++
class MaxDivision {
public:
    int findMaxDivision(vector<int> A, int n) {
        // write code here
        int maxValue = A[0];
        int minValue = A[0];
        //找到最大值和最小值
        for(int i=1;i<=n-1;i++){
            maxValue = max(maxValue,A[i]);
            minValue = min(minValue,A[i]);
        }
        //生成最大值-最小值+1个桶，A中的数字减去最小值放在对应的桶中，
        //这样，最小值放在第0个桶中，最大值放在最后一个桶中。
        vector<int> t(maxValue-minValue+1,minValue-1);
        for(int i=0;i<=n-1;i++){
            t[A[i]-minValue] = A[i];
        }
        //统计连续的空桶的数量，这就是最后要的结果
        int result = 0;
        int tmp=0;
        for(int i=0;i<t.size();++i){
            if(t[i] == minValue-1){
                tmp++;
            }else{
                result = max(tmp,result);
                tmp = 0;
            }
        }
        // 第一次循环，找到了最大值和最小值
        //第二次循环，将n个数字放到了对应的桶中
        //第三次循环，统计空桶的个数，注意这里循环次数可能显著高于N，如果最大值和最小值相差很大的话。 所以该算法可能尚不满足题目要求的O（N）的复杂度
        return result+1;
    }
};
```

### 二分查找 C++ [nowcoder]
对于一个有序数组，我们通常采用二分查找的方式来定位某一元素，请编写二分查找的算法，在数组中查找指定元素。
给定一个整数数组A及它的大小n，同时给定要查找的元素val，请返回它在数组中的位置(从0开始)，若不存在该元素，返回-1。若该元素出现多次，请返回第一次出现的位置。
测试样例：
[1,3,5,7,9],5,3
返回：1

https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10607745

```C++
class BinarySearch {
public:
    int getPos(vector<int> A, int n, int val) {
        // write code here
        if(n == 0) return -1;
        size_t left = 0; size_t right = n - 1; size_t mid;
        while(left <= right){
            mid = (left + right) / 2 ;
            if(A[mid] == val){
                // 查找前面是否有相同的元素
                size_t tp = mid;
                while(A[tp] == val){
                    tp--;
                }
                return tp+1;
            }
            if(A[mid] > val){
                right = mid -1;
            }
            if(A[mid] < val){
                left = mid + 1;
            }
        }
        return -1;
    }
};
```

### 最高分是多少
老师想知道从某某同学当中，分数最高的是多少，现在请你编程模拟老师的询问。当然，老师有时候需要更新某位同学的成绩.
https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10595364
```C++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main(){
    while(cin){
    int m,n;
    cin>>m>>n;
    vector<int> v;
    for(int i=0;i<m;i++){
        int a;
        cin>>a;
        v.push_back(a);
    }
    for(int i=0;i<n;i++){
        char commond;
        cin>>commond;
        if(commond == 'Q'){
            int start; int end;
            cin>>start;
            cin>>end;
            if(start > end ){
                int pp = start;
                start = end;
                end = pp;
            }
            auto it = max_element(v.begin()+start-1,v.begin()+end);
            cout<<*it<<endl;

        }
        if(commond == 'U'){
            int index; int value;
            cin>>index;
            cin>>value;
            v[index-1] = value;
        }
    }
    }
    return 0;
}
```

### 从上往下打印二叉树
从上往下打印出二叉树的每个节点，同层节点从左至右打印。
https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10591248
```C++
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};*/
class Solution {
public:
    vector<int> PrintFromTopToBottom(TreeNode* root) {
        vector<int> result;
        if(root == nullptr) return result;
        deque<TreeNode*> tmp;
        tmp.push_back(root);
        while( !tmp.empty() ){
            result.push_back( tmp.front()->val );
            TreeNode* pNode = tmp.front();
            tmp.pop_front();
            if(pNode->left){
                tmp.push_back(pNode->left);
            }
            if(pNode->right){
                tmp.push_back(pNode->right);
            }

        }
        return result;
    }
};
```

### 顺时针打印矩阵 C++ [nowcoder]
输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.
https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10572756
```C++
class Solution {
public:
    vector<int> printEdge(vector<vector<int>> v,int li,int lj,int ri,int rj,vector<int> &re){
    if(li == ri){
        for(int j=lj;j<=rj;j++){
            re.push_back(v[li][j]);
        }
        return re;
    }
    if(lj == rj){
        for(int i=li;i<=ri;i++){
            re.push_back(v[i][lj]);
        }
        return re;
    }
    int i=li;
    int j=lj;
    while(i==li && j<=rj){
        re.push_back(v[i][j]);
        j++;
    }
    j--;
    i++;
    while(j==rj && i<=ri){
        re.push_back(v[i][j]);
        i++;
    }
    i--;
    j--;
    while(i==ri && j>=lj){
        re.push_back(v[i][j]);
        j--;
    }
    j++;
    i--;
    while(j == lj && i>li){
        re.push_back(v[i][j]);
        i--;
    }
    return re;
}
    vector<int> printMatrix(vector<vector<int> > matrix) {
        vector<int> result;
    if(matrix.empty()){ return result;}
    auto cow = matrix.size();
    auto col = matrix[0].size();
    int li=0;
    int lj=0;
    int ri=cow-1;
    int rj=col-1;
    while(li<=ri && lj <= rj){
        printEdge(matrix,li,lj,ri,rj,result);
        li++;
        lj++;
        ri--;
        rj--;
    }
    return result;
    }
};
```

### 树的子结构 C++ [nowcoder]
输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）

https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10561636

```C++
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};*/
class Solution {
public:
   bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)
    {
        if(!pRoot1||!pRoot2){
            return false;
        }
        bool falg=help(pRoot1,pRoot2);
        if(!falg){
            falg=help(pRoot1->left,pRoot2);
        }
        if(!falg){
            falg=help(pRoot1->right,pRoot2);
        }
        return falg;
    }
    bool help(TreeNode* p1,TreeNode* p2){
        if(p2==NULL){//一定先
            return true;
        }
        if(p1==NULL){
            return false;
        }

        if(p1->val!=p2->val){
            return false;
        }
        return help(p1->left,p2->left)&&help(p1->right,p2->right);
    }
};
```

### 二叉树的镜像 C++ [nowcoder]
操作给定的二叉树，将其变换为源二叉树的镜像。
```C++
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};*/
class Solution {
public:
    void Mirror(TreeNode *pRoot) {
        if(pRoot == nullptr){
            return;
        }
        TreeNode* tmp = pRoot->left;
        pRoot->left= pRoot->right;
        pRoot->right = tmp;
        Mirror(pRoot->left);
        Mirror(pRoot->right);
    }
};
```

### 合并两个排序的链表 C++ [nowcoder]
输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。
https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10559603
```C++
/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) :
            val(x), next(NULL) {
    }
};*/
class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)
    {
        if(pHead1 == nullptr) return pHead2;
        if(pHead2 == nullptr) return pHead1;
        if(pHead1->val <= pHead2->val){
            pHead1->next = Merge(pHead1->next,pHead2);
            return pHead1;
        }else{
            pHead2->next = Merge(pHead1,pHead2->next);
            return pHead2;
        }
        return nullptr;
    }
};
```

###  调整数组顺序使奇数位于偶数前面 C++ [nowcoder]
输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。
https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10556963
```C++
class Solution {
public:
    void reOrderArray(vector<int> &array) {
        size_t i = 0;
        int ji_index = -1; // 记录奇数的个数
        for(i=0;i<array.size();i++){
            int tmp = 0;
            if( array[i]%2 == 1 ){
                tmp = array[i];
                int j = i-1;
                while(j>ji_index){
                    array[j+1] = array[j];
                    j--;
                }

                ji_index++;
                array[ji_index] = tmp;
            }
        }
    }
};
```

### 滑动窗口的最大值 C++ [nowcoder]
给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。
https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10555019
```C++
class Solution {
public:
    vector<int> maxInWindows(const vector<int>& num, unsigned int size)
    {
        vector<int> result;
        if(num.empty() || num.size() < size) return result;
        if(size == 1) return num;
        deque<int> win;
        win.push_back(0);
        for(unsigned int i=1;i<num.size();i++){
            if(num[win.back()] >= num[i]){
                win.push_back(i);
            }else{
                while(!win.empty() && num[win.back()] < num[i]){
                    win.pop_back();
                }
                win.push_back(i);
            }
            if( i-win.front() == size){
                win.pop_front();
            }
            if(i>=size-1){
                result.push_back(num[win.front()]);
            }
        }
        return result;
    }
};
```

### 和为S的两个数字 C++ [nowcoder]
输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。
https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10523746
```C++
class Solution {
public:
    vector<int> FindNumbersWithSum(vector<int> array,int sum) {
        vector<int> result;
        if(array.empty()) return result;
        int i = 0;
        int j = array.size()-1;
        while(i < j){
            if(array[i] + array[j] > sum){
                j--;
            }else if(array[i] + array[j] < sum){
                i++;
            }else if(array[i] + array[j] == sum){
                result.push_back(array[i]);
                result.push_back(array[j]);
                break;
            }
        }
        return result;
    }
};
```

### 链表中环的入口结点
一个链表中包含环，请找出该链表的环的入口结点。
```c
/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) :
        val(x), next(NULL) {
    }
};
*/
class Solution {
public:
    ListNode* EntryNodeOfLoop(ListNode* pHead)
    {
		if(pHead == nullptr || pHead->next == nullptr) return nullptr;
        if(pHead->next == pHead) return pHead;
        ListNode* a = pHead;
        ListNode* b = pHead;
        while(a!=nullptr){
            a = a->next->next;
            b = b->next;
            if( a == b){
               a = pHead;
               while(a!=b){
                   a = a->next;
                   b = b->next;
               }
               if(a==b){
                   return a;
               }
            }
        }
        return nullptr;
    }
};
```
### 构建乘积数组
![2017-04-11_102510.png](2017-04-11_102510.png)
```c
class Solution {
public:
    vector<int> multiply(const vector<int>& A) {
        vector<int> v(A.size(),0);
        // 一般的方法时间复杂度是O(n^2), 预处理一下数组，可以将时间复杂度降低至O（n）
        vector<int> left(A.size(),1);
        vector<int> right(A.size(),1);
        for(int i=1;i<A.size();i++){
            left[i] = left[i-1] * A[i-1];
            right[i] = right[i-1] * A[A.size()-i];
        }
        for(int i=0;i<A.size();i++){
            v[i] = left[i] * right[A.size()-1-i];
        }
        return v;
    }
};
```

### 数组中重复的数字
在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者3。
```c
class Solution {
public:
    // Parameters:
    //        numbers:     an array of integers
    //        length:      the length of array numbers
    //        duplication: (Output) the duplicated number in the array number
    // Return value:       true if the input is valid, and there are some duplications in the array number
    //                     otherwise false
    bool duplicate(int numbers[], int length, int* duplication) {
        vector<int> v(length,0);
        for(int i=0;i<length;i++){
            if(numbers[i] >= length) return false;
            if (v[ numbers[i] ] == 0 ) v[ numbers[i] ] = 1;
            else{
                *duplication = numbers[i];
                return true;
            }
        }
        return false;
    }
};
```
### 不用加减乘除做加法
写一个函数，求两个整数之和，要求在函数体内不得使用```+、-、*、/```四则运算符号。
```c
class Solution {
public:
    int Add(int num1, int num2)
    {
        int sum = num1;
        while(num2!=0){
            sum = num1 ^num2;
            num2 = (num1 & num2)<<1;
            num1 = sum;
        }
        return sum;
    }
};
```
### 求1+2+3+...+n
```c
class Solution {
public:
    int Sum_Solution(int n) {
        int sum = n;
        bool ans = (n>0) && ((sum+=Sum_Solution(n-1))>0);
        return sum;
    }
};
```
### 栈的压入、弹出序列
输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）
```c
class Solution {
public:
    bool IsPopOrder(vector<int> pushV,vector<int> popV) {
        if(pushV.size() != popV.size()) return false;
        stack<int> s1;
        //找到第一个相同的元素
        size_t i = 0;
        while(pushV[i] != popV[0] && i<pushV.size()){
            s1.push(pushV[i]);
            i++;
        }
        s1.push(pushV[i]); //此时是s1栈顶和popV的第一个元素相同；
        i++;//i指向下一元素；
        for(size_t j=0;j<=popV.size();j++){
            if( j<popV.size() && popV[j] == s1.top() ){
               s1.pop();
            }else if(i<pushV.size()){
                s1.push(pushV[i]);
                j--;
                i++;
            }else if( j== popV.size() && s1.empty()){
                return true;
            }else{
                return false;
            }
        }
        return false;
    }
};
```
### 包含min函数的栈
定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。
```c
class Solution {
public:
    stack<int> data;
    stack<int> minV;
    void push(int value) {
        data.push(value);
        if(minV.empty() || value <= minV.top()){minV.push(value);}
    }
    void pop() {
        int top = data.top();
        data.pop();
        if(top == minV.top()){
            minV.pop();
        }
    }
    int top() {
       return data.top();
    }
    int min() {
        return minV.top();
    }
};
```
### 反转链表
输入一个链表，反转链表后，输出链表的所有元素。
```c
/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) :
            val(x), next(NULL) {
    }
};*/
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
        ListNode* pre = nullptr;
        ListNode* t = pHead;
        ListNode* next = pHead;
        while(t!=nullptr){
            next = t->next;
            t->next = pre;
            pre = t;
            t = next;
        }
        return pre;
    }
};
```
### 链表中倒数第k个结点
输入一个链表，输出该链表中倒数第k个结点。
```c
/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) :
            val(x), next(NULL) {
    }
};*/
class Solution {
public:
    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) {
        //先获取链表的长度
        unsigned int len = 0;
        ListNode* temp =  pListHead;
        while(temp!=nullptr){
            len++;
            temp = temp->next;
        }
        if(k>len){return nullptr;}
        if(k==len){return pListHead;}
        temp = pListHead;
        for(int i=0;i<len-k;i++){
            temp = temp->next;
        }
        return temp;
    }
};
添加笔记

```
### 数值的整数次方
给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。
```c
class Solution {
public:
    double Power(double base, int exponent) {
        if(exponent == 0) return 1;
        int sum = 1;
        if(exponent > 0){
            for(int i=0;i<exponent;i++){
                sum *= base;
            }
            return sum;
        }
        if(exponent < 0){
            for(int i=0;i<-exponent;i++){
                sum *= base;
            }
            return 1.0 / sum;
        }
        return -1;
    }
};
```
### 二进制中1的个数
输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
```c
class Solution {
public:
     int  NumberOf1(int n) {
         int count = 0;
         while(n!=0){
             count++;
             n = n&(n-1);
         }
         return count;
     }
};
```
### 矩形覆盖
我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？
```c
class Solution {
public:
    int rectCover(int number) {
        if(number == 0) return 0;
        if(number == 1) return 1;
        vector<int> v(number,0);
        v[0] = 1;
        v[1] = 2;
        for(int i=0;i<v.size()-2;i++){
            v[i+2] = v[i+1] + v[i];
        }
        return v[v.size() -1];
    }
};
```
### 变态跳台阶
一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
```c
class Solution {
public:
    int jumpFloorII(int number) {
        if(number == 0) return 0;
        if(number == 1) return 1;
        return pow(2.0,number-1);
    }
};
```
### 跳台阶
一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
```c
class Solution {
public:
    int jumpFloor(int number) {
        if(number==0) return 0;
        if(number==1) return 1;
        vector<int> v(number,0);
        v[0] = 1;
        v[1] = 2;
        for(int i=0;i<v.size()-2;i++){
            v[i+2] = v[i+1] + v[i];
        }
        return v[v.size()-1];
    }
};

```
### 斐波那契数列
大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。
```c
class Solution {
public:
    int Fibonacci(int n) {
        if(n==0) return 0;
        vector<int> f(n,1);
        for(int i=0;i<n-2;i++){
            f[i+2] = f[i+1] + f[i];
        }
        return f[n-1];
    }
};
```
### 旋转数组的最小数字
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
```c
class Solution {
public:
    int minNumberInRotateArray(vector<int> rotateArray) {
        if(rotateArray.empty()) return 0;
        for(int i=0;i<rotateArray.size();++i){
            if(rotateArray[i]>rotateArray[i+1]){
                return rotateArray[i+1];
            }
        }
        return rotateArray[0];
    }
};
```
### 用两个栈实现队列
用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。
```c
class Solution
{
public:
    void push(int node) {
        stack1.push(node);
    }

    int pop() {
        if(stack2.empty()){
            while(!stack1.empty()){
               stack2.push(stack1.top());
               stack1.pop();
            }

        }
                    int topValue = stack2.top();
            stack2.pop();
            return topValue;
    }

private:
    stack<int> stack1;
    stack<int> stack2;
};

```
### 重建二叉树
输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。
https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10499929

```C++
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
         if(pre.empty() | vin.empty()){return nullptr;}
        TreeNode* node = new TreeNode(pre[0]);// 先建立根节点
        int len = pre.size();
        for(size_t i=0;i<vin.size();++i){
            if(vin[i] == pre[0]){
                // 找到了中序遍历的根节点，则左面的全部是左子树，右面的全部是右子树。
                vector<int> left_pre(i,0);
                vector<int> left_vin(i,0);
                vector<int> right_pre(len-1-i,0);
                vector<int> right_vin(len-1-i,0);
                copy(vin.begin(),vin.begin()+i,left_vin.begin());
                copy(vin.begin()+i+1,vin.end(),right_vin.begin());
                copy(pre.begin()+1,pre.begin()+1+i,left_pre.begin());
                copy(pre.begin()+i+1,pre.end(),right_pre.begin());
                node->left =  reConstructBinaryTree(left_pre,left_vin);
                node->right = reConstructBinaryTree(right_pre,right_vin);
            }

        }
        return node;



    }
};
```
### 从尾到头打印链表
输入一个链表，从尾到头打印链表每个节点的值。
/**
*  struct ListNode {
*        int val;
*        struct ListNode *next;
*        ListNode(int x) :
*              val(x), next(NULL) {
*        }
*  };
*/
class Solution {
public:
    vector<int> printListFromTailToHead(ListNode* head) {
        ListNode* current = head;
        vector<int> v;
        while(current != nullptr){
            v.insert(v.begin(),current->val);
            current = current->next;
        }
        return v;
    }
};
### 替换空格
请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。
```c
class Solution {
public:
    void replaceSpace(char *str,int length) {
        string newString;
        for(int i=0;i<length;i++){
            if(str[i] != ' '){
                newString.push_back(str[i]);
            }
            if(str[i] == ' '){
                newString +="%20";
            }
        }
    strcpy(str,newString.c_str());
    }
};

```

### 二维数组中的查找
在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
```c
class Solution {
public:
    bool Find(int target, vector<vector<int> > array) {
        int cow = array.size();
        int col = array[0].size();
        int i=0;
        int j=col-1;
        while(i<cow && j>=0){
            if(array[i][j] == target){
                return true;
            }
            if(array[i][j] > target){
                j = j-1;
            }
            if(array[i][j] < target){
                i = i+1;
            }
        }
        return false;
    }
};
```
