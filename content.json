{"meta":{"title":"FEI's Blog","subtitle":"Talents come from diligence, and knowledge is gained by accumulation.","description":null,"author":"FF120","url":"http://ff120.github.io/hexoblog","root":"/hexoblog/"},"pages":[{"title":"","date":"2017-10-08T14:11:09.137Z","updated":"2017-10-08T14:11:09.137Z","comments":true,"path":"404.html","permalink":"http://ff120.github.io/hexoblog/404.html","excerpt":"","text":""},{"title":"Categories","date":"2019-03-23T02:19:21.638Z","updated":"2019-03-22T00:35:28.826Z","comments":true,"path":"categories/index.html","permalink":"http://ff120.github.io/hexoblog/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2019-03-23T02:19:21.628Z","updated":"2019-03-22T00:35:28.819Z","comments":true,"path":"about/index.html","permalink":"http://ff120.github.io/hexoblog/about/index.html","excerpt":"","text":""},{"title":"欢迎大家在这里留言","date":"2017-05-06T10:17:53.000Z","updated":"2017-10-08T14:11:16.793Z","comments":true,"path":"message/index.html","permalink":"http://ff120.github.io/hexoblog/message/index.html","excerpt":"","text":""},{"title":"Tags","date":"2019-03-23T02:19:21.648Z","updated":"2019-03-22T00:35:28.838Z","comments":true,"path":"tags/index.html","permalink":"http://ff120.github.io/hexoblog/tags/index.html","excerpt":"","text":""},{"title":"һЩ���õĹ��ߺϼ�","date":"2017-05-06T10:17:53.000Z","updated":"2017-10-08T14:11:16.795Z","comments":true,"path":"message/tools.html","permalink":"http://ff120.github.io/hexoblog/message/tools.html","excerpt":"","text":""},{"title":"常用的工具合集","date":"2017-05-08T11:51:08.000Z","updated":"2017-10-08T14:11:16.802Z","comments":true,"path":"tools/index.html","permalink":"http://ff120.github.io/hexoblog/tools/index.html","excerpt":"","text":"Latex 手写识别系统 传送门 Katex支持的所有符号 传送门 ## 计算器 传送门 画图工具 visio illustrator 制作精美的矢量图: http://www.adobe.com/cn/products/illustrator.html inkscape 开源的自由软件，全平台支持： https://inkscape.org/zh/ coreldraw 最好的产品变得更好了！使用全新的 LiveSketch™ 绘图工具、增强触控笔和触摸功能等更多功能，使设计重新充满乐趣：http://www.coreldraw.com/cn/"}],"posts":[{"title":"代码记忆法","slug":"心理学/记忆魔法/代码记忆法","date":"2019-04-03T14:51:32.000Z","updated":"2019-04-02T23:22:52.402Z","comments":true,"path":"2019/04/03/心理学/记忆魔法/代码记忆法/","link":"","permalink":"http://ff120.github.io/hexoblog/2019/04/03/心理学/记忆魔法/代码记忆法/","excerpt":"","text":"代码记忆法 使用英语单词对数字编码，强化记忆数字和编码之间的关系，就可以把数字转换成对应的英语单词，而英语单词是有意义的，可以转化成画面，运用画面辅助记忆，可以达到快速记忆的目的。这就是代码记忆法的思路。 数字编码方法 来自布拉德·乔伊斯（美）的超级记忆力训练 0 Z, S 1 T,D,tie,领带 2 N, noah, 诺亚方舟 3 M, ma, 妈妈 4 R, rye, 燕麦 5 L, law, 法律 6 ### 7 K,C, cow, 奶牛 8 V, ivy, 常春藤 9 B,P, bee, 蜜蜂 0 到9都有了代表它们的发音字母和具体的实物，接下来为10 到 99 设置对应的代表实物，方法是分解成单个数字，然后组合。 例如： 10 由 1 和 0 组成， 所以代表10的单词应该包含T或者D，且包含Z或者S，找一个满足这个条件的单词，我们使用toes这个单词。 10 toes, 脚趾 11 – 50 数字 单词 含义 自己想象画面 11 tot 小孩 12 tin 罐头 13 tomb 坟墓 14 tire 轮胎 15 towel 毛巾 16 dish 盘子 17 tack 大头针 18 dove 鸽子 19 tub 浴盆 20 nose 鼻子 21 net 网 22 nun 修女 23 name 名字 24 nero 罗马暴君尼禄 25 nail 指甲 26 notch 东非大裂谷 27 neck 脖子 28 knife 刀子 29 knob 球形把手 30 mice 老鼠 31 mat 席子 32 moon 月亮 33 mummy 木乃伊 34 mower 割草机 35 mule 骡子 36 match 火柴 37 mug 大杯子 38 movie 电影 39 mob 拖把 40 rose 玫瑰 41 rod 杆子 42 rain 雨水 43 ram 公羊 44 rower 划船的人 45 roll 面包卷 46 roach 螳螂 47 rock 岩石 48 roof 房顶 49 rope 绳子 50 lace 鞋带","categories":[{"name":"心理学","slug":"心理学","permalink":"http://ff120.github.io/hexoblog/categories/心理学/"},{"name":"记忆魔法","slug":"心理学/记忆魔法","permalink":"http://ff120.github.io/hexoblog/categories/心理学/记忆魔法/"}],"tags":[{"name":"记忆","slug":"记忆","permalink":"http://ff120.github.io/hexoblog/tags/记忆/"}]},{"title":"AutoHotKey非常有用的脚本","slug":"技术/工具/AutoHotKey/AutoHotKey非常有用的脚本","date":"2018-12-02T09:42:38.000Z","updated":"2019-03-29T00:28:33.890Z","comments":true,"path":"2018/12/02/技术/工具/AutoHotKey/AutoHotKey非常有用的脚本/","link":"","permalink":"http://ff120.github.io/hexoblog/2018/12/02/技术/工具/AutoHotKey/AutoHotKey非常有用的脚本/","excerpt":"","text":"键盘和鼠标按键修改工具AutoHotKey可以实现修改任意键盘按键和鼠标按键的功能，可以实现快捷短语的输入。 我的AutoHotKey脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408SetCapsLockState, AlwaysOff;***********************************************************;|+=======================================================+|;|| 使用键盘模拟鼠标 ||;|+-------------------------+-----------------------------+|;|| CapsLock+d | 开启 ||;|| CapsLock+f | 关闭 ||;|+-------------------------+-----------------------------+|;|| d | 左键 ||;|| f | 右键 ||;|| ikjl | 鼠标移动 ||;|+=======================================================+|#SingleInstancecount = 0JoyMultiplier = 0.20JoyThreshold = 3JoyThresholdUpper := 50 + JoyThresholdrJoyThresholdLower := 50 - JoyThresholdYAxisMultiplier = -1SetTimer, WatchKeyboard, 20Hotkey, d, ButtonRightHotkey, f, ButtonLeftHotkey, i,emptyHotkey, k,emptyHotkey, j,emptyHotkey, l,emptyHotkey, u,emptyHotkey, m,emptyReturnCapsLock &amp; d:: SetTimer, WatchKeyboard,On Hotkey, d, on Hotkey, f, on Hotkey, i, on Hotkey, k, on Hotkey, j, on Hotkey, l, on Hotkey, u, on Hotkey, m, onReturnCapsLock &amp; f:: SetTimer, WatchKeyboard, Off Hotkey, d, Off Hotkey, f, Off Hotkey, i, Off Hotkey, k, Off Hotkey, j, Off Hotkey, l, Off Hotkey, u, off Hotkey, m, offReturnempty:ReturnWatchKeyboard:MouseNeedsToBeMoved := false ; Set default.JoyMultiplier+=0.01SetFormat, float, 03i:=GetKeyState(&quot;i&quot;,&quot;p&quot;)k:=GetKeyState(&quot;k&quot;,&quot;p&quot;)j:=GetKeyState(&quot;j&quot;,&quot;p&quot;)l:=GetKeyState(&quot;l&quot;,&quot;p&quot;)u:=GetKeyState(&quot;u&quot;,&quot;p&quot;)m:=GetKeyState(&quot;m&quot;,&quot;p&quot;)if(u)&#123; send,&#123;WheelUp&#125;&#125;if(m)&#123; send,&#123;WheelDown&#125;&#125;if(l)&#123; MouseNeedsToBeMoved := true DeltaX := 10&#125;else if(j)&#123; MouseNeedsToBeMoved := true BeMoved := true DeltaX := -10&#125;else DeltaX = 0if (i)&#123; MouseNeedsToBeMoved := true DeltaY := 10&#125;else if (k)&#123; MouseNeedsToBeMoved := true DeltaY := -10&#125;else DeltaY = 0if MouseNeedsToBeMoved&#123; SetMouseDelay, -1 ; Makes movement smoother. MouseMove, DeltaX * JoyMultiplier, DeltaY * JoyMultiplier * YAxisMultiplier, 0, R&#125;Elsecount++If(count&gt;20)&#123;JoyMultiplier = 0.30count=0&#125;returnButtonLeft:SetMouseDelay, -1 ; Makes movement smoother.MouseClick, left,,, 1, 0, D ; Hold down the left mouse button.SetTimer, WaitForLeftButtonUp, 10returnButtonRight:SetMouseDelay, -1 ; Makes movement smoother.MouseClick, right,,, 1, 0, D ; Hold down the right mouse button.SetTimer, WaitForRightButtonUp, 10returnWaitForLeftButtonUp:if GetKeyState(&quot;f&quot;) return ; The button is still, down, so keep waiting.; Otherwise, the button has been released.SetTimer, WaitForLeftButtonUp, offSetMouseDelay, -1 ; Makes movement smoother.MouseClick, left,,, 1, 0, U ; Release the mouse button.returnWaitForRightButtonUp:if GetKeyState(&quot;d&quot;) return ; The button is still, down, so keep waiting.; Otherwise, the button has been released.SetTimer, WaitForRightButtonUp, offMouseClick, right,,, 1, 0, U ; Release the mouse button.return;************************************************************;|+=======================================================+|;|| 使用键盘模拟鼠标 ||;|+-------------------------+-----------------------------+|;|| a+f | 左键 ||;|| a+d | 右键 ||;|| a+u | 向上滚轮 ||;|| a+m | 向下滚轮 ||;|| a+i,j,k,l | 鼠标移动 ||;|+=======================================================+|;************************************************************$a::Send, areturna &amp; i::SetMouseDelay, -1 MouseMove, 0, -15, 0, R returna &amp; k::SetMouseDelay, -1 MouseMove, 0, 15, 0, Rreturna &amp; j::SetMouseDelay, -1 MouseMove, -15, 0, 0, Rreturna &amp; l::SetMouseDelay, -1MouseMove 15 ,0,0,Rreturna &amp; u::Send, &#123;WheelUp&#125;returna &amp; m::Send, &#123;WheelDown&#125;returna &amp; f::SetMouseDelay, -1 MouseClick, left,,, 1, 0, D ; Hold down the left mouse button.SetTimer, WaitForLeftButtonUp, 10returna &amp; d::SetMouseDelay, -1 MouseClick, right,,, 1, 0, D ; Hold down the right mouse button.SetTimer, WaitForRightButtonUp, 10return;************************************************************;|+=======================================================+|;|| CapsLock改成Enter键 ||;|+-------------------------+-----------------------------+|;|| CaspLock | Enter ||;|| alt + CapsLock | CaspLock ||;|+=======================================================+|;************************************************************$CapsLock::Enter LAlt &amp; CapsLock::GetKeyState, CapsLockState, CapsLock, Tif CapsLockState = D SetCapsLockState, AlwaysOffelse SetCapsLockState, AlwaysOnKeyWait, CapsLock returnRAlt &amp; CapsLock::GetKeyState, CapsLockState, CapsLock, Tif CapsLockState = D SetCapsLockState, AlwaysOffelse SetCapsLockState, AlwaysOnKeyWait, CapsLock return;************************************************************;|+=======================================================+|;|| 主键盘增加方向键 ||;|+-------------------------+-----------------------------+|;|| CaspLock + i | Up ||;|| CaspLock + k | Down ||;|| CaspLock + j | Left ||;|| CaspLock + l | Right ||;|| CaspLock + u | Home ||;|| CaspLock + m | End ||;|+=======================================================+|;************************************************************CapsLock &amp; k::if GetKeyState(&quot;LShift&quot;, &quot;P&quot;) Send, +&#123;Down&#125;else if GetKeyState(&quot;LAlt&quot;, &quot;P&quot;) Send,^&#123;Down&#125;else if GetKeyState(&quot;LControl&quot;, &quot;P&quot;) Send,^+&#123;Down&#125;else Send, &#123;Down&#125;ReturnCapsLock &amp; i::if GetKeyState(&quot;LShift&quot;, &quot;P&quot;) Send, +&#123;Up&#125;else if GetKeyState(&quot;LAlt&quot;, &quot;P&quot;) Send,^&#123;Up&#125;else if GetKeyState(&quot;LControl&quot;, &quot;P&quot;) Send,^+&#123;Up&#125;else Send, &#123;Up&#125;Return; move leftCapsLock &amp; j::if GetKeyState(&quot;LShift&quot;, &quot;P&quot;) Send, +&#123;Left&#125;else if GetKeyState(&quot;LAlt&quot;, &quot;P&quot;) Send,^&#123;left&#125;else if GetKeyState(&quot;LControl&quot;, &quot;P&quot;) Send,^+&#123;left&#125;else Send, &#123;Left&#125;ReturnCapsLock &amp; l::if GetKeyState(&quot;LShift&quot;, &quot;P&quot;) Send, +&#123;Right&#125;else if GetKeyState(&quot;LAlt&quot;, &quot;P&quot;) Send,^&#123;Right&#125;else if GetKeyState(&quot;LControl&quot;, &quot;P&quot;) Send,^+&#123;Right&#125;else Send, &#123;Right&#125;ReturnCapsLock &amp; u::if GetKeyState(&quot;LShift&quot;, &quot;P&quot;) Send, +&#123;Home&#125;else if GetKeyState(&quot;LAlt&quot;, &quot;P&quot;) Send, ^&#123;Home&#125;else if GetKeyState(&quot;LControl&quot;, &quot;P&quot;) Send, ^&#123;Home&#125;else Send, &#123;Home&#125;returnCapsLock &amp; m::if GetKeyState(&quot;LShift&quot;, &quot;P&quot;) Send, +&#123;End&#125;else if GetKeyState(&quot;LAlt&quot;, &quot;P&quot;) Send, ^&#123;End&#125;else if GetKeyState(&quot;LControl&quot;, &quot;P&quot;) Send, ^&#123;End&#125;else Send, &#123;End&#125;return;************************************************************;|+=======================================================+|;|| 剪贴板设置成3个 ||;|+-------------------------+-----------------------------+|;|| Ctrl + 1 | 复制到剪贴板1 ||;|| Ctrl + 2 | 复制到剪贴板2 ||;|| Ctrl + 3 | 复制到剪贴板3 ||;|| Alt + l | 粘贴剪贴板1的内容 ||;|| Alt + 2 | 粘贴剪贴板2的内容 ||;|| Alt + 3 | 粘贴剪贴板3的内容 ||;|+=======================================================+|;************************************************************^1:: Send ^ca = %ClipBoard%return^2:: Send ^cb = %ClipBoard%return^3:: Send ^cc = %ClipBoard%return!1:: ClipBoard = %a%Send ^vreturn!2:: ClipBoard = %b%Send ^vreturn!3:: ClipBoard = %c%Send ^vreturn;************************************************************;|+=======================================================+|;|| 主键盘区域增加小键盘 ||;|+-------------------------+-----------------------------+|;|| CapsLock + p | 开关 ||;|| m | 0 ||;|| j, k, l | 1, 2, 3 ||;|| u, i, p | 4, 5, 6 ||;|| 7, 8, 9 | 7, 8, 9 ||;|+=======================================================+|;************************************************************#if CapsLock &amp; p:: ONOFF := !ONOFFReturn#if ONOFF&#123; u::4 i::5 o::6 j::1 k::2 l::3 m::0 n::0&#125;#if;************************************************************;|+=======================================================+|;|| 快捷搜索 ||;|+-------------------------+-----------------------------+|;|| CapsLock + e | 翻译所选词汇 ||;|| CapsLock + s | 搜索所选词汇 ||;|+=======================================================+|;************************************************************CapsLock &amp; e::ffSearchWord = %ClipBoard%run https://fanyi.baidu.com/#en/zh/%ffSearchWord%run https://cn.bing.com/dict/search?q=%ffSearchWord%returnCapsLock &amp; s::Send ^ccontent = %ClipBoard%run https://www.baidu.com/s?wd=%content%run https://cn.bing.com/search?q=%content%returnCapsLock &amp; n::run http://www.baidu.comreturn;************************************************************;|+=======================================================+|;|| 重新加载本脚本 ||;|+-------------------------+-----------------------------+|;|| CapsLock + r | 重载 ||;|+=======================================================+|;************************************************************CapsLock &amp; r::Send ^sreloadreturn","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"工具","slug":"技术/工具","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/"},{"name":"AutoHotKey","slug":"技术/工具/AutoHotKey","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/AutoHotKey/"}],"tags":[{"name":"AutoHotKey","slug":"AutoHotKey","permalink":"http://ff120.github.io/hexoblog/tags/AutoHotKey/"}]},{"title":"Git 手册","slug":"技术/工具/Git/Git查询手册","date":"2018-07-29T09:13:42.000Z","updated":"2019-03-28T13:37:41.721Z","comments":true,"path":"2018/07/29/技术/工具/Git/Git查询手册/","link":"","permalink":"http://ff120.github.io/hexoblog/2018/07/29/技术/工具/Git/Git查询手册/","excerpt":"","text":"Git 的结构 Git 分成三个区域，工作区，暂存区，版本库 工作区：就是和.git文件夹在同一级的工程目录。 暂存区：.git中的index中存储暂存区的目录树 版本库：.git中的其他地方存储版本库的内容，这个里面包含历史提交和即将要推送到远程版本库的内容。 工作区的文件我们可以从文件管理器直观的看到，暂存区和版本库的文件git只是存储的相应的目录树，具体文件的内容在.git\\object对象库中存储，并且使用的是差异化的存储，所以不能之间看到相应的文件，但是可以利用Git提供的工具间接的了解其中的内容。 Git内部结构 查看差异 git diff ： 比较工作区和暂存区的差异 git diff --cached ： 比较暂存区和版本库的差异 git diff HEAD : 比较工作区和版本库的差异 将上面命令中的giff换成difftool, 可以使用自定义的图形工具比较差异文件。 1. 从工作区到暂存区 如果想把工作区所做的改动(添加文件、修改内容、删除文件)，可以使用git add命令。 git add filename : 把工作区文件filename的改动添加到暂存区 git reset -- filename : 把添加到暂存区的文件filename 撤销，工作区的文件filename不变，其实就是撤销刚才的git add filename 命令。 git add . : 把工作区所有改动添加到暂存区 git reset : 撤销git add .操作 git add -i : 用交互的方式选择添加哪些文件到暂存区 2. 从暂存区到工作区 git checkout filename : 把暂存区的文件filename添加到工作区，工作区的该文件会被覆盖，其实相当于git add filename的逆操作。 git reset filename : 用暂存区的文件filename覆盖工作区的文件，相当于git add filename的反操作 git checkout . : 把暂存区的所有文件添加到工作区，相当于git add .的逆操作。 git reset : 撤销git add .操作，即用暂存区的内容覆盖工作区的内容。 git checkout会清除工作区中尚未add到暂存区中的内容，一定不要用错，否则自己做的工作就要白费了。 3. 从暂存区到版本库 如果想把在暂存区的内容提交到版本库，推送到远程版本库，可以使用git commit命令。 git commit : 提交暂存区的内容到版本库，需要写提交说明。 git commit --allow-empty : 允许提交空的内容 git commit --amend : 修补提交，不生成新的提交，而是在上一次提交的基础上修改提交内容。 git reset --soft HEAD^ : 撤销最新的提交，相当于git commit的逆操作。 命令解析：--soft选项指定不改变工作区和暂存区, HEAD指向最新的提交，HEAD^指向上一次提交，合起来该命令实现的功能就是撤销最新的提交，而工作区和暂存区的内容不改变。 4. 从版本库到暂存区 git reset HEAD^ : 工作区不改变，暂存区回退到上一次提交，版本库回退到上一次提交。 5. 工作区直接到版本库 6. 版本库直接到工作区 git reset --hard HEAD^ : 工作区、暂存区都会回退到上一次提交，版本库回退到上一次提交 常用命令解析 git diff git log git log -g -2 HEAD : 查看最近HEAD指向的两次提交 git add git checkout 有两种主要的用法，切换分支 和 检出文件 检出文件： git checkout -- filename : 从暂存区检出filename到工作区，工作区未提交的内容会丢失 git checkout -- '.' :用暂存区覆盖工作区 git reset reset就是重置的意思，该命令的本质是修改HEAD指向的提交ID，可以使用不同的参数指定对暂存区和工作区的影响。 git reset : 其对应的完成形式应该是git reset --mixed HEAD, 含义是用HEAD指向的内容覆盖暂存区内容， 它是git add .的逆操作。 git reset -- filename : 其完整形式是git reset -- filename HEAD, 含义是用HEAD指向的文件filename的内容覆盖暂存区内容，它是git add filename的逆操作。 git reset --mixed : 工作区内容不变，暂存区和版本库重置； git reset --soft : 工作区和暂存区内容都不变，版本库重置； git reset --hard : 工作区，暂存区和版本库都改变。 例如，git reset --soft HEAD^, 撤销最近的提交，暂存区和工作区都不变，要想恢复直接git commit; git reset --mixed HEAD^, 撤销最近的提交和暂存区的内容，要想恢复需要git add ., git commit两条命令； git reset --hard HEAD^ 工作区，暂存区都会被上一次提交覆盖，工作区保持和上一次提交一致，未提交的内容会丢失。","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"工具","slug":"技术/工具","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/"},{"name":"Git","slug":"技术/工具/Git","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://ff120.github.io/hexoblog/tags/Git/"}]},{"title":"正则表达式","slug":"技术/工具/正则表达式/正则表达式","date":"2018-07-29T09:13:42.000Z","updated":"2019-03-28T00:54:58.534Z","comments":true,"path":"2018/07/29/技术/工具/正则表达式/正则表达式/","link":"","permalink":"http://ff120.github.io/hexoblog/2018/07/29/技术/工具/正则表达式/正则表达式/","excerpt":"","text":"正则表达式是使用一个字符串表达一个要匹配的模式。模式的表示通过元字符，正则表达式常用的元字符及含义如下： 元字符 匹配单个字符 含义 . 匹配任意一个字符，除了\\r和\\n \\d 匹配数字0-9，等价于[0-9] \\D 匹配除了0-9之外的字符,等价于[^0-9] \\w 匹配任何一个字母数字或者下划线，等价于[A-Za-z0-9_] \\W 匹配任何一个非字母数字下划线，等价于[^A-Za-z0-9_] \\b 匹配单词边界 \\B 匹配非单词边界 \\s 匹配任意一个空白字符，等价于[\\f\\n\\r\\t\\v] \\S 匹配任意一个非空白字符 ^ 匹配一行的开头 $ 匹配一行的结束 匹配重复次数 含义 ? 匹配0次或者1次，用在一个表达式后面可以表示非贪心的匹配 + 匹配一次或者多次 * 匹配0次或者多次 {n} 匹配n次 {m,} 至少匹配m次 {m,n} 最少匹配m次，最多匹配n次 了解了以上的元字符，便可以构造匹配任意字符任意次的一个模式，但是还不能指定多个字符构成的模式的重复次数，下面介绍分组和捕获的相关内容。 逻辑控制 含义 x|y 逻辑或，匹配x或者匹配y {} 里面跟数字，指定前面的模式的重复次数 [] 里面放置任意字符，都是或的关系，匹配这个集合里面的任意一个 (pattern) 指定分组，分组后面紧跟的描述符描述的是这一组模式重复的次数,这个分组会被捕获，可以使用\\num来引用捕获的这个分组 (?:pattern) 指定这个分组不被捕获 (?=pattern) 非捕获匹配，正向肯定预先查找，匹配后面符合pattern的前面部分，例如Windows(?=95|98|NT|2000),在匹配Windows的时候会查找Windows后面的字符，只匹配那些后面紧跟的是95,98,NT,2000的Windows,而不会匹配到Windows3.1中的Windows (?!pattern) 非捕获匹配，正向非肯定预先查找 (?&lt;=pattern) 非捕获匹配，反向肯定预先查找 (?&lt;!pattern) 非捕获查找，反向非肯定预先查找 常用实例解析","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"工具","slug":"技术/工具","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/"},{"name":"正则表达式","slug":"技术/工具/正则表达式","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/正则表达式/"}],"tags":[]},{"title":"机器学习-第七章-感知机","slug":"技术/机器学习/机器学习-第七章-感知机","date":"2017-11-04T01:06:41.000Z","updated":"2019-03-28T00:54:57.561Z","comments":true,"path":"2017/11/04/技术/机器学习/机器学习-第七章-感知机/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/11/04/技术/机器学习/机器学习-第七章-感知机/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"}],"tags":[]},{"title":"机器学习-第六章-kmeans","slug":"技术/机器学习/机器学习-第六章-kmeans","date":"2017-11-04T01:06:21.000Z","updated":"2019-03-28T00:54:57.654Z","comments":true,"path":"2017/11/04/技术/机器学习/机器学习-第六章-kmeans/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/11/04/技术/机器学习/机器学习-第六章-kmeans/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"}],"tags":[]},{"title":"机器学习-第五章-最近邻","slug":"技术/机器学习/机器学习-第五章-最近邻","date":"2017-11-04T01:05:45.000Z","updated":"2019-03-28T00:54:57.630Z","comments":true,"path":"2017/11/04/技术/机器学习/机器学习-第五章-最近邻/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/11/04/技术/机器学习/机器学习-第五章-最近邻/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"}],"tags":[]},{"title":"机器学习-第四章-支持向量机","slug":"技术/机器学习/机器学习-第四章-支持向量机","date":"2017-11-04T01:05:10.000Z","updated":"2019-03-28T00:54:57.687Z","comments":true,"path":"2017/11/04/技术/机器学习/机器学习-第四章-支持向量机/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/11/04/技术/机器学习/机器学习-第四章-支持向量机/","excerpt":"【支持向量机】【函数间隔】【几何间隔】【KTT】","text":"【支持向量机】【函数间隔】【几何间隔】【KTT】 模型 令 \\(\\theta = (w_1,w_2,...,w_n,b)\\), \\(x = (x_1,x_2,...,x_n,1)\\),则有： \\[ \\theta^T \\cdot x = w_1x_1+x_2x_2+...+w_nx_n+b \\] 支持向量机要得到的分类决策函数是： \\[ h_\\theta(x) = sign(\\theta^T \\cdot x) \\] 其中，\\(sign(x)\\)的定义是： \\[ sign(x) = \\begin{cases} 1, &amp; x&gt;=0 \\\\ 0, &amp; x &lt; 0 \\\\ \\end{cases} \\] 当\\(\\theta^T &gt;= 0\\) 的时候，分类成正类，当\\(\\theta^T &lt; 0\\)的时候，分类成负类。支持向量机就是通过给定的训练数据求解出\\(\\theta\\). 策略 函数间隔 \\(\\theta^T \\cdot x = 0\\) 可以确定一个超平面(n维空间中，n-1维的叫做超平面)，\\(\\theta^T \\cdot x &gt; 0\\) 的时候，我们定义类别的标签是1, \\(\\theta^T \\cdot x &lt; 0\\) 的时候，我们定义类别的标签是-1. 这样，\\(\\theta^T \\cdot x\\)的符号和标签y的符号是一致的。 $ y(\\theta^T x ) &gt; 0 $ 表示分类正确， $y(\\theta^T x)&lt;0 $ 表示分类错误. 而\\(|\\theta^T \\cdot x|\\)表示的是点x到分类超平面的距离，可以认为距离越远，分类的可信度越高。 点\\((x_i,y_i)\\)函数间隔的定义为： \\[ \\hat \\gamma_i = y_i(\\theta^T \\cdot x_i) \\] 训练集合中所有样本的函数间隔定义为所有样本的函数间隔最小的那一个。 几何间隔 \\(\\theta^T \\cdot x = wx+b\\), 其中\\(w = (w_1,w_2,...,w_n)\\). 函数间隔有一个问题，就是成比例的改变\\(w\\)和\\(b\\)的值，函数间隔的大小就会成比例的变化。所以函数间隔并不适合用来求极值点。 改进的方法是限制\\(w\\)的取值，是\\(||w|| = 1\\), 这样函数间隔就变成了几何间隔。 样本\\((x_i,y_i)\\)到分类超平面\\(wx+b=0\\)的几何间隔是： \\[ \\gamma_i = y_i(\\frac w {||w||} \\cdot x_i + \\frac b {||w||}) \\] 训练集的几何间隔取 训练集合中所有的样本点到分类超平面几何间隔的最小值。 优化目标 支持向量机的优化目标就是找到使得 几何间隔最大化的参数取值。这是一个约束优化问题，目标是\\(max(\\gamma)\\), 约束条件是\\(\\gamma_i &gt;= \\gamma\\), 含义是在保证某个点的几何间隔都大于等于\\(\\gamma\\)的情况下，求最大的\\(\\gamma\\). 在约束条件两边都乘以一个\\(||w||\\), 等式的性质不变，现在约束变成 \\(y_i(w \\cdot x_i + b) &gt;= \\hat \\gamma\\), 因为 \\(\\gamma = \\frac {\\hat \\gamma} \\gamma\\), 最优化的目标变为： \\(\\frac {\\hat \\gamma} {||w||}\\), \\(\\hat \\gamma\\)的取值是不影响最后的结果的，前面介绍过了，函数间隔会根据\\(w\\)和\\(b\\)的取值等比例的缩放，所以这里我们令\\(\\hat \\gamma = 1\\), 最优化问题可以写成下面的形式： \\[ min \\quad \\frac 1 2 {||w||^2} \\\\ s.t. \\quad y_i(w \\cdot x_i + b)-1 &gt;= 0, \\quad \\text{i=1,2,...,n} \\] 最大化 \\(\\frac 1 {||w||}\\) 等价于 最小化\\(\\frac 1 2 {||w||^2}\\) 支持向量机就是求解上面的最优化问题，来求得参数\\(\\theta\\)，然后构造分类超平面为未知的数据分类的。 方法 拉格朗日函数 凸优化问题的一般形式 \\[ min \\quad f(x) \\\\ s.t. \\quad c_i(x) &lt;= 0, \\quad i = 1,2,...,k \\\\ h_j(x) = 0, \\quad j = 1,2,...,l \\] 其中，\\(f(x)\\)和\\(c_i(x)\\) 都是 \\(R^n\\)上的连续可微的凸函数，\\(h_j(x)\\) 是 \\(R^n\\)上的仿射函数。 \\(f(x)\\)是仿射函数的含义是满足条件：\\(f(x) = ax+b\\),其中\\(a \\in R^n\\),\\(b \\in R\\),\\(x \\in R^n\\). 拉格朗日函数是在 约束优化问题中 用来把约束条件添加到目标函数中的一种手段，广义的拉格朗日函数的定义是： \\[ L(x,\\alpha,\\beta) = f(x) + \\sum_{i=1}^k \\alpha_i c_i(x) + \\sum_{j=1}^l \\beta_j h_j(x) \\quad \\alpha_i &gt;= 0 \\] 其中，\\(f(x)\\)是原来约束优化问题的目标函数，\\(c_i(x)\\)和\\(h_j(x)\\)是约束条件中的函数. 定义函数： \\[ P(x) = \\mathop{max} \\limits_{\\alpha,\\beta} L(x,\\alpha,\\beta) \\] 其中，\\(P(x)\\)表示在把\\(x\\)看作常数，\\(\\alpha,\\beta\\)看作变量的情况下，求\\(L(x,\\alpha,\\beta)\\)的最大值； 现在来分析函数\\(P(x)\\), 如果\\(x\\)满足原来最优化问题的约束条件，即\\(c_i(x) &lt;= 0\\), \\(h_j(x) = 0\\), 那么 \\(P(x) = \\mathop{max} \\limits_{\\alpha,\\beta} ( f(x) + \\sum_{i=1}^k \\alpha_i c_i(x))\\), 这个时候的最大值的结果就是\\(P(x) = f(x)\\), \\(\\alpha_i = 0\\). 除此之外，\\(\\alpha_i\\)取任何大于0的值最后的结果都会减小。 如果\\(x\\)不满足约束条件，即 \\(c_i(x) &gt; 0\\) 或者 \\(h_j(x) \\neq 0\\), 这个时候总能找到满足的 \\(\\alpha\\) 或 \\(\\beta\\) ,使得 \\(P(x) = +\\infty\\) . 例如，如果\\(c_i(x) &gt; 0\\), 只需要让\\(\\alpha_i\\)足够大，就能保证结果足够大，如果\\(h_j(x) \\neq 0\\), 只需要让\\(\\beta_j\\)足够大就能保证结果趋近 \\(+\\infty\\) . 综上，\\(P(x)\\)是一个满足下述条件的函数： \\[ P(x) = \\begin{cases} f(x) &amp; \\text{x 满足约束条件} \\\\ +\\infty &amp; \\text{x 不满足约束条件} \\end{cases} \\] 那么， \\(min P(x)\\) 表示求\\(P(x)\\)的最小值，其含义就是求在满足约束条件的情况下，\\(f(x)\\)的最小值。所以原来的约束最优化问题，在引入拉格朗日函数之后，可以变成下面的无约束优化问题，它与原来的问题等价： \\[ \\mathop{min} \\limits_x \\quad \\mathop{max} \\limits_{\\alpha,\\beta} ( f(x) + \\sum_{i=1}^k \\alpha_i c_i(x) + \\sum_{j=1}^l \\beta_j h_j(x)) \\quad \\alpha_i &gt;= 0 \\] 对偶问题 如果原始问题是： \\[ p^* = \\mathop{min} \\limits_x \\quad \\mathop{max} \\limits_{\\alpha,\\beta} ( f(x) + \\sum_{i=1}^k \\alpha_i c_i(x) + \\sum_{j=1}^l \\beta_j h_j(x)) \\quad \\alpha_i &gt;= 0 \\] 则它的对偶问题是： \\[ d^* = \\mathop{max} \\limits_{\\alpha,\\beta} \\quad \\mathop{min} \\limits_x ( f(x) + \\sum_{i=1}^k \\alpha_i c_i(x) + \\sum_{j=1}^l \\beta_j h_j(x)) \\quad \\alpha_i &gt;= 0 \\] 原问题是先固定的把\\(x\\)看作常数，求解\\(\\alpha,\\beta\\), 再把\\(\\alpha,\\beta\\)看作常数，求解\\(x\\); 而对偶问题正好反了过来，是先把\\(\\alpha,\\beta\\)看作常数，求解出\\(x\\),再把\\(x\\)看作常数，求解出\\(\\alpha,\\beta\\) 如果\\(p^*\\)表示原始问题的最优解，而\\(d^*\\)表示对偶问题的最优解，则有\\(d^* &lt;= p^*\\). 原问题的解是大于等于对偶问题的最优解的，如果想通过解对偶问题来解原来的问题，需要满足如下的KKT条件，才能保证原问题和对偶问题的解相同： \\[ \\triangledown_x L(x,\\alpha,\\beta) = 0 \\\\ \\triangledown_{\\alpha} L(x,\\alpha,\\beta) = 0 \\\\ \\triangledown_{\\beta} L(x,\\alpha,\\beta) = 0 \\\\ \\alpha_ic_i(x) = 0,i=1,2,...,k \\\\ c_i(x) &lt;=0, i = 1,2,...,k \\\\ \\alpha_i &gt;= 0, i=1,2,...,k \\\\ h_j(x) = 0, j=1,2,...,l \\] 其中， \\(x,\\alpha,\\beta\\),分别代表原始问题和最优问题的解。如果满足上述的约束条件，则原始问题和对偶问题有相同的解。 前三个条件是对\\(x,\\alpha,\\beta\\)的偏导数为0， 后三个条件是原来问题的约束条件，只有中间的条件是新的约束条件 \\(\\alpha_i c_i(x) = 0\\), 这意味着如果\\(\\alpha_i &gt; 0\\), 那么\\(c_i(x) = 0\\)，否则约束条件就无法得到满足。 求解原问题 支持向量机的优化目标是： \\[ min \\quad \\frac 1 2 {||w||^2} \\\\ s.t. \\quad y_i(w \\cdot x_i + b)-1 &gt;= 0, \\quad \\text{i=1,2,...,n} \\] 把约束条件加入优化函数，改写成拉格朗日函数如下： \\[ L(w,\\alpha) = \\frac 1 2 {||w||^2} - ( \\sum_{k=1}^m \\alpha_i (y_i(w \\cdot x_i + b)-1) ) \\] 因为没有等式约束条件，所以这里没有\\(\\beta\\), 还有这里是\\(-\\)号，因为凸优化的标准约束是小于等于的形式，而这里却是大于等于的形式。 所以原来的优化问题可以转化成求解下面的问题： \\[ \\mathop{min} \\limits_w \\quad \\mathop{max} \\limits_{\\alpha} L(w,\\alpha) \\] 它的对偶问题是: \\[ \\mathop{max} \\limits_{\\alpha} \\quad \\mathop{min} \\limits_w L(w,\\alpha) \\] 首先要求解\\(\\mathop{min} \\limits_w L(w,\\alpha)\\), 这个时候\\(w,b\\)是变量，\\(\\alpha\\)看作常量，求解函数 \\(\\frac 1 2 {||w||^2} - ( \\sum_{k=1}^m \\alpha_i (y_i(w \\cdot x_i + b)-1) )\\) 的最小值。 多元函数的极值点必在驻点（偏导数为0的点）和偏导数不存在的点中。 要求极值点，首先对每个变量(\\(w,b\\))求偏导数，令其等于0： \\[ \\triangledown_w L(w,b,\\alpha) = w - \\sum_{i=1}^m \\alpha_i y_i x_i = 0 \\\\ \\triangledown_b L(w,b,\\alpha) = \\sum_{i=1}^m \\alpha_i y_i = 0 \\] 把得到的等式带入原来的式子\\(L(w,b,\\alpha)\\)中化简,去掉\\(w,b\\),得到只有\\(x,y,\\alpha\\)的表达式： \\[ \\mathop{min} \\limits_{w,b} L(w,b,\\alpha) = - \\frac 1 2 \\sum_{i=1}^m \\sum_{j=1}^m \\alpha_i \\alpha_j y_i y_j(x_i \\cdot x_j) + \\sum_{i=1}^m \\alpha_i \\] 上式中，\\(w,b\\)已经确定了，得到了一个极小值，下一步是求极大值\\(\\mathop{max} \\limits_{\\alpha} \\quad \\mathop{min} \\limits_{w,b} L(w,b,\\alpha)\\), 具体的式子带入，转化成求如下的约束优化问题： \\[ \\mathop{max} \\limits_{\\alpha} \\quad - \\frac 1 2 \\sum_{i=1}^m \\sum_{j=1}^m \\alpha_i \\alpha_j y_i y_j(x_i \\cdot x_j) + \\sum_{i=1}^m \\alpha_i \\\\ s.t. \\quad \\sum_{i=1}^m \\alpha_i y_i = 0 \\\\ \\alpha_i &gt;= 0, \\quad i=1,2,...,m \\] 把求解最大化问题转化成求解最小化问题： \\[ \\mathop{min} \\limits_{\\alpha} \\quad \\frac 1 2 \\sum_{i=1}^m \\sum_{j=1}^m \\alpha_i \\alpha_j y_i y_j(x_i \\cdot x_j) - \\sum_{i=1}^m \\alpha_i \\\\ s.t. \\quad \\sum_{i=1}^m \\alpha_i y_i = 0 \\\\ \\alpha_i &gt;= 0, \\quad i=1,2,...,m \\] 设该问题的解是\\(\\alpha^*\\), 则原来问题的解是\\(w^*,b^*\\), KKT条件成立，可以导出三者之间的关系为： \\[ w^* = \\sum_{i=1}^m \\alpha^* y_i x_i \\\\ b^* = y_i - \\sum_{i=1}^m \\alpha^* y_i (x_i \\cdot x_j) \\] 求解支持向量机参数的一般步骤 输入：训练集\\((x_i,y_i)\\), 训练集合有样本m个，特征数量n个。 输出：分类决策函数 最大间隔法 构造并求解约束最优化问题： \\[ \\mathop{min} \\limits_{w,b} \\quad \\frac 1 2 {||w||^2} \\\\ s.t. \\quad y_i(w \\cdot x_i + b) - 1 &gt;= 0, \\quad i=1,2,...,m \\] 求解该问题得到问题的解\\(w^*,b^*\\) 构造分类平面 \\(w^* \\cdot x + b^* = 0\\) 对偶学习算法 构造并求解约束最优化问题： \\[ \\mathop{min} \\limits_{\\alpha} \\quad \\frac 1 2 \\sum_{i=1}^n \\sum_{j=1}^n \\alpha_i \\alpha_j y_i y_j (x_i \\cdot x_j) - \\sum_{i=1}^n \\\\ s.t. \\quad \\sum_{i=1}^m \\alpha_i y_i = 0 \\\\ \\alpha_i &gt;= 0, \\quad i=1,2,...,m \\] 求解上面的最优化问题得到 \\(\\alpha^*\\). 计算 \\(w^*\\) 和 \\(b^*\\) : \\[ w^* = \\sum_{i=1}^n \\alpha^* y_i x_i \\\\ b^* = y_i - \\sum_{i=1}^n \\alpha^*_i y_i (x_i \\cdot x_j) \\] 根据第二步求解的参数构造分类决策函数： \\[ w^* \\cdot x + b^* = 0 \\] 一个具体的例子 有三个训练样本，每个样本有两个特征，\\(x_1 = (3,3), x_2 = (4,3), x_3 = (1,1)\\), 求支持向量机的分类超平面。其中\\(x_1,x_2\\)是正样本，\\(x_3\\)是负样本。 用最大间隔法求解 根据数据构造约束最优化问题： \\[ \\mathop{min} \\limits_{w,b} \\quad \\frac 1 2 (w_1^2+w_2^2) \\\\ s.t. \\quad 3w_1 + 3w_2 + b &gt;= 1 \\\\ 4w_1 + 4w_2 + b &gt;= 1 \\\\ -w_1 - w_2 - b &gt;= 1 \\] 求解此最优化问题得到结果：\\(w_1 = w_2 = \\frac 1 2, b = -2\\), 最后的分类超平面是: \\[ \\frac 1 2 x^{(1)} + \\frac 1 2 x^{(2)} - 2 = 0 \\] 用对偶学习算法求解： 根据数据构造约束最优化问题： \\[ \\mathop{min} \\limits_{\\alpha} \\quad \\frac 1 2 (18\\alpha_1^2 + 25\\alpha_2^2 + 2\\alpha_3^2 + 42 \\alpha_1 \\alpha_2 - 12 \\alpha_1 \\alpha_3 - 14 \\alpha_2 \\alpha_3) - (\\alpha_1 + \\alpha_2 + \\alpha_3) \\\\ s.t. \\quad \\alpha_1 + \\alpha_2 - \\alpha_3 = 0 \\\\ \\alpha_i &gt;= 0, \\quad i=1,2,3 \\] 求解最优化问题得到结果：\\(\\alpha_1 = \\frac 1 4, \\alpha_2 = 0, \\alpha_3 = \\frac 1 4\\). 则可以得到 \\(w_1^* = = w_2^* = \\frac 1 2\\), \\(b^* = -2\\). 最后的分类超平面为： \\[ \\frac 1 2 x^{(1)} + \\frac 1 2 x^{(2)} - 2 = 0 \\] 比较最大间隔算法和对偶学习算法可以看出，对偶学习算法更容易求解，因为其约束条件变得更少，更容易得到不同变量之间的转换关系。","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"}],"tags":[{"name":"ML","slug":"ML","permalink":"http://ff120.github.io/hexoblog/tags/ML/"}]},{"title":"机器学习-第三章-朴素贝叶斯","slug":"技术/机器学习/机器学习-第三章-朴素贝叶斯","date":"2017-11-04T01:04:49.000Z","updated":"2019-03-28T00:54:57.585Z","comments":true,"path":"2017/11/04/技术/机器学习/机器学习-第三章-朴素贝叶斯/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/11/04/技术/机器学习/机器学习-第三章-朴素贝叶斯/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"}],"tags":[{"name":"ML","slug":"ML","permalink":"http://ff120.github.io/hexoblog/tags/ML/"}]},{"title":"机器学习-第二章-决策树","slug":"技术/机器学习/机器学习-第二章-决策树","date":"2017-11-04T01:04:25.000Z","updated":"2019-03-28T00:54:57.607Z","comments":true,"path":"2017/11/04/技术/机器学习/机器学习-第二章-决策树/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/11/04/技术/机器学习/机器学习-第二章-决策树/","excerpt":"【决策树】【ID3】【C4.5】","text":"【决策树】【ID3】【C4.5】 模型 一棵树，每次分支都按照某个属性确定分到哪一个分支，直到所有的数据集都被分到正确的类别上。 策略 主要涉及使用什么指标划分 如何剪枝避免过拟合 方法 ID3 C4.5 CART","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"}],"tags":[{"name":"ML","slug":"ML","permalink":"http://ff120.github.io/hexoblog/tags/ML/"}]},{"title":"机器学习-第一章-逻辑回归","slug":"技术/机器学习/机器学习-第一章-逻辑回归","date":"2017-11-04T01:04:05.000Z","updated":"2019-03-28T00:54:57.537Z","comments":true,"path":"2017/11/04/技术/机器学习/机器学习-第一章-逻辑回归/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/11/04/技术/机器学习/机器学习-第一章-逻辑回归/","excerpt":"【逻辑回归】","text":"【逻辑回归】 模型 令 \\(\\theta = (w_1,w_2,...,w_n,b)\\), \\(x = (x_1,x_2,...,x_n,1)\\),则有： \\[ \\theta^T \\cdot x = w_1x_1+x_2x_2+...+w_nx_n+b \\] 逻辑回归要训练得到的函数模型是： \\[ h_\\theta(x) = f(\\theta^T \\cdot x) \\] 其中f是下面的函数： \\[ f(z) = \\frac 1 {1+e^{-z}} \\] 函数f的图像如下图所示： 1Plot[1.0 / (1 + E^(-x)), &#123;x, -10, 10&#125;] f(z) \\(h_\\theta(x)\\) 的结果是(0,1)，含义是类别为正类别的概率; \\(\\theta\\)的含义是模型的参数. 算法的目标是在已知\\((x_1,x_2,...x_n)\\) 和对应的 \\(y\\) 的若干个样本的情况下，求解出\\((w_1,w_2,...,w_n,b)\\)这些参数，使得损失函数最小。 Wolfram Mathematica 是一个专业的科学计算软件，使用它可以非常方便的绘制出函数的图形。Plot[1.0 / (1 + E^(-x)), {x, -10, 10}]就是绘制出上面的函数图形的命令。 策略 逻辑回归使用的损失函数是： \\[ cost(h_\\theta(x),y) = \\begin{cases} -log(h_\\theta(x)) &amp; \\text{if y = 1} \\\\ -log(1-h_\\theta(x)) &amp; \\text{if y = 0} \\end{cases} \\] 其中，\\(h_\\theta(x)\\)就是模型预测的结果，\\(y\\)是实际的标签，取值是\\(0，1\\). 当\\(y=1\\)时，\\(h_\\theta(x)\\)接近1的时候，损失函数\\(-log(h_\\theta(x))\\)接近0，而当\\(h_\\theta(x)\\)接近0的时候，损失函数是接近正无穷的。其对应的关系如下图所示： 当\\(y = 0\\)时，\\(h_\\theta(x)\\)接近0的时候，损失函数\\(-log(1-h_\\theta(x))\\)接近0，而当\\(h_\\theta(x)\\)接近1的时候，损失函数\\(-log(1-h_\\theta(x))\\)接近正无穷。其对应的关系如下图所示： 分段函数不利于表达，把上面的cost函数写成统一的格式如下： \\[ cost(h_\\theta(x),y) = - ( y \\times log(h_\\theta(x)) + (1-y) \\times log(1-h_\\theta(x)) ) \\] 对于一个有m个样本的训练集，训练集上的损失为： \\[ J(\\theta) = - \\frac 1 m \\sum_{i=1}^{m} (y^{(i)} \\times log(h_\\theta(x^{(i)})) + (1-y^{(i)}) \\times log(1-h_\\theta(x^{(i)}))) \\] 其中，\\(i\\)表示训练集中的第\\(i\\)个样本，\\(x\\)表示特征向量\\((x_1,x_2,...,x_n,x_{n+1})\\), \\(y\\) 表示实际的标签，取值\\(0,1\\)。 算法 找到一种算法，在已经知道\\(x\\)和\\(y\\)的情况下，求解出能够使得\\(J(\\theta)\\)最小的\\(\\theta\\)的值，具体的就是\\((w_1,w_2,...,w_n,b)\\)的值。 梯度下降法 梯度， 函数对每一个参数求偏导数，偏导数组合成向量，向量的方向就是梯度的方向，函数在梯度的方向上升最快，在梯度的反方向下降最快。 使用梯度下降法求解参数的步骤： 初始化参数。 首先给参数一个初始值\\(\\theta = \\theta^0\\), 定义一个步长\\(\\alpha\\),就是每次要在梯度的方向上移动的距离; 定义一个终止条件\\(\\epsilon\\)，确定算法在什么条件下终止。（一般是看参数更新前后两者的差值，小于某一个很小的数字，就可以结束算法） 计算梯度： \\[ \\frac \\partial {\\partial\\theta_j} J(\\theta_1,\\theta_2,...,\\theta_{n+1})) = \\frac 1 m \\sum_{i=1}^m (h_\\theta(x^{(i)}) - y^{(i)})x \\] 其中，\\(j \\in (1,n+1)\\) 表示第j个参数， \\(i \\in (1,m)\\) 表示第m个样本。 这里涉及到函数的求导，先来复习一下函数的链式求导法则： \\[ \\frac {dx} {dy} = \\frac {dx} {dz} \\times \\frac {dz} {dy} \\] 举个例子： sigmoid 函数的导数是： \\[ y = f(z) = \\frac 1 {1 + e^{-z}} \\] 它的导数可以很容易的求出来，还可以把它表示成y的乘积的形式。 \\[ \\frac {dy} {dz} = \\frac {e^{-z}} {1+e^{-z}} = y(1-y) \\] 现在来求损失函数的对每一个参数\\(\\theta_i\\)的导数： \\[ \\frac {\\partial cos(h_\\theta,y)} {\\partial \\theta} = (h_\\theta(x) - y) \\cdot x \\] 假设一共有m个训练样本,\\(i \\in (1,m)\\), 一共有n+1个参数，\\(j \\in (1,n+1)\\), 则每个参数的导数如下： \\[ \\frac {\\partial cos(h_\\theta(x),y)} {\\theta_j} = \\frac 1 m \\sum_{i=1}^m (h_\\theta(x^{(i)}) - y^{(i)})) x_j^{(i)} \\] 根据上面的公式，初始化\\(\\theta^0\\)之后，可以利用整个训练集的数据\\((x^{(i)},y^{(i)}),i \\in (1,m)\\), 计算出一个梯度向量\\((\\Delta \\theta_1,\\Delta \\theta_2,...,\\Delta \\theta_{n+1})\\). 更新参数 \\[ \\theta^{i+1} = \\theta^i + \\alpha \\Delta \\theta^i \\] 其中，\\(\\theta^i\\)表示第\\(i\\)次迭代的时候的参数取值，\\(\\Delta \\theta^i\\)表示第二步计算出来的梯度，\\(\\alpha\\)表示 学习率，是控制梯度下降的每步大小的一个超参数，需要自己设置。 比较更新前后的参数的变化 \\[ \\epsilon = \\sum_{i=1}^{n+1} ( \\theta^{i+1} - \\theta^{i} ) \\] 如果\\(\\epsilon\\)的值小于预先确定的结束条件，算法结束，最后的\\(\\theta\\)就是要求解的参数，如果\\(\\epsilon\\)大于结束条件，则转到第三步继续迭代，直到满足结束条件为止。 梯度下降的几种策略： 上面的例子中，每一次参数的更新，我们是使用训练集中的所有样本计算的梯度，这样做每次计算出来的梯度比较准确，但是当训练集合非常大的时候，每次的计算开销就很大。 \\[ \\frac {\\partial cos(h_\\theta(x),y)} {\\theta_j} = \\frac 1 m \\sum_{i=1}^m (h_\\theta(x^{(i)}) - y^{(i)})) x_j^{(i)} \\] 可以看出，求解的方法是每个样本计算出一个梯度，然后求和取平均值作为最后的梯度。 随机梯度下降法 随机梯度下降法就是把上面的式子中的求和符号去掉，每次只使用一个样本计算梯度，计算出来就更新一次参数，然后再在更新之后的参数上，利用下一个样本计算梯度，这样每次更新的速度都很快，但是只是利用一个样本计算出来的梯度可能根本就不是函数上升最快的方向，所以收敛的速度不一定快。 批量梯度下降法 这种方法就综合上面两种方法的利弊提出的，每次使用若干个（一般是10个）样本计算梯度，计算完就更新参数，然后在更新的参数的基础上利用另外的10个样本计算下一个梯度方向，直到算法结束。 梯度下降法算法调优 通过梯度下降法的求解过程，我们知道要设置三个重要的参数，一个是\\(\\theta^0\\), 初始参数的值；一个是\\(\\alpha\\),学习率；一个是算法停止条件，\\(\\epsilon\\). 如果要优化的函数是凸函数（只有一个极值点），\\(\\theta^0\\) 的值不会影响最终的结果，但是会影响算法结束的速度；如果优化的函数有多个极值点，\\(\\theta^0\\) 的初始值会影响最后的结果。这个时候，一个解决的办法是随机选择多次初始点，分别计算出极值点，选择极值点最小的那个初始点作为算法的初始点。 理论上如果选择足够多的初始点(并且是随机选择)，一定可以找到真正的极值点。 \\(\\alpha\\) 的选择也十分重要，如果过小，算法迭代次数过多，会结束的非常慢；如果过大，很可能会越过极值点，找不到正确的结果。 \\(\\epsilon\\) 的选择影响算法的终止条件，如果过大，可能还没有达到极值点就结束了，如果过小，可能导致算法运行时间过长。 除此之外，使用梯度下降法时候，特征一般要归一化处理，这是因为，如果不同的维度取值范围差异很大的话，算法的迭代效率就很差，归一化的方法是计算数据的均值和方差，然后每个特征减去均值之后除以标准差 使用随机梯度下降的时候，如果数据集不是线性可分的(存在噪声的情况)，可能会造成梯度来回波动的情况，可以下面的方式优化： 在每次迭代时，调整更新步长\\(\\alpha\\)的值。随着迭代的进行，\\(\\alpha\\)越来越小，这会缓解系数的高频波动（也就是每次迭代系数改变得太大，跳的跨度太大）。当然了，为了避免\\(\\alpha\\)随着迭代不断减小到接近于0（这时候，系数几乎没有调整，那么迭代也没有意义了），我们约束\\(\\alpha\\)一定大于一个稍微大点的常数项. 每次迭代，改变样本的优化顺序。也就是随机选择样本来更新回归系数。这样做可以减少周期性的波动，因为样本顺序的改变，使得每次迭代不再形成周期性。 牛顿法 拟牛顿法 对模型的理解 理解一个模型的含义有时候会很有帮助，但不是所有的模型都有确切的含义，幸运的是，逻辑回归模型有一些很好的解释便于理解实际含义。 对数几率 在逻辑回归模型中，\\(\\theta^T \\cdot x\\)的值是有含义的。假设一件事发生的概率是\\(P\\),不发生的概率是\\(1-P\\),定义一件事发生的几率 为发生的概率和不发生的概率的比值：\\(p / (1-p)\\). 定义一件事发生的对数几率是：\\(log(p / (1-p))\\). 逻辑回归的输出\\(h_\\theta(x)\\)可以看作分类为1的概率： \\[ P(Y=1|X) = h_\\theta(x) = \\frac 1 {1 + e^{-\\theta^T \\cdot x}} \\] 记A表示分类结果是1这一时间，则A的对数几率是： \\[ logit(A) = log(\\frac {h_\\theta(x)} {1-h_\\theta(x)}) = \\theta^T = w_1 x_1+ x_2 x_2 + ... + w_n x_n + b \\] \\(\\theta^T \\cdot x\\) 的含义其实是事件A发生的对数几率，取对数并不影响函数原来的极值点，可以认为是原来的含义。所以可以认为\\(\\theta^T \\cdot x\\) 度量了事件A发生的几率。 而原来的\\(h_\\theta(x)\\) 表示的事件A发生的概率。 最大似然 最大似然的思想是： 选择使得已经发生的事件概率取得最大值的 那些参数。 例如\\(\\theta\\)表示箱子的编号，1号箱子里面有1个红球，9个白球，2号箱子里面有1个白球，9个红球；如果任意选择一个箱子，任意取一个球，发现取得的是红球，那么根据最大似然的原理\\(\\theta = 2\\),因为如果是2号箱子，取得红球的概率是0.9， 如果是1号箱子，取得红球的概率是0.1. 把训练集中的出现的样本作为一次实验，那么出现这种实验结果的概率是： \\[ P(Y=1|X)^{y_i} (1-P(Y=0|X))^{1-y_i} \\] 所有的m个样本出现的概率是每一个样本出现的概率的乘积： \\[ L(\\theta) = \\prod_{i=1}^m (h_\\theta(x))^{y_i} (1-h_\\theta(x))^{1-y_i} \\] 用最大似然的观点，逻辑回归转化成求\\(L(\\theta)\\)最大的时候，\\(\\theta\\)的值。求解该函数的极大值，就是求解负函数的极小值。对\\(\\theta\\)求导之后会发现，最优化函数和上面提到的用损失函数表示的是一样的。所以求解的方法依然是梯度下降法。 编写算法（Python） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# -*- coding: utf-8 -*-\"\"\"Created on Sat Nov 04 20:47:47 2017@author: FF120\"\"\"import numpy as npimport math as mmclass LogisticRegression(): \"\"\" theta : 初始的参数选择(n+1_features),最后一个参数是截距b alpha : 学习率 epsilon : 终止条件 \"\"\" def __init__(self,theta,alpha,epsilon): self.theta = theta self.alpha = alpha self.epsilon = epsilon def sigmoid(z): return 1.0 / (1 + mm.exp(-z)) def update_theta(self,X,y): \"\"\" 使用所有训练数据完成一次参数的更新过程 返回值 epsilon: 本次更新的梯度和上次的差异 \"\"\" m,n = X.shape for j in range(n+1): # 第j个参数的偏移 delta_theta = np.zeros((1,n+1)) for i,line_x,line_y in enumerate(zip(X,y)): line_x = np.array(list(line_x) + [1]) # 添加x_n+1 theta = np.array(self.theta) delta_theta[i] += self.sigmoid(np.dot(theta.T,line_x) - line_y) * (line_x[j]) delta_theta = delta_theta*(1.0 / m) epsilon = np.sum(np.absolute(self.alpha *delta_theta)) self.theta = self.theta + self.alpha * delta_theta return epsilon def fix(self,X,y): \"\"\" X : (n_samples,n_featues) 训练集合 y : (n_samples,) 训练集对应的标签 \"\"\" while True: epsilon = self.update_theta(X,y) if epsilon &lt; self.epsilon: break return def predict(self,X): \"\"\" X : (n_samples.n_features) 训练集合 \"\"\" if X.shape[0] == 1: y = self.sigmoid( np.dot(self.theta.T,X) ) if y &gt;= 0.5: return 1 if y &lt; 0.5: return 0","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"}],"tags":[{"name":"ML","slug":"ML","permalink":"http://ff120.github.io/hexoblog/tags/ML/"}]},{"title":"机器学习-绪论-基本概念","slug":"技术/机器学习/机器学习-绪论-基本概念","date":"2017-11-04T01:03:50.000Z","updated":"2019-03-28T00:54:57.740Z","comments":true,"path":"2017/11/04/技术/机器学习/机器学习-绪论-基本概念/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/11/04/技术/机器学习/机器学习-绪论-基本概念/","excerpt":"","text":"统计学习方法的三要素 方法 = 模型 + 策略 + 算法 模型 是方法依据的数学原理 策略 是使用哪种损失函数或者代价函数 算法 是如何如何求解问题 一个模型可以有多种策略(例如使用不同的损失函数度量损失的程度)， 一种策略可以有多种不同的方法(例如可以用梯度下降法，最小二乘法求解)。 常用的模型 常用的损失函数 0-1 损失函数 \\[ L(Y,f(X)) = \\begin{cases} 1, &amp; { Y \\neq f(X)} \\\\ 0, &amp; { Y = f(X) } \\end{cases} \\] Y表示实际的值，f(X)表示通过模型预测出来的值，0-1损失就是当预测正确的时候损失是0，预测错误的时候损失是1. 绝对值损失函数 \\[ L(Y,f(X) = |Y - f(X)| \\] 平方损失函数 \\[ L(Y,f(X)) = (Y - f(X))^2 \\] 对数损失函数 \\[ L(Y,P(Y|X)) = -logP(Y|X) \\] 常用的算法","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"}],"tags":[{"name":"ML","slug":"ML","permalink":"http://ff120.github.io/hexoblog/tags/ML/"}]},{"title":"SQL","slug":"技术/数据库/SQL","date":"2017-11-02T06:15:52.000Z","updated":"2019-03-28T00:54:55.839Z","comments":true,"path":"2017/11/02/技术/数据库/SQL/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/11/02/技术/数据库/SQL/","excerpt":"基于MySQL的语法说明数据库查询的一些操作。 在test数据库中创建一个user表，执行一些查询操作。 123456789106 Li Xiao 10 2017-11-017 Li Xiao 20 2017-11-028 Li Xiao 10 2017-11-039 Zhao Hi 20 2016-10-1110 Zhao Hi 20 2016-10-1211 Zhao Hi 20 2016-10-1312 Kao Ha 10 2016-03-0113 Kao Ha 20 2016-03-0214 Cao Pi 50 2016-09-1115 Cao Pi 10 2016-09-12","text":"基于MySQL的语法说明数据库查询的一些操作。 在test数据库中创建一个user表，执行一些查询操作。 123456789106 Li Xiao 10 2017-11-017 Li Xiao 20 2017-11-028 Li Xiao 10 2017-11-039 Zhao Hi 20 2016-10-1110 Zhao Hi 20 2016-10-1211 Zhao Hi 20 2016-10-1312 Kao Ha 10 2016-03-0113 Kao Ha 20 2016-03-0214 Cao Pi 50 2016-09-1115 Cao Pi 10 2016-09-12 切换数据库 1use test; 显示数据库中的表 1show tables; 如果已经存在user表，删除它 1drop table user; 创建表 123456create table user( id int(11) auto_increment primary key, name varchar(200) not null, price numeric(20,2) default 0.0, update_time date); 创建表的时候基本语法是： 列名 类型 [约束]， 约束是可选的，可用的约束有： unique 唯一值 not null 不能为空 default 默认值 添加默认值 check 满足某一个条件 primary key 指定为主键 foreign key 指定外键 只约束某一列的时候，可以直接写在某个列上，如果涉及多个列，要写在最后。 1234567create table user( id int(11) primary key, name varchar(200) not null, price numeric(20,2) default 0.0, update_time date, check (id &gt; 0 and price &gt; 0),); 插入值 1insert into user (name, price , update_time) values ('Li Xiao',10.0,'2017-11-01'); 指定自动增长的列和没有设置非空约束的列可以没有对应的值，会自动添加对应的数据。指定非空的列在插入的时候必须有值。 更新值 1update user set update_time = curdate() where name = 'Li Xiao'; 删除值 1delete from user where name = 'Li Xiao'; 完整的创建数据库和插入需要的数据的语句： 12345678910111213141516create table user( id int(11) primary key auto_increment, name varchar(100) not null, price numeric default 0.0, date date );insert into user (name,price,date) values ('Li Xiao',10.2,curdate());insert into user (name,price,date) values ('Li Xiao',80.0,curdate());insert into user (name,price,date) values ('Li Xiao',10.0,curdate());insert into user (name,price,date) values ('Zhao Hi',20.0,'2016-10-10');insert into user (name,price,date) values ('Zhao Hi',20.0,'2016-6-10');insert into user (name,price,date) values ('Zhao Hi',20.0,'2016-3-6');insert into user (name,price,date) values ('Kao Ha',10.0,'2016-3-5');insert into user (name,price,date) values ('Kao Ha',20.0,'2016-3-7');insert into user (name,price,date) values ('Cao Pi',50.0,'2016-9-10');insert into user (name,price,date) values ('Cao Pi',10.0,'2016-2-10'); 查询 每个人的总额 1select name, sum(price) as total from user group by name; 每个人的记录数量 1select name, count(*) as nums from user group by name; 每个人的平均值 1select name, sum(price) / count(*) as avg from user group by name; 总的金额 1select sum(price) from user; 每个人每次得到的钱占总共金额的百分比 1select name, price / (select sum(price) from user) as percent from user; 每个人得到的钱的和占总金额的百分比： 1select name, sum(price) / (select sum(price) from user) as percent from user group by name; 输出记录数量大于2且总金额大于90的人的姓名 1select name from user group by name having count(*) &gt; 2 and sum(price) &gt; 90; 输出2016年每个人得到的金额 占 2016 年总金额的百分比 1select name, sum(price) / (select sum(price) from user where extract(year from date) = 2016) as percent from user where extract(year from date) = 2016 group by name; 输出每一年 每个人得到的总金额 占当年总金额的百分比 12345678910111. 获得每个人在一年总的收入金额(select name, sum(price) as price ,extract(year from date) as year from user group by name)；2. 获得每一年总的金额select extract(year from date) as year , sum(price) as sum from user group by extract(year from date);3. 两个表连接select a.name, a.price, b.sum, a.year from ((select name, sum(price) as price ,extract(year from date) as year from user group by name)) as a, (select extract(year from date) as year , sum(price) as sum from user group by extract(year from date)) as b where a.year = b.year;4. 查询连接之后的表得到结果select name, price / sum as percent from (select a.name, a.price, b.sum, a.year from ((select name, sum(price) as price ,extract(year from date) as year from user group by name)) as a, (select extract(year from date) as year , sum(price) as sum from user group by extract(year from date)) as b where a.year = b.year) as tmp","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据库","slug":"技术/数据库","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据库/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://ff120.github.io/hexoblog/tags/SQL/"}]},{"title":"KNN with C++","slug":"技术/机器学习/KNN-with-C","date":"2017-10-15T14:27:57.000Z","updated":"2019-03-28T00:54:57.473Z","comments":true,"path":"2017/10/15/技术/机器学习/KNN-with-C/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/10/15/技术/机器学习/KNN-with-C/","excerpt":"","text":"KNN 算法步骤： 存储训练集的特征和标签，确定K 预测一个未知的样本的时候，计算该样本到每一个训练集中的样本的距离，取前K个距离的最小值 在前K个最小值中选择标签出现次数最大的那个，作为预测结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class KNN&#123;public: int k = 3; int feature_num = 0; vector&lt;vector&lt;double&gt;&gt; trainSet; vector&lt;int&gt; trainLabel; // 特征向量之间的距离，修改这里使用不同的距离度量 double distance(vector&lt;double&gt; &amp;a, vector&lt;double&gt; &amp;b)&#123; // 返回两个点的距离 if(a.size() != b.size()) return -1; double sum = 0.0; for(int i=0;i&lt;a.size();i++)&#123; sum += (a[i] - b[i]) * (a[i] - b[i]); &#125; double dis = sqrt(sum); return dis; &#125; KNN() : k(3) &#123;&#125; // 创建类的时候保存训练集的特征和标签数据 KNN(vector&lt;vector&lt;double&gt;&gt; features,vector&lt;int&gt; labels)&#123; int samples = features.size(); if(samples != labels.size())&#123; throw new exception; &#125; this-&gt;trainSet = features; this-&gt;trainLabel = labels; if(!features.empty()) feature_num = features[0].size(); &#125; // 预测一个测试样例的标签 int predict(vector&lt;double&gt; test)&#123; if(test.size() != this-&gt;feature_num) throw new exception(); // 求test到训练集合中所有点的距离，找出距离最小的K个值 priority_queue&lt;pair&lt;double,int&gt;,vector&lt;pair&lt;double,int&gt;&gt;,lessThan&gt; maxHeap; for(int i=0;i&lt;trainSet.size();i++)&#123; double dis = this-&gt;distance(trainSet[i],test); if(maxHeap.size() &lt; this-&gt;k)&#123; maxHeap.push(make_pair(dis,trainLabel[i])); &#125;else&#123; if(dis &lt; maxHeap.top().first)&#123; maxHeap.pop(); &#125; &#125; &#125; // 统计K个点的类别标签，找到出现次数最多的那个标签 map&lt;int,int&gt; cc; // 统计每个类别从出现的次数 kye while(!maxHeap.empty())&#123; if(cc.count(maxHeap.top().second) == 0)&#123; cc[maxHeap.top().second] = 1; &#125;else&#123; cc[maxHeap.top().second]++; &#125; maxHeap.pop(); &#125; int maxV = INT32_MIN; int label = -1; for(auto iter= cc.begin();iter != cc.end(); iter++)&#123; if(iter-&gt;second &gt; maxV)&#123; maxV = iter-&gt;second; label = iter-&gt;first; &#125; &#125; return label; &#125; // 预测一个测试样例的标签 int predict(vector&lt;double&gt; test, int k)&#123; this-&gt;k = k; return this-&gt;predict(test); &#125;&#125;; Kmeans 算法步骤 在数据集中随机选择K个点 计算所有的点到K个中心点的距离，距离哪个中心点近，就标记成哪个中心点所属的列别 计算每个团的新的中心， 计算新的中心和上次的中心的差距 如果差距大，就继续循环，否则退出 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;const double MINVALUE = 0.01;struct feature&#123; vector&lt;double&gt; v; int label; // 属于哪一个聚类&#125;;class Kmeans&#123;private: // 从[start,end] 产生 count 个随机数 vector&lt;int&gt; random(int start,int end,int count)&#123; return &#123;1,3,7&#125;; &#125; double distance(feature &amp;a, feature &amp;b)&#123; return 0; &#125;public: int k = 3; int cycle = 1000; void cluster(vector&lt;feature&gt; dataset)&#123; vector&lt;int&gt; random3 = random(0,dataset.size()-1,3); vector&lt;feature&gt; centers; for(int i=0;i&lt;random3.size();i++)&#123; dataset[i].label = i; centers.push_back(dataset[i]); &#125; while(cycle--) &#123; // 标记所有点的所属聚簇 for (int i = 0; i &lt; dataset.size(); i++) &#123; double minDistance = INT32_MAX; int label = -1; for (int j = 0; j &lt; random3.size(); j++) &#123; double dis = distance(dataset[i], dataset[random3[j]]); if (dis &lt; minDistance) &#123; minDistance = dis; label = j; &#125; &#125; dataset[i].label = label; &#125; // 更新每个聚簇的中心 vector&lt;feature&gt; newCenters(centers); for (int j = 0; j &lt; dataset[0].v.size(); j++) &#123; vector&lt;double&gt; sum(k, 0.0); vector&lt;int&gt; cc(k, 0); for (int i = 0; i &lt; dataset.size(); i++) &#123; for (int p = 0; p &lt; k; p++) &#123; if (dataset[i].label == p) &#123; sum[p] += dataset[i].v[j]; cc[p]++; &#125; &#125; &#125; for (int i = 0; i &lt; k; i++) &#123; sum[i] = sum[i] / cc[i]; newCenters[i].v.push_back(sum[i]); &#125; &#125; // 计算和上次中心的差距，差距在一定范围内就退出,centers, newcenters 之间的差距 double dis = 0.0; for (int i = 0; i &lt; k; i++) &#123; dis += distance(newCenters[i], centers[i]); &#125; if (dis &lt; MINVALUE) &#123; return; &#125; &#125; &#125; void cluster(vector&lt;feature&gt; dataset,int k)&#123; this-&gt;k = k; this-&gt;cluster(dataset); &#125;&#125;;","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"}],"tags":[{"name":"KNN","slug":"KNN","permalink":"http://ff120.github.io/hexoblog/tags/KNN/"}]},{"title":"大数据基础框架","slug":"技术/大数据/大数据基础框架","date":"2017-10-06T12:21:59.000Z","updated":"2019-03-28T00:54:55.378Z","comments":true,"path":"2017/10/06/技术/大数据/大数据基础框架/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/10/06/技术/大数据/大数据基础框架/","excerpt":"大数据系统最初由google公布的一篇论文引起，后来发展出hadoop和一系列工具，后来又有spark，本文介绍在大数据处理领域一些常用工具的基本原理。","text":"大数据系统最初由google公布的一篇论文引起，后来发展出hadoop和一系列工具，后来又有spark，本文介绍在大数据处理领域一些常用工具的基本原理。 HDFS hadoop distributed file system (HDFS) 是脱胎于google file system的一个分布式文件系统,据说，其性能并没有达到GFS的水平，只是根据谷歌论文的原理的一个开源实现版本。 HDFS的特定有以下几点： 同时保存多个副本(默认三个)，提供容错机制，副本丢失能够自动恢复。 运行在不可靠机器上(廉价机器上) 适合大数据的处理，HDFS默认将文件分成64M大小的block, 将block按照键值对的方式存储在HDFS上。将映射关系保存在内存中。 HDFS的构成 HDFS是主从结构(master/slave结构)，主要由NameNode和DataNode组成。NameNode 是Master节点，负责整个系统的结构信息和调度控制，DataNode是slave节点，负责存储数据。除此之外，一般还有一个SecondaryNameNode节点，是NameNode节点的备份，负责承担一部分NameNode的工作，定时备份NameNode的数据，当NameNode出现故障的时候，可以从SecondaryNameNode恢复数据。 NameNode DataNode 写文件操作 HDFS写文件示意图 如上图，该图表示一个win7系统的电脑要把一个100M的文件写入一个HDFS文件系统。该HDFS文件系统运行在一个Hadoop集群之上，集群拥有一个NameNode(NN)节点，8个DataNode(DN)节点，有三个机架(rack1,rack2,rack3), 全部在一个机房内。 client把文件分割程64M大小(HDFS文件系统的默认大小)，生成两个文件块，一个64M， 一个36M。 client向NameNode发送写文件的请求。 NameNode收到请求之后，查询自己数据中记录的整个HDFS文件系统的信息，确定这些数据写入哪些DataNode节点中，并且记录下该信息，返回该信息给请求的主机。 假设分配的情况如下： block1: host2,host1,host3 block2: host7,host8,host4 分配DataNode节点的规则为： 如果client为DataNode节点，那么副本1存储在与client相同的节点上，副本2存储在不同机架的节点上，副本三存储在同副本2相同机架上的不同节点； 如果client不是DataNode节点，则副本1随机选择一个节点，副本2选择不同的机架，副本3同副本2的机架的不同节点。 client根据收到的写入信息,把block1写入第一个主机host2, 整个写入过程是流式写入的，数据被分割策划那个64K的小数据包写入，每次写完64K，host2将自己刚刚得到的64K数据写入host1, host1得到64K之后写入host3, 实际上客户端只需要向host2写入一次数据，数据就可以有三个备份。当第一个block写完之后，host2,host1,host3向NameNode, host2向client发送信息说明数据已经写完。 client收到信息之后发送第二个block，过程和第一个block一样。 第二个block写完之后，数据彻底写完，写文件的过程就结束了。 通过写文件的过程和不同副本的分配策略可以看出，挂掉一个节点设置整个机架都是没有关系的，总能从其他的地方找回这些丢失的数据。 读文件操作 HDFS读取文件示意图 如图，win7客户端要从HDFS文件系统上读取一个100M大小的的文件，该文件在HDFS中有两个数据块组成:block1,block2. client 向NameNode 发送读取文件的请求。 NameNode收到读取文件的请求，查询自己存储的元信息，返回block1和block2的存储位置： block1: host2,host1,host3; block2: host7,host8,host4; 客户端收到NameNode的消息，去机器host2读取block1,去机器host7读取block2,读取完成之后合并成一个完整的文件，整个读文件的过程就结束了。如果client位于DataNode内，则优先读取本机架上的数据。 参考文献：HDFS读写原理 MapReduce MapReduce 是一个计算框架，就是在特定的输入上产生特定的输出。输入和输出都是&lt;key,val&gt;这种键值对的形式。 Mapper就是对每个个体进行操作，不涉及个体之间的相互作用，例如转换格式，分割字符串等，这样Mapper这个阶段做的工作可以在许多机器上并行的执行， Reducer执行一些需要不同条目之间协同才能完成的操作，例如计数，求和，需要遍历所有的条目才能得到结果。Reducer任务会在不同的机器上传递结果，得到最终的结果之后再返回。 MapReduce运行机制 在执行Map计算之前，先要根据文件的大小和HDFS的配置情况进行分片(input split), 假设HDFS默认的block大小是64M，而本次任务的输入有3个文件，一个10M，一个70M，一个128M，则10M的文件会被分成一片，70M的文件会被分成两片，128M的文件也会被分成两片。 分片操作仅仅计算出一个分片的长度和每个分片对应的数据的索引位置，并不改变原来的数据。 执行程序中定义好的Map操作，Map在各个数据节点上独立的执行，相互之间没有影响。 combiner阶段：目的是在本地机器上执行reduce操作，把可以在本地机器上合并的结果先执行了，避免以后需要大量传输数据(机器之间传输数据 的开销往往是分布式系统最大的瓶颈). 例如求最大值，最小值和求和等操作，可以Map之后可以现在各个数据节点求出整个数据节点的最大值，作为一个结果输出，之后的reduce操作会大大减少结果的传输负担。 shuffle阶段： 将Mapper阶段的输出作为Reducer阶段的输入数据。 Reduce阶段： 执行用户编写的reduce函数，得出结果之后存储在HDFS文件系统之上。 Map-Shuffle-Reduce过程解析 参考文献:cnblogs Spark 弹性分布式数据集(RDD) Spark 底层存储数据的时候使用的是Hadoop的HDFS分布是文件系统，所以可以存储任何兼容Hadoop的数据源，例如Hbase. Spark 在逻辑上把数据存储在一个一个的RDD中，一个RDD可以看作一张表格，可以保存任何类型的数据。RDD是不可改变的，任何改变RDD的操作都会返回一个全新的RDD，spark的所有操作，在逻辑上都是针对RDD的操作。 RDD支持两种操作：transformation 和 action . transformation 是对RDD执行一个变换操作，不会立即计算，只是记录了应该在该RDD上执行这样的操作。 action 一般会是一个reduce操作， 会立刻执行，就是之前定义的所有transformation操作和当前定义的action操作。 transformation: 对RDD执行一个变换，返回一个新的RDD。可用的操作有map,filter,flatMap, groupByKey, reduceByKey 等。 action: 在该RDD对象上执行之前定义的所有操作(包括所有的transformation操作)， 返回计算的结果。 可用的操作有reduce, collect, count, first, countByKey 等。 WordCount 程序 使用spark运行一个统计单词个数的程序十分简单，这个过程可以帮助我们了解spark是如何工作的。 读取文本文件并生成RDD，将RDD缓存在内存中，缓存的RDD不需要从头开始计算，如果RDD没有缓存，就算过后的RDD会被立刻丢弃，每次想要得到结果都需要从头开始计算。 12345678910111213141516/* SimpleApp.scala */import org.apache.spark.SparkContextimport org.apache.spark.SparkContext._import org.apache.spark.SparkConfobject SimpleApp &#123; def main(args: Array[String]) &#123; val logFile = \"YOUR_SPARK_HOME/README.md\" // 应该是你系统上的某些文件 val conf = new SparkConf().setAppName(\"Simple Application\") val sc = new SparkContext(conf) val logData = sc.textFile(logFile, 2).cache() val numAs = logData.filter(line =&gt; line.contains(\"a\")).count() val numBs = logData.filter(line =&gt; line.contains(\"b\")).count() println(\"Lines with a: %s, Lines with b: %s\".format(numAs, numBs)) &#125;&#125; 这个程序仅仅是在 Spark README 中计算行里面包含 ‘a’ 和包含 ‘b’ 的次数. Spark 框架的主要内容 Spark生态系统 spark streaming : 基于微批量方式的计算和处理，可以用于处理实时的流数据。它使用DStream，简单来说就是一个弹性分布式数据集（RDD）系列，处理实时数据。 spark SQL : 可以通过JDBC API将Spark数据集暴露出去，而且还可以用传统的BI和可视化工具在Spark数据上执行类似SQL的查询。用户还可以用Spark SQL对不同格式的数据（如JSON，Parquet以及数据库等）执行ETL，将其转化，然后暴露给特定的查询。 spark mlib : 是一个可扩展的Spark机器学习库，由通用的学习算法和工具组成，包括二元分类、线性回归、聚类、协同过滤、梯度下降以及底层优化原语。 spark graphx : 是用于图计算和并行图计算的新的（alpha）Spark API。通过引入弹性分布式属性图（Resilient Distributed Property Graph），一种顶点和边都带有属性的有向多重图，扩展了Spark RDD。为了支持图计算，GraphX暴露了一个基础操作符集合（如subgraph，joinVertices和aggregateMessages）和一个经过优化的Pregel API变体。此外，GraphX还包括一个持续增长的用于简化图分析任务的图算法和构建器集合。 blinkDB : 一个近似查询引擎，用于在海量数据上执行交互式SQL查询。BlinkDB可以通过牺牲数据精度来提升查询响应时间。通过在数据样本上执行查询并展示包含有意义的错误线注解的结果，操作大数据集合。 sparkR : R语言的spark接口 HBASE HBase, Hadoop Database, 是Google Bigtable的开源实现，是一个面向列的，可伸缩的分布式存储系统，它的底层文件存储使用的是HDFS。 HBase的存储逻辑 表由行和列组成，列被分组，若干个列组成一个列簇（row family）,表在定义的时候，就必须声明所有的列簇，但是列簇内包含几个列可以动态增加(这也体现了面向列的存储这一方面). 同一个列簇使用相同的前缀为其命名，例如temperature:air 和 temperature:dew 都是temperature列簇的成员, HBase的每个列簇称作一个store，同一个列簇的数据会存储在同一个目录下，可能会分割成多个文件存储。 每个行由一个键表示，行键是一个字节数组，行按照行键进行排序。 行列交叉的位置称作Cell，每个cell都有版本，以时间戳标识，这个标识可以自己定义。也就是说，Hbase中的每个数据都是有版本的，数据按照时间倒序排列，最新的数据排列在最前面。cell中的内容是字节数组，不带格式,HBase存储的数据都是无格式的。唯一的确定一个cell需要下面这些数据：row key(行键), column:label(列簇的前缀的列的名称)， version(版本号)， 行键用来确定是哪一行，column:label确定是哪一列，版本号确定是哪个版本的数据，这样可以唯一的确定一个单元格里的数据。 HBase自动把表格水平划分程若干region, 每个region都是连续的若干行数据(类似数据库的水平分割). HBase的物理存储结构 一个Table最初只有一个Region,随这行的数量的增加，当超过一个既定的阈值的时候，Region就会等分为2个。 相同的Region保证存储在相同的机器上，不同的Region可以存储在不同的机器上，叫做region server。 每个Region存储的若干行和这些行的所有列。每个Region的内部存储是这样的：Region 由一个或者多个store组成，每个store存储一个列簇， 每个store包括一个memStore和0个或者多个storefile,storefile是存储的最小单位，以HFile的格式保存在HDFS文件系统上。 HBase架构示意图 HBase的运行 HBase 由一个主节点master和若干个RegionServer组成，主节点的负载较轻，主要负责引导初始安装，分配区域给已经注册的区域服务器，恢复区域服务器的故障等。 区域服务器负责自己存储的若干个区域的读写工作。 Hive hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供完整的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析 Hive是建立在 Hadoop 上的数据仓库基础构架。它提供了一系列的工具，可以用来进行数据提取转化加载（ETL），这是一种可以存储、查询和分析存储在 Hadoop 中的大规模数据的机制。Hive 定义了简单的类 SQL 查询语言，称为 HQL，它允许熟悉 SQL 的用户查询数据。同时，这个语言也允许熟悉 MapReduce 开发者的开发自定义的 mapper 和 reducer 来处理内建的 mapper 和 reducer 无法完成的复杂的分析工作 简单来讲，Hive提供了一种高级的类似SQL的语言，来执行一些以前必须要自己写Map,Reduce程序才能实现的功能，大大简化了数据处理的难度(MapReduce程序很难写)， 但是，Hive的实时性很差，适合离线处理，数据分析和数据挖掘等对实时性要求不高的任务。 Pig 提供类似SQL的语言叫做Pig Latin, 可以把类SQL的语言转化程优化处理过的MapReduce运算。 Pig是一种大规模数据集的脚本语言，它实际上提供了一整套脚本语言的特性，用来处理海量的数据。 Zookeeper Zookeeper的目的是提供一些工具集，用来建立安全处理局部故障的分布式应用。 使用Zookeeper, 我们可以更容易的自己实现一个分布式的应用。 参考文献:1","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"大数据","slug":"技术/大数据","permalink":"http://ff120.github.io/hexoblog/categories/技术/大数据/"}],"tags":[{"name":"HDFS","slug":"HDFS","permalink":"http://ff120.github.io/hexoblog/tags/HDFS/"}]},{"title":"算法专题_常见题目","slug":"技术/数据结构和算法/算法专题-常见题目","date":"2017-10-03T03:06:18.000Z","updated":"2019-03-28T00:54:56.233Z","comments":true,"path":"2017/10/03/技术/数据结构和算法/算法专题-常见题目/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/10/03/技术/数据结构和算法/算法专题-常见题目/","excerpt":"【栈】【队列】【链表】【二叉树】【堆】【快速排序】【归并排序】【数组】【指针】","text":"【栈】【队列】【链表】【二叉树】【堆】【快速排序】【归并排序】【数组】【指针】 栈 栈的压入弹出序列 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 123bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123; &#125; 132序列 Given a sequence of n integers a1, a2, …, an, a 132 pattern is a subsequence ai, aj, ak such that i &lt; j &lt; k and ai &lt; ak &lt; aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list. n will be less than 20,000. 12345678910111213141516bool find132pattern(vector&lt;int&gt;&amp; nums) &#123; int third = INT32_MIN; // 中间大的数 stack&lt;int&gt; s; for (int i = nums.size() - 1; i &gt;= 0; --i) &#123; // 如果找到小于第二大的数字，则小于第二大的数字，第二大的数字和最大的数字三个数字都找到，返回true; if (nums[i] &lt; third) return true; else&#123; // 如果当前数字大于栈顶元素，则找到了第二大的数字(栈顶元素)，最大的数字变成了当前数字 while (!s.empty() &amp;&amp; nums[i] &gt; s.top()) &#123; third = s.top(); s.pop(); &#125; &#125; s.push(nums[i]); &#125; return false;&#125; 链表 翻转链表 翻转一个链表 123ListNode * reverse(ListNode * head) &#123; // write your code here&#125; 合并K个链表 合并k个排序链表，并且返回合并后的排序链表。尝试分析和描述其复杂度。 123ListNode *mergeKLists(vector&lt;ListNode *&gt; &amp;lists) &#123; // write your code here&#125; 复杂链表的复制 给出一个链表，每个节点包含一个额外增加的随机指针可以指向链表中的任何节点或空的节点。 返回一个深拷贝的链表。 123RandomListNode *copyRandomList(RandomListNode *head) &#123; // write your code here&#125; 链表求和 假定用一个链表表示两个数，其中每个节点仅包含一个数字。假设这两个数的数字顺序排列，请设计一种方法将两个数相加，并将其结果表现为链表的形式。 123ListNode * addLists2(ListNode * l1, ListNode * l2) &#123; // write your code here&#125; 链表的中间节点 1234567891011121314/** * 找到链表的中间节点并返回 * @param head * @return */ListNode* findMiddle(ListNode* head)&#123; if(head == nullptr || head-&gt;next == nullptr) return head; ListNode *first = head, *second = head; while(second-&gt;next &amp;&amp; second-&gt;next-&gt;next)&#123; first = first-&gt;next; second = second-&gt;next-&gt;next; &#125; return first;&#125; 二叉树 前序遍历的非递归实现 123vector&lt;int&gt; preorderTraversal(TreeNode * root) &#123; // write your code here&#125; 中序遍历的非递归实现 123vector&lt;int&gt; inorderTraversal(TreeNode * root) &#123; // write your code here &#125; 后序遍历的非递归实现 123vector&lt;int&gt; postorderTraversal(TreeNode * root) &#123; // write your code here &#125; 二叉树的最大深度 123int maxDepth(TreeNode *root) &#123; // write your code here&#125; 二叉树的最小深度 123int minDepth(TreeNode * root) &#123; // write your code here &#125; 叶子之间的最长距离 堆排序 TOP K 12 数据流的中位数 123vector&lt;int&gt; medianII(vector&lt;int&gt; &amp;nums) &#123; // write your code here&#125; 快速排序 第K大的数 123int kthLargestElement(int n, vector&lt;int&gt; &amp;nums) &#123; // write your code here&#125; 中位数 给定一个未排序的整数数组，找到其中位数。 中位数是排序后数组的中间值，如果数组的个数是偶数个，则返回排序后数组的第N/2个数。 123int median(vector&lt;int&gt; &amp;nums) &#123; // write your code here&#125; 归并排序 数组的逆序对的个数 123long long reversePairs(vector&lt;int&gt; &amp;A) &#123; // write your code here &#125; 字符串 KMP算法 1234int strStr(const char *source, const char *target) &#123; // write your code here return -1; &#125; 字典树 给定整数m以及n个数字A1, A2, …, An，将数列A中所有元素两两异或，共能得到n(n-1)/2个结果。请求出这些结果中大于m的有多少个。 12 哈夫曼编码 一维数组 出现一半以上的数 一个数组中有一个数字的出现次数超过一半(超过50%),求出这个数字。 123int getMajority(vector&lt;int&gt; &amp;v)&#123;&#125; 数组跳跃能否达到终点 一个整形数组，每个元素代表可以在当前位置的基础上向后跳跃几步，问要跳跃到最后最少需要跳跃几步，如果不能到达最后返回-1; 123int getMin(vector&lt;int&gt; v)&#123;&#125; 大数据 布隆过滤器","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"手写代码-其他","slug":"技术/数据结构和算法/手写代码-其他","date":"2017-09-27T15:12:30.000Z","updated":"2019-03-28T00:54:56.087Z","comments":true,"path":"2017/09/27/技术/数据结构和算法/手写代码-其他/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/09/27/技术/数据结构和算法/手写代码-其他/","excerpt":"【快速排序】【第K大的数】【归并排序】【逆序对】【二分查找】【冒泡排序】【单例模式】","text":"【快速排序】【第K大的数】【归并排序】【逆序对】【二分查找】【冒泡排序】【单例模式】 二分查找 123456789101112131415161718192021222324252627282930313233343536373839// 不考虑重复元素int binarySearch(vector&lt;int&gt; &amp;v, int val)&#123; if(v.empty()) return -1; int i = 0; int j = v.size() - 1; int mid; while(i &lt;= j)&#123; if(v[mid] == val) return mid; if(v[mid] &gt; val)&#123; j = mid - 1; &#125; if(v[mid] &lt; val)&#123; i = mid + 1; &#125; &#125; return -1;&#125;// 如果有重复的val,返回val的起始位置int binaryResearch()&#123; if(v.empty()) return -1; int i=0; int j = v.size() -1; int mind; while(i &lt; j))&#123; if(v[mid] == val)&#123; while(v[mid] == val &amp;&amp; mid &gt;= 0)&#123; mid--; &#125; return p+1; &#125; if(v[mid] &gt; val)&#123; j = mid - 1; &#125; if(v[mid] &lt; val)&#123; i = mid + 1; &#125; &#125;&#125; 冒泡排序 1234567void sort(vector&lt;int&gt; &amp;v)&#123; for(int j = v.size()-1;j&gt;=1;j--)&#123; for(int i=0;i&lt;j;i++)&#123; if(v[i] &gt; v[i+1]) swap(v[i],v[i+1]); &#125; &#125;&#125; 单例模式 1234567891011121314151617181920class Singleton&#123; private: static Single* instance = null; // 静态私有变量，属于类 Singleton()&#123;&#125; Singleton(const Singleton&amp;)&#123;&#125; Singleton&amp; operator=(const Singleton&amp;)&#123;&#125; // 防止赋值的时候拷贝 public: static Singleton* getInstance() // 静态方法，确保使用类可以调用 &#123; if (instance == NULL)&#123; lock(); // 线程安全的写法，如果不用确保线程安全，不需要 if(instance == NULL)&#123; instance = new Singleton(); &#125; unlock(); &#125; return instance; &#125;&#125;; // 使用方法 auto instance = Singleton::getInstance();","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"算法专题_二叉树2","slug":"技术/数据结构和算法/算法专题_二叉树2","date":"2017-09-23T10:26:58.000Z","updated":"2019-03-28T00:54:56.362Z","comments":true,"path":"2017/09/23/技术/数据结构和算法/算法专题_二叉树2/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/09/23/技术/数据结构和算法/算法专题_二叉树2/","excerpt":"【前序遍历】【中序遍历】【后序遍历】【路径搜索】【公共祖先】【堆】【top K】【线段树】【树状数组】【并查集】","text":"【前序遍历】【中序遍历】【后序遍历】【路径搜索】【公共祖先】【堆】【top K】【线段树】【树状数组】【并查集】 前序遍历 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class TreeNode &#123;public: int val; TreeNode *left, *right; TreeNode(int val) &#123; this-&gt;val = val; this-&gt;left = this-&gt;right = NULL; &#125;&#125;;// 递归前序遍历vector&lt;int&gt; preorderTraversal(TreeNode * root) &#123; vector&lt;int&gt; re; if(!root) return re; re.push_back(root-&gt;val); if(root-&gt;left)&#123; auto tmp = preorderTraversal(root-&gt;left); re.insert(re.end(),tmp.begin(),tmp.end()); &#125; if(root-&gt;right)&#123; auto tmp = preorderTraversal(root-&gt;right); re.insert(re.end(),tmp.begin(),tmp.end()); &#125; return re;&#125;// 非递归前序遍历vector&lt;int&gt; preorder(TreeNode* root)&#123; vector&lt;int&gt; re; if(!root) return re; stack&lt;TreeNode*&gt; s; TreeNode* iter = root; while(iter || !s.empty())&#123; while(iter)&#123; // 首先输出根 re.push_back(iter-&gt;val); s.push(iter); iter = iter-&gt;left; &#125; iter = s.top(); s.pop(); iter = iter-&gt;right; &#125; return re;&#125; 中序遍历 12345678910111213141516171819202122232425262728293031323334353637// 递归中序遍历vector&lt;int&gt; inorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; re; if(!root) return re; if(root-&gt;left)&#123; auto tmp = inorderTraversal(root-&gt;left); re.insert(re.end(),tmp.begin(),tmp.end()); &#125; re.push_back(root-&gt;val); if(root-&gt;right)&#123; auto tmp = inorderTraversal(root-&gt;right); re.insert(re.end(),tmp.begin(),tmp.end()); &#125; return re;&#125;// 非递归中序遍历vector&lt;int&gt; inorder(TreeNode* root)&#123; vector&lt;int&gt; re; if(!root) return re; stack&lt;TreeNode*&gt; s; TreeNode* iter = root; while(iter || !s.empty())&#123; while(iter)&#123; s.push(iter); iter = iter-&gt;left; &#125; iter = s.top(); s.pop(); // 输出 re.push_back(iter-&gt;val); iter = iter-&gt;right; &#125; return re;&#125; 后序遍历 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 递归后序遍历vector&lt;int&gt; postorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; re; if(!root) return re; if(root-&gt;left)&#123; auto tmp = postorderTraversal(root-&gt;left); re.insert(re.end(),tmp.begin(),tmp.end()); &#125; if(root-&gt;right)&#123; auto tmp = postorderTraversal(root-&gt;right); re.insert(re.end(),tmp.begin(),tmp.end()); &#125; re.push_back(root-&gt;val); return re;&#125;// 后序遍历的非递归实现vector&lt;int&gt; postOrder(TreeNode *root)&#123; vector&lt;int&gt; re; if(!root) return re; TreeNode *iter = root; stack&lt;TreeNode *&gt; s; TreeNode *last = root; s.push(iter); while (!s.empty()) &#123; iter = s.top(); // 1. 当前节点是叶节点(没有左右孩子)，输出 // 2. 上次访问了当前节点的左孩子，而且当前节点没有右孩子，输出 // 3. 上次访问了当前节点的右孩子，输出 if( (iter-&gt;left == nullptr &amp;&amp; iter-&gt;right == nullptr) || (iter-&gt;right == nullptr &amp;&amp; last == iter-&gt;left) || (last == iter-&gt;right) ) &#123; re.push_back(iter-&gt;val); last = iter; s.pop(); &#125; else &#123; // 栈是后进先出的，要先处理左孩子，所以要先放入右耗资 if(iter-&gt;right) s.push(iter-&gt;right); if(iter-&gt;left) s.push(iter-&gt;left); &#125; &#125; return re;&#125; 二叉树的路径搜索 1234567891011121314151617// 搜索根节点到叶子节点的所有路径 [http://lintcode.com/zh-cn/problem/binary-tree-paths/#]vector&lt;vector&lt;int&gt;&gt; vv;void binaryTreePaths(TreeNode *root,vector&lt;int&gt; &amp;tmp) &#123; // write your code here if(!root-&gt;left &amp;&amp; !root-&gt;right)&#123; tmp.push_back(root-&gt;val); vv.push_back(tmp); tmp.clear(); return; &#125;else&#123; tmp.push_back(root-&gt;val); vector&lt;int&gt; tmp1(tmp); vector&lt;int&gt; tmp2(tmp); if(root-&gt;left) binaryTreePaths(root-&gt;left,tmp1); if(root-&gt;right) binaryTreePaths(root-&gt;right,tmp2); &#125;&#125; 二叉树最大深度 12345678// 调用方式： maxDepth2(root,0)int maxDepth2(TreeNode *root, const int dep)&#123; if(!root) return dep; if(!root-&gt;left &amp;&amp; !root-&gt;right) return dep+1; if(root-&gt;left &amp;&amp; !root-&gt;right) return maxDepth2(root-&gt;left,dep+1); if(root-&gt;right &amp;&amp; !root-&gt;left) return maxDepth2(root-&gt;right,dep+1); return max(maxDepth2(root-&gt;left,dep+1),maxDepth2(root-&gt;right,dep+1)); &#125; 二叉树最小深度 12345678// 最小深度 int minDepth2(TreeNode* root,const int dep)&#123; if(!root) return dep; if(!root-&gt;left &amp;&amp; !root-&gt;right) return dep+1; if(root-&gt;left &amp;&amp; !root-&gt;right) return minDepth2(root-&gt;left,dep+1); if(!root-&gt;left &amp;&amp; root-&gt;right) return minDepth2(root-&gt;right,dep+1); return min(minDepth2(root-&gt;left,dep+1),minDepth2(root-&gt;right,dep+1));&#125; 叶子节点到叶子节点路径的搜索 1234567891011121314151617181920map&lt;TreeNode*,vector&lt;TreeNode*&gt;&gt; nodes; // 存储树的结构map&lt;TreeNode*,bool&gt; visited;vector&lt;vector&lt;int&gt;&gt; vv;void dfs(TreeNode* leaf,vector&lt;int&gt; &amp;v)&#123; visited[leaf] = true; vector&lt;TreeNode*&gt; tmp = nodes[leaf]; bool is = true; v.push_back(leaf-&gt;val); for(int i=0;i&lt;tmp.size();i++)&#123; if(visited[tmp[i]] == false)&#123; vector&lt;int&gt; v1(v); dfs(tmp[i],v1); is = false; &#125; &#125; if(is)&#123; // 叶节点 vv.push_back(v); &#125; return;&#125; top K 问题 如果是最大的K个数，那么首先使用前K个数建立一个最小堆，然后从第K+1个数开始和堆顶的元素比较，如果大于堆顶的元素，就把堆顶的元素弹出，把该元素push进堆。 12345678910111213141516171819vector&lt;int&gt; topk(vector&lt;int&gt; &amp;v, int k)&#123; priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; heap; // 最小堆（堆顶元素最小） for(int i=0;i&lt;k;i++)&#123; heap.push(v[i]); &#125; for(int i=k;i&lt;v.size();i++)&#123; if(v[i] &gt; heap.top())&#123; heap.pop(); heap.push(v[i]); &#125; &#125; vector&lt;int&gt; re; while(!heap.empty())&#123; re.push_back(heap.top()); heap.pop(); &#125; return re;&#125; 数据流的中位数 使用大顶堆(priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt;) 保存前半部分的数据，使用小顶堆(priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;) 保存后半部分的数据, 保证大顶堆的顶 小于等于 小顶堆的顶， 那么在每次需要求当前的数据的中位数的时候，只需要两个堆顶元素就可以求出来了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class MedianFinder &#123;private: priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt; maxHeap; priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; minHeap; long long n; bool is_left;public: MedianFinder() &#123; this-&gt;n = 0; this-&gt;is_left = true; &#125; void addNum(int num) &#123; // 轮流加入左右两个堆 if(is_left)&#123; // 如果right的堆为空，可以确保左边最大的小于等于右边最小的，直接加入 // 如果要加入的元素小于等于right的堆顶，也可以保证上述条件 if(minHeap.empty() || num &lt;= minHeap.top())&#123; maxHeap.push(num); &#125; // 如果num &gt; minHeap.top(); 不能直接加入maxHeap,因为如果这样做，就不能保证maxHeap中的所有的数字都小于等于minHeap中的数字。 // 这个时候的做法是， 先把num加入minHeap, 在把minHeap.top()弹出，加入maxHeap; else&#123; minHeap.push(num); maxHeap.push(minHeap.top()); minHeap.pop(); &#125; is_left = !is_left; &#125; if(!is_left)&#123; if(maxHeap.empty() || num &gt;= maxHeap.top())&#123; minHeap.push(num); &#125;else&#123; maxHeap.push(num); minHeap.push(maxHeap.top()); maxHeap.pop(); &#125; is_left = !is_left; &#125; this-&gt;n++; &#125; double findMedian() &#123; if(n &gt;&gt; 1)&#123; return (maxHeap.top() + minHeap.top()) / 2.0; &#125;else&#123; return maxHeap.top(); &#125; &#125;&#125;; 合并K个排序链表 这里使用小顶堆这种结构保存K个链表，每次取得堆顶的元素就可以得到K个链表中最小的。 123456789101112131415161718192021222324252627ListNode *mergeKLists(vector&lt;ListNode *&gt; &amp;lists) &#123; priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,bigger&gt; minHeap; if(lists.empty()) return nullptr; for(int i=0;i&lt;lists.size();i++)&#123; if(lists[i]) minHeap.push(lists[i]); &#125; ListNode *head = nullptr; ListNode *iter = nullptr; while(!minHeap.empty())&#123; if(head == nullptr)&#123; head = minHeap.top(); iter = head; if(minHeap.top()-&gt;next)&#123; minHeap.push(minHeap.top()-&gt;next); &#125; minHeap.pop(); &#125;else&#123; iter-&gt;next = minHeap.top(); iter = iter-&gt;next; if(minHeap.top()-&gt;next)&#123; minHeap.push(minHeap.top()-&gt;next); &#125; minHeap.pop(); &#125; &#125; return head;&#125; 堆排序 使用堆这种结构维护数据的有序性，从而进行排序的算法是堆排序。堆排序的具体步骤是： 使用要排序的整个数组建立堆。然后把最后一个元素和堆顶元素交换，堆的大小减1，调整堆，然后再把新的堆的最后一个元素和堆顶元素交换，调整堆，直到全部数据有序为止。 12345678910void heapSort(vector&lt;int&gt; &amp;v)&#123; // 建立最大堆 make_heap(v.begin(),v.end(),less&lt;int&gt;()); int index = v.size(); while(index &gt; 0)&#123; // 交换堆顶和堆尾的元素，重新调整堆 pop_heap(v.begin(),v.begin()+index,less&lt;int&gt;()); index--; &#125;&#125; 二叉树的序列化和反序列化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;template &lt;typename T&gt;struct Node&#123; T val; Node *left,*right; Node()&#123;&#125; Node(T init) : val(init), left(nullptr), right(nullptr) &#123;&#125;&#125;;/** * 二叉树的先根遍历，非递归实现，使用栈 * @param root * @return */vector&lt;int&gt; preOrder(Node&lt;int&gt;* root)&#123; vector&lt;int&gt; ans; if(!root) return ans; stack&lt;Node&lt;int&gt;*&gt; s; Node&lt;int&gt;* iter = root; while(iter || !s.empty())&#123; while(iter)&#123; ans.push_back(iter-&gt;val); s.push(iter); iter = iter-&gt;left; &#125; iter = s.top(); s.pop(); iter = iter-&gt;right; &#125; return ans;&#125;/** * 二叉树的层次遍历，非递归，使用队列 * @param root * @return */vector&lt;int&gt; levelOrder(Node&lt;int&gt;* root)&#123; vector&lt;int&gt; ans; if(!root) return ans; queue&lt;Node&lt;int&gt;*&gt; q; q.push(root); Node&lt;int&gt;* iter; while(!q.empty())&#123; iter = q.front(); if(iter)&#123; ans.push_back(iter-&gt;val); if(iter-&gt;left) q.push(iter-&gt;left); if(iter-&gt;right) q.push(iter-&gt;right); &#125; q.pop(); &#125; return ans;&#125;/** * 使用层次遍历的方法序列化二叉树 * @param root * @return */vector&lt;string&gt; levelOrderSeries(Node&lt;int&gt;* root)&#123; vector&lt;string&gt; ans; if(!root) return ans; queue&lt;Node&lt;int&gt;*&gt; q; q.push(root); Node&lt;int&gt;* iter; while(!q.empty())&#123; iter = q.front(); if(iter)&#123; if(iter-&gt;val != -1)&#123; ans.push_back(to_string(iter-&gt;val)); if(iter-&gt;left)&#123; q.push(iter-&gt;left); &#125;else&#123; q.push(new Node&lt;int&gt;(-1)); &#125; if(iter-&gt;right)&#123; q.push(iter-&gt;right); &#125;else&#123; q.push(new Node&lt;int&gt;(-1)); &#125; &#125;else&#123; ans.push_back(\"#\"); &#125; &#125; q.pop(); &#125; while(*(--ans.end()) == \"#\") ans.erase(--ans.end()); return ans;&#125;/** * 根据二叉树的层次遍历的结果重建二叉树 * @param c * @return */Node&lt;int&gt;* reConstructTree(const vector&lt;string&gt; &amp;c)&#123; if(c.empty()) return nullptr; queue&lt;Node&lt;int&gt;*&gt; q; int index = 0; if(c[index] == \"#\") return nullptr; auto root = new Node&lt;int&gt;( stoi(c[index]) ); index++; q.push(root); while(!q.empty())&#123; Node&lt;int&gt;* parent = q.front(); q.pop(); Node&lt;int&gt;* left = nullptr; Node&lt;int&gt;* right = nullptr ; if(index &lt; c.size() &amp;&amp; c[index] != \"#\") &#123; left = new Node&lt;int&gt;(stoi(c[index])); &#125; index++; if(index &lt; c.size() &amp;&amp; c[index] != \"#\") &#123; right = new Node&lt;int&gt;(stoi(c[index])); &#125; index++; if(left) &#123; parent-&gt;left = left; q.push(left); &#125; if(right) &#123; parent-&gt;right = right; q.push(right); &#125; &#125; return root;&#125;int main()&#123; vector&lt;string&gt; v = &#123;\"3\",\"9\",\"20\",\"#\",\"#\",\"15\",\"7\"&#125;; auto re = reConstructTree(v); auto hh = levelOrderSeries(re); return 0;&#125; 使用非递归、非栈的方式遍历二叉树 核心的思想是使用二叉树的左子树的最右边的空指针指向 在遍历完左子树之后 需要遍历的下一个节点。 具体的步骤是： 令iter = root,root表示二叉树的根节点。首先让iter的左子树的最右节点的right指针指向iter. 完成这一步的代码类似下面这样： 12345678910Node* tp = iter-&gt;left; // tp 指向iter的左子树if(tp)&#123; // 通过循环找到最右边的节点 while(tp-&gt;right != nullptr)&#123; tp = tp-&gt;right; &#125; // 最右节点的right指针指向iter if(tp-&gt;right == nullptr)&#123; tp-&gt;right = iter; &#125; 处理完root节点之后，循环处理iter=iter-&gt;left直到iter的left指针为空为止，也就是上文中的tp==nullptr的情况。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;struct Node&#123; int val; Node* left; Node* right; Node()&#123;&#125; Node(int v) : val(v),left(nullptr),right(nullptr)&#123;&#125;&#125;;/** * 二叉树的前序遍历，非递归，不用栈 * @param root * @return */vector&lt;int&gt; preOrder(Node* root)&#123; vector&lt;int&gt; ans; if(!root) return ans; Node* iter = root; Node* tp = nullptr; while(iter != nullptr)&#123; // 处理iter的左子树 tp = iter-&gt;left; if(tp != nullptr)&#123; // 找到 iter 左子树的最右节点 while(tp-&gt;right != nullptr &amp;&amp; tp-&gt;right != iter)&#123; tp = tp-&gt;right; &#125; // 如果是不满足tp-&gt;right != nullptr 而退出了上面的循环， // 说明找到的节点iter的左子树的最右面的空节点， // 把该节点指向iter // 继续处理 iter 的左孩子 if(tp-&gt;right == nullptr)&#123; tp-&gt;right = iter; // 左子树的最右节点指向之前的节点 ans.push_back(iter-&gt;val); // 一旦找到左子树最右边的节点就输出iter，因为前序遍历根节点要最先输出 iter = iter-&gt;left; continue; &#125; // 如果是因为不满足tp-&gt;right != iter 退出了循环， // 就是说tp-&gt;right == iter // 说明已经遍历过一遍(否则不可能有指向iter的指针) // 把tp-&gt;right 置空，恢复二叉树原来的样子 else&#123; tp-&gt;right = nullptr; &#125; &#125;else&#123; // 没有左子树，也要输出根 ans.push_back(iter-&gt;val); &#125; iter = iter-&gt;right; &#125; return ans;&#125;/** * 二叉树的中序遍历，非递归，不用栈 * @param root * @return */vector&lt;int&gt; inOrder(Node* root)&#123; vector&lt;int&gt; ans; if(!root) return ans; Node* iter = root; Node* tp = nullptr; while(iter != nullptr)&#123; // 处理iter的左子树 tp = iter-&gt;left; if(tp != nullptr)&#123; // 找到 iter 左子树的最右节点 while(tp-&gt;right != nullptr &amp;&amp; tp-&gt;right != iter)&#123; tp = tp-&gt;right; &#125; // 如果是不满足tp-&gt;right != nullptr 而退出了上面的循环， // 说明找到的节点iter的左子树的最右面的空节点， // 把该节点指向iter // 继续处理 iter 的左孩子 if(tp-&gt;right == nullptr)&#123; tp-&gt;right = iter; // 左子树的最右节点指向之前的节点 iter = iter-&gt;left; continue; &#125; // 如果是因为不满足tp-&gt;right != iter 退出了循环， // 就是说tp-&gt;right == iter // 说明已经遍历过一遍(否则不可能有指向iter的指针) // 把tp-&gt;right 置空，恢复二叉树原来的样子 else&#123; tp-&gt;right = nullptr; &#125; &#125; ans.push_back(iter-&gt;val); iter = iter-&gt;right; &#125; return ans;&#125;int main()&#123; return 0;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"算法专题_字典树(Trie树)","slug":"技术/数据结构和算法/算法专题-字典树-Trie树","date":"2017-08-23T01:58:56.000Z","updated":"2019-03-28T00:54:56.209Z","comments":true,"path":"2017/08/23/技术/数据结构和算法/算法专题-字典树-Trie树/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/08/23/技术/数据结构和算法/算法专题-字典树-Trie树/","excerpt":"一种字符串前缀的匹配技术。","text":"一种字符串前缀的匹配技术。 字典树 字典树的应用 异或（今日头条2017秋招真题） 异或（今日头条2017秋招真题） 题目描述 给定整数m以及n个数字A1, A2, …, An，将数列A中所有元素两两异或，共能得到n(n-1)/2个结果。请求出这些结果中大于m的有多少个。 输入 第一行包含两个整数n, m。 第二行给出n个整数A1, A2, …, An。 样例输入 3 10 6 5 10 输出 输出仅包括一行，即所求的答案。 样例输出 2 时间限制 C/C++语言：1000MS其它语言：3000MS 内存限制 C/C++语言：65536KB其它语言：589824K 思路： 从最高位开始建立字典树，左子树表示二进制0，右子树表示二进制位1. 每个节点统计在n个数字中对应的二进制位上有多少个对应的0或者1. 查询每个数字a和m，比较a和m对应的位，有如下情况 2.1 a = 0, m = 0, 这个时候 b=0 , a^b = 0 不能确定谁大，继续查找下一位 2.2 a = 0, m = 1, 这个时候 b=0 , 肯定有a^b &lt; m, 不满足条件，跳过； b = 1, 继续查找下一位 2.3 a = 1, m = 0, 这个时候 b=0 , 肯定有a^b &gt; m, 满足条件，直接将对应的count加在结果上， b=1,继续查找下一位 2.4 a = 1, m = 1, 这个时候 b=0 , 继续查找下一位，b = 1,肯定不满足条件， 最后的结果除以2返回， 因为我们既统计了a与b的异或，也统计了b与a的异或。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct TrieTree&#123; int count; struct TrieTree* next[2]&#123;NULL,NULL&#125;; TrieTree():count(1)&#123;&#125;&#125;;TrieTree* buildTrieTree(const vector&lt;int&gt;&amp; array)&#123; TrieTree* trieTree = new TrieTree(); for(int i=0;i&lt;(int)array.size();++i) &#123; TrieTree* cur = trieTree; for(int j=16;j&gt;=0;--j) &#123; int digit = (array[i] &gt;&gt; j) &amp; 1; if(NULL == cur-&gt;next[digit]) cur-&gt;next[digit] = new TrieTree(); else ++(cur-&gt;next[digit]-&gt;count); cur = cur-&gt;next[digit]; &#125; &#125; return trieTree;&#125;long long queryTrieTree(TrieTree*&amp; trieTree, const int a, const int m, const int index)&#123; if(NULL == trieTree) return 0; TrieTree* cur = trieTree; for(int i=index;i&gt;=0;--i) &#123; int aDigit = (a &gt;&gt; i) &amp; 1; int mDigit = (m &gt;&gt; i) &amp; 1; if(1==aDigit &amp;&amp; 1==mDigit) &#123; if(NULL == cur-&gt;next[0]) return 0; cur = cur-&gt;next[0]; &#125; else if(0 == aDigit &amp;&amp; 1==mDigit) &#123; if(NULL == cur-&gt;next[1]) return 0; cur = cur-&gt;next[1]; &#125; else if(1 == aDigit &amp;&amp; 0 == mDigit) &#123; long long val0 = (NULL == cur-&gt;next[0]) ? 0 : cur-&gt;next[0]-&gt;count; long long val1 = queryTrieTree(cur-&gt;next[1],a,m,i-1); return val0+val1; &#125; else if(0 == aDigit &amp;&amp; 0 == mDigit) &#123; long long val0 = queryTrieTree(cur-&gt;next[0],a,m,i-1); long long val1 = (NULL == cur-&gt;next[1]) ? 0 : cur-&gt;next[1]-&gt;count; return val0+val1; &#125; &#125; return 0;&#125;long long solve(const vector&lt;int&gt;&amp; array, const int&amp; m)&#123; TrieTree* trieTree = buildTrieTree(array); long long result = 0; for(int i=0;i&lt;(int)array.size();++i) &#123; result += queryTrieTree(trieTree,array[i],m,16); &#125; return result /2;&#125;int main()&#123; freopen(\"d:/A.in\",\"r\",stdin); int n,m; while(cin&gt;&gt;n&gt;&gt;m) &#123; vector&lt;int&gt; array(n); for(int i=0;i&lt;n;++i) cin&gt;&gt;array[i]; cout&lt;&lt; solve(array,m) &lt;&lt;endl; &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;using namespace std;using ll = long long;const int MAXBIT = 17;struct trieTree&#123; ll count = 0; trieTree* next[2] = &#123;nullptr, nullptr&#125;; trieTree() : count(0)&#123;&#125; trieTree(int c) : count(c)&#123;&#125;&#125;;trieTree* createTree(const vector&lt;int&gt; &amp;arr)&#123; trieTree* root = new trieTree(1); for (int i = 0; i &lt; arr.size(); ++i) &#123; int index = MAXBIT; // int 整形最多32位 trieTree* cur = root; while(index &gt;= 0)&#123; int digit = (arr[i] &gt;&gt; index) &amp; 1; // 从低位到高位第index+1位的值 if(cur-&gt;next[digit] == nullptr)&#123; cur-&gt;next[digit] = new trieTree(1); &#125;else&#123; cur-&gt;next[digit]-&gt;count ++; &#125; cur = cur-&gt;next[digit]; index--; &#125; &#125; return root;&#125;/** * 查询trie树中有多少个数字满足a^b&gt;m * @param root * @param a * @param m * @param index * @return */ll queryTree(trieTree* root,int a, int m, int index)&#123; if(root == nullptr) return 0; for (int i = index; i &gt;= 0; --i) &#123; int aDigit = (a &gt;&gt; i) &amp; 1; int mDigit = (m &gt;&gt; i) &amp; 1; if(aDigit == 0 &amp;&amp; mDigit == 0)&#123; ll v0 = 0 , v1 = 0; if(root-&gt;next[1] != nullptr)&#123; v0 = root-&gt;next[1]-&gt;count; &#125; v1 = queryTree(root-&gt;next[0],a,m,i-1); return v0 + v1; &#125;else if(aDigit == 0 &amp;&amp; mDigit == 1)&#123; if(root-&gt;next[1] == nullptr) return 0; return queryTree(root-&gt;next[1],a,m,i-1); &#125;else if(aDigit == 1 &amp;&amp; mDigit == 0)&#123; ll v0 = 0 , v1 = 0; if(root-&gt;next[0] != nullptr)&#123; v0 = root-&gt;next[0]-&gt;count; &#125; v1 = queryTree(root-&gt;next[1],a,m,i-1); return v0 + v1; &#125;else if(aDigit == 1 &amp;&amp; mDigit == 1)&#123; if(root-&gt;next[0] == nullptr) return 0; return queryTree(root-&gt;next[0],a,m,i-1); &#125;else&#123; cout&lt;&lt;\"error\"&lt;&lt;endl; &#125; &#125; return 0;&#125;ll solve(vector&lt;int&gt; &amp;v, int m)&#123; trieTree* root = createTree(v); ll result = 0; for (int i = 0; i &lt; v.size(); ++i) &#123; result += queryTree(root,v[i],m,MAXBIT); &#125; return result / 2;&#125;int main()&#123; freopen(\"d:/A.in\",\"r\",stdin); int n, m ; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; v(n,0); for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; v[i]; &#125; cout&lt;&lt;solve(v,m)&lt;&lt;endl; return 0;&#125; 统计子目录 统计子目录 描述 小Hi的电脑的文件系统中一共有N个文件，例如： /hihocoder/offer22/solutions/p1 /hihocoder/challenge30/p1/test /game/moba/dota2/uninstall 小Hi想统计其中一共有多少个不同的子目录。上例中一共有8个不同的子目录： /hihocoder /hihocoder/offer22 /hihocoder/offer22/solutions /hihocoder/challenge30 /hihocoder/challenge30/p1 /game /game/moba /game/moba/dota2/ 输入 第一行包含一个整数N (1 ≤ N ≤ 10000) 以下N行每行包含一个字符串，代表一个文件的绝对路径。保证路径从根目录“/”开始，并且文件名和目录名只包含小写字母和数字。 对于80%的数据，N个文件的绝对路径长度之和不超过10000 对于100%的数据，N个文件的绝对路径长度之和不超过500000 输出 一个整数代表不同子目录的数目。 样例输入 3 /hihocoder/offer22/solutions/p1 /hihocoder/challenge30/p1/test /game/moba/dota2/uninstall 样例输出 8 思路： 用每个目录的名字建立字典树，根是空字符，然后统计整棵树节点的数目，最后返回节点的数目-1. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;deque&gt;#include &lt;stack&gt;using namespace std;/* * [统计子目录](http://hihocoder.com/problemset/solution/1157194) * */struct trieTree&#123; string description; vector&lt;trieTree*&gt; sons; trieTree() : description(\"\")&#123;&#125; trieTree(string &amp;s) : description(s)&#123;&#125;&#125;;/** * 层次遍历统计节点数目 * @param root * @return */int countNodes(trieTree* root)&#123; if(root == nullptr) return 0; if(root-&gt;sons.empty()) return 1; vector&lt;trieTree*&gt; nodes, next; nodes.push_back(root); int re = 0; while(!nodes.empty())&#123; for (int i = 0; i &lt; nodes.size(); ++i) &#123; next.insert(next.end(),nodes[i]-&gt;sons.begin(),nodes[i]-&gt;sons.end()); &#125; re += nodes.size(); nodes = next; next.clear(); &#125; return re;&#125;/** * 递归遍历节点数目 * @param root * @return */int countNode2(trieTree *root)&#123; if(root == nullptr) return 0; if(root-&gt;sons.empty()) return 1; int re = 1; for (int i = 0; i &lt; root-&gt;sons.size(); ++i) &#123; re += countNode2(root-&gt;sons[i]); &#125; return re;&#125;vector&lt;string&gt; splitString(const string &amp;s)&#123; vector&lt;string&gt; re; if(s.empty()) return re; size_t index1 = 0; size_t index2 = 1; while(s.find('/',index2) != -1)&#123; index2 = s.find('/',index1+1); re.push_back(s.substr(index1+1,index2-index1-1)); index1 = index2; index2++; &#125; return re;&#125;int solve(vector&lt;string&gt; &amp;pathes, int n)&#123; if(pathes.empty() || n &lt;= 0) return 0; int result = 0; trieTree *root = new trieTree(); for (int i = 0; i &lt; n; ++i) &#123; vector&lt;string&gt; path = splitString(pathes[i]); trieTree *cur = root; for (int j = 0; j &lt; path.size(); ++j) &#123; if(cur-&gt;sons.empty())&#123; cur-&gt;sons.push_back(new trieTree(path[j])); result++; cur = cur-&gt;sons[0]; &#125;else&#123; int index = cur-&gt;sons.size(); for (int k = 0; k &lt; cur-&gt;sons.size(); ++k) &#123; if(cur-&gt;sons[k]-&gt;description == path[j])&#123; index = k; break; &#125; &#125; if(index == cur-&gt;sons.size())&#123; cur-&gt;sons.push_back(new trieTree(path[j])); result++; cur = cur-&gt;sons[cur-&gt;sons.size()-1]; &#125;else&#123; cur = cur-&gt;sons[index]; &#125; &#125; &#125; &#125; int re = countNode2(root) - 1; return result;&#125;int main()&#123; freopen(\"d:/A.in\",\"r\",stdin); int n; cin&gt;&gt;n; vector&lt;string&gt; pathes(n,\"\"); for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; pathes[i]; &#125; cout&lt;&lt;solve(pathes,n)&lt;&lt;endl; return 0;&#125; 合并子目录 合并子目录 描述 小Hi的电脑的文件系统中一共有N个文件，例如： /hihocoder/offer23/solutions/p1 /hihocoder/challenge30/p1/test /game/moba/dota2/uninstall 经过统计，小Hi认为他的电脑中子目录实在太多了，于是他决定减少子目录的数量。小Hi发现其中一些子目录只包含另一个子目录，例如/hihocoder/offer22只包含一个子目录solution，/game只包含一个子目录moba，而moba也只包含一个子目录dota2。小Hi决定把这样的子目录合并成一个子目录，并且将被合并的子目录的名字用’-’连起来作为新子目录的名字。合并之后上例的3个文件的路径会变为： /hihocoder/offer23-solutions/p1 /hihocoder/challenge30-p1/test /game-moba-dota2/uninstall 输入 第一行包含一个整数N (1 ≤ N ≤ 10000) 以下N行每行包含一个字符串，代表一个文件的绝对路径。保证路径从根目录“/”开始，并且文件名和目录名只包含小写字母和数字。 对于80%的数据，N个文件的绝对路径长度之和不超过10000 对于100%的数据，N个文件的绝对路径长度之和不超过500000 输出 对于输入中的每个文件，输出合并子目录之后该文件的绝对路径。 样例输入 3 /hihocoder/offer23/solutions/p1 /hihocoder/challenge30/p1/test /game/moba/dota2/uninstall 样例输出 /hihocoder/offer23-solutions/p1 /hihocoder/challenge30-p1/test /game-moba-dota2/uninstall 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;deque&gt;#include &lt;stack&gt;using namespace std;/* * [统计子目录](http://hihocoder.com/problemset/solution/1157194) * */struct trieTree&#123; string description; vector&lt;trieTree*&gt; sons; trieTree() : description(\"\")&#123;&#125; trieTree(string &amp;s) : description(s)&#123;&#125;&#125;;vector&lt;string&gt; splitString(string &amp;s)&#123; vector&lt;string&gt; re; if(s.empty()) return re; s.push_back('/'); size_t index1 = 0; size_t index2 = 1; while(s.find('/',index2) != -1)&#123; index2 = s.find('/',index1+1); re.push_back(s.substr(index1+1,index2-index1-1)); index1 = index2; index2++; &#125; return re;&#125;trieTree* createTree(vector&lt;string&gt; &amp;pathes)&#123; if(pathes.empty()) return 0; int result = 0; trieTree *root = new trieTree(); for (int i = 0; i &lt; pathes.size(); ++i) &#123; vector&lt;string&gt; path = splitString(pathes[i]); trieTree *cur = root; for (int j = 0; j &lt; path.size(); ++j) &#123; if(cur-&gt;sons.empty())&#123; cur-&gt;sons.push_back(new trieTree(path[j])); result++; cur = cur-&gt;sons[0]; &#125;else&#123; int index = cur-&gt;sons.size(); for (int k = 0; k &lt; cur-&gt;sons.size(); ++k) &#123; if(cur-&gt;sons[k]-&gt;description == path[j])&#123; index = k; break; &#125; &#125; if(index == cur-&gt;sons.size())&#123; cur-&gt;sons.push_back(new trieTree(path[j])); result++; cur = cur-&gt;sons[cur-&gt;sons.size()-1]; &#125;else&#123; cur = cur-&gt;sons[index]; &#125; &#125; &#125; &#125; return root;&#125;trieTree* reduceTree(trieTree* root)&#123; trieTree* re = root; if(root-&gt;sons.empty()) return root; if(root-&gt;sons.size() &gt;= 2)&#123; for (int i = 0; i &lt; root-&gt;sons.size(); ++i) &#123; reduceTree(root-&gt;sons[i]); &#125; &#125; if(root-&gt;sons.size() == 1)&#123; trieTree* next = root-&gt;sons[0]; if(next-&gt;sons.empty())&#123;// root-&gt;description = root-&gt;description + \"-\";// root-&gt;description = root-&gt;description + next-&gt;description;// root-&gt;sons.clear(); return root; &#125; root-&gt;sons.clear(); for (int i = 0; i &lt; next-&gt;sons.size(); ++i) &#123; root-&gt;sons.push_back(next-&gt;sons[i]); &#125; root-&gt;description = root-&gt;description + \"-\"; root-&gt;description = root-&gt;description + next-&gt;description; reduceTree(root); &#125; return re;&#125;void printTree(trieTree* root,string out)&#123; if(nullptr == root) return; out += root-&gt;description + \"/\"; if(root-&gt;sons.empty())&#123; if(out.find_last_of('/') == out.size() - 1)&#123; out.erase(out.size()-1); &#125; cout&lt;&lt;out&lt;&lt;endl; &#125;else&#123; for (int i = 0; i &lt; root-&gt;sons.size(); ++i) &#123; printTree(root-&gt;sons[i],out); &#125; &#125;&#125;void solve(vector&lt;string&gt; &amp;pathes, int n)&#123; int result = 0; trieTree* root = createTree(pathes); trieTree* reduced = reduceTree(root); string out = \"\"; printTree(reduced,out);&#125;int main()&#123; freopen(\"d:/A.in\",\"r\",stdin); int n; cin&gt;&gt;n; vector&lt;string&gt; pathes(n,\"\"); for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; pathes[i]; &#125; solve(pathes,n); return 0;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"今日头条_在线编程题","slug":"技术/数据结构和算法/今日头条-在线编程题","date":"2017-08-22T08:10:10.000Z","updated":"2019-03-28T00:54:55.996Z","comments":true,"path":"2017/08/22/技术/数据结构和算法/今日头条-在线编程题/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/08/22/技术/数据结构和算法/今日头条-在线编程题/","excerpt":"","text":"头条校招 头条校招 头条的2017校招开始了！为了这次校招，我们组织了一个规模宏大的出题团队，每个出题人都出了一些有趣的题目，而我们现在想把这些题目组合成若干场考试出来，在选题之前，我们对题目进行了盲审，并定出了每道题的难度系统。一场考试包含3道开放性题目，假设他们的难度从小到大分别为a,b,c，我们希望这3道题能满足下列条件： a&lt;=b&lt;=c b-a&lt;=10 c-b&lt;=10 所有出题人一共出了n道开放性题目。现在我们想把这n道题分布到若干场考试中（1场或多场，每道题都必须使用且只能用一次），然而由于上述条件的限制，可能有一些考试没法凑够3道题，因此出题人就需要多出一些适当难度的题目来让每场考试都达到要求，然而我们出题已经出得很累了，你能计算出我们最少还需要再出几道题吗？ 输入描述: 输入的第一行包含一个整数n，表示目前已经出好的题目数量。 第二行给出每道题目的难度系数d1,d2,…,dn。 数据范围 对于30%的数据，1 ≤ n,di ≤ 5; 对于100%的数据，1 ≤ n ≤ 10^5,1 ≤ di ≤ 100。 在样例中，一种可行的方案是添加2个难度分别为20和50的题目，这样可以组合成两场考试：（20 20 23）和（35,40,50）。 输出描述: 输出只包括一行，即所求的答案。 示例1 输入 4 20 35 23 40 输出 2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;string&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int solve(vector&lt;int&gt; &amp;v, int n)&#123; if(v.empty()) return 3; sort(v.begin(),v.end()); int i = 0; int re = 0; while(i &lt; n)&#123; if(i+1&lt;n)&#123; if(v[i+1] - v[i] &gt; 20)&#123; re = re + 2; i = i + 1; &#125;else if(v[i+1] - v[i] &gt; 10)&#123; re = re + 1; i = i + 2; &#125;else&#123; if(i+2 &lt; n)&#123; if(v[i+2] - v[i+1] &gt; 10)&#123; re = re + 1; i = i + 2; &#125;else&#123; i = i + 3; &#125; &#125;else&#123; re = re + 1; break; &#125; &#125; &#125;else&#123; re = re + 2; break; &#125; &#125; return re;&#125;int main()&#123; freopen(\"d:/A.in\",\"r\",stdin); int n; cin &gt;&gt; n; vector&lt;int&gt; v(n,0); for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; v[i] ; &#125; auto re = solve(v,n); cout&lt;&lt;re&lt;&lt;endl; return 0;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"阿里笔试","slug":"技术/数据结构和算法/阿里在线测评-兔子繁殖问题","date":"2017-08-18T11:38:27.000Z","updated":"2019-03-28T00:54:57.414Z","comments":true,"path":"2017/08/18/技术/数据结构和算法/阿里在线测评-兔子繁殖问题/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/08/18/技术/数据结构和算法/阿里在线测评-兔子繁殖问题/","excerpt":"阿里巴巴网络技术有限公司（简称：阿里巴巴集团）是以曾担任英语教师的马云为首的18人于1999年在浙江杭州创立，他们相信互联网能够创造公平的竞争环境，让小企业通过创新与科技扩展业务，并在参与国内或全球市场竞争时处于更有利的位置","text":"阿里巴巴网络技术有限公司（简称：阿里巴巴集团）是以曾担任英语教师的马云为首的18人于1999年在浙江杭州创立，他们相信互联网能够创造公平的竞争环境，让小企业通过创新与科技扩展业务，并在参与国内或全球市场竞争时处于更有利的位置 兔子繁殖问题 问题 猎人把一对兔子婴儿(一公一母称为一对)放到一个荒岛上，两年之后，它们生下一对小兔，之后开始每年都会生下一对小兔。生下的小兔又会以同样的方式继续繁殖。 兔子的寿命都是x(x&gt;=3)年，并且生命的最后一年不繁殖。 如果岛上的兔子多于10对，那么猎人会每年在兔子们完成繁殖或者仙逝之后，从岛上带走两对最老的兔子。 请问y年(y&gt;=3)后荒岛上所有的兔子加起来多少岁?(注意, 在条件3执行完之后) 输入: 从命令行输入两行整数，第一行是x，第二行是y 输出: y年后荒岛上所有的兔子岁数的总和 测试数据： x y n 3 3 2 3 7 2 3 8 4 4 5 12 5 6 26 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int x ; int y ; x = 10; y = 12; vector&lt;int&gt; res = &#123;0&#125;; for (int year = 1; year &lt;= y; year++) &#123; // // 每年长一岁 for (int i=0;i&lt;res.size();i++) &#123; res[i]++; &#125; // over for (int i=0;i&lt;res.size();i++) &#123; if (res[i] &gt;= x) res.erase(res.begin() + i); else i++; &#125; // 生孩子 for (int i=0;i&lt;res.size();i++) &#123; if (res[i]&gt;= 2 &amp;&amp; res[i] &lt; x) &#123; res.push_back(0); &#125; &#125; if (res.size() &gt; 10) &#123; res.erase(res.begin()); res.erase(res.begin()); &#125; &#125; int num = 0; for (auto x : res) num += x; cout &lt;&lt; num * 2 &lt;&lt; endl;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"算法专题_贪心法","slug":"技术/数据结构和算法/算法专题-贪心法","date":"2017-08-17T11:57:30.000Z","updated":"2019-03-28T00:54:56.255Z","comments":true,"path":"2017/08/17/技术/数据结构和算法/算法专题-贪心法/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/08/17/技术/数据结构和算法/算法专题-贪心法/","excerpt":"贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。 贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。","text":"贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。 贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。 任务安排问题 Maximum Length of Pair Chain 按照结束时间排序，贪心的选择结束时间最早的。 12 整数分解求乘积最大 leetcode 分解策略是尽可能的分解成2，3， 尽可能均匀的分解成2，3 123456789101112131415161718192021class Solution &#123;public: int integerBreak(int n) &#123; vector&lt;int&gt; dp = &#123;1,2,4,6,9&#125;; if(n &lt;= 6) return dp[n-2]; int c3 = 0, c2 = 0; while(n - 3 &gt;= 2)&#123; n = n - 3; c3++; &#125; if(n % 2 == 0)&#123; c2 = n / 2; &#125;else if( n % 3 == 0)&#123; c3 = c3 + n / 3; &#125; double re = pow(2.0,c2) * pow(3.0,c3); int res = re; return res; &#125;&#125;;","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"算法专题_hihocoder","slug":"技术/数据结构和算法/算法专题-hihocoder","date":"2017-08-13T12:19:33.000Z","updated":"2019-03-28T00:54:56.173Z","comments":true,"path":"2017/08/13/技术/数据结构和算法/算法专题-hihocoder/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/08/13/技术/数据结构和算法/算法专题-hihocoder/","excerpt":"hihocoder 每周编程比赛","text":"hihocoder 每周编程比赛 [Offer收割]编程练习赛22 顺序三元组 给定一个长度为N的数组A=[A1, A2, … AN]，已知其中每个元素Ai的值都只可能是1, 2或者3。 请求出有多少下标三元组(i, j, k)满足1 ≤ i &lt; j &lt; k ≤ N且Ai &lt; Aj &lt; Ak。 分析：统计2前面有多少个1，2前面有多少个12就可以了。 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;ll solve(vector&lt;int&gt; &amp;v,int n)&#123; if(v.empty() || n &lt;= 0) return 0; ll c1 = 0, c12 = 0, c123 = 0; for (int i = 0; i &lt; n; ++i) &#123; if(v[i] == 1)&#123; c1++; &#125;else if(v[i] == 2)&#123; c12 = c12 + c1; &#125;else if(v[i] == 3)&#123; c123 = c123 + c12; &#125;else&#123; // 输入数据有错 &#125; &#125; return c123;&#125;int main()&#123; freopen(\"d:/A.in\",\"r\",stdin); int n; cin &gt;&gt; n; vector&lt;int&gt; v(n,0); for (int i = 0; i &lt; n; ++i) &#123; cin&gt;&gt;v[i]; &#125; ll result = solve(v,n); cout&lt;&lt;result&lt;&lt;endl; return 0;&#125; 合并子目录 小Hi的电脑的文件系统中一共有N个文件，例如： /hihocoder/offer22/solutions/p1 /hihocoder/challenge30/p1/test /game/moba/dota2/uninstall 小Hi想统计其中一共有多少个不同的子目录。上例中一共有8个不同的子目录： /hihocoder /hihocoder/offer22 /hihocoder/offer22/solutions /hihocoder/challenge30 /hihocoder/challenge30/p1 /game /game/moba /game/moba/dota2/ 前缀树 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;int N;int ret = 0;struct FS &#123; string name; unordered_map&lt;string, FS*&gt; subs; FS(const string &amp;n): name(n)&#123;&#125;;&#125;;vector&lt;string&gt; parse(const string &amp;path) &#123; vector&lt;string&gt; ret; // 需要的字符串前后都有/,first_表示前面/的位置，second_表示后面.的位置 int first_ = 0; int second_ = 0; while(first_ &lt; path.size()) &#123; second_ = path.find('/', first_); // 没有找到/,退出循环 if (second_ == -1) &#123; break; &#125; if (second_ &gt; first_) &#123; ret.push_back(string(path.begin() + first_, path.begin() + second_)); &#125; first_ = second_ + 1; &#125; return ret;&#125;void dfs(FS *root) &#123; if (!root) return; ret++; for(auto p: root-&gt;subs) &#123; dfs(p.second); &#125;&#125;int main () &#123; freopen(\"d:/A.in\",\"r\",stdin); cin &gt;&gt; N; FS* root= new FS(\"\"); string path; for(int i = 0; i &lt; N; ++i) &#123; cin &gt;&gt; path; vector&lt;string&gt; dirs = parse(path); // 构造前缀树 auto cur = root; for(auto dir: dirs) &#123; if (cur-&gt;subs.count(dir) == 0) &#123; FS *ndir = new FS(dir); cur-&gt;subs[dir] = ndir; &#125; cur = cur-&gt;subs[dir]; &#125; &#125; // 遍历树，统计结果 dfs(root); cout &lt;&lt; ret - 1 &lt;&lt; endl; return 0;&#125; 缺失的拼图 小Hi在玩一个拼图游戏。如下图所示，整个拼图是由N块小矩形组成的大矩形。现在小Hi发现其中一块小矩形不见了。给定大矩形以及N-1个小矩形的顶点坐标，你能找出缺失的那块小矩形的顶点坐标吗？ 分析： 每个矩形用四个点的坐标来表示，那么如果不缺失矩形，每个点应该出现偶数次。缺失矩形的地方，每个点只出现奇数次，这样就能找到缺失矩形的坐标。 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(false); freopen(\"d:/A.in\",\"r\",stdin); int n; cin &gt;&gt; n; map&lt;pair&lt;int,int&gt;,int&gt; m; for (int i = 0; i &lt; n; ++i)&#123; int x1,y1,x2,y2; cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2; m[make_pair(x1,y1)]++; m[make_pair(x1,y2)]++; m[make_pair(x2,y1)]++; m[make_pair(x2,y2)]++; &#125; vector&lt;int&gt; xx; vector&lt;int&gt; yy; for (auto i : m) &#123; if(i.second % 2 == 0) continue; xx.push_back(i.first.first); yy.push_back(i.first.second); &#125; sort(xx.begin(),xx.end()); sort(yy.begin(),yy.end()); cout&lt;&lt;xx[0]&lt;&lt;\" \"&lt;&lt;yy[0]&lt;&lt;\" \"&lt;&lt;xx[3]&lt;&lt;\" \"&lt;&lt;yy[3]&lt;&lt;endl; return 0;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"算法专题_归并排序","slug":"技术/数据结构和算法/算法专题_归并排序","date":"2017-08-07T13:13:50.000Z","updated":"2019-03-28T00:54:56.605Z","comments":true,"path":"2017/08/07/技术/数据结构和算法/算法专题_归并排序/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/08/07/技术/数据结构和算法/算法专题_归并排序/","excerpt":"归并排序是分治法思想的典型应用。归并排序要处理好两件事，划分和合并。划分就是将待排序序列划分成子序列。合并就是如何将两个有序的子序列合并为一个有序的子序列。 归并的排序的思想是：首先把原来序列划分成n个子序列，每个子序列一个元素，这样每个子序列都可以看作是有序的。然后分别合并相邻的两个子序列，使合并之后的序列保持有序。这样，一趟归并之后子序列减少二分之一，直到最后归并为一个序列为止。","text":"归并排序是分治法思想的典型应用。归并排序要处理好两件事，划分和合并。划分就是将待排序序列划分成子序列。合并就是如何将两个有序的子序列合并为一个有序的子序列。 归并的排序的思想是：首先把原来序列划分成n个子序列，每个子序列一个元素，这样每个子序列都可以看作是有序的。然后分别合并相邻的两个子序列，使合并之后的序列保持有序。这样，一趟归并之后子序列减少二分之一，直到最后归并为一个序列为止。 归并排序的实现 归并排序中最重要的操作是如何将两个有序的序列合并为一个有序的序列。 这里合并两个有序序列的方法可以自己设计，我们使用逐个元素比较的方法，时间复杂度是O(a1+a2). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566void print(vector&lt;int&gt; v)&#123; for(auto a:v)&#123; cout&lt;&lt;a&lt;&lt;\" \"; &#125; cout&lt;&lt;\" | \";&#125;//合并两个有序的数组,返回新的有序的数组vector&lt;int&gt; merge(vector&lt;int&gt; &amp;v1,vector&lt;int&gt; &amp;v2)&#123; vector&lt;int&gt; re; size_t i=0,j=0; while(i&lt;v1.size() &amp;&amp; j&lt;v2.size())&#123; if(v1[i] &lt;= v2[j])&#123; re.push_back(v1[i]); i++; &#125;else&#123; re.push_back(v2[j]); j++; &#125; &#125; //把剩下的放在最后 for(size_t a = i;a&lt;v1.size();a++)&#123; re.push_back(v1[a]); &#125; for(size_t a=j;a&lt;v2.size();a++)&#123; re.push_back(v2[a]); &#125; return re;&#125;//归并排序的非递归实现vector&lt;int&gt; mergeSort2(vector&lt;int&gt; &amp;v)&#123; vector&lt;vector&lt;int&gt;&gt; group; // 一开始，每一个元素单独为一组，然后一步一步的合并相邻的组，直到最后只剩下一组。 for(int i=0;i&lt;v.size();i++) &#123; group.push_back(&#123;v[i]&#125;); &#125; int group_end = group.size(); // 指示结果，每次归并，都是合并相邻的两组数据，所以group的元素个数每次都减少一半，为了减少开销， //我们每次合并之后的数组还是放在原来的数组中，用group指示数组的结束。 //当group_end = 1的时候，所有的数组已经归并到一起了 while(group_end &gt; 1)&#123; for(size_t b=0;b&lt;group_end;b++)&#123; print(group[b]); &#125; cout&lt;&lt;endl; int j = 0; while(j+1&lt;group.size())&#123; group[j/2] = merge(group[j],group[j+1]); j = j + 2; &#125; // 个数是奇数的情况 if(j == group_end -1 )&#123; group[ceil(group_end / 2.0)-1] = group[group_end-1]; &#125; group_end = ceil(group_end / 2.0); &#125; print(group[0]); return group[0];&#125;int main() &#123; vector&lt;int&gt; v = &#123;49,38,65,97,76,13,27&#125;; auto a = mergeSort2(v); return 0;&#125; 运行结果: 123449 | 38 | 65 | 97 | 76 | 13 | 27 |38 49 | 65 97 | 13 76 | 27 |38 49 65 97 | 13 27 76 |13 27 38 49 65 76 97 | 归并排序的递归实现方法 ： 12345678910// 归并排序的递归实现vector&lt;int&gt; mergeSort(vector&lt;int&gt; &amp;v,int start,int end)&#123; if(start &gt;= end)&#123; return &#123;v[start]&#125;; &#125; int mid = (start + end) / 2; auto v1 = mergeSort(v,start,mid); // 递归左半部分的排序 auto v2 = mergeSort(v,mid+1,end); // 递归右半部分的排序 return merge(v1,v2);&#125; 归并排序的应用 统计数组的逆序对 归并排序是一种稳定的排序（合并两个有序数组的时候是稳定的），所以可以用来求数组的逆序对这样的问题。 归并排序是将数列a[l,h]分成两半a[l,mid]和a[mid+1,h]分别进行归并排序，然后再将这两半合并起来。 在合并的过程中（设l&lt;=i&lt;=mid，mid+1&lt;=j&lt;=h），当a[i]&lt;=a[j]时，并不产生逆序数；当a[i]&gt;a[j]时，在 前半部分中比a[i]大的数都比a[j]大，将a[j]放在a[i]前面的话，逆序数要加上mid-i+1。因此，可以在归并 排序中的合并过程中计算逆序数. 123456789101112131415161718192021222324252627282930313233343536//合并两个有序的数组,返回新的有序的数组vector&lt;int&gt; merge(vector&lt;int&gt; &amp;v1,vector&lt;int&gt; &amp;v2,int &amp;cc)&#123; vector&lt;int&gt; re; size_t i=0,j=0; while(i&lt;v1.size() &amp;&amp; j&lt;v2.size())&#123; if(v1[i] &lt;= v2[j])&#123; re.push_back(v1[i]); i++; &#125;else&#123; re.push_back(v2[j]); cc = cc + v1.size() - i; //增加统计逆序对的功能，以传递引用的方法返回结果，注意传入的参数的初始值要为0； j++; &#125; &#125; //把剩下的放在最后 for(size_t a = i;a&lt;v1.size();a++)&#123; re.push_back(v1[a]); &#125; for(size_t a=j;a&lt;v2.size();a++)&#123; re.push_back(v2[a]); &#125; return re;&#125;//归并排序的递归实现vector&lt;int&gt; mergeSort(vector&lt;int&gt; &amp;v,int start,int end,int &amp;cc)&#123; if(start &gt;= end)&#123; return &#123;v[start]&#125;; &#125; int mid = (start + end) / 2; auto v1 = mergeSort(v,start,mid,cc); // 递归左半部分的排序 auto v2 = mergeSort(v,mid+1,end,cc); // 递归右半部分的排序 return merge(v1,v2,cc);&#125;//使用的使用定义int cc = 0; 传入函数即可。 统计数组的逆序对，还可以使用树状数组，不过就复杂度而言，使用归并排序已经足够了。 另外一种归并排序的实现方法，尽量少的占用额外的空间。 1234567891011121314151617181920212223242526272829303132333435363738void merge(vector&lt;int&gt; &amp;v,int s1,int e1, int s2, int e2)&#123; vector&lt;int&gt; tmp; int ss1 = s1, ss2 = s2; while(s1&lt;=e1 &amp;&amp; s2 &lt;= e2)&#123; if(v[s1] &lt; v[s2])&#123; tmp.push_back(v[s1]); s1++; &#125; if(v[s1] &gt;= v[s2])&#123; tmp.push_back(v[s2]); s2++; &#125; &#125; if(s1 &lt;= e1)&#123; tmp.insert(tmp.end(),v.begin() + s1,v.begin() + e1+1); &#125; if(s2 &lt;= e2)&#123; tmp.insert(tmp.end(),v.begin() + s2,v.begin() + e2+1); &#125; int t = 0; for(int i=ss1;i&lt;=e1;i++)&#123; v[i] = tmp[t]; t++; &#125; for(int i = ss2;i&lt;=e2;i++)&#123; v[i] = tmp[t]; t++; &#125; tmp.clear(); return ;&#125;void mergeSort(vector&lt;int&gt; &amp;v,int start,int end)&#123; if(start &gt;= end) return; int mid = (start+end) / 2; mergeSort(v,start,mid); mergeSort(v,mid+1,end); merge(v,start,mid,mid+1,end);&#125; 统计逆序对 在归并排序归并两个已经排好序的数组的时候，是统计逆序对的最好时机。假设两个待合并的序列为v1,v2, 有两个指针s1,s2分别指向v1,v2,当v1[s1] &gt; v2[s2]的时候，(v1.size() - s1), 也就是从s1到v1的结尾的所有元素都会和v[s2]组成逆序对。 123456789101112131415161718192021222324252627282930313233343536373839void merge(vector&lt;int&gt; &amp;v,int s1,int e1, int s2, int e2, int &amp;cc)&#123; vector&lt;int&gt; tmp; int ss1 = s1, ss2 = s2; while(s1&lt;=e1 &amp;&amp; s2 &lt;= e2)&#123; if(v[s1] &lt;= v[s2])&#123; tmp.push_back(v[s1]); s1++; &#125; if(v[s1] &gt; v[s2])&#123; tmp.push_back(v[s2]); s2++; cc += e1-s1+1; // 记录逆序对的数量 &#125; &#125; if(s1 &lt;= e1)&#123; tmp.insert(tmp.end(),v.begin() + s1,v.begin() + e1+1); &#125; if(s2 &lt;= e2)&#123; tmp.insert(tmp.end(),v.begin() + s2,v.begin() + e2+1); &#125; int t = 0; for(int i=ss1;i&lt;=e1;i++)&#123; v[i] = tmp[t]; t++; &#125; for(int i = ss2;i&lt;=e2;i++)&#123; v[i] = tmp[t]; t++; &#125; tmp.clear(); return ;&#125;void mergeSort(vector&lt;int&gt; &amp;v,int start,int end,int &amp;cc)&#123; if(start &gt;= end) return ; int mid = (start+end) / 2; mergeSort(v,start,mid,cc); mergeSort(v,mid+1,end,cc); merge(v,start,mid,mid+1,end,cc);&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"算法专题_快速排序","slug":"技术/数据结构和算法/算法专题_快速排序","date":"2017-08-07T13:13:31.000Z","updated":"2019-03-28T00:54:56.629Z","comments":true,"path":"2017/08/07/技术/数据结构和算法/算法专题_快速排序/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/08/07/技术/数据结构和算法/算法专题_快速排序/","excerpt":"快速排序是分治思想的典型应用，它的时间复杂度是o(nlogn),在数据没有特殊的规律的情况下，快速排序是首选的排序方法。它的思想也经常用来出各种算法题目。","text":"快速排序是分治思想的典型应用，它的时间复杂度是o(nlogn),在数据没有特殊的规律的情况下，快速排序是首选的排序方法。它的思想也经常用来出各种算法题目。 快排算法 快速排序的基本思想是每次选择一个基准元素，调整数组，使得所有比基准元素小的元素都位于左边，所有比基准元素大的元素都位于基准元素的右边，从而使得基准元素放在了正确的位置上。然后以基准元素为准，把数组分成两个部分，递归的应用上面的方法，得到最终的结果。所以，快速排序的实现也有递归的版本和非递归的版本。一般使用递归的版本就够了。 1234567891011121314151617181920212223242526272829303132333435int partition(vector&lt;int&gt; &amp;v,int i,int j)&#123; // 以i指向的元素为基准元素 bool base = true; // base = true 表示此时 i 指向base 元素， base = false 表示此时j 指向base元素 while(i &lt; j)&#123; if(v[i] &gt; v[j] &amp;&amp; base)&#123; swap(v[i],v[j]); base = false; i++; &#125; if(v[i] &gt; v[j] &amp;&amp; !base)&#123; swap(v[i],v[j]); base = true; j--; &#125; if(base)&#123; j--; &#125; if(!base)&#123; i++; &#125; &#125; return i;&#125;/** * 快速排序 * @param v 待排序数组 * @param start 起始位置下标 * @param end 结束位置下标 */void quickSort(vector&lt;int&gt; &amp;v,int start, int end)&#123; if(start &gt;= end) return; int mid = partition(v,start,end); quickSort(v,start,mid-1); quickSort(v,mid+1,end);&#125; 快排的应用 N个元素中查找第K小的元素(o(n)时间内) 如果查找最小的元素，只需要遍历一遍数组即可。如果是第2小的，首先遍历一遍找到最小的，然后再遍历一遍就可以找到第二小的了。所以，朴素的解法需要的时间复杂度是o(kn),与k有关系。 快速排序partition函数的特点是每次能确定一个元素排好序之后应该在的位置。假设partition(0,n-1) = i, 我们可以获得这样的信息，[0..i-1]位置的元素都比A[i]小，而i后面的元素都比A[i]大。这样，我们每次调用partition都可以去掉一半元素，这样时间复杂度就能降到o(n)了。 lintcode 1234567891011121314int Kth(vector&lt;int&gt; &amp;v, int k)&#123; if(v.empty() || k &lt;= 0) return -1; int begin = 0; int end = v.size() - 1; while(true)&#123; int i = partition(v,begin,end); if(i+1 == k) return v[i]; if(i+1 &lt; k)&#123; begin = i + 1; &#125;else&#123; end = i - 1; &#125; &#125;&#125; leetcode 1234567891011121314151617181920212223242526272829303132333435363738int partition(vector&lt;int&gt; &amp;v,int i, int j)&#123; if(i &gt; j) return -1; int tmp; int start = i; int end = j; bool base = true; // 指示 i 是否指向base 元素，如果i 不指向base元素，则j肯定指向base元素。 while(i &lt; j)&#123; if(v[i] &gt; v[j] &amp;&amp; base)&#123; tmp = v[j]; v[j] = v[i]; v[i] = tmp; i = i + 1; base = false; &#125;else if(v[i] &gt; v[j] &amp;&amp; !base)&#123; tmp = v[j]; v[j] = v[i]; v[i] = tmp; j = j - 1; base = true; &#125;else if(base)&#123; j--; &#125;else&#123; i++; &#125; &#125; return i;&#125;int kthLargestElement(vector&lt;int&gt;&amp; nums, int k) &#123; int left = 0, right = nums.size() - 1, len = nums.size(); while (true) &#123; int pos = partition(nums, left, right); if (len - pos == k ) return nums[pos]; if (len - pos &lt; k) right = pos - 1; else left = pos + 1; &#125; return -1;&#125; 查找中位数 一般的做法是排序，返回中间的数字，但是这样的时间复杂度是o(nlogn). 其实还有o(n)的算法，和上面一样，也是利用了快速排序的partition函数。 lintcode 12345int median(vector&lt;int&gt; &amp;nums) &#123; if(nums.empty()) return -1; int len = nums.size(); return kthLargestElement(nums,len / 2 + 1);&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"算法专题_二叉堆","slug":"技术/数据结构和算法/算法专题_二叉堆","date":"2017-08-06T00:53:25.000Z","updated":"2019-03-28T00:54:56.311Z","comments":true,"path":"2017/08/06/技术/数据结构和算法/算法专题_二叉堆/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/08/06/技术/数据结构和算法/算法专题_二叉堆/","excerpt":"堆，或者更准确的叫作二叉堆，是一种特殊的完全二叉树，通常分为最大堆和最小堆。最大堆是指堆顶的元素最大，堆顶的左右孩子的值小于等于它，然后左右子树也满足这个条件。最小堆是指堆顶的元素最小，左右孩子大于等于堆顶元素，左右子树也满足这个条件。 可以看到，堆是递归定义了，而且是一种完全二叉树。节点之间是有大小次序关系的。但是左右子树是没有顺序的。而二叉搜索树左右孩子是有次序的，不能颠倒。 既然堆是完全二叉树，就可以使用数组来简便的表示一棵树。假设一个节点的下标是i,那么它的左孩子为2*i,右孩子为2*i+1,父节点为i/2. 本文主要介绍二叉堆的构建，调整和有关应用(堆排序和优先队列)。注意这里假设根节点的标号是1. 如果根节点是从0开始标号的，那么对于节点i, 左孩子为2*i+1,右孩子为2*i+2,父节点为(i-1)/2.","text":"堆，或者更准确的叫作二叉堆，是一种特殊的完全二叉树，通常分为最大堆和最小堆。最大堆是指堆顶的元素最大，堆顶的左右孩子的值小于等于它，然后左右子树也满足这个条件。最小堆是指堆顶的元素最小，左右孩子大于等于堆顶元素，左右子树也满足这个条件。 可以看到，堆是递归定义了，而且是一种完全二叉树。节点之间是有大小次序关系的。但是左右子树是没有顺序的。而二叉搜索树左右孩子是有次序的，不能颠倒。 既然堆是完全二叉树，就可以使用数组来简便的表示一棵树。假设一个节点的下标是i,那么它的左孩子为2*i,右孩子为2*i+1,父节点为i/2. 本文主要介绍二叉堆的构建，调整和有关应用(堆排序和优先队列)。注意这里假设根节点的标号是1. 如果根节点是从0开始标号的，那么对于节点i, 左孩子为2*i+1,右孩子为2*i+2,父节点为(i-1)/2. 1234567891011// 根节点从0开始标号，对于节点i，求其左孩子，右孩子和父节点inline int left(int i)&#123; return (i&lt;&lt;1) + 1;&#125;inline int right(int i)&#123; return (i&lt;&lt;1) + 2;&#125;inline int parent(int i)&#123; if(i == 0) return -1; return (i-1) &gt;&gt; 1;&#125; 最大堆 最大堆就是满足父节点大于等于子节点的堆。最大堆的根节点是所有元素中最大的(但可能不是唯一的最大的，注意这里是大于等于)。 维护最大堆(调整最大堆) 假设A是存储堆的数组,A.length()表示数组的大小，heap_size表示堆中元素的个数, 满足heap_size &lt;= A.length().假设我们需要调整节点i以使得堆重新满足最大堆的性质(注意这个时候只有节点i是不满足最大堆的性质的)，步骤如下： 找出节点i的左右孩子l,r; 如果l,r超过了堆的大小，直接返回，如果A[i]大于等于l,r,直接返回 找到l,r中的较大者,记为maxIndex，和A[i]交换 令i = maxIndex, 转到1。 1234567891011121314151617181920212223242526/** * 调整节点i,使得整个堆保持最大堆的性质 * @param A * @param i */void max_heap(vector&lt;int&gt; &amp;A,int i)&#123; int heap_size = A.size(); // 不存在这个样的节点（节点从0开始编号） if(i &gt;= heap_size || i &lt; 0) return; auto l = left(i); auto r = right(i); // 如果没有孩子节点了，不需要调整了 if(l &gt;= heap_size ) return; int maxIndex = -1; if(r &gt;= heap_size )&#123; if(A[i] &gt;= A[l]) return; maxIndex = l; &#125;else&#123; // 如果节点i比它两个孩子节点都大，则满足最大堆的性质，不用调整 if(A[i] &gt;= A[l] &amp;&amp; A[i] &gt;= A[r]) return; // 找到两个孩子节点中较大的那一个 A[l] &gt;= A[r] ? maxIndex = l : maxIndex = r; &#125; swap(A[i],A[maxIndex]); max_heap(A,maxIndex);&#125; 1234567891011121314151617181920212223242526/** * 调整节点i,使得整个堆保持最小堆的性质 * @param A * @param i */void min_heap(vector&lt;int&gt; &amp;A,int i)&#123; int heap_size = A.size(); // 不存在这个样的节点（节点从0开始编号） if(i &gt;= heap_size || i &lt; 0) return; auto l = left(i); auto r = right(i); // 如果没有孩子节点了，不需要调整了 if(l &gt;= heap_size ) return; int minIndex = -1; if(r &gt;= heap_size ) &#123; if(A[i] &lt;= A[l]) return; minIndex = l; &#125;else&#123; // 如果节点i比它两个孩子节点都小，则满足最小堆的性质，不用调整 if(A[i] &lt;= A[l] &amp;&amp; A[i] &lt;= A[r]) return; // 找到两个孩子节点中较大的那一个 A[l] &lt;= A[r] ? minIndex = l : minIndex = r; &#125; swap(A[i],A[minIndex]); min_heap(A,minIndex);&#125; 建堆 如何从一个无序的数组建立一个堆是堆操作中一个基本的，但很重要的问题，它通常是很多问题的第一步。 根据完全二叉树的性质，一个包含n个元素的数组形成的完全二叉树中，n - ([n/2] + 1) + 1个元素是叶子节点。我们只需要针对所有的叶子节点之外的节点调用上面的重建堆的函数，就可以构建一个最大堆。 时间复杂度是O(n). 12345678910/** * 从无序数组建立最大堆 * @param A */void build_max_heap(vector&lt;int&gt; &amp;A)&#123; int leaf = A.size() / 2 ; for (int i = leaf - 1; i &gt;= 0 ; --i) &#123; max_heap(A,i); &#125;&#125; 12345678910/** * 从无序数组建立最小堆 * @param A */void build_min_heap(vector&lt;int&gt; &amp;A)&#123; int leaf = A.size() / 2; for (int i = leaf - 1; i &gt;= 0 ; --i) &#123; min_heap(A,i); &#125;&#125; 堆排序 堆排序就是利用堆的结构来维护最大值或者最小值实现排序的一种算法，这里以最大堆为例来说明。 首先把无序数组重建一个最大堆，使用上面提到的函数，这一步可以轻松的在O(n)的时间复杂度内完成。 此时A[0]存储的是这个数组的最大值，将它与数组的最后一个元素交换位置，然后堆的长度减少1，也就是数组的最后一个元素不再当作堆的元素，因为它已经在正确的位置上了，然后调整堆使之符合最大堆的性质。 重复这个步骤直到所有的元素放到了正确的位置之上。 12345678910111213141516171819202122232425262728293031323334353637void max_heap(vector&lt;int&gt; &amp;A,int heap_size,int i)&#123; // 不存在这个样的节点（节点从0开始编号） if(i &gt;= heap_size || i &lt; 0) return; auto l = left(i); auto r = right(i); // 如果没有孩子节点了，不需要调整了 if(l &gt;= heap_size ) return; int maxIndex = -1; if(r &gt;= heap_size )&#123; if(A[i] &gt;= A[l]) return; maxIndex = l; &#125;else&#123; // 如果节点i比它两个孩子节点都大，则满足最大堆的性质，不用调整 if(A[i] &gt;= A[l] &amp;&amp; A[i] &gt;= A[r]) return; // 找到两个孩子节点中较大的那一个 A[l] &gt;= A[r] ? maxIndex = l : maxIndex = r; &#125; swap(A[i],A[maxIndex]); max_heap(A,heap_size,maxIndex);&#125;void build_max_heap(vector&lt;int&gt; &amp;A)&#123; int leaf = A.size() / 2 ; for (int i = leaf - 1; i &gt;= 0 ; --i) &#123; max_heap(A,A.size(),i); &#125;&#125;void sort_with_max_heap(vector&lt;int&gt; &amp;v)&#123; build_max_heap(v); int heap_size = v.size(); while(heap_size)&#123; swap(v[0],v[heap_size-1]); heap_size--; max_heap(v,heap_size,0); &#125;&#125; 堆排序的时间性能是nlogn,但是实际使用的时候，快速排序的性能更好一些，一般情况下都是使用快速排序。 优先队列 优先队列是能够快速的完成以下操作的数据结构： 返回最大值 返回最大值并删除该元素 将任意一个已在优先队列中的元素增加k. 插入一个任意值 能够维护一个数据结构，快速的实现以上所有操作的叫做优先队列。使用堆来实现优先队列，可以保证所有的操作都可以在o(lgn)完成。 返回最大值 使用最大堆实现优先队列这种结构，直接返回A[0]就是最大值。 返回最大值并删除该元素 首先输出A[0], 然后把最后一个元素赋值给A[0],调整堆使之符合最大堆性质。 1234567int maxP(vector&lt;int&gt; &amp;A)&#123; int maxV = A[0]; A[0] = A[A.size()-1]; int heap_size = A.size()-1; max_heap(A,heap_size,0); return maxV;&#125; 直接使用STL进行堆操作 C++11 中的STL已经有了堆的各种操作的高效实现，我们可以直接使用。既能减少自己编写出错的概率，也能使得代码更加简洁，效率更高。 建堆 建立最大堆 12345678#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;// v 是一个无序的数组make_heap(v.begin(),v.end());// 或者使用make_heap(v.begin(),v.end(),less&lt;int&gt;()); 建立最小堆 1make_heap(v.begin(),v.end(),greater&lt;int&gt;()); make_heap()方法的第三个参数其实可以传入一个函数的实例，表示你怎样比较两个元素。例如我们可以自己实现less方法。 1234567891011// 大根堆bool mless(const int &amp;a,const int &amp;b)&#123; return a &lt;= b;&#125;make_heap(v.begin(),v.end(),mless);//小根堆bool mgreater(const int &amp;a,const int &amp;b)&#123; return a &gt;= b;&#125;make_heap(v.begin(),v.end(),mgreater); 当堆中存放的数据不是简单的数字，而是复杂的结构体或者类数据的时候，自定义比较函数就十分有用了，可以自定义依据类中哪个字段生成堆。 其他与堆有关的操作 1234567891011// 弹出大根堆的顶部元素，重排堆，注意这个时候顶部元素没有删除，放在了数组的最后pop_heap(v.begin(),v.end(),less&lt;int&gt;())// 弹出小根堆的顶部元素pop_heap(v.begin(),v.end(),greater&lt;int&gt;())// 把[v.begin(), v.end()-2] 作为大根堆，v.end()-1, 也就是最后一个元素作为插入元素插入到大根堆中，重新调整好顺序push_heap(v.begin(),v.end(),less&lt;int&gt;())// 插入小根堆push_heap(v.begin(),v.end(),less&lt;int&gt;()) 优先队列 priority_queue&lt;Type, Container, Functional&gt; 实现了优先队列的结构和相应的操作方法，可以用他来实现大根堆，小根堆，优先队列等数据结构。 大根堆 123456789101112priority_queue&lt;int&gt; q;// 或者使用完整的声明形式priority_queue&lt;int,vector&lt;int&gt; less&lt;int&gt;()&gt; q;// 从无序数组建立大顶堆vector&lt;int&gt; v = &#123;5,4,10,14,7,9,3,2,8,30&#125;;for (int i = 0; i &lt; v.size(); ++i) &#123; q.push(v[i]);&#125;// 弹出最大元素q.pop() 小根堆 12345678910priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;// 从无序数组建立小顶堆vector&lt;int&gt; v = &#123;5,4,10,14,7,9,3,2,8,30&#125;;for (int i = 0; i &lt; v.size(); ++i) &#123; q.push(v[i]);&#125;// 弹出最大元素q.pop()","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"算法专题_链表2","slug":"技术/数据结构和算法/算法专题_链表2","date":"2017-07-26T10:46:20.000Z","updated":"2019-03-28T00:54:57.135Z","comments":true,"path":"2017/07/26/技术/数据结构和算法/算法专题_链表2/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/07/26/技术/数据结构和算法/算法专题_链表2/","excerpt":"【翻转链表】【删除重复元素】【判断有环】【合并链表】【复杂链表的复制】【…】","text":"【翻转链表】【删除重复元素】【判断有环】【合并链表】【复杂链表的复制】【…】 反转链表 1234567891011121314151617181920212223/*** 1. 如果是空链表，或者只有一个元素，直接返回头节点* 2. pre --&gt; head, iter --&gt; head-&gt;next, pre-&gt;next = nullptr;* pre 指向第一个元素，iter指向第二个节点(可能为空，为空说明到达了链表的结尾)，断开前两个节点之间的连接* 3. while(iter!=nullptr) 转换pre iter指向的节点的连接。* 首先用一个新的节点变量存储iter的下一个节点信息，node = iter-&gt;next* iter-&gt;next = pre;* pre = iter;* iter = node;*/ListNode *reverse(ListNode *head)&#123; if(!head || !head-&gt;next) return head; ListNode* pre = head; ListNode* iter = head-&gt;next; pre-&gt;next = nullptr; while(iter)&#123; ListNode* next = iter-&gt;next; iter-&gt;next = pre; pre = iter; iter = next; &#125; return pre;&#125; 局部翻转链表 123456789101112131415161718192021222324252627282930313233343536373839ListNode * reverseBetween(ListNode * head, int m, int n) &#123; // 翻转从m到n之间的链表，连接在原来的链表上 if(!head || !head-&gt;next || m &lt;=0 || n &lt;=0 || m &gt;= n) return head; // 1. 增加一个头节点 ListNode* g = new ListNode(0); g-&gt;next = head; head = g; ListNode* pre_start = head; ListNode* end_next = head; // 1. 找到第m个节点的前一个节点 m = m - 1; while(pre_start &amp;&amp; m--)&#123; pre_start = pre_start-&gt;next; &#125; // 2. 找到第n个节点的后一个节点 n = n + 1; while(end_next &amp;&amp; n--)&#123; end_next = end_next-&gt;next; &#125; if(m &gt;0 || n&gt;0) return head; // 3. 翻转m 到 n之间的链表 ListNode* stmp = pre_start-&gt;next; ListNode* start = pre_start-&gt;next; ListNode* end = start-&gt;next; start-&gt;next = nullptr; while(end != end_next)&#123; ListNode* tmp = end-&gt;next; end-&gt;next = start; start = end; end = tmp; &#125; // 4. 连接到原来的链表上 pre_start-&gt;next = start; stmp-&gt;next = end; return head-&gt;next;&#125; K组翻转链表 1234567891011121314151617181920212223242526272829303132333435363738ListNode *reverseKGroup(ListNode *head, int k) &#123; // 每K个节点翻转一下链表 if(!head || k &lt;= 1) return head; // 增加一个头节点 ListNode* g = new ListNode(0); g-&gt;next = head; head = g; ListNode* pre_start = head; ListNode* end_next = head; while(true)&#123; // 1. 找到第K个节点的下一个节点 int cc = k + 1; while(end_next &amp;&amp; cc--)&#123; end_next = end_next-&gt;next; &#125; if(cc &gt; 0) break; // 不足K个节点的部分不翻转 // 2. 翻转K个节点 ListNode* start = pre_start-&gt;next; ListNode* stmp = pre_start-&gt;next; ListNode* end = start-&gt;next; while(end &amp;&amp; end != end_next)&#123; ListNode* tmp = end-&gt;next; end-&gt;next = start; start = end; end = tmp; &#125; //3. 连接到原来的链表 pre_start-&gt;next = start; stmp-&gt;next = end_next; //4. 维护pre_start, end_start在正确的位置上，执行下一次循环 pre_start = end_next = stmp; &#125; return head-&gt;next;&#125; 删除链表中倒数第n个节点 使用两个指针，遍历一遍链表就能解决； 1234567891011121314151617181920212223242526/*** 删除倒数第K个节点，我们需要找到倒数第K+1个节点* 1. 设链表的长度是n, 1&lt;=k&lt;=n* 2. 用两个间隔是K的指针，当第二个指针指向链表的null元素的时候，第一个指针指向导数第K+1个节点* 3. 在链表的第一个节点的前面添加一个节点guard; first --&gt; guard* 4. second = guard-&gt;next; second向后移动K步，如果在K大于0的时候循环结束，表示没有导数第K个元素，返回原来的链表* 循环退出的时候，first 和second间隔K个节点，此时同时移动first second, second到达链表结尾的时候，first指向导数第K+1个节点，* 5. 删除节点： first-&gt;next = first-&gt;next-&gt;next;*/ListNode *removeNthFromEnd(ListNode *head, int n) &#123; ListNode *g = new ListNode(0); g-&gt;next = head; head = g; ListNode* first = g; ListNode* second = g-&gt;next; while(second &amp;&amp; n--)&#123; second = second -&gt; next; &#125; if(n &gt; 0) return head-&gt;next; // n超过了链表的长度 while(second)&#123; first = first-&gt;next; second = second-&gt;next; &#125; first-&gt;next = first-&gt;next-&gt;next; return head-&gt;next;&#125; 判断链表是否有环 123456789101112131415161718192021222324/*** 1. head=null 或者 head-&gt;next = null，肯定无环* 2. first = second = head;* 3. do&#123;&#125;while(); first == second时候循环结束，说明链表有环；* 4. 一旦找到环，把first = head, 然后一步一步的移动first second, 再次相遇的地方就是环的入口。*/bool hasCycle(ListNode *head) &#123; if(!head || !head-&gt;next) return false; ListNode* first = head; ListNode* second = head; do&#123; first = first-&gt;next; second = second-&gt;next-&gt;next; &#125;while(first &amp;&amp; second &amp;&amp; second-&gt;next &amp;&amp; second != first); if(!first || !second || !second-&gt;next) return false; // 找到入口节点 first = head; while(first != second)&#123; first = first-&gt;next; second = second-&gt;next; &#125; return true;&#125; 判断链表是否相交 两种思路： 一种先遍历一遍两个链表，得出每个链表的长度，将尾部对其，判断 另外一种，将一个链表的尾部连接到其头结点，从另外一个链表的头节点开始遍历，转换成判断链表是否有环的问题。 123456789101112131415161718192021222324252627282930bool hasCycle(ListNode *head,ListNode* &amp;enter) &#123; if(!head || !head-&gt;next || !head-&gt;next-&gt;next) return false; ListNode* first = head; ListNode* second = head; do&#123; first = first-&gt;next; second = second-&gt;next-&gt;next; &#125;while(first &amp;&amp; second &amp;&amp; second-&gt;next &amp;&amp; first != second); if(!first || !second || !second-&gt;next) return false; // 找到入口节点 first = head; while(first != second)&#123; first = first-&gt;next; second = second-&gt;next; &#125; enter = first; return true;&#125;ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; if(!headA || !headB) return nullptr; ListNode* iterA = headA; while(iterA-&gt;next !=nullptr)&#123; iterA = iterA-&gt;next; &#125; iterA-&gt;next = headA; ListNode* enter; hasCycle(headB,enter); return enter;&#125; 合并K个排序的链表 第一方法，用一个数组保存K个链表的头指针，每次都比较K个元素的大小，选出最小的元素，链接到新的链表的结尾，然后该链表向下一个节点移动一位。 利用上面的思路，每次都要从K个元素中选择最小的元素，可以使用一个K个元素的最小堆实现，降低时间复杂度。 利用归并的思想，两两合并； 12345678910111213141516171819202122232425262728293031323334353637// 第一种方法// 每次找出最小值的方式 ListNode *mergeKLists(vector&lt;ListNode *&gt; &amp;lists) &#123; // write your code here ListNode* guard = new ListNode(0); ListNode* head = guard; // current 指向K个链表的头指针 vector&lt;ListNode*&gt; currents; for(auto link : lists)&#123; if(link != nullptr) currents.push_back(link); &#125; int index = 0; while(!currents.empty())&#123; int minV = INT32_MAX; for(int i = 0; i &lt; currents.size();++i)&#123; // 去掉已经为空的链表 if(currents[i] == nullptr)&#123; currents.erase(currents.begin()+i); &#125; if(currents[i]-&gt;val &lt; minV)&#123; index = i; minV = currents[i]-&gt;val; &#125; &#125; guard-&gt;next = currents[index]; guard = guard-&gt;next; if(currents[index]-&gt;next != nullptr) currents[index] = currents[index]-&gt;next; else currents.erase(currents.begin()+index); &#125; return head-&gt;next;&#125; 第二种方法， 最小堆 12345678910111213141516171819202122232425262728// 第二种方法， 最小堆ListNode *mergeKLists(vector&lt;ListNode *&gt; &amp;lists) &#123; priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,bigger&gt; minHeap; if(lists.empty()) return nullptr; for(int i=0;i&lt;lists.size();i++)&#123; if(lists[i]) minHeap.push(lists[i]); &#125; ListNode *head = nullptr; ListNode *iter = nullptr; while(!minHeap.empty())&#123; if(head == nullptr)&#123; head = minHeap.top(); iter = head; if(minHeap.top()-&gt;next)&#123; minHeap.push(minHeap.top()-&gt;next); &#125; minHeap.pop(); &#125;else&#123; iter-&gt;next = minHeap.top(); iter = iter-&gt;next; if(minHeap.top()-&gt;next)&#123; minHeap.push(minHeap.top()-&gt;next); &#125; minHeap.pop(); &#125; &#125; return head;&#125; 第三种方法,归并排序的方式 12345678910111213141516171819202122232425262728293031323334353637// 第三种方法,归并排序的方式// 通过调用合并两个排序链表的方式实现ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) &#123; // write your code here ListNode* guard = new ListNode(0); ListNode* head = guard; while(l1 &amp;&amp; l2)&#123; if(l1-&gt;val &gt; l2-&gt;val)&#123; guard-&gt;next = l2; guard = guard-&gt;next; l2 = l2-&gt;next; &#125;else&#123; guard-&gt;next = l1; guard = guard-&gt;next; l1 = l1-&gt;next; &#125; &#125; if(l1)&#123; guard-&gt;next = l1; &#125; if(l2)&#123; guard-&gt;next = l2; &#125; return head-&gt;next;&#125;ListNode *mergeKLists(const vector&lt;ListNode *&gt; &amp;lists) &#123; if(lists.empty()) return nullptr; if(lists.size() == 1) return lists[0]; if(lists.size() == 2) return mergeTwoLists(lists[0],lists[1]); size_t n = lists.size(); vector&lt;ListNode*&gt; left((n+1)/2),right(n-(n+1)/2); copy(lists.begin(),lists.begin()+(n+1)/2,left.begin()); copy(lists.begin()+(n+1)/2,lists.end(),right.begin()); return mergeTwoLists(mergeKLists(left),mergeKLists(right));&#125; 上面采用的是自顶向下的递归归并的方式，下面采用非递归的自底向上的方法来实现 123456789101112131415161718192021// 简单的实现一个数据的归并求和// 自底向上归并int solve(vector&lt;int&gt; &amp;v)&#123; size_t end = v.size() - 1; if(end &lt; 0) throw \"\"; if(end == 0) return v[0]; while(end &gt; 0)&#123; int index = 0; for(int i=0;i&lt;=end;i+=2)&#123; if(i+1 &lt;= end)&#123; v[index] = add(v[i],v[i+1]); index++; &#125;else&#123; v[index] = v[i]; index++; &#125; &#125; end = index - 1; &#125; return v[0];&#125; 12345678910111213141516171819202122ListNode *mergeKLists(vector&lt;ListNode *&gt; &amp;lists) &#123; if(lists.empty()) return nullptr; if(lists.size() == 1) return lists[0]; if(lists.size() == 2) return mergeTwoLists(lists[0],lists[1]); size_t end = lists.size() - 1; while(end &gt; 0)&#123; int index = 0; for(int i=0;i&lt;=end;i+=2)&#123; if(i+1 &lt;= end)&#123; lists[index] = mergeTwoLists(lists[i],lists[i+1]); index++; &#125;else&#123; lists[index] = lists[i]; index++; &#125; &#125; end = index - 1; &#125; return lists[0];&#125; 带随机指针链表的复制|复杂链表的复制 使用O（1）的额外空间完成链表的复制，基本思路是把拷贝的新节点链接在原来节点的后面，设置完随机指针之后再断开与原来旧链表的连接。 12345678910111213141516171819202122232425262728RandomListNode *copyRandomList(RandomListNode *head) &#123; // write your code here if(!head) return head; RandomListNode* iter = head; // 1. 复制每个节点连接在原来节点的后面 while(iter)&#123; RandomListNode* node = new RandomListNode(iter-&gt;label); node-&gt;next = iter-&gt;next; iter-&gt;next = node; iter = node-&gt;next; &#125; // 2. 设置随机指针 RandomListNode* newHead = head-&gt;next; head-&gt;next-&gt;random = head-&gt;random==nullptr ? nullptr : head-&gt;random-&gt;next; iter = newHead-&gt;next; while(iter)&#123; RandomListNode* next = iter-&gt;next-&gt;next; iter-&gt;next-&gt;random = iter-&gt;random == nullptr ? nullptr : iter-&gt;random-&gt;next; iter = next; &#125; // 3. 断开和旧链表的连接 iter = newHead; while(iter-&gt;next)&#123; iter-&gt;next = iter-&gt;next-&gt;next; iter = iter-&gt;next; &#125; return newHead;&#125; 删除链表元素 删除链表节点为某个值的所有元素。(某个值可能有多个，也可能全部都是) 1234567891011121314151617181920ListNode *removeElements(ListNode *head, int val) &#123; // Write your code here ListNode *guard=new ListNode(0); guard-&gt;next = head; head = guard; ListNode *pre = guard; ListNode *tmp = guard-&gt;next; while(tmp)&#123; if(tmp-&gt;val == val)&#123; pre-&gt;next = tmp-&gt;next; tmp = tmp-&gt;next; &#125;else&#123; pre = tmp; tmp = tmp -&gt; next; &#125; &#125; return head-&gt;next; &#125; 不使用哨兵的方法，在要求不使用额外空间的时候可以用这种方法。 123456789101112131415161718192021ListNode *removeElements(ListNode *head, int val) &#123; // Write your code here // 删除链表中等于给定值val的所有节点 while(head &amp;&amp; head-&gt;val == val)&#123; head = head-&gt;next; &#125; if(head == nullptr) return head; ListNode *pre = head; ListNode *c = head-&gt;next; // 头结点已经不可能==val了，因为前面已经删除了 while(c)&#123; if(c-&gt;val == val)&#123; pre-&gt;next = c-&gt;next; c-&gt;next= nullptr; c = pre-&gt;next; &#125;else&#123; pre = c; c = c-&gt;next; &#125; &#125; return head;&#125; 在O(1)时间复杂度删除链表节点 思路：给出要删除的节点，是不可能在O(1)的时间内删除该节点的，因为想要删除该节点，必须找到它前面的节点，这个操作只能从头遍历(在没有指向前面的指针的情况下)，复杂度不可能是O(1). 但是可以把要删除的节点后面的节点的值赋给要删除的节点，再删除要删除的节点后面的节点，这样’看起来’好像删除了当前的节点。实际上在计算机内存中真正的变化是要删除的节点的值变成了它后面节点的值. 12345void deleteNode(ListNode *node) &#123; // write your code here node-&gt;val = node-&gt;next-&gt;val; node-&gt;next = node-&gt;next-&gt;next;&#125; 删除排序链表中的重复元素 给定一个排序链表，删除所有重复的元素每个重复元素只留下一个。 遇到不同的元素的时候再删除。 12345678910111213141516171819ListNode *deleteDuplicates(ListNode *head) &#123; // write your code here if(head == nullptr || head-&gt;next == nullptr) return head; ListNode *pre = head; ListNode *current = head-&gt;next; while(current)&#123; if(pre-&gt;val == current-&gt;val)&#123; current = current-&gt;next; &#125;else&#123; pre-&gt;next = current; pre = current; current = current-&gt;next; &#125; &#125; // 链表结尾有重复元素的情况 pre-&gt;next = current; return head;&#125; 一旦遇到相同的元素就删除。 1234567891011121314151617ListNode *deleteDuplicates(ListNode *head) &#123; // 给定一个排序链表，删除所有重复的元素每个元素只留下一个。 if(head == nullptr || head-&gt;next == nullptr) return head; if(head-&gt;next-&gt;next == nullptr &amp;&amp; head-&gt;val == head-&gt;next-&gt;val) return head-&gt;next; ListNode *pre = head; ListNode *c = head-&gt;next; while(c)&#123; if(pre-&gt;val == c-&gt;val)&#123; pre-&gt;next = c-&gt;next; c = c-&gt;next; &#125;else&#123; pre = pre-&gt;next; c = c-&gt;next; &#125; &#125; return head;&#125; 删除排序链表中的重复元素2 给定一个排序链表，删除所有重复的元素只留下原链表中没有重复的元素。 1234567891011121314151617181920212223ListNode * deleteDuplicates(ListNode *head) &#123; //给定一个排序链表，删除所有重复的元素只留下原链表中没有重复的元素。 ListNode *guard = new ListNode(0); guard-&gt;next = head; head = guard; ListNode *pre = guard; ListNode *start = guard-&gt;next; ListNode *end = guard-&gt;next; while(end)&#123; while(end &amp;&amp; start-&gt;val == end-&gt;val)&#123; end = end-&gt;next; &#125; if(start-&gt;next == end)&#123; pre = start; start = end; &#125;else&#123; pre-&gt;next = end; start = end; &#125; &#125; return head-&gt;next;&#125; 不使用哨兵节点的方案 1234567891011121314151617181920212223ListNode * deleteDuplicates(ListNode *head) &#123; //给定一个排序链表，删除所有重复的元素只留下原链表中没有重复的元素。 ListNode *pre = head; ListNode *start = head; ListNode *end = head; while(end)&#123; while(end &amp;&amp; start-&gt;val == end-&gt;val)&#123; end = end-&gt;next; &#125; if(start-&gt;next == end)&#123; pre = start; start = end; &#125;else&#123; if(pre == start &amp;&amp; pre == head)&#123; head = end; pre = end; &#125; else pre-&gt;next = end; start = end; &#125; &#125; return head;&#125; 删除单向链表中倒数第K个节点 例如：head--&gt;1--&gt;2--&gt;3--&gt;4--&gt;5--&gt;6 K=2 返回：head--&gt;1--&gt;2--&gt;3--&gt;4--&gt;6 思路一： 先遍历一遍链表，统计链表有多少个元素。然后就可以知道倒数第K个元素就是 正数第n-k+1个元素，从head开始移动指针，移动n-k次就是要删除的节点。 删除一个节点，只需要把原来指向这个元素的指针指向它后面的元素就可以了。所以我们要做的 操作就是从head开始，移动n-k-1次，找到要删除的节点前面的节点a,然后执行a-&gt;next = a-&gt;next-&gt;next 1234567891011121314151617181920ListNode *removeNthFromEnd(ListNode *head, int n) &#123; // write your code here int len = 0; ListNode *tmp = head; while(tmp)&#123; len ++; tmp = tmp-&gt;next; &#125; if(len &lt; n) return nullptr; if(len == n) return head-&gt;next; tmp = head; int count = len + 1 - n ;// 正数第count个节点 count = count - 2; while(count--)&#123; tmp = tmp-&gt;next; &#125; tmp-&gt;next = tmp-&gt;next-&gt;next; return head;&#125; 思路二：使用两个间隔K个元素的指针遍历一遍链表，当前面的指针走到尾节点的时候，后面的节点指向的就是倒数第K个节点。 123456789101112131415161718ListNode *removeNthFromEnd(ListNode *head, int n) &#123; // write your code here if(head == nullptr) return nullptr; ListNode *first = head; ListNode *second = head; int count = n + 1; while(first &amp;&amp; count--)&#123; first = first-&gt;next; &#125; if(first == nullptr) return head-&gt;next; // 删除第一个节点 if(count &gt; 0) return nullptr; // 没有导数第n个节点 while(first)&#123; first = first-&gt;next; second = second-&gt;next; &#125; second-&gt;next = second-&gt;next-&gt;next; return head;&#125; 查找链表的中间节点 思路： 设置两个指针同时指向头部，一个指针每次移动两步，一个指针每次移动一步，这样在快的指针走到尽头的时候，慢的指针恰好走到了中部。 1234567891011121314/** * 找到链表的中间节点并返回 * @param head * @return */ListNode* findMiddle(ListNode* head)&#123; if(head == nullptr || head-&gt;next == nullptr) return head; ListNode *first = head, *second = head; while(second-&gt;next &amp;&amp; second-&gt;next-&gt;next)&#123; first = first-&gt;next; second = second-&gt;next-&gt;next; &#125; return first;&#125; 插入排序（使用单链表实现） 12345678910111213141516171819202122232425262728293031323334353637ListNode *insertionSortList(ListNode *head) &#123; // 使用链表实现插入排序 if(head == nullptr || head-&gt;next == nullptr) return head; ListNode *guard = new ListNode(INT32_MIN); guard-&gt;next = head; head = guard; ListNode *sorted = guard; ListNode *ends = guard-&gt;next; ListNode *unsorted = ends-&gt;next; ends-&gt;next = nullptr; // 链表断开 while(unsorted)&#123; // 找到插入的位置 while(sorted != ends)&#123; if(unsorted-&gt;val &gt;= sorted-&gt;val &amp;&amp; unsorted-&gt;val &lt; sorted-&gt;next-&gt;val)&#123; // 插入到iter1后面 ListNode *tmp = unsorted; unsorted = unsorted-&gt;next; tmp-&gt;next = sorted-&gt;next; sorted-&gt;next = tmp; sorted = guard; break; &#125; sorted = sorted-&gt;next; &#125; if(sorted == ends &amp;&amp; unsorted-&gt;val &gt;= ends-&gt;val)&#123; ends-&gt;next = unsorted; unsorted = unsorted-&gt;next; ends = ends-&gt;next; ends-&gt;next = nullptr; sorted = guard; &#125; &#125; return head-&gt;next;&#125; 快速排序(单链表实现) 快速排序一般的思想是首尾两个指针相向运动，但是单链表没有向前的指针，这要求我们换一种思路。如何从前往后遍历找到支点的位置。假设支点的值是value. 我们需要遍历一遍链表，使得所有小于value的值都在前面，所有大于value的值都在后面，这个时候就找到的value应该在的位置。 1// 单链表实现快排 交换链表当中两个节点 给你一个链表以及两个权值v1和v2，交换链表中权值为v1和v2的这两个节点。保证链表中节点权值各不相同，如果没有找到对应节点，那么什么也不用做。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253ListNode* swapNodes(ListNode* head, int v1, int v2) &#123; // Write your code here if(head==nullptr) return head; // add a guard ListNode *guard = new ListNode(0); guard-&gt;next = head; head = guard; //search the value ListNode *pre_v1=nullptr; ListNode *pre_v2=nullptr; ListNode *pre_tmp=guard; ListNode *tmp=pre_tmp-&gt;next; while(tmp)&#123; if(tmp-&gt;val==v1)&#123; pre_v1 = pre_tmp; &#125; if(tmp-&gt;val==v2)&#123; pre_v2 = pre_tmp; &#125; pre_tmp = tmp; tmp = tmp-&gt;next; &#125; // not find v1 or v2 if(pre_v1==nullptr || pre_v2==nullptr)&#123; return head-&gt;next; &#125; // swap the two nodes ListNode *v1s = pre_v1-&gt;next; ListNode *v2s = pre_v2-&gt;next; ListNode *next_v1 = v1s-&gt;next; ListNode *next_v2 = v2s-&gt;next; if(pre_v1 == v2s)&#123; pre_v2-&gt;next = v1s; v1s-&gt;next = v2s; v2s-&gt;next = next_v1; &#125;else if(pre_v2 == v1s)&#123; pre_v1-&gt;next = v2s; v2s-&gt;next = v1s; v1s-&gt;next = next_v2; &#125;else&#123; v1s-&gt;next = next_v2; v2s-&gt;next = next_v1; pre_v1-&gt;next = v2s; pre_v2-&gt;next = v1s; &#125; return head-&gt;next;&#125; 两两交换链表中的节点 给一个链表，两两交换其中的节点，然后返回交换后的链表。 12345678910111213141516171819202122232425ListNode* swapPairs(ListNode* head) &#123; // Write your code here if(head==nullptr || head-&gt;next==nullptr) return head; ListNode *guard = new ListNode(0); guard-&gt;next = head; head = guard; ListNode *pres1 = guard; ListNode *s1 = guard-&gt;next; ListNode *s2 = guard-&gt;next-&gt;next; while(s1!=nullptr &amp;&amp; s2!=nullptr)&#123; pres1-&gt;next = s2; s1-&gt;next = s2-&gt;next; s2-&gt;next = s1; if(s1-&gt;next==nullptr || s1-&gt;next-&gt;next==nullptr)&#123; return head-&gt;next; &#125;else&#123; pres1 = s1; s1 = s1-&gt;next; s2 = s2-&gt;next-&gt;next-&gt;next; &#125; &#125; return head-&gt;next; &#125; 旋转链表 1234567891011121314151617181920212223ListNode *rotateRight(ListNode *head, int k) &#123; //给定一个链表，旋转链表，使得每个节点向右移动k个位置，其中k是一个非负数 if(head == nullptr || head-&gt;next == nullptr || k &lt;= 0) return head; ListNode *end = head; int len = 1; while(end-&gt;next)&#123; end = end-&gt;next; len++; &#125; k = k % len; if(k == 0) return head; int index = (len - 1 - k) % len; ListNode *tmp = head; while(tmp &amp;&amp; index --)&#123; tmp = tmp-&gt;next; &#125; if(index == -1)&#123; end-&gt;next = head; head = tmp-&gt;next; tmp-&gt;next = nullptr; &#125; return head;&#125; 首尾交错重排链表 给定一个单链表L: L0→L1→…→Ln-1→Ln,重新排列后为：L0→Ln→L1→Ln-1→L2→Ln-2→…必须在不改变节点值的情况下进行原地操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * 找到链表的中间节点并返回 * @param head * @return */ListNode* findMiddle(ListNode* head)&#123; if(head == nullptr || head-&gt;next == nullptr) return head; ListNode *first = head, *second = head; while(second-&gt;next &amp;&amp; second-&gt;next-&gt;next)&#123; first = first-&gt;next; second = second-&gt;next-&gt;next; &#125; return first;&#125;/** * 反转链表 * @param head * @return */ListNode *reverse(ListNode *head) &#123; // write your code here if(head==nullptr || head-&gt;next==nullptr) return head; ListNode *iter =head; ListNode *next_iter = head-&gt;next; iter-&gt;next=nullptr; while(next_iter)&#123; ListNode *tmp = next_iter-&gt;next; next_iter-&gt;next = iter; iter = next_iter; next_iter = tmp; &#125; head = iter; return head;&#125;/** * 交叉合并两个链表 * @param l1 * @param l2 * @return */ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) &#123; // 如果其中一个链表为空，直接返回另外一个链表就是结果 if(l1 == nullptr) return l2; if(l2 == nullptr) return l1; ListNode *head = l1; l1 = l1-&gt;next; ListNode *iter = head; bool odd = false; while(l1 != nullptr || l2 != nullptr)&#123; if(!odd)&#123; if(l2)&#123; iter-&gt;next = l2; l2 = l2-&gt;next; iter = iter-&gt;next; &#125; &#125; if(odd)&#123; if(l1)&#123; iter-&gt;next = l1; l1 = l1-&gt;next; iter = iter-&gt;next; &#125; &#125; odd = !odd; &#125; return head;&#125;ListNode* reorderList(ListNode *head) &#123; if(head == nullptr || head-&gt;next == nullptr) return head; // 给定一个单链表L: L0→L1→…→Ln-1→Ln,重新排列后为：L0→Ln→L1→Ln-1→L2→Ln-2→…必须在不改变节点值的情况下进行原地操作 // 找到中间节点， 反转后半段，然后交叉拼接起来，可以确保不适用额外的空间 ListNode* middle = findMiddle(head); ListNode* head2 = reverse(middle-&gt;next); middle-&gt;next = nullptr; head = mergeTwoLists(head,head2); return head;&#125; 回文链表 判断一个链表中的值是否是回文 找到中间节点，把后面的链表反转，然后与前面的逐个节点比较，如果完全一样或者只有最后一个节点不一样，则是回文的。 1234567891011121314151617181920212223bool isPalindrome(ListNode* head) &#123; // Write your code here if(head == nullptr) return true; ListNode *middle = findMiddle(head); ListNode *head2 = reverse(middle-&gt;next); middle-&gt;next = nullptr; ListNode *iter1 = head, *iter2 = head2; while(iter1 &amp;&amp; iter2)&#123; if(iter1-&gt;val != iter2-&gt;val) return false; iter1 = iter1-&gt;next; iter2 = iter2-&gt;next; &#125; if(iter1 &amp;&amp; iter1-&gt;next == nullptr)&#123; return true; &#125; if(iter2 &amp;&amp; iter2-&gt;next == nullptr)&#123; return true; &#125; if(iter1 == nullptr &amp;&amp; iter2 == nullptr)&#123; return true; &#125; return false;&#125; 链表求和 你有两个用链表代表的整数，其中每个节点包含一个数字。数字存储按照在原来整数中相反的顺序，使得第一个数字位于链表的开头。写出一个函数将两个整数相加，用链表形式返回和。 12345678910111213141516171819202122232425262728293031323334353637383940ListNode *addLists(ListNode *l1, ListNode *l2) &#123; if(l1 == nullptr) return l2; if(l2 == nullptr) return l1; // 链表求和 int carry = 0; ListNode *head = new ListNode(0); ListNode *iter = head; int number; while(l1 != nullptr &amp;&amp; l2 != nullptr)&#123; number = (l1-&gt;val + l2-&gt;val + carry ) % 10 ; carry = (l1-&gt;val + l2-&gt;val + carry ) / 10 ; ListNode *node = new ListNode(number); iter-&gt;next = node; iter = iter-&gt;next; l1 = l1-&gt;next; l2 = l2-&gt;next; &#125; while(l1)&#123; number = (l1-&gt;val + carry) % 10; carry = (l1-&gt;val + carry) / 10; ListNode *node = new ListNode(number); iter-&gt;next = node; iter = iter-&gt;next; l1 = l1-&gt;next; &#125; while(l2)&#123; number = (l2-&gt;val + carry) % 10; carry = (l2-&gt;val + carry) / 10; ListNode *node = new ListNode(number); iter-&gt;next = node; iter = iter-&gt;next; l2 = l2-&gt;next; &#125; if(carry)&#123; ListNode *node = new ListNode(carry); iter-&gt;next = node; &#125; return head-&gt;next;&#125; 链表求和 II 假定用一个链表表示两个数，其中每个节点仅包含一个数字。假设这两个数的数字顺序排列，请设计一种方法将两个数相加，并将其结果表现为链表的形式。 先翻转链表，求和，在翻转回去。 123ListNode *addLists2(ListNode *l1, ListNode *l2) &#123; return reverse(addLists(reverse(l1),reverse(l2)));&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"英语","slug":"技术/专业术语/术语","date":"2017-07-24T14:26:56.000Z","updated":"2019-03-28T00:07:17.758Z","comments":true,"path":"2017/07/24/技术/专业术语/术语/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/07/24/技术/专业术语/术语/","excerpt":"英语语言方面相关的内容，包括专业术语，缩写，常用短语，小故事。","text":"英语语言方面相关的内容，包括专业术语，缩写，常用短语，小故事。 常用短语 提供极有用的信息 – provide invalueable information 右利手的被试 – right-handed participants 构建于Matlab内部的 – with in-house MATLAB scripts 提供机制方面的解释能力 – afford mechanistic interpretability 相比于传统的方法 – over conventional method 外部的|内部的 – extrinsic|intrinsic 把…归因为… – ascribes 变量未知和随机 – unknown and stochastic 在括号里的 – in brackets 广告 DAU, dailyactive user, 日活跃用户 MAU, monthactive user, 月活跃用户 CPM, cost per mille, 前人展现成本，按照看到的人数付费。 CPC, cost per click, 按照点击广告的用户数量付费。 CPA, cost per action, 按照回应付费，即用户不仅仅点击了广告，还回应了(注册、互动、下载、下单、购买)。 pv, pageview, 页面浏览量或点击量 uv, uniquevisitor,统计访问网站的不同IP数量 其他 IP, intellectual property, 知识产权 ACG, animation, comic, game, 动画，漫画，游戏 KOL, key opinion leader, 有话语权的人 UGC, user generated content, 用户生成内容 TMT, technology, media, telecom, 数字新媒体。","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"专业术语","slug":"技术/专业术语","permalink":"http://ff120.github.io/hexoblog/categories/技术/专业术语/"}],"tags":[{"name":"English","slug":"English","permalink":"http://ff120.github.io/hexoblog/tags/English/"}]},{"title":"Visual Studio Code使用技巧","slug":"技术/工具/编程IDE/VSCode/Visual-Studio-Code使用技巧","date":"2017-07-24T13:31:40.000Z","updated":"2019-03-28T00:54:55.697Z","comments":true,"path":"2017/07/24/技术/工具/编程IDE/VSCode/Visual-Studio-Code使用技巧/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/07/24/技术/工具/编程IDE/VSCode/Visual-Studio-Code使用技巧/","excerpt":"Visual Studio Code 是微软出的一个文本编辑工具，与SublimeText, Atom, Vim定位是一样的，都是带扩展功能的文本编辑器，可以安装多种扩张插件，实现IDE的功能。","text":"Visual Studio Code 是微软出的一个文本编辑工具，与SublimeText, Atom, Vim定位是一样的，都是带扩展功能的文本编辑器，可以安装多种扩张插件，实现IDE的功能。 Visual Studio Code 与Atom相比，最大的优点就是响应速度快，如果使用Windows系统，Visual Studio Code无疑是首选。使用习惯与Atom, SumlimeText都是一样的。 安装地址：VSCode","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"工具","slug":"技术/工具","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/"},{"name":"编程IDE","slug":"技术/工具/编程IDE","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/编程IDE/"},{"name":"VSCode","slug":"技术/工具/编程IDE/VSCode","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/编程IDE/VSCode/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://ff120.github.io/hexoblog/tags/工具/"}]},{"title":"机器学习_Numpy使用技巧","slug":"技术/机器学习/机器学习-Numpy使用技巧","date":"2017-07-23T01:50:10.000Z","updated":"2019-03-28T00:54:57.498Z","comments":true,"path":"2017/07/23/技术/机器学习/机器学习-Numpy使用技巧/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/07/23/技术/机器学习/机器学习-Numpy使用技巧/","excerpt":"NumPy的主要对象是齐次多维数组。表由相同类型的元素组成（通常为数字），由一个正整数元组索引。在NumPy中维数被称为轴，轴数称为秩。例如，一个三维空间中点的坐标[1,2,1]是一个秩为1的数组，因为其轴数为1，轴的长度为3。在下图中，数组的秩为2（2维），第二维的长度为3。 12[[ 1., 0., 0.], [ 0., 1., 2.]]","text":"NumPy的主要对象是齐次多维数组。表由相同类型的元素组成（通常为数字），由一个正整数元组索引。在NumPy中维数被称为轴，轴数称为秩。例如，一个三维空间中点的坐标[1,2,1]是一个秩为1的数组，因为其轴数为1，轴的长度为3。在下图中，数组的秩为2（2维），第二维的长度为3。 12[[ 1., 0., 0.], [ 0., 1., 2.]] 随机打乱数据 12import numpy as nprandom_y = np.random.permutation(y)","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"}],"tags":[{"name":"python","slug":"python","permalink":"http://ff120.github.io/hexoblog/tags/python/"},{"name":"numpy","slug":"numpy","permalink":"http://ff120.github.io/hexoblog/tags/numpy/"}]},{"title":"算法专题_并查集","slug":"技术/数据结构和算法/算法专题_并查集","date":"2017-07-22T16:22:37.000Z","updated":"2019-03-28T00:54:56.583Z","comments":true,"path":"2017/07/23/技术/数据结构和算法/算法专题_并查集/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/07/23/技术/数据结构和算法/算法专题_并查集/","excerpt":"并查集可以高效的维护数据的分组信息，并可以快速完成以下操作： 查询元素a和元素b是否属于同一个组 合并元素a和元素b所在的组 并查集使用一棵树来维护一个分组的信息，多棵树构成的森林表示这个完整的数据结构。如果查询a和b是否属于同一组，只需要向上搜索直到树根，看a和b的树根是否一样就可以了。如果要合并a和b所在的分组，只需要把a和b连在一起就可以了，通常是把a和b所在树的树根连在一起。","text":"并查集可以高效的维护数据的分组信息，并可以快速完成以下操作： 查询元素a和元素b是否属于同一个组 合并元素a和元素b所在的组 并查集使用一棵树来维护一个分组的信息，多棵树构成的森林表示这个完整的数据结构。如果查询a和b是否属于同一组，只需要向上搜索直到树根，看a和b的树根是否一样就可以了。如果要合并a和b所在的分组，只需要把a和b连在一起就可以了，通常是把a和b所在树的树根连在一起。","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"},{"name":"并查集","slug":"并查集","permalink":"http://ff120.github.io/hexoblog/tags/并查集/"}]},{"title":"算法专题_树状数组","slug":"技术/数据结构和算法/算法专题_树状数组","date":"2017-07-22T16:18:24.000Z","updated":"2019-03-28T00:54:56.830Z","comments":true,"path":"2017/07/23/技术/数据结构和算法/算法专题_树状数组/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/07/23/技术/数据结构和算法/算法专题_树状数组/","excerpt":"树状数组是一个能够快速完成下术操作的数据结构： 给定一个初始值全为0的数列，a1,a2,a3,a4,…an 给定i,计算a1+a2+…+ai 给定i和x,计算ai = ai + x;","text":"树状数组是一个能够快速完成下术操作的数据结构： 给定一个初始值全为0的数列，a1,a2,a3,a4,…an 给定i,计算a1+a2+…+ai 给定i和x,计算ai = ai + x; 上面提到的线段树其实已经满足了上面的要求，只不过有些(大材小用了)。可以用更简单的结构实现这个要求。 2017-04-12_161624.png 把线段树所有的右节点去掉，只剩下左节点，然后对应的位置不变，投射到最下面一行，就形成了树状数组的结构。例如8个元素的树状数组的结构是： A[1] A[2] A[3] A[4] A[5] A[6] A[7] A[8] 1 [1,2] 3 [1,4] 5 [5,6] 7 [1,8] 0001 0010 0011 0100 0101 0110 0111 1000 有了上面的结构，如果想求c[3]+c[4]+c[5]就是A[4]-A[2]+A[5]; 如果想求c[4],就是A[4]-A[3]-A[2]; 总之，一个区间内的和总可以在常数时间内通过树状数组中的值求出来。树状数组可以使用位来保存，通过寻找其中的规律，可以使用简单的位操作实现树状数组的求和和更新。上面表格的最后一行是对树状数组A进行的二进制的编码。 求树状数组的前i项和： i 表达式 二进制表示 1 A[1] 0001 2 A[2] 0010 3 A[3]+A[2] 0011+0010 4 A[4] 0100 5 A[5]+A[4] 0101+0100 6 A[6]+A[4] 0110+0100 7 A[7]+A[6]+A[4] 0111+0110+0100 8 A[8] 1000 从二进制当中寻找规律，求前i项： 初始化sum=0; 从树状数组A[i]开始，把A[i]加入到结果中去。然后从i中减去i最低位1对应的数字。i的最低位的1对应的数字的值的大小可以用i&amp;(-i)求得。 直到i的结果为0停止。 按照上面的步骤分析上面表格中的每一行的求解： 0001减去最后一位二进制1对应的数字（1）之后为0，所以最后结果是A[1] 0010减去最后一位二进制1对应的数字(2)之后为0，所以最后的结果是A[2] 0011减去最后以为二进制1对应的数字(1)之后为(0010,A[2]),而0010减去最后一位二进制1对应的数字(2)之后为0,所以最后的结果是A[3]+A[2] 0100减去最后以为二进制1对应的数字(4)之后为0,所以最后的结果是A[4] 0101减去最后以为二进制1对应的数字(1)之后为0100,0100减去最后以为二进制1对应的数字(4)之后为0,所以最后的结果是A[5]+A[4] 0110 = 0110 + 0100 = A[6] + A[4] 0111 = 0111 + 0110 + 0100 + A[7] + A[6] + A[4] 1000 = 1000 = A[8] 上面就是BIT数组求和的详细解释，了解了这个过程，在知道如何求解一个数字最低位1对应的值，实现BIT的求和应该不难。下面看看BIT如何更新。 假如我们想更新c[2]的值，那么A中所有包含c[2]的值都可能发生变化，到底哪些值包含c[2]呢？从上面的表格我们看出，包含c[2]的A元素有A[2],A[4],A[8];下面再列一个表格，显示每个元素的更新都涉及哪些元素，这样就比较容易找到其中的规律。 更新的值 涉及的BIT 二进制表示 c[1] A[1],A[2],A[4],A[8] 0001,0010,0100,1000 c[2] A[2],A[4],A[8] 0010,0100,1000 c[3] A[3],A[4],A[8] 0011,0100,1000 c[4] A[4],A[8] 0100,1000 c[5] A[5],A[6],A[8] 0101,0110,1000 c[6] A[6],A[8] 0110,1000 c[7] A[7],A[8] 0111,1000 c[8] A[8] 1000 可以看到，更新的时候和求和的时候顺序似乎相反，规律是：如果要更新c[i],那么就从i开始，更新A[i]之后将i更新为i = i+(i&amp;(-i)),直到最后一个元素为止。因为无论更新哪个元素，最后一个元素包含所有值的和，所以必须更新最后一个元素。i&amp;(-i)是得到i的最后一位二进制1对应的数值的大小，然后加到i上，对比上面的表格。i的更新情况是： 0001(1)-0001+0001(2)-0010+0010(4)-0100+0100(8)=1000 停止 0010(2)-0010+0010(4)-0100+0100(8)=1000 停止 0011(3)-0011+0001(4)-0100+0100(8)=1000 停止 0100(4)-0100+0100(8)=1000 停止 0101(5)-0101+0001(6)-0110+0010(8)=1000 停止 0110(6)-0110+0010(8)=1000 停止 0111(7)-0111+0001(8)=1000 停止 1000(8) = 1000 停止 树状数组的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class BIT&#123;public: vector&lt;int&gt; v; int n; BIT()&#123;&#125; // 构建n个元素的空树状数组 BIT(int num)&#123; n = num+1; // v[0]不用，下标从1开始。 for(int i=0;i&lt;n;i++)&#123; v.push_back(0); &#125; &#125; //求前i项的和 int sum(int i)&#123; int s = 0; while(i&gt;0)&#123; s += v[i]; i -= i &amp; (-i); &#125; return s; &#125; //第i 项加上x void add(int i,int x)&#123; while(i&lt;=n)&#123; v[i] += x; i += i&amp;(-i); &#125; &#125; //根据传入的数组c构建它的树状数组 void create(vector&lt;int&gt; &amp;c)&#123; for(int i=0;i&lt;c.size();i++)&#123; add(i+1,c[i]); &#125; &#125;&#125;;void printV(vector&lt;int&gt; a)&#123; for(auto aa:a)&#123; cout&lt;&lt;aa&lt;&lt;\" \"; &#125; cout&lt;&lt;endl;&#125;int main() &#123; vector&lt;int&gt; c = &#123;3,7,6,5,4,2,8,1&#125;; BIT *b = new BIT(c.size()); b-&gt;create(c); printV(b-&gt;v); b-&gt;add(8,10); printV(b-&gt;v); b-&gt;add(1,1); printV(b-&gt;v); return 0;&#125; 运行结果： 1230 3 10 6 21 4 6 8 360 3 10 6 21 4 6 8 460 4 11 6 22 4 6 8 47 可以看到，树状数组仅仅使用位操作就可以实现求和和更新，比线段树的开销要少很多，所以，一些能用树状数组解决的问题，不宜使用线段树。 参考博文： http://www.cnblogs.com/wuwangchuxin0924/p/5921130.html http://www.cnblogs.com/GeniusYang/p/5756975.html","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"},{"name":"树状数组","slug":"树状数组","permalink":"http://ff120.github.io/hexoblog/tags/树状数组/"}]},{"title":"算法专题_线段树","slug":"技术/数据结构和算法/算法专题_线段树","date":"2017-07-22T16:15:49.000Z","updated":"2019-03-28T00:54:56.982Z","comments":true,"path":"2017/07/23/技术/数据结构和算法/算法专题_线段树/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/07/23/技术/数据结构和算法/算法专题_线段树/","excerpt":"线段树是一棵二叉树，他的每个节点包含了两个额外的属性start和end用于表示该节点所代表的区间。start和end都是整数，并按照如下的方式赋值: 根节点的 start 和 end 由 build 方法所给出。 对于节点 A 的左儿子，有 start=A.left, end=(A.left + A.right) / 2。 对于节点 A 的右儿子，有 start=(A.left + A.right) / 2 + 1, end=A.right。 如果 start 等于 end, 那么该节点是叶子节点，不再有左右儿子。 实现一个 build 方法，接受 start 和 end 作为参数, 然后构造一个代表区间[start, end]的线段树，返回这棵线段树的根。","text":"线段树是一棵二叉树，他的每个节点包含了两个额外的属性start和end用于表示该节点所代表的区间。start和end都是整数，并按照如下的方式赋值: 根节点的 start 和 end 由 build 方法所给出。 对于节点 A 的左儿子，有 start=A.left, end=(A.left + A.right) / 2。 对于节点 A 的右儿子，有 start=(A.left + A.right) / 2 + 1, end=A.right。 如果 start 等于 end, 那么该节点是叶子节点，不再有左右儿子。 实现一个 build 方法，接受 start 和 end 作为参数, 然后构造一个代表区间[start, end]的线段树，返回这棵线段树的根。 线段树(又称区间树), 是一种高级数据结构，他可以支持这样的一些操作: 查找给定的点包含在了哪些区间内 查找给定的区间包含了哪些点 样例: 比如给定start=1, end=6，对应的线段树为： 1234567 [1, 6] / \\ [1, 3] [4, 6] / \\ / \\ [1, 2] [3,3] [4, 5] [6,6] / \\ / \\[1,1] [2,2] [4,4] [5,5] 线段树结构的定义 12345678910Definition of SegmentTreeNode: class SegmentTreeNode &#123; public: int start, end; SegmentTreeNode *left, *right; SegmentTreeNode(int start, int end) &#123; this-&gt;start = start, this-&gt;end = end; this-&gt;left = this-&gt;right = NULL; &#125; &#125; 线段树的构造 123456789101112131415161718class Solution &#123;public: /** *@param start, end: Denote an segment / interval *@return: The root of Segment Tree */ SegmentTreeNode * build(int start, int end) &#123; // write your code here if(start &gt; end) return nullptr; SegmentTreeNode *node = new SegmentTreeNode(start,end); if( start &lt; end ) &#123; node-&gt;left = build(node-&gt;start,(node-&gt;start+node-&gt;end)/2); node-&gt;right = build((node-&gt;start+node-&gt;end)/2+1,node-&gt;end); &#125; return node; &#125;&#125;; 自底向上构造线段树online judge 123456789101112131415161718192021222324SegmentTreeNode * build(vector&lt;int&gt; A) &#123; // write your code here if (A.size() &lt;= 0) &#123; return nullptr; &#125; return build(0, A.size() - 1, A); &#125; SegmentTreeNode * build(int start, int end, vector&lt;int&gt; &amp;nums) &#123; // write your code here if (start &gt; end) &#123; return nullptr; &#125; SegmentTreeNode *root = new SegmentTreeNode(start, end, 0); if (start != end) &#123; root-&gt;left = build(start, (start + end) / 2, nums); root-&gt;right = build((start + end) / 2 + 1, end, nums); root-&gt;max = max(root-&gt;left-&gt;max, root-&gt;right-&gt;max); &#125; else &#123; root-&gt;max = nums[start]; &#125; return root; &#125; 线段树的查询 12345678910111213141516171819202122232425class Solution &#123;public: /** *@param root, start, end: The root of segment tree and * an segment / interval *@return: The maximum number in the interval [start, end] */ int query(SegmentTreeNode *root, int start, int end) &#123; // write your code here // 区间比根区间还大的情况 if(start &lt;= root-&gt;start &amp;&amp; end &gt;= root-&gt;end)&#123; return root-&gt;max; &#125; //如果左边界已经大于等于又边界 或者 右边界已经大于等于左边界， 则不存在的这样的区域 //返回不影响计算最大值的数字 if(start&gt;root-&gt;end || end &lt; root-&gt;start)&#123; return 0; &#125; int ll = query(root-&gt;left,start,end); int rr = query(root-&gt;right,start,end); return max(ll,rr); &#125;&#125;; 线段树的更新 123456789101112131415161718192021void modify(Node *root, int idx)&#123; if (root == NULL) &#123; return; &#125; if (root-&gt;start == root-&gt;end &amp;&amp; root-&gt;start == idx) &#123; ++(root-&gt;cnt); return; &#125; int mid = root-&gt;start + ((root-&gt;end - root-&gt;start) &gt;&gt; 1); if (mid &gt;= idx) &#123; modify(root-&gt;left, idx); &#125; else &#123; modify(root-&gt;right, idx); &#125; root-&gt;cnt = root-&gt;left-&gt;cnt + (root-&gt;right ? root-&gt;right-&gt;cnt : 0); &#125; 统计前面比自己大的数有多少个 使用线段树存储每个区间有多少个数字。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;bits/stdc++.h&gt;using namespace std;class Node&#123;public: Node(int _start, int _end) : start(_start), end(_end), left(nullptr), right(nullptr), cnt(0) &#123;&#125; int start, end; Node *left, *right; int cnt;&#125;;Node *build(int start, int end)&#123; if (start &gt; end) &#123; return NULL; &#125; if (start == end) &#123; return new Node(start, end); &#125; int mid = start + ((end - start) &gt;&gt; 1); Node *root = new Node(start, end); root-&gt;left = build(start, mid); root-&gt;right = build(mid + 1, end); return root;&#125;void modify(Node *root, int idx)&#123; if (root == NULL) &#123; return; &#125; if (root-&gt;start == root-&gt;end &amp;&amp; root-&gt;start == idx) &#123; ++(root-&gt;cnt); return; &#125; int mid = root-&gt;start + ((root-&gt;end - root-&gt;start) &gt;&gt; 1); if (mid &gt;= idx) &#123; modify(root-&gt;left, idx); &#125; else &#123; modify(root-&gt;right, idx); &#125; root-&gt;cnt = root-&gt;left-&gt;cnt + (root-&gt;right ? root-&gt;right-&gt;cnt : 0);&#125;int query(Node *root, int start, int end)&#123; if (root-&gt;end &lt; start || root-&gt;start &gt; end) &#123; return 0; &#125; if (root-&gt;start &gt;= start &amp;&amp; root-&gt;end &lt;= end) &#123; return root-&gt;cnt; &#125; int mid = root-&gt;start + ((root-&gt;end - root-&gt;start) &gt;&gt; 1); if (mid &gt;= end) &#123; return query(root-&gt;left, start, end); &#125; if (mid &lt; start) &#123; return query(root-&gt;right, start, end); &#125; int leftRes = query(root-&gt;left, start, mid); int rightRes = query(root-&gt;right, mid + 1, end); return leftRes + rightRes;&#125;vector&lt;int&gt; countOfSmallerNumberII(vector&lt;int&gt; &amp;A) &#123; // write your code here int len = A.size(); Node *root = build(0, 2*len); int maxV = INT32_MIN; for (int j = 0; j &lt; len; ++j) &#123; maxV = max(maxV,A[j]); &#125; vector&lt;int&gt; res; for (int i = 0; i &lt; A.size(); i++) &#123; int cnt = query(root,A[i] + 1, maxV); res.push_back(cnt); modify(root, A[i]); &#125; return res;&#125;int main()&#123; vector&lt;int&gt; v = &#123;1,2,7,8,5&#125;; auto re = countOfSmallerNumberII(v); return 0;&#125; 统计前面比自己小的数字有多少个 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107class Node&#123;public: Node(int _start, int _end) : start(_start), end(_end), left(nullptr), right(nullptr), cnt(0) &#123;&#125; int start, end; Node *left, *right; int cnt;&#125;;class Solution &#123;public: /** * @param A: An integer array * @return: Count the number of element before this element 'ai' is * smaller than it and return count number array */ vector&lt;int&gt; countOfSmallerNumberII(vector&lt;int&gt; &amp;A) &#123; // write your code here Node *root = build(0, 20000); vector&lt;int&gt; res; for (int i = 0; i &lt; A.size(); i++) &#123; int cnt = query(root, 0, A[i] - 1); res.push_back(cnt); modify(root, A[i]); &#125; return res; &#125;private: Node *build(int start, int end) &#123; if (start &gt; end) &#123; return NULL; &#125; if (start == end) &#123; return new Node(start, end); &#125; int mid = start + ((end - start) &gt;&gt; 1); Node *root = new Node(start, end); root-&gt;left = build(start, mid); root-&gt;right = build(mid + 1, end); return root; &#125; void modify(Node *root, int idx)&#123; if (root == NULL) &#123; return; &#125; if (root-&gt;start == root-&gt;end &amp;&amp; root-&gt;start == idx) &#123; ++(root-&gt;cnt); return; &#125; int mid = root-&gt;start + ((root-&gt;end - root-&gt;start) &gt;&gt; 1); if (mid &gt;= idx) &#123; modify(root-&gt;left, idx); &#125; else &#123; modify(root-&gt;right, idx); &#125; root-&gt;cnt = root-&gt;left-&gt;cnt + (root-&gt;right ? root-&gt;right-&gt;cnt : 0); &#125; int query(Node *root, int start, int end) &#123; if (root-&gt;end &lt; start || root-&gt;start &gt; end) &#123; return 0; &#125; if (root-&gt;start &gt;= start &amp;&amp; root-&gt;end &lt;= end) &#123; return root-&gt;cnt; &#125; int mid = root-&gt;start + ((root-&gt;end - root-&gt;start) &gt;&gt; 1); if (mid &gt;= end) &#123; return query(root-&gt;left, start, end); &#125; if (mid &lt; start) &#123; return query(root-&gt;right, start, end); &#125; int leftRes = query(root-&gt;left, start, mid); int rightRes = query(root-&gt;right, mid + 1, end); return leftRes + rightRes; &#125;&#125;;","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"},{"name":"线段树","slug":"线段树","permalink":"http://ff120.github.io/hexoblog/tags/线段树/"}]},{"title":"N皇后问题","slug":"技术/数据结构和算法/N皇后问题","date":"2017-07-20T06:58:58.000Z","updated":"2019-03-28T00:54:55.973Z","comments":true,"path":"2017/07/20/技术/数据结构和算法/N皇后问题/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/07/20/技术/数据结构和算法/N皇后问题/","excerpt":"在一个N*N的棋盘上放置N个皇后，要求任意两个皇后不能在同一行、同一列和同一对角线上，求有多少种放置的方法。","text":"在一个N*N的棋盘上放置N个皇后，要求任意两个皇后不能在同一行、同一列和同一对角线上，求有多少种放置的方法。 该问题的基本思路是搜索所有的状态。先在第一行的第一个位置放置皇后，然后在第二行找一个合法的位置，接着在第三行找一个合法的位置，一旦达到最后一行，就产生了一个解，如果到某一行的时候没有解了，就回溯到上一行，移动刚才放置的皇后到下一个可行的位置，继续向下搜索。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;deque&gt;#include &lt;stack&gt;using namespace std;/** * 判断在棋盘的row,col位置是否可以放置皇后 * @param C c[i]=j 表示第i行第j列有皇后 * @param row * @param col * @return */bool isValid(const vector&lt;int&gt; &amp;C,int &amp;row,int &amp;col)&#123; for (int i = 0; i &lt; row; ++i) &#123; // 在col列已经有皇后 if(C[i] == col) return false; // 对角线上的皇后行坐标相减总是等于列坐标 if(abs(i-row) == abs(C[i]-col)) return false; &#125; return true;&#125;/** * * @param C * @param row */void dfs(vector&lt;int&gt; &amp;C,int row,int &amp;sum)&#123; const int N = C.size(); if(row == N)&#123; sum++; return; &#125; //测试每一列 for (int j = 0; j &lt; N; ++j) &#123; if(isValid(C,row,j))&#123; C[row] = j; //(row,j) 放置一个皇后 dfs(C,row+1,sum); &#125;else&#123; continue; // 不行就尝试下一个位置 &#125; &#125;&#125;//N皇后问题int totalNQueens(int n) &#123; vector&lt;int&gt; C(n,-1); int sum = 0; dfs(C,0,sum); return sum;&#125;int main()&#123; cout&lt;&lt;totalNQueens(4)&lt;&lt;endl; return 0;&#125; 由于放置和不放置皇后只需要一个标识，所以可以使用位来标记，这样可以大大节省空间，也可以使用位运算来加速算法。 12","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"Hexo中使用gist存储代码片段","slug":"技术/工具/Hexo/Hexo的使用06-使用gist存储代码片段","date":"2017-07-17T11:10:07.000Z","updated":"2019-03-28T00:54:55.582Z","comments":true,"path":"2017/07/17/技术/工具/Hexo/Hexo的使用06-使用gist存储代码片段/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/07/17/技术/工具/Hexo/Hexo的使用06-使用gist存储代码片段/","excerpt":"以前都是直接把代码用代码块的形式写在markdown里面，这样有的时候代码太长，文件就会变得很长，不方便阅读。最近发现了GitHub上面的gist,能不限量的存储代码块，而且可以方便的引用和分享。就想着以后Hexo博客里面的代码直接放在Gist里面再引用好了。这样代码片段都可以保存在一起，还有代码管理功能，修改起来也方便。","text":"以前都是直接把代码用代码块的形式写在markdown里面，这样有的时候代码太长，文件就会变得很长，不方便阅读。最近发现了GitHub上面的gist,能不限量的存储代码块，而且可以方便的引用和分享。就想着以后Hexo博客里面的代码直接放在Gist里面再引用好了。这样代码片段都可以保存在一起，还有代码管理功能，修改起来也方便。 如果每次引用Gist的时候都需要打开Github,创建代码块，就太麻烦了。今天发现了Clion可以方便的创建Gist，只要登陆了自己的GitHub帐号，创建的Gist就全部都在自己的帐号里面，以后可以很方便的管理。 使用Clion创建Gist非常方便，选中需要创建Gist的片段，右键选择创建Gist,就会自动创建Gist。","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"工具","slug":"技术/工具","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/"},{"name":"Hexo","slug":"技术/工具/Hexo","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://ff120.github.io/hexoblog/tags/hexo/"},{"name":"gist","slug":"gist","permalink":"http://ff120.github.io/hexoblog/tags/gist/"}]},{"title":"矩阵的遍历","slug":"技术/数据结构和算法/矩阵的遍历","date":"2017-07-12T10:43:53.000Z","updated":"2019-03-28T00:54:56.148Z","comments":true,"path":"2017/07/12/技术/数据结构和算法/矩阵的遍历/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/07/12/技术/数据结构和算法/矩阵的遍历/","excerpt":"矩阵的各种遍历方法。","text":"矩阵的各种遍历方法。 斜对角线遍历数组(主对角线) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//斜对角线遍历数组(主对角线)vector&lt;vector&lt;int&gt;&gt; printMatrix(vector&lt;vector&lt;int&gt;&gt; v)&#123; vector&lt;vector&lt;int&gt;&gt; re; int m = v.size(); if(m==0) return re; if(m==1)&#123;return v;&#125; int n = v[0].size(); if(n==1) return v; int count = m+n-1; int row = 0; int col = n - 1; vector&lt;int&gt; tmp; tmp.push_back(v[row][col]); re.push_back(tmp); int i = row + 1; int j = col -1; while(true)&#123; int i1=row; int j1=j; tmp.clear(); while(i1&lt;=i &amp;&amp; j1&lt;=col)&#123; tmp.push_back(v[i1][j1]); i1++; j1++; &#125; re.push_back(tmp); if(i==m-1)&#123; col--; &#125;else&#123; i++; &#125; if(j==0)&#123; row++; &#125;else&#123; j--; &#125; if(i == m-1 &amp;&amp; j == 0 &amp;&amp; col==0 &amp;&amp; row == m-1)&#123; tmp.clear(); tmp.push_back(v[row][col]); re.push_back(tmp); break; &#125; &#125; return re;&#125; 斜对角线遍历数组(副对角线) 1234567891011121314151617181920212223242526272829303132333435363738394041424344//斜对角线遍历数组(副对角线)vector&lt;vector&lt;int&gt;&gt; printMatrix(vector&lt;vector&lt;int&gt;&gt; v)&#123; vector&lt;vector&lt;int&gt;&gt; re; int m = v.size(); if(m==0) return re; if(m==1)&#123;return v;&#125; int n = v[0].size(); if(n==1) return v; int count = m+n-1; int row = 0; int col = 0; vector&lt;int&gt; tmp; tmp.push_back(v[row][col]); re.push_back(tmp); int i = row + 1; int j = col + 1; while(true)&#123; int i1=row; int j1=j; tmp.clear(); while(i1&lt;=i &amp;&amp; j1&gt;=col)&#123; tmp.push_back(v[i1][j1]); i1++; j1--; &#125; re.push_back(tmp); if(i==m-1)&#123; col++; &#125;else&#123; i++; &#125; if(j==n-1)&#123; row++; &#125;else&#123; j++; &#125; if(i == m-1 &amp;&amp; j == n-1 &amp;&amp; col==n-1 &amp;&amp; row == m-1)&#123; tmp.clear(); tmp.push_back(v[row][col]); re.push_back(tmp); break; &#125; &#125; return re;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"计算机网络","slug":"技术/计算机基础/计算机网络/计算机网络","date":"2017-07-12T04:35:41.000Z","updated":"2019-03-28T00:54:59.365Z","comments":true,"path":"2017/07/12/技术/计算机基础/计算机网络/计算机网络/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/07/12/技术/计算机基础/计算机网络/计算机网络/","excerpt":"","text":"网络分层 OSI七层模型： OSI层 功能 协议 应用层 文件传输、电子邮件、文件服务、虚拟终端 TFTP、HTTP、SNMP、FTP、SMTP、DNS、Telnet 表示层 数据格式化、代码转换、数据加密 没有协议 会话层 解除或建立与别的接点的联系 没有协议 传输层 提供端对端的接口 TCP、UDP 网络层 为数据包选择路由 IP ICMP，RIP，OSPF，BGP，IGMP 数据链路层 传输有地址的帧以及错误检测功能 SLIP，CSLIP，PPP，ARP，RARP，MTU 物理层 以二进制数据形式在物理媒体上传输数据 ISO2110，IEEE802，IEEE802.2 TCP|IP 四层模型： 网络接口层（链路层）： 网络层： IP,ICMP,IGMP，【ARP,RARP】 传输层：TCP ,UDP,UGP 应用层：Telnet,FTP,SMTP,SNMP. ARP, RARP 在OSI七层模型中，是属于数据链路层的，但是在TCPIP模型中，它属于整个TCPIP协议簇的一部分，属于网络层。 物理层 以二进制数据的形式在物理媒介上传送数据（无线，光钎） 数据链路层 提供一个设备到另外一个设备的数据传输功能，寻找设备依靠设备的MAC地址。所以在这一层传送的数据包需要源MAC地址和目的MAC地址的信息。 ARP : 地址解析协议，把IP地址解析程Mac地址；RARP是逆地址解析协议，把Mac解析成IP地址； 网络层的通信依靠的是IP地址，而数据链路层通信依靠的是Mac地址。 ARP协议的过程： 主机A将包含 本机IP地址和本机Mac地址 和 要请求的目标IP地址 的ARP请求广播到网络上的所有主机，网络上的所有主机收到ARP请求的广播之后比较目标IP地址和自己的IP地址是否一样，如果不一致就忽略，如果一致，记录下此ARP包中的源IP和Mac地址的对应关系，然后发送自己的IP地址和Mac地址。 ARP 欺骗： 通过伪造ARP应答包的方式 改变目标主机中IP-MAc地址的对应关系，从而劫持目标主机的通信信息。 这种方式只有在局域网内有效。 网络层 提供终端对终端的数据传输功能，寻找目标依靠的是IP地址，在这一层传输的数据包需要有源IP地址和目的IP地址。 ICMP: 网际控制报文协议(差错与控制协议)，运行与IP协议之上(ICMP报文封装与IP数据包的数据部分，在IP数据报的头部中的协议字段指出数据中存在ICMP报文), 主要的功能是传输差错信息和传输控制信息。 传输层 提供应用程序到应用程序的数据传输服务，区分不同的应用程序依靠的是端口号，在这一层传输的数据包需要有源端口号，目的端口号。 访问一个网址的过程 根据网址解析出主机名称，例如www.baidu.com 根据主机名，查找对应的IP地址，首先在本机的hosts中寻找，没有则根据本机配置的首选DNS服务器的地址，使用DNS协议去DNS服务器上查找，DNS协议使用UDP传输数据，默认端口号是53. DNS服务器是一个树形结构，如果该DNS服务器查询不到，会将请求发送到上一级的DNS服务器查询。 发送HTTP请求。 HTTP是工作在TCP协议之上的应用层的协议，它和服务器的连接使用的三次握手和四次挥手的机制，可以确保可靠的传输。 服务器收到HTTP请求之后，解析该请求，发送所请求的内容。 TCP三次握手和四次挥手 TCP协议的头部格式 TCP 头部格式 Source Port和Destination Port:分别占用16位，表示源端口号和目的端口号；用于区别主机中的不同进程，而IP地址是用来区分不同的主机的，源端口号和目的端口号配合上IP首部中的源IP地址和目的IP地址就能唯一的确定一个TCP连接； Sequence Number:用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节在数据流中的序号；主要用来解决网络报乱序的问题； Acknowledgment Number:32位确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加1。不过，只有当标志位中的ACK标志（下面介绍）为1时该确认序列号的字段才有效。主要用来解决不丢包的问题； Offset:给出首部中32 bit字的数目，需要这个值是因为任选字段的长度是可变的。这个字段占4bit（最多能表示15个32bit的的字，即4*15=60个字节的首部长度），因此TCP最多有60字节的首部。然而，没有任选字段，正常的长度是20字节； 三次握手 三次握手 第一次，客户端发送请求连接报文(编程中一般用connect())，SYN = 1， ACK = 0，seq = x, （这两个标志位是TCP Flag中的两个，每个用一个比特位表示，连接请求的时候，ACK=0，SYN = 1； 连接响应的时候， ACK = 1， SYN = 1）. 发送完之后客户端进入SYN_SEND状态，等待服务器的响应。 服务器收到客户端发送的请求建立连接的报文，设置Acknowledgment Number = x + 1, Sequence Number = y, SYN = 1, 发送给客户端，服务器进入SYN_RECV状态； 服务器这次发送的包含两个信息，一个是应答客户端请求的信息，ACK = x + 1, 另外一个和客户端一样，是请求和客户端建立连接的请求报文，两者在一起合成一个报文发送。 客户端收到服务器来的消息后，发送确认消息ack = y + 1, 发送完之后, 进入established状态，服务器收到消息之后也进入这一状态。 四次挥手 四次挥手 主机1向主机2发送FIN报文，进入FIN_WAIT1状态 主机2收到主机1发送的FIN报文，向主机1回一个ACK报文，主机1进入FIN_WAIT2状态，这个时候主机2其实是告诉了主机1， 我同意了关闭连接的请求。 主机1已经确认主机2同意了关闭连接的请求，此时主机1不再发送数据到主机2，等待主机2请求关闭连接的信息。 主机2向主机1发送FIN报文，主机2进入LAST_ACK状态。 主机1收到主机2发来的FIN报文，知道主机2该处理的都已经处理完了，不会再发送来消息了，所以发送ACK报文到主机2，主机1进入TIME_WAIT状态， 主机2收到ACK报文，关闭连接。 主机1在等待2MSL之后，没有收到来自主机2的消息，正常关闭连接。 参考文献: 简析TCP三次握手与四次挥手 TCP 流量控制 如果发送方数据发送的过快，接收方来不及接收，就会造成数据的丢失，而TCP协议需要确保数据的有序到达，所以流量控制是很重要的一个方面。 利用滑动窗口可以方便的在TCP连接上实现对发送方的流量控制。 A向B发送数据，则在建立连接的时候，B会告诉A，我的接收窗口是 400 字节，发送方A的窗口不能超过B给出的接收窗口的值。 A在发送数据的时候，会记录已经发送的数据量，如果超过400字节，就不再发送新的数据，但是可以发送以前发送过的数据(比如丢失的数据)， 收到B端发送过来的带有调整接收窗口大小的报文，可以重新按照新的窗口大小发送数据。下面是一个示意图： 使用滑动窗口进行流量控制 TCP拥塞控制 拥塞控制与流量控制不同，拥塞控制是对整个网络的控制，需要在节点之间交换信息和各种命令，所以拥塞控制本身增加了网络的开销。 拥塞控制的主要方法有： 慢开始， 拥塞避免， 快重传和快恢复。具体方法参考这里. TCP和UDP的区别 TCP和UDP都属于传输层的协议，正常工作都需要端口号。 TCP协议是面向连接的，需要先建立连接之后才能发送数据，它的传输是可靠传输，可以确保发送的信息到达目标端口。因为其提供了流量控制，超时重发，数据检验等功能，所以负载比较大，传输速度慢，特别是在拥挤的网络中。 UDP协议是非连接的协议，发送数据之前不需要首先建立连接，直接根据数据包中的目标地址发送数据过去。正因为这样，UDP是不可靠的传输，不能确保发出去的信息能够达到目标地址。 它的优点是负载小，传输速度较快，可以支持一对一，多对一，一对多，和多对多的通信。要是使用UDP协议来实现可靠传输，需要自己实现上层的控制逻辑。 IP地址和子网掩码 IP地址 在TCPIP通信协议的基础上进行通信的两台电脑，必须有自己的IP地址唯一的标识自己，如果是广域网，IP地址由NIC统一分配，如果是一个局域网，可以按照自己的喜好分配IP地址(不与其他的网络通信的情况下)。 IP协议有版本4和版本6之分，版本4是目前广泛使用的协议，它使用32个字节表示一个IP地址。IP地址分为4段，每段8位，可以表示0-255的数字。最多能够区分的主机数量是42亿9千多万，在今天已经不够使用了。 IP地址右两部分组成： 网络号 + 主机号； 前面若干位表示网络号，唯一的标识一个网络，后面剩下的位数标识一个主机。 根据网络号所占用的位数的不同，IP地址可以分为A,B,C,D,E五类IP地址。 假设IP地址用w.x.y.z表示，每个字母代表8位二进制位 类别 网络号 主机号 W的取值范围 每个网络的主机数量 A w x.y.z 1-126 (0) 2^(24) - 2 B w.x y.z 128-191 (10) 2^(16) - 2 C w.x.y z 192-223 (110) 2^(8) - 2 D w.x.y.z 224-239 (1110) 用于多播 E w.x.y.z 240-247 (1111) 保留未用 每个网络上主机数量的计算方法 2^(主机号占用的比特位) - 2； -2是因为规定了两个保留地址：主机部分全部为0的地址引用为一个网络(表示这个网络), 主机部分全为1的地址称为广播地址，它同时指向一个网络上的所有主机。 网络号能表示的网络数量的计算方法 A类地址，只能取1-126，所以A类地址可以表示126个网络； B类地址，用两个字节表示网络号，第一个字节的取值是128-191,第二个字节可以取0-255，所以总的数量是(191-128+1)*256=16384个； C类地址，三个字节，同理，可以表示的网络数量为(223-192+1)256256=2097152个。 常用的十进制和二进制的对应 十进制 二进制 128 1000 0000 192 1100 0000 224 1110 0000 240 1111 0000 248 1111 1000 252 1111 1100 254 1111 1110 255 1111 1111 子网掩码 子网掩码是用来判断任意两台的计算机是否是属于同一子网络的：将IP地址和子网掩码按位与之后，如果结果相同，则两台电脑处于同一个子网中。 子网掩码由连续的1和连续的0组成，连续的1的个数等于子网网络号的长度。 子网 ： 这里指的是广播报文可以直达的所有连接在一起的主机构成的网络，和网络号不是一回事。网络号相同的网络是同一个网络，在该网络下还可以划分子网，占用一些比特位给子网标号，使得IP地址变成：网络号+ 子网号+主机号 三段的格式。 划分子网一是为了节约IP地址空间，更好的利用好每一个IP地址； 二是为了不同子网之间的隔离。 HTTP|GET|POST HTTP协议 HTTP协议是应用层无状态(对事务处理没有记忆能力，如果后面的处理必须使用前面的信息，需要重新传输前面的结果),无连接(每次连接(TCP连接)只处理一个请求，处理完成之后就断开连接)的协议，它可以传输任意的数据类型(数据类型在HTTP协议字段Content-Type指出)。 它提供的请求方法主要有get,post,head等方法。 HTTP状态码： 一共有五类：1xx 表示请求已经被成功接收； 2xx 表示成功; 3xx 表示重定向，要完成请求还需要进一步的操作； 4xx 表示客户端错误； 5xx表示服务器端错误。 常见的HTTP错误代码 含义 200 OK，客户端请求成功 301 请求的资源永久移动到新位置 302 请求的资源临时移动到了新的位置，下次请求还应该使用原来的位置 304 请求的资源未被修改过 400 bad request, 客户端请求有语法错误 401 unauthorized, 请求未经过授权 403 forbidden, 服务器收到请求，拒绝提供服务 404 not found, 请求的资源不存在 500 internal sever error, 服务器发生不可预期的错误 503 sever unavailable, 服务器当前不能处理请求 参考文献： HTTP协议 GET 和 POST get 和 post 是HTTP协议中定义的两种请求的方法，get的含义是请求信息，不改变服务器上的信息； post的含义是提交信息，可能会改变服务器的信息。但是实际使用的时候并不是严格按照这样的要求使用的，一般可以把两种方式都看成传输信息的方式，只是信息传输的方式不同。 GET方式是把传输的数据附在URL的末尾传输的，优点是可以添加到书签，缺点是安全性差，长度受限制。 POST方式是把传输的数据放在HTTP报文里面的，优点是传输的数据量大(理论上是无限大的，但是通常服务器端会有一个最大容量的限制，这个可以通过修改服务器的设置改变)， 缺点是不能添加书签，意思就是不能记录当前的状态。 路由协议 路由的作用是找到一条路径，一条从一个主机到达另外一个主机的路径。 路由表可以是静态的，由网络管理员手工配置，也可以是动态的，基于学习算法自动学习出对应的路由，动态更新路由表。 这里值介绍最简单的，使用最普遍的RIP协议。 RIP适用与数据链路故障低，规模较小的局域网(小于15跳), RIP使用UDP数据包更新路由信息，路由器每隔30s更新一次路由信息，如果在180s内没有收到相邻的路由器的回应，则认为去往该路由器的路由不可用，如果超过240s，则删除该路由。 RIP使用距离向量路由算法实现，基本原理是这样的： 使用到达目标主机经过的路由器的个数表示一条路由的距离，认为距离越近路由质量越好。 路由器每隔一定的时间把自己的路由表发送到与自己相邻的所有路由器上，路由器在接收到路由表信息之后与自己的路由表比较，如果发现一条更好的路由（经过更少的路由器可以到达目标），就合并该路由表，把新的路由表发送到与自己相邻的所有路由器上。","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"计算机基础","slug":"技术/计算机基础","permalink":"http://ff120.github.io/hexoblog/categories/技术/计算机基础/"},{"name":"计算机网络","slug":"技术/计算机基础/计算机网络","permalink":"http://ff120.github.io/hexoblog/categories/技术/计算机基础/计算机网络/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://ff120.github.io/hexoblog/tags/网络/"}]},{"title":"四等分数组","slug":"技术/数据结构和算法/四等分数组","date":"2017-07-12T02:09:19.000Z","updated":"2019-03-28T00:54:56.063Z","comments":true,"path":"2017/07/12/技术/数据结构和算法/四等分数组/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/07/12/技术/数据结构和算法/四等分数组/","excerpt":"题目 123456对于一个长度为N的整型数组A， 数组里所有的数都是正整数，对于两个满足0&lt;=X &lt;= Y &lt;N的整数，A[X], A[X+1] … A[Y]构成A的一个切片，记作(X, Y).用三个下标 m1, m2, m3下标满足条件0 &lt; m1, m1 + 1 &lt; m2, m2 +1 &lt; m3 &lt; N – 1。可以把这个整型数组分成(0, m1-1), (m1+1, m2-1), (m2+1, m3-1), (m3+1, N-1) 四个切片。如果这四个切片的整数求和相等，称作“四等分”。 编写一个函数，求一个给定的整型数组是否可以四等分要求： 函数的计算复杂度为O(N)，使用的额外存储空间（除了输入的数组之外）最多为O(N)。","text":"题目 123456对于一个长度为N的整型数组A， 数组里所有的数都是正整数，对于两个满足0&lt;=X &lt;= Y &lt;N的整数，A[X], A[X+1] … A[Y]构成A的一个切片，记作(X, Y).用三个下标 m1, m2, m3下标满足条件0 &lt; m1, m1 + 1 &lt; m2, m2 +1 &lt; m3 &lt; N – 1。可以把这个整型数组分成(0, m1-1), (m1+1, m2-1), (m2+1, m3-1), (m3+1, N-1) 四个切片。如果这四个切片的整数求和相等，称作“四等分”。 编写一个函数，求一个给定的整型数组是否可以四等分要求： 函数的计算复杂度为O(N)，使用的额外存储空间（除了输入的数组之外）最多为O(N)。 思路：如果不去掉中间的元素，直接判断一个数组是否能够四等分，只需要看数组的和被4整除的情况下能否依次加和成sum/4就可以了，代码可以写成下面这样： 12345678910111213141516171819202122232425bool judge(vector&lt;int&gt; v)&#123; int sum = 0; for(auto vv:v)&#123; sum += vv; &#125; if(sum % 4 != 0)&#123;return false;&#125; int partSum = sum / 4; sum = 0; int count = 0; for(int i=0;i&lt;v.size();i++)&#123; sum += v[i]; if(sum == partSum)&#123; count++; sum = 0; &#125; if(sum &gt; partSum)&#123; return false; &#125; &#125; if(count == 4)&#123; return true; &#125;else&#123; return false; &#125;&#125; 但是本题要复杂的多，需要确定三个分割元素的位置，数组的和也不再一定是4的倍数。本题可以从两边入手，如果一个数组可以四等分，则两边一定可以有连续的若干个元素的和是相等的，即a[0]+a[1]+…a[low] = a[N-1]+a[N-2]+a[high]. 找到第一个这样的分割，确定low,和high, 然后在low,high的基础上，搜索是否有一个介于low和high中间的元素m可以被剩下的数组分成和相等的两部分，并且和==第一部分和第四部分。如果存在，就完成了数组的四等分，如果不存在，就递增low, 找到第二个low,high的值，继续重复上面的步骤。 在中间阶段查找的时候，m的位置可以定在low,high的中间，使用二分查找的方式快速定位。因为左右和相等的情况不会特别多，所以该算法的时间复杂度应该能够满足要求。 查找一个数组两端连续个元素和相等的所有情况的代码实现： 12345678910111213141516171819202122/* * 找到数组两侧和相等的连续序列 */vector&lt;int&gt; bothSidesSum(vector&lt;int&gt; v)&#123; vector&lt;int&gt; re; if(v.size()&lt;2) return re; int left = 0; int right = v.size()-1; int leftSum = v[left++]; int rightSum = v[right--]; while(left&lt;=right)&#123; if(leftSum &lt; rightSum)&#123; leftSum += v[left++]; &#125;else if(leftSum &gt; rightSum)&#123; rightSum += v[right--]; &#125;else&#123; re.push_back(leftSum); leftSum += v[left++]; &#125; &#125; return re;&#125; 现在假设确定了某一次的low,high的值。即从最左侧开始到low-1的和等于从最右侧开始到high+1的值。现在看如何搜索m应该的位置，使得以m为分割的两段和是相等的。 1234567891011121314151617181920/*** 找到和相等的分界点，没有返回0，有的话返回和的值*/int findMiddle(vector&lt;int&gt; sums,int low,int high)&#123; int left = low + 1; int right = high -1 ; while(left &lt;= right)&#123; int middle = (left + right) / 2; int leftSum = sums[middle-1] - sums[low]; int rightSum = sums[high-1] - sums[middle]; if(leftSum &lt; rightSum)&#123; left = middle + 1; &#125;else if(leftSum &gt; rightSum)&#123; right = middle - 1; &#125;else&#123; return leftSum; &#125; &#125; return 0;&#125; 把上面的两个操作结合起来搜索，就是本题的解。具体的步骤是外层首先搜索low,high,一旦搜索到low,high，就调用findMiddle方法看是否能够找到分界。如果能够找到分界，还要看其sum是否等于第一个sum，如果相等，解就找到了，如果不相等，递增low,继续下一次搜索。 完整的代码如下： 12345678910111213141516171819202122232425bool solve(vector&lt;int&gt; v)&#123; if(v.size() &lt; 7) return false; auto sums = sumArray(v); int left = 0; int right = v.size()-1; int leftSum = v[left++]; int rightSum = v[right--]; while(left&lt;=right)&#123; if(leftSum &lt; rightSum)&#123; leftSum += v[left++]; &#125;else if(leftSum &gt; rightSum)&#123; rightSum += v[right--]; &#125;else&#123; auto secondSum = findMiddle(sums,left,right); if(leftSum == secondSum)&#123; return true; &#125;else&#123; leftSum += v[left++]; &#125; &#125; &#125; return false;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"深度学习_Python使用技巧","slug":"技术/机器学习/机器学习_Python使用技巧","date":"2017-06-15T11:47:07.000Z","updated":"2019-03-28T00:54:57.849Z","comments":true,"path":"2017/06/15/技术/机器学习/机器学习_Python使用技巧/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/06/15/技术/机器学习/机器学习_Python使用技巧/","excerpt":"记录所有涉及Python的短语句的写法。","text":"记录所有涉及Python的短语句的写法。 常用的包的引入和别名： 12345678910111213141516171819import xlrdimport xlwtimport numpy as npimport pandas as pdimport seaborn as snsimport scipy.io as sioimport matplotlib.pyplot as pltfrom scipy import statsfrom sklearn import metricsfrom sklearn.metrics import classification_report,accuracy_score,confusion_matrix,roc_curve, aucfrom sklearn import preprocessingfrom sklearn.svm import LinearSVC,SVCfrom sklearn.neighbors import KNeighborsClassifierfrom sklearn.linear_model import LogisticRegressionfrom sklearn.feature_selection import SelectKBest, f_classif,RFECVfrom sklearn import cross_validationfrom sklearn.cross_validation import StratifiedKFold,LeavePOut,LeaveOneOutfrom sklearn.model_selection import train_test_split Python 目录操作 1234import osdirs_and_files = os.listdir(r'd:/') #os.chdir(r'd:/')os.path.join(path1,path2) # 拼接路径 读写文本文件 123file_object = open(filepath, 'w')file_object.write(string)file_object.close() 读写Excel 12345678910111213141516171819import xlrddata = xlrd.open_workbook(excelfile)table = data.sheets()[0] #通过索引顺序获取table = data.sheet_by_index(0) #通过索引顺序获取table = data.sheet_by_name(u'详细信息')#通过名称获取cellij = table.cell(i,j).valueimport xlwtworkbook = xlwt.Workbook(encoding = 'ascii')worksheet = workbook.add_sheet('sheet1')worksheet.write(i, j, label = value)workbook.save(r'excel.xls')import pandas as pddataframe = pd.read_excel(filepath,sheetname='sheet1',header=None,index_col=None)dataframe = pd.read_csv(filepath,sheetname='sheet1',header=None,index_col=None)dataframe.to_excel(filepath,sheet_name='sheet2',header=False,index=False)dataframe.to_csv(filepath,sheet_name='sheet2',header=False,index=False) list类型转换成string类型输出 使用python将list类型的数据转换成string类型的。eg: [1,2,3,4,5,6] to 1,2,3,4,5,6 123456789101112131415161718192021def list_to_str(list): str1 = str(list) str1 = str1.replace(']','').replace('[','').replace(' ','') return str1for line in open('e:/test_sigmoid222.txt','r'): aa = line.strip('\\n') .split('\\t'); bb = map(int,aa[1].split(',')); cc = [] maxValues = max(bb) minValues = min(bb) for x in bb: y = (float)(x-minValues)/(maxValues-minValues) y = (int)(y*1000) cc.append(y) with open('e:/test_sigmoid.txt','a') as of: outstr = aa[0] outstr = outstr + \"\\t\" outstr = outstr + list_to_str(cc) outstr = outstr + \"\\n\" of.write(outstr) 输入和输出 读取首行是字段名称的CSV数据，或者文本数据 12345import pandas as pd# pandas.dataFrame 类型data = pd.read_csv(file_path)# numpy ndarray 类型data_matrix = data.as_matrix() 从控制台读取整数 123456789101112import stringtry: lists = [] while True: line = raw_input().split() lists.append(string.atoi(line[0]))except EOFError: pass## 或者这样写(x,y) = (int(x) for x in raw_input().split()) 读取控制台一行字符串 12345678910try: lineStrings=[] lineStrings.append(raw_input())except EOFError: pass# 或者这样写import sysnum = sys.stdin.readline()[:-1] # -1 to discard the '\\n' in input stream 每次输出一个字符 123import syssys.stdout.write('a')sys.stdout.write(' ') 倒序输出一个List 1print range(10)[::-1] 格式转换 字符串转整形和浮点型 123import stringstring.atoi()string.atof() 数序运算 1234567a = 10print a*2print a**2print a**0.5print a%10print a%3print a/3","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"}],"tags":[{"name":"python","slug":"python","permalink":"http://ff120.github.io/hexoblog/tags/python/"}]},{"title":"机器学习_Scipy使用技巧","slug":"技术/机器学习/机器学习_Scipy使用技巧","date":"2017-06-15T11:38:53.000Z","updated":"2019-03-28T00:54:57.925Z","comments":true,"path":"2017/06/15/技术/机器学习/机器学习_Scipy使用技巧/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/06/15/技术/机器学习/机器学习_Scipy使用技巧/","excerpt":"scipy是一个统计工具包，包含各种各种的统计方法。本文主要记录各种统计计算需要调用的函数名称和函数的调用格式。","text":"scipy是一个统计工具包，包含各种各种的统计方法。本文主要记录各种统计计算需要调用的函数名称和函数的调用格式。 单样本T检验 12from scipy import statspvalues = stats.ttest_1samp(dffeatures,mean=0.0,axis=0) 双样本T检验 12from scipy import statspvalues = stats.ttest_ind(group1,group2)","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"}],"tags":[{"name":"ML,统计","slug":"ML-统计","permalink":"http://ff120.github.io/hexoblog/tags/ML-统计/"}]},{"title":"机器学习_分类器性能的度量","slug":"技术/机器学习/机器学习_分类器性能的度量","date":"2017-06-03T05:18:13.000Z","updated":"2019-03-28T00:54:57.969Z","comments":true,"path":"2017/06/03/技术/机器学习/机器学习_分类器性能的度量/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/06/03/技术/机器学习/机器学习_分类器性能的度量/","excerpt":"分类器性能的度量指标，包括accuracy,recall,Specificity,precision,f1,ROC,等概念的定义和如何使用matplotlib绘制相应的图形。","text":"分类器性能的度量指标，包括accuracy,recall,Specificity,precision,f1,ROC,等概念的定义和如何使用matplotlib绘制相应的图形。 导入需要用到的包 1from sklearn import metrics 对于二分类问题，我们用列表示真正的类别标签，用行表示分类器预测的类别标签。 positive negative positive TP FP negative FN TN 两个大写字母表示的简写可以这样理解：T表示预测正确，F表示预测错误。P表示正例(例如病人的分类，病人是正例，健康的是负例。)， N表示负例。TP表示正确的预测为正例(可知该样本本身为正例。)，FP表示错误的预测为正例(可知该样本本身为负例)，FN表示错误的预测成为负例(可知该样本本身为正例)，TN表示正确的预测成为负例(可知该样本本身为负例). 12# get the tablecm = confusion_matrix(y_true,y_pred) Accuracy 中文一般翻译成准确率，这个是最容易理解的，就是分类正确的样本数量占样本总量的百分比。 \\[ Accuracy = \\dfrac {TP+TN} {TP+FP+TN+FN} \\] 1accuracy_scores = metrics.accuracy_score(y_true,y_pred) Sensitivity Sensitivity(灵敏度)==recall(召回率)==true positive rate(真阳性率)==probability of detection \\[ recall = \\dfrac {TP} {TP+FN} \\] 含义是，所有病人中被分类成病人的 占 所有病人的百分比。 1recall_scores=metrics.recall_score(y_true,y_pred) Specificity Specificity==true negative rate \\[ Specificity = \\dfrac {TN} {TN+FP} \\] 健康人被误分类成病人 占 所有健康人的 百分比。 1specificity_scores = cm[1][1] / (float)(cm[1][1]+cm[0][1]) precision precision == positive predictive value \\[ precision = \\dfrac {TP} {TP+FP} \\] 在所有被分类成病人的样本中，真正的病人 占的百分比。 1precision_scores=metrics.precision_score(y_true,y_pred) F1 精确率和召回率的调和平均值。 \\[ \\dfrac 2 {F1}=\\dfrac 1 {precision}+\\dfrac 1 {recall}=\\dfrac {2TP} {2TP+FP+FN} \\] 1f1_scores = metrics.f1_score(y_true,y_pred) ROC 一种度量分类器性能的标准，曲线下面的面积越大，表示分类器越好。 12345678910111213141516171819202122232425def plot_roc(pfAcc): \"\"\" Parameters ---------- pfAcc : (n_classifier, ) of dict, in each dict, it is a dict which has the key 'y_true','y_pred','y_predproba' Returns -------- \"\"\" color=['r','b','g','y','k','#eeefff','#e44fff','#eee44f','#eeef22','#e99fff'] for i,(key,value) in enumerate(pfAcc.iteritems()): y_true = np.asarray([x[0] for x in value['y_true']]) y_pred_prob = np.asarray([x[0][1] for x in value['y_predprob']]) false_positive_rate, recall, thresholds = roc_curve(y_true,y_pred_prob,pos_label=2) roc_auc = auc(false_positive_rate, recall) plt.plot(false_positive_rate, recall, color[i], label=key+',AUC = %0.2f' % roc_auc) plt.plot([0, 1], [0, 1], '--', color=(0.6, 0.6, 0.6), label='Luck') plt.xlim([-0.05, 1.05]) plt.ylim([-0.05, 1.05]) plt.xlabel('False Positive Rate') plt.ylabel('True Positive Rate') plt.legend(loc=\"lower right\") plt.legend().draggable() plt.show()","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"}],"tags":[{"name":"ML","slug":"ML","permalink":"http://ff120.github.io/hexoblog/tags/ML/"}]},{"title":"fMRI相关问题汇总","slug":"技术/认知神经科学/fMRI相关问题汇总","date":"2017-05-30T06:56:06.000Z","updated":"2019-03-28T00:54:59.513Z","comments":true,"path":"2017/05/30/技术/认知神经科学/fMRI相关问题汇总/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/05/30/技术/认知神经科学/fMRI相关问题汇总/","excerpt":"记录fMRI中还没有十分理解的概念。","text":"记录fMRI中还没有十分理解的概念。 functional connection 和 functional connectivity 相关的英文短语 At present, we do not have any biological tests which can contribute towards a diagnosis of depression. is feasible 可行的。 These findings provide an important step in the development of potential neuroimaging based tools for clinical diagnosis as the findings demonstrate that the identification of depression is feasible within a multi-ethnic group from the general community. understanding of the neuropsychopathology of depression. Alzheimer’s disease has been linked to decreased default mode functional connectivity. in line with can be interpreted as 可以被解读为 The spDCM uses cross spectra through Fourier transform of the correlation of the time series instead of the original time series. Thus, spDCM is a deterministic DCM approach, which can computationally explain functional connectivity in an explicit and direct way. spDCM和功能连接的关系的一种解释。 respectively. 各自的，分别的。 10.hexo","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"认知神经科学","slug":"技术/认知神经科学","permalink":"http://ff120.github.io/hexoblog/categories/技术/认知神经科学/"}],"tags":[{"name":"fMRI","slug":"fMRI","permalink":"http://ff120.github.io/hexoblog/tags/fMRI/"}]},{"title":"算法专题_字符串匹配","slug":"技术/数据结构和算法/算法专题_字符串匹配","date":"2017-05-28T06:47:13.000Z","updated":"2019-03-28T00:54:56.569Z","comments":true,"path":"2017/05/28/技术/数据结构和算法/算法专题_字符串匹配/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/05/28/技术/数据结构和算法/算法专题_字符串匹配/","excerpt":"字符串匹配问题的相关算法。","text":"字符串匹配问题的相关算法。 KMP算法 设有字符串T，模式串P，要从T中找出P，通常的做法是逐个比较T和P的第一个字符，如果相同，就比较T和P的第二个字符，一旦匹配失败，T后移一个字符重新开始与P的第一个字符比较。但是这样的方法如果遇到特别“刁钻”的T和P的组合，就会浪费很多比较的时间，例如，每次都是比较到P的最后一个字符才不匹配。KMP算法就是为了减少不必要的比较，使得每次比较不成功的时候，P可以向后移动尽可能远的距离。 每次失败后要向后移动多少呢？这个由P的next数组决定。next数组是一个与P等长，只与模式串P有关系，而与T没有关系的一个整数数组。它的值表示当前这个字符比较失败后，模式串向后移动的距离。 next数组如何求解呢？ P中任何一个字符对应的next数组的值，等于从P开始到它所对应的前缀和后缀的共有元素的长度。举例来说，P=“ABCDABD” “A”的前缀和后缀都是0，共有的长度也是0； “AB”的前缀是“A”,后缀是“B”,共有的长度是0； “ABC”的前缀是“A”,“AB”,后缀是“C”,“BC”,共有的长度为0； “ABCD”的前缀是“A”,“AB”,“ABC”,后缀是“D”,“CD”,“BCD”,共有的长度为0； “ABCDA”的前缀是“A”,“AB”,“ABC”,“ABCD”,后缀是“A”,“DA”,“CDA”,“BCDA”,二者都有A，所有共有的长度是1. “ABCDAB” 共有的长度为2 “ABCDABD” 共有的长度为0. 所以P的next数组为[0,0,0,0,1,2,0]. 可以看到，求解next数组的过程还是很清晰的，但是这个next数组并不是真正在KMP算法中使用的next数组。但是KMP算法中使用的next数组可以可容易的由这个数组生成，规则是：所有的元素右移一位。最右边的元素丢弃不要了，最左边补-1，这样新的next数组为[-1,0,0,0,0,1,2]. 直到next数组的值，KMP算法其实就算实现了，接下来只需要在每次匹配失败的时候，模式串向右移动的位数是： 失配字符所在的位置-失配字符对应的next数组的值。 求解next数组的代码： 12345678910111213141516171819202122232425262728/** * 求解模式串的next数组 * @param p * @return */vector&lt;int&gt; GetNext(string p)&#123; int pLen = p.size(); vector&lt;int&gt; next(pLen,0); next[0] = -1; int k = -1; int j = 0; while (j &lt; pLen - 1) &#123; //p[k]表示前缀，p[j]表示后缀 if (k == -1 || p[j] == p[k]) &#123; ++k; ++j; next[j] = k; &#125; else &#123; k = next[k]; &#125; &#125; return next;&#125; 此方法求解next数组其实并不是最优的，因为还有可能存在重复的比较，具体的实例可以参考http://blog.csdn.net/v_july_v/article/details/7041827, 优化后的next数组求解方法可以进一步减少比较的次数，只是这个会更不容易理解。 12345678910111213141516171819202122232425262728vector&lt;int&gt; OGetNext(string p)&#123; int pLen = p.size(); vector&lt;int&gt; next(pLen,0); next[0] = -1; int k = -1; int j = 0; while (j &lt; pLen - 1) &#123; //p[k]表示前缀，p[j]表示后缀 if (k == -1 || p[j] == p[k]) &#123; ++j; ++k; //较之前next数组求法，改动在下面4行 if (p[j] != p[k]) next[j] = k; //之前只有这一行 else //因为不能出现p[j] = p[ next[j ]]，所以当出现时需要继续递归，k = next[k] = next[next[k]] next[j] = next[k]; &#125; else &#123; k = next[k]; &#125; &#125; return next;&#125; 使用next数组查找模式串第一次出现的位置，并返回索引的函数，不存在会返回-1. 123456789101112131415161718192021222324252627int KmpSearch(string &amp;s, string &amp;p)&#123; int i = 0; int j = 0; int sLen = s.size(); int pLen = p.size(); auto next = OGetNext(p); while (i &lt; sLen &amp;&amp; j &lt; pLen) &#123; //①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++ if (j == -1 || s[i] == p[j]) &#123; i++; j++; &#125; else &#123; //②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j] //next[j]即为j所对应的next值 j = next[j]; &#125; &#125; if (j == pLen) return i - j; else return -1;&#125; 使用next数组比较字符串，返回模式串在S中出现的次数的函数。 12345678910111213141516171819202122232425262728293031int KmpSearch(string &amp;s, string &amp;p)&#123; int i = 0; int j = 0; int sLen = s.size(); int pLen = p.size(); auto next = OGetNext(p); int count = 0; while(i&lt;sLen)&#123; while (i &lt; sLen &amp;&amp; j &lt; pLen) &#123; //①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++ if (j == -1 || s[i] == p[j]) &#123; i++; j++; &#125; else &#123; //②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j] //next[j]即为j所对应的next值 j = next[j]; &#125; &#125; if (j == pLen)&#123; count++; j=0; &#125; &#125; return count;&#125; 字典树 异或（今日头条2017秋招真题） 异或（今日头条2017秋招真题） 题目描述 给定整数m以及n个数字A1, A2, …, An，将数列A中所有元素两两异或，共能得到n(n-1)/2个结果。请求出这些结果中大于m的有多少个。 输入 第一行包含两个整数n, m。 第二行给出n个整数A1, A2, …, An。 样例输入 3 10 6 5 10 输出 输出仅包括一行，即所求的答案。 样例输出 2 时间限制 C/C++语言：1000MS其它语言：3000MS 内存限制 C/C++语言：65536KB其它语言：589824K 思路： 从最高位开始建立字典树，左子树表示二进制0，右子树表示二进制位1. 每个节点统计在n个数字中对应的二进制位上有多少个对应的0或者1. 查询每个数字a和m，比较a和m对应的位，有如下情况 2.1 a = 0, m = 0, 这个时候 b=0 , a^b = 0 不能确定谁大，继续查找下一位 2.2 a = 0, m = 1, 这个时候 b=0 , 肯定有a^b &lt; m, 不满足条件，跳过； b = 1, 继续查找下一位 2.3 a = 1, m = 0, 这个时候 b=0 , 肯定有a^b &gt; m, 满足条件，直接将对应的count加在结果上， b=1,继续查找下一位 2.4 a = 1, m = 1, 这个时候 b=0 , 继续查找下一位，b = 1,肯定不满足条件， 最后的结果除以2返回， 因为我们既统计了a与b的异或，也统计了b与a的异或。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct TrieTree&#123; int count; struct TrieTree* next[2]&#123;NULL,NULL&#125;; TrieTree():count(1)&#123;&#125;&#125;;TrieTree* buildTrieTree(const vector&lt;int&gt;&amp; array)&#123; TrieTree* trieTree = new TrieTree(); for(int i=0;i&lt;(int)array.size();++i) &#123; TrieTree* cur = trieTree; for(int j=16;j&gt;=0;--j) &#123; int digit = (array[i] &gt;&gt; j) &amp; 1; if(NULL == cur-&gt;next[digit]) cur-&gt;next[digit] = new TrieTree(); else ++(cur-&gt;next[digit]-&gt;count); cur = cur-&gt;next[digit]; &#125; &#125; return trieTree;&#125;long long queryTrieTree(TrieTree*&amp; trieTree, const int a, const int m, const int index)&#123; if(NULL == trieTree) return 0; TrieTree* cur = trieTree; for(int i=index;i&gt;=0;--i) &#123; int aDigit = (a &gt;&gt; i) &amp; 1; int mDigit = (m &gt;&gt; i) &amp; 1; if(1==aDigit &amp;&amp; 1==mDigit) &#123; if(NULL == cur-&gt;next[0]) return 0; cur = cur-&gt;next[0]; &#125; else if(0 == aDigit &amp;&amp; 1==mDigit) &#123; if(NULL == cur-&gt;next[1]) return 0; cur = cur-&gt;next[1]; &#125; else if(1 == aDigit &amp;&amp; 0 == mDigit) &#123; long long val0 = (NULL == cur-&gt;next[0]) ? 0 : cur-&gt;next[0]-&gt;count; long long val1 = queryTrieTree(cur-&gt;next[1],a,m,i-1); return val0+val1; &#125; else if(0 == aDigit &amp;&amp; 0 == mDigit) &#123; long long val0 = queryTrieTree(cur-&gt;next[0],a,m,i-1); long long val1 = (NULL == cur-&gt;next[1]) ? 0 : cur-&gt;next[1]-&gt;count; return val0+val1; &#125; &#125; return 0;&#125;long long solve(const vector&lt;int&gt;&amp; array, const int&amp; m)&#123; TrieTree* trieTree = buildTrieTree(array); long long result = 0; for(int i=0;i&lt;(int)array.size();++i) &#123; result += queryTrieTree(trieTree,array[i],m,16); &#125; return result /2;&#125;int main()&#123; freopen(\"d:/A.in\",\"r\",stdin); int n,m; while(cin&gt;&gt;n&gt;&gt;m) &#123; vector&lt;int&gt; array(n); for(int i=0;i&lt;n;++i) cin&gt;&gt;array[i]; cout&lt;&lt; solve(array,m) &lt;&lt;endl; &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;using namespace std;using ll = long long;const int MAXBIT = 17;struct trieTree&#123; ll count = 0; trieTree* next[2] = &#123;nullptr, nullptr&#125;; trieTree() : count(0)&#123;&#125; trieTree(int c) : count(c)&#123;&#125;&#125;;trieTree* createTree(const vector&lt;int&gt; &amp;arr)&#123; trieTree* root = new trieTree(1); for (int i = 0; i &lt; arr.size(); ++i) &#123; int index = MAXBIT; // int 整形最多32位 trieTree* cur = root; while(index &gt;= 0)&#123; int digit = (arr[i] &gt;&gt; index) &amp; 1; // 从低位到高位第index+1位的值 if(cur-&gt;next[digit] == nullptr)&#123; cur-&gt;next[digit] = new trieTree(1); &#125;else&#123; cur-&gt;next[digit]-&gt;count ++; &#125; cur = cur-&gt;next[digit]; index--; &#125; &#125; return root;&#125;/** * 查询trie树中有多少个数字满足a^b&gt;m * @param root * @param a * @param m * @param index * @return */ll queryTree(trieTree* root,int a, int m, int index)&#123; if(root == nullptr) return 0; for (int i = index; i &gt;= 0; --i) &#123; int aDigit = (a &gt;&gt; i) &amp; 1; int mDigit = (m &gt;&gt; i) &amp; 1; if(aDigit == 0 &amp;&amp; mDigit == 0)&#123; ll v0 = 0 , v1 = 0; if(root-&gt;next[1] != nullptr)&#123; v0 = root-&gt;next[1]-&gt;count; &#125; v1 = queryTree(root-&gt;next[0],a,m,i-1); return v0 + v1; &#125;else if(aDigit == 0 &amp;&amp; mDigit == 1)&#123; if(root-&gt;next[1] == nullptr) return 0; return queryTree(root-&gt;next[1],a,m,i-1); &#125;else if(aDigit == 1 &amp;&amp; mDigit == 0)&#123; ll v0 = 0 , v1 = 0; if(root-&gt;next[0] != nullptr)&#123; v0 = root-&gt;next[0]-&gt;count; &#125; v1 = queryTree(root-&gt;next[1],a,m,i-1); return v0 + v1; &#125;else if(aDigit == 1 &amp;&amp; mDigit == 1)&#123; if(root-&gt;next[0] == nullptr) return 0; return queryTree(root-&gt;next[0],a,m,i-1); &#125;else&#123; cout&lt;&lt;\"error\"&lt;&lt;endl; &#125; &#125; return 0;&#125;ll solve(vector&lt;int&gt; &amp;v, int m)&#123; trieTree* root = createTree(v); ll result = 0; for (int i = 0; i &lt; v.size(); ++i) &#123; result += queryTree(root,v[i],m,MAXBIT); &#125; return result / 2;&#125;int main()&#123; freopen(\"d:/A.in\",\"r\",stdin); int n, m ; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; v(n,0); for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; v[i]; &#125; cout&lt;&lt;solve(v,m)&lt;&lt;endl; return 0;&#125; 统计子目录 统计子目录 描述 小Hi的电脑的文件系统中一共有N个文件，例如： /hihocoder/offer22/solutions/p1 /hihocoder/challenge30/p1/test /game/moba/dota2/uninstall 小Hi想统计其中一共有多少个不同的子目录。上例中一共有8个不同的子目录： /hihocoder /hihocoder/offer22 /hihocoder/offer22/solutions /hihocoder/challenge30 /hihocoder/challenge30/p1 /game /game/moba /game/moba/dota2/ 输入 第一行包含一个整数N (1 ≤ N ≤ 10000) 以下N行每行包含一个字符串，代表一个文件的绝对路径。保证路径从根目录“/”开始，并且文件名和目录名只包含小写字母和数字。 对于80%的数据，N个文件的绝对路径长度之和不超过10000 对于100%的数据，N个文件的绝对路径长度之和不超过500000 输出 一个整数代表不同子目录的数目。 样例输入 3 /hihocoder/offer22/solutions/p1 /hihocoder/challenge30/p1/test /game/moba/dota2/uninstall 样例输出 8 思路： 用每个目录的名字建立字典树，根是空字符，然后统计整棵树节点的数目，最后返回节点的数目-1. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;deque&gt;#include &lt;stack&gt;using namespace std;/* * [统计子目录](http://hihocoder.com/problemset/solution/1157194) * */struct trieTree&#123; string description; vector&lt;trieTree*&gt; sons; trieTree() : description(\"\")&#123;&#125; trieTree(string &amp;s) : description(s)&#123;&#125;&#125;;/** * 层次遍历统计节点数目 * @param root * @return */int countNodes(trieTree* root)&#123; if(root == nullptr) return 0; if(root-&gt;sons.empty()) return 1; vector&lt;trieTree*&gt; nodes, next; nodes.push_back(root); int re = 0; while(!nodes.empty())&#123; for (int i = 0; i &lt; nodes.size(); ++i) &#123; next.insert(next.end(),nodes[i]-&gt;sons.begin(),nodes[i]-&gt;sons.end()); &#125; re += nodes.size(); nodes = next; next.clear(); &#125; return re;&#125;/** * 递归遍历节点数目 * @param root * @return */int countNode2(trieTree *root)&#123; if(root == nullptr) return 0; if(root-&gt;sons.empty()) return 1; int re = 1; for (int i = 0; i &lt; root-&gt;sons.size(); ++i) &#123; re += countNode2(root-&gt;sons[i]); &#125; return re;&#125;vector&lt;string&gt; splitString(const string &amp;s)&#123; vector&lt;string&gt; re; if(s.empty()) return re; size_t index1 = 0; size_t index2 = 1; while(s.find('/',index2) != -1)&#123; index2 = s.find('/',index1+1); re.push_back(s.substr(index1+1,index2-index1-1)); index1 = index2; index2++; &#125; return re;&#125;int solve(vector&lt;string&gt; &amp;pathes, int n)&#123; if(pathes.empty() || n &lt;= 0) return 0; int result = 0; trieTree *root = new trieTree(); for (int i = 0; i &lt; n; ++i) &#123; vector&lt;string&gt; path = splitString(pathes[i]); trieTree *cur = root; for (int j = 0; j &lt; path.size(); ++j) &#123; if(cur-&gt;sons.empty())&#123; cur-&gt;sons.push_back(new trieTree(path[j])); result++; cur = cur-&gt;sons[0]; &#125;else&#123; int index = cur-&gt;sons.size(); for (int k = 0; k &lt; cur-&gt;sons.size(); ++k) &#123; if(cur-&gt;sons[k]-&gt;description == path[j])&#123; index = k; break; &#125; &#125; if(index == cur-&gt;sons.size())&#123; cur-&gt;sons.push_back(new trieTree(path[j])); result++; cur = cur-&gt;sons[cur-&gt;sons.size()-1]; &#125;else&#123; cur = cur-&gt;sons[index]; &#125; &#125; &#125; &#125; int re = countNode2(root) - 1; return result;&#125;int main()&#123; freopen(\"d:/A.in\",\"r\",stdin); int n; cin&gt;&gt;n; vector&lt;string&gt; pathes(n,\"\"); for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; pathes[i]; &#125; cout&lt;&lt;solve(pathes,n)&lt;&lt;endl; return 0;&#125; 合并子目录 合并子目录 描述 小Hi的电脑的文件系统中一共有N个文件，例如： /hihocoder/offer23/solutions/p1 /hihocoder/challenge30/p1/test /game/moba/dota2/uninstall 经过统计，小Hi认为他的电脑中子目录实在太多了，于是他决定减少子目录的数量。小Hi发现其中一些子目录只包含另一个子目录，例如/hihocoder/offer22只包含一个子目录solution，/game只包含一个子目录moba，而moba也只包含一个子目录dota2。小Hi决定把这样的子目录合并成一个子目录，并且将被合并的子目录的名字用’-’连起来作为新子目录的名字。合并之后上例的3个文件的路径会变为： /hihocoder/offer23-solutions/p1 /hihocoder/challenge30-p1/test /game-moba-dota2/uninstall 输入 第一行包含一个整数N (1 ≤ N ≤ 10000) 以下N行每行包含一个字符串，代表一个文件的绝对路径。保证路径从根目录“/”开始，并且文件名和目录名只包含小写字母和数字。 对于80%的数据，N个文件的绝对路径长度之和不超过10000 对于100%的数据，N个文件的绝对路径长度之和不超过500000 输出 对于输入中的每个文件，输出合并子目录之后该文件的绝对路径。 样例输入 3 /hihocoder/offer23/solutions/p1 /hihocoder/challenge30/p1/test /game/moba/dota2/uninstall 样例输出 /hihocoder/offer23-solutions/p1 /hihocoder/challenge30-p1/test /game-moba-dota2/uninstall 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;deque&gt;#include &lt;stack&gt;using namespace std;/* * [统计子目录](http://hihocoder.com/problemset/solution/1157194) * */struct trieTree&#123; string description; vector&lt;trieTree*&gt; sons; trieTree() : description(\"\")&#123;&#125; trieTree(string &amp;s) : description(s)&#123;&#125;&#125;;vector&lt;string&gt; splitString(string &amp;s)&#123; vector&lt;string&gt; re; if(s.empty()) return re; s.push_back('/'); size_t index1 = 0; size_t index2 = 1; while(s.find('/',index2) != -1)&#123; index2 = s.find('/',index1+1); re.push_back(s.substr(index1+1,index2-index1-1)); index1 = index2; index2++; &#125; return re;&#125;trieTree* createTree(vector&lt;string&gt; &amp;pathes)&#123; if(pathes.empty()) return 0; int result = 0; trieTree *root = new trieTree(); for (int i = 0; i &lt; pathes.size(); ++i) &#123; vector&lt;string&gt; path = splitString(pathes[i]); trieTree *cur = root; for (int j = 0; j &lt; path.size(); ++j) &#123; if(cur-&gt;sons.empty())&#123; cur-&gt;sons.push_back(new trieTree(path[j])); result++; cur = cur-&gt;sons[0]; &#125;else&#123; int index = cur-&gt;sons.size(); for (int k = 0; k &lt; cur-&gt;sons.size(); ++k) &#123; if(cur-&gt;sons[k]-&gt;description == path[j])&#123; index = k; break; &#125; &#125; if(index == cur-&gt;sons.size())&#123; cur-&gt;sons.push_back(new trieTree(path[j])); result++; cur = cur-&gt;sons[cur-&gt;sons.size()-1]; &#125;else&#123; cur = cur-&gt;sons[index]; &#125; &#125; &#125; &#125; return root;&#125;trieTree* reduceTree(trieTree* root)&#123; trieTree* re = root; if(root-&gt;sons.empty()) return root; if(root-&gt;sons.size() &gt;= 2)&#123; for (int i = 0; i &lt; root-&gt;sons.size(); ++i) &#123; reduceTree(root-&gt;sons[i]); &#125; &#125; if(root-&gt;sons.size() == 1)&#123; trieTree* next = root-&gt;sons[0]; if(next-&gt;sons.empty())&#123;// root-&gt;description = root-&gt;description + \"-\";// root-&gt;description = root-&gt;description + next-&gt;description;// root-&gt;sons.clear(); return root; &#125; root-&gt;sons.clear(); for (int i = 0; i &lt; next-&gt;sons.size(); ++i) &#123; root-&gt;sons.push_back(next-&gt;sons[i]); &#125; root-&gt;description = root-&gt;description + \"-\"; root-&gt;description = root-&gt;description + next-&gt;description; reduceTree(root); &#125; return re;&#125;void printTree(trieTree* root,string out)&#123; if(nullptr == root) return; out += root-&gt;description + \"/\"; if(root-&gt;sons.empty())&#123; if(out.find_last_of('/') == out.size() - 1)&#123; out.erase(out.size()-1); &#125; cout&lt;&lt;out&lt;&lt;endl; &#125;else&#123; for (int i = 0; i &lt; root-&gt;sons.size(); ++i) &#123; printTree(root-&gt;sons[i],out); &#125; &#125;&#125;void solve(vector&lt;string&gt; &amp;pathes, int n)&#123; int result = 0; trieTree* root = createTree(pathes); trieTree* reduced = reduceTree(root); string out = \"\"; printTree(reduced,out);&#125;int main()&#123; freopen(\"d:/A.in\",\"r\",stdin); int n; cin&gt;&gt;n; vector&lt;string&gt; pathes(n,\"\"); for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; pathes[i]; &#125; solve(pathes,n); return 0;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"计蒜之道2017程序设计大赛","slug":"技术/数据结构和算法/计蒜之道2017程序设计大赛","date":"2017-05-27T14:27:35.000Z","updated":"2019-03-28T00:54:57.366Z","comments":true,"path":"2017/05/27/技术/数据结构和算法/计蒜之道2017程序设计大赛/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/05/27/技术/数据结构和算法/计蒜之道2017程序设计大赛/","excerpt":"记录计蒜之道竞赛题目的相关解题方案。","text":"记录计蒜之道竞赛题目的相关解题方案。 2017 计蒜之道 初赛 第一场 阿里的新游戏 题目要求 题库链接：https://nanti.jisuanke.com/t/15499 题目分析 仔细分析能够成三的坐标，发现非常有规律。可以按照这个规律遍历成三的坐标，一旦成三的坐标上都有小红的棋子在，结果就加1. 小红棋子的坐标我们用一个二维数组H来存储，H[i][j]=1表示在棋盘的x,y位置有小红的棋子。那么我们必须找出x,y和i,j之间的映射关系。这个是一个简单的坐标变换问题，直接给出变换关系如下： \\[ i = -y+3 \\\\ j = x+3 \\] 接下来就可以从行和列的角度分别遍历成三的坐标，检查是否成三了。完整的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;using namespace std;int main() &#123; int n,m; cin&gt;&gt;n&gt;&gt;m; int hong[9][9]; for(int i=0;i&lt;n;i++)&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; int x = -b+3; int y = a+3; hong[x][y] = 1; &#125; int num = 0; for(int x=-3;x&lt;=3;x++)&#123; int i1 = -x+3,i2=x+3,i3=3; int j = x+3; if(x!=0)&#123; (hong[i1][j]==1 &amp;&amp; hong[i2][j]==1 &amp;&amp; hong[i3][j]==1)?num++:num; &#125; if(x==0)&#123; int ii1=-1+3,ii2=-2+3,ii3=-3+3; (hong[ii1][j]==1 &amp;&amp; hong[ii2][j]==1 &amp;&amp; hong[ii3][j]==1)?num++:num; ii3=3+3, ii1= 1 + 3, ii2= 2 + 3; (hong[ii1][j]==1 &amp;&amp; hong[ii2][j]==1 &amp;&amp; hong[ii3][j]==1)?num++:num; &#125; &#125; for(int y=-3;y&lt;=3;y++)&#123; int i = -y+3; int j1 = -y+3,j2=y+3,j3=3; if(y!=0)&#123; (hong[i][j1]==1 &amp;&amp; hong[i][j2]==1 &amp;&amp; hong[i][j3]==1)?num++:num; &#125; if(y==0)&#123; int jj1=-3+3,jj2=-2+3,jj3=-1+3; (hong[i][jj1]==1 &amp;&amp; hong[i][jj2]==1 &amp;&amp; hong[i][jj3]==1)?num++:num; jj1=3+3,jj2=2+3,jj3=1+3; (hong[i][jj1]==1 &amp;&amp; hong[i][jj2]==1 &amp;&amp; hong[i][jj3]==1)?num++:num; &#125; &#125; cout&lt;&lt;num&lt;&lt;endl; return 0;&#125; 阿里天池的新任务 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;limits&gt;using namespace std;vector&lt;int&gt; OGetNext(string p)&#123; int pLen = p.size(); vector&lt;int&gt; next(pLen,0); next[0] = -1; int k = -1; int j = 0; while (j &lt; pLen - 1) &#123; //p[k]表示前缀，p[j]表示后缀 if (k == -1 || p[j] == p[k]) &#123; ++j; ++k; //较之前next数组求法，改动在下面4行 if (p[j] != p[k]) next[j] = k; //之前只有这一行 else //因为不能出现p[j] = p[ next[j ]]，所以当出现时需要继续递归，k = next[k] = next[next[k]] next[j] = next[k]; &#125; else &#123; k = next[k]; &#125; &#125; return next;&#125;int KmpSearch(string &amp;s, string &amp;p)&#123; int i = 0; int j = 0; int sLen = s.size(); int pLen = p.size(); auto next = OGetNext(p); int count = 0; while(i&lt;sLen)&#123; while (i &lt; sLen &amp;&amp; j &lt; pLen) &#123; //①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++ if (j == -1 || s[i] == p[j]) &#123; i++; j++; &#125; else &#123; //②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j] //next[j]即为j所对应的next值 j = next[j]; &#125; &#125; if (j == pLen)&#123; count++; j=0; &#125; &#125; return count;&#125;int main() &#123; int n,a,b,L,R; cin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;L&gt;&gt;R; string t; cin&gt;&gt;t; string s(n,' '); for(int i=0;i&lt;n;i++)&#123; int wi = (i*a+b)%n; if((wi&lt;L||wi&gt;R)&amp;&amp;wi%2==0)&#123; s[i] = 'G'; &#125; if((wi&lt;L||wi&gt;R)&amp;&amp;wi%2==1)&#123; s[i] = 'C'; &#125; if((wi&gt;=L&amp;&amp;wi&lt;=R)&amp;&amp;wi%2==0)&#123; s[i]='A'; &#125; if((wi&gt;=L&amp;&amp;wi&lt;=R)&amp;&amp;wi%2==1)&#123; s[i]='T'; &#125; &#125; cout&lt;&lt;KmpSearch(s,t)&lt;&lt;endl; return 0;&#125; 2017 计蒜之道 初赛 第二场 百度的年会游戏 题目要求 https://nanti.jisuanke.com/t/15503 题目分析 建立合适的坐标系，把人和第几个木块对应到建立的坐标系上，只要坐标的转换过程不出错。题目很容易解决。可以暴力遍历每一种组合，看是否能够赢。毕竟解的空间很小，完全不用考虑时间复杂度的问题。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;limits&gt;using namespace std;int main() &#123; int num1,num2,num3,num4,k,d; cin&gt;&gt;num1&gt;&gt;num2&gt;&gt;num3&gt;&gt;num4&gt;&gt;k&gt;&gt;d; int total = num1+num2+num3+num4; // 0 表示普通的，1表示获胜的木块 vector&lt;int&gt; zh(total,0); if(k==1)&#123; zh[d-1] = 1; zh[d] = 1; &#125;else if(k==2)&#123; zh[num1+num4+num3+d-1] = 1; zh[num1+num4+num3+d] = 1; &#125;else if(k==3)&#123; zh[num1+num4+d-1] = 1; zh[num1+num4+d] = 1; &#125;else&#123; zh[num1+d-1] = 1; zh[num1+d] = 1; &#125; int count = 0; for(int x=1;x&lt;=6;x++)&#123; for(int y=x;y&lt;=6;y++)&#123; // 从谁的面前开始数 int people = (x+y)%4==0 ? 4 : (x+y)%4; //数多少个开始拿 int kth = min(x,y)+1; //判断能不能获胜 &#125; &#125; return 0;&#125; 2017 计蒜之道 初赛 第三场 腾讯课堂的物理实验 题目要求 题库链接：https://nanti.jisuanke.com/t/15546 题目分析 光滑跑道，两个小球都是匀速运动，碰撞之后向反方向运动，各自的速度不变(依然保持1m/s),所以可以看作两个小球不受干扰的各自在跑道上运动，运动到跑道的边缘返回(因为题目中只是求解两个小球的距离，并不要求区分哪个小球是A, 哪个是B.) 我们把0时刻A所在的位置定位坐标原点，B所在的位置的坐标就是L,只要求解出T时刻A的坐标x1和B的坐标x2，就能轻松得到二者的距离为|x1-x2|. T时刻A走过的路程是T，此时它的坐标应该是x=(T/L)%2==0 ? T%L : L-(T%L),T时刻B走过的路程要分情况讨论，当T&lt;=t的时候，B在L处，此时y=L;当T&gt;t时，B运动的时间是T-t,路程也是T-t,此时它的坐标是y=((T-t)/L%2==0) ? L-(T-t)%L : (T-t)%L. 完整的解题代码如下： 12345678910111213141516#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int L,t,T; cin&gt;&gt;L&gt;&gt;t&gt;&gt;T; int x=0,y=L,dis=0; x=(T/L)%2==0 ? T%L : L-(T%L); if(T&gt;t)&#123; y=((T-t)/L%2==0) ? L-(T-t)%L : (T-t)%L; &#125; dis = abs(x-y); cout&lt;&lt;dis&lt;&lt;endl; return 0;&#125; 腾讯狼人杀 题目要求 题库链接：https://nanti.jisuanke.com/t/15547 题目分析 最终要 求的是 \\(value = \\dfrac {\\sum w_i} {k(2n-k)}\\) 的最大值，所以要确定的是k的值，选几个人，还有就是都选哪些人。这些确定了就可以计算答案了。这个题目给出了简单，中等，困难三个难度等级。按照一般的套路，简单的问题是可以暴力求解的。所以，我们首先试着用遍历的方式求解该题目的简单版本。 如果暂时不考虑最后一个限制条件，那么这就是一个全排列问题。假设m=3，有3条记录。那么所有的情况是：(1),(2),(3),(1,2),(1,3),(2,3),(1,2,3), 共有6种情况，计算这6种情况下对应的value,取最大的输出就可以。 枚举所有的情况是找一个集合的子集的问题，集合元素是m的时候，它的所有子集是 \\(2^m\\),这里空集没有意义，所以要枚举的情况有 \\(2^m-1\\) 种。枚举一个集合的所有子集的问题可以使用位操作加快速度，对于每个枚举出来的项，首先判断是否满足限制条件，不满足的直接舍弃。","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"机器学习_损失函数","slug":"技术/机器学习/机器学习_损失函数","date":"2017-05-22T11:34:46.000Z","updated":"2019-03-28T00:54:58.096Z","comments":true,"path":"2017/05/22/技术/机器学习/机器学习_损失函数/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/05/22/技术/机器学习/机器学习_损失函数/","excerpt":"衡量预测标签和真实标签之间的差别，通常使用损失函数。","text":"衡量预测标签和真实标签之间的差别，通常使用损失函数。 log对数损失函数（逻辑回归） 平方损失(最小二乘法) 指数损失函数（Adaboost） Hinge损失函数（SVM）","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"}],"tags":[{"name":"ML","slug":"ML","permalink":"http://ff120.github.io/hexoblog/tags/ML/"}]},{"title":"机器学习_逻辑回归","slug":"技术/机器学习/机器学习_逻辑回归","date":"2017-05-19T12:24:29.000Z","updated":"2019-03-28T00:54:58.248Z","comments":true,"path":"2017/05/19/技术/机器学习/机器学习_逻辑回归/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/05/19/技术/机器学习/机器学习_逻辑回归/","excerpt":"本文总结常见的线性模型和他们之间的区别和联系。线性模型是一种比较简单的模型，实际使用中已经有了多种变化，来满足不同的需求。","text":"本文总结常见的线性模型和他们之间的区别和联系。线性模型是一种比较简单的模型，实际使用中已经有了多种变化，来满足不同的需求。 线性模型 最基本的线性模型是下面这样的形式： \\[ y = w_1x_1+w_2x_2+...+w_nx_n = w * x + b \\] 给定一组训练数据 \\((X,y)\\), 只要确定了 \\(w\\) 和 \\(b\\), 这个线性模型就确定了，就可以利用它来预测。 广义线性模型 简单的说，在 \\(w*x+b\\)的基础上再增加一个函数映射，把结果赋值给y,这样的模型叫做广义线性模型。 \\[ y = f(w*x+b) \\] 式子中的 \\(f(x)\\) 可以是各种映射函数，当 \\(f(x)=x\\) 的时候，就是普通的线性模型了。 逻辑回归 逻辑回归应该也算作是一种广义的线性模型，它就是 \\(f(x) = sigmoid\\) 函数的的广义线性模型。最常使用的sigmoid函数定义为： \\[ f(x) = \\dfrac {1} {1+e^{-z}} \\] softmax 回归 逻辑回归的sigmoid函数取值范围是0-1，通常只能用来解决二分类问题。我们可以扩展该方法，使之能处理n类的分类问题。这里其实就是把原来的sigmoid函数换成softmax函数.softmax函数是逻辑函数的一种推广。它能将一个含任意实数的 \\(K\\)维的向量 \\(z\\) 压缩”到另一个K维实向量中，使得每一个元素的范围都在(0, 1)之间，并且所有元素的和为1. \\[ {\\displaystyle \\sigma (\\mathbf {z} )_{j}={\\frac {e^{z_{j}}}{\\sum _{k=1}^{K}e^{z_{k}}}}} for j = 1, …, K. \\] 线性模型与神经网络的关系","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"}],"tags":[{"name":"LR","slug":"LR","permalink":"http://ff120.github.io/hexoblog/tags/LR/"}]},{"title":"机器学习_感知机","slug":"技术/机器学习/机器学习_感知机","date":"2017-05-19T06:40:18.000Z","updated":"2019-03-28T00:54:58.025Z","comments":true,"path":"2017/05/19/技术/机器学习/机器学习_感知机/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/05/19/技术/机器学习/机器学习_感知机/","excerpt":"感知机是神经网络的基本组成单元，这里有一篇文章是从零基础开始介绍感知机的，本文就是参考她实现的感知机。https://www.zybuluo.com/hanbingtao/note/433855","text":"感知机是神经网络的基本组成单元，这里有一篇文章是从零基础开始介绍感知机的，本文就是参考她实现的感知机。https://www.zybuluo.com/hanbingtao/note/433855 自己动手实现感知机 感知机是只有一层功能神经元的最简单的神经网络，它只能处理简单的线性分类。它的基本形式是： perception 设 \\(x\\) 表示输入向量，\\(y\\) 表示输出，感知机其实就是实现了以下的函数的结构： \\[ y = f(w \\times x + b) \\] 其中，\\(w\\) 是一个和 \\(x\\) 长度相同的向量，代表每个 \\(x_i\\) 的权重，\\(b\\) 是一个实数，表示偏置。\\(f(x)\\) 是任意一个定义在实数域上的函数，输入是一个实数，输出是一个实数。 感知机的学习就是根据给出的 \\(x\\) 和对应的 \\(y\\), 求解出参数 \\(w\\) 和偏置 \\(b\\). 感知机的预测就是利用训练好的模型( \\(w\\) 和 \\(b\\) 已经确定)，给出 \\(x\\), 求解 \\(y\\). 开始的时候，\\(w\\) 和 \\(b\\) 都初始化为0，用python代码表示就是： 12345678910def __init__(self, input_num, activator): ''' 初始化感知器，设置输入参数的个数，以及激活函数。 激活函数的类型为double -&gt; double ''' self.activator = activator # 权重向量初始化为0 self.weights = [0.0 for _ in range(input_num)] # 偏置项初始化为0 self.bias = 0.0 其中，input_num表示向量 \\(x\\) 包含多少个数字，activator 是上式中的 \\(f(x)\\). 感知机的预测就是在已知 \\(w\\) 和 \\(b\\) 的情况下， 计算 \\(y\\). 12345678910111213def predict(self, input_vec): ''' 输入向量，输出感知器的计算结果 ''' # 把input_vec[x1,x2,x3...]和weights[w1,w2,w3,...]打包在一起 # 变成[(x1,w1),(x2,w2),(x3,w3),...] # 然后利用map函数计算[x1*w1, x2*w2, x3*w3] # 最后利用reduce求和 return self.activator( reduce(lambda a, b: a + b, map(lambda (x, w): x * w, zip(input_vec, self.weights)) , 0.0) + self.bias) 感知机的训练就是在给出 \\(x\\) 和 \\(y\\) 的情况下，一步一步调整 \\(w\\) 和 \\(b\\) 的取值，使得输入和输出尽可能的匹配。这里直接给出参数调整的方法，至于为什么会是这样，为什么这样可以保证得到结果，可以看算法导论上相关的数学推导。 \\[ w_i \\leftarrow w_i + \\triangle w_i \\\\ b \\leftarrow b + \\triangle b \\\\ 其中 \\\\ \\triangle w = \\beta (t-y) x_i \\\\ \\triangle b = \\beta (t-y) \\] \\(y\\) 是感知机在当前的参数设置条件下(初始化的时候都是0) 的输出， \\(y\\) 是训练数据实际的标签，\\(\\beta\\) 称为学习率，控制参数更新的程度大小。可以看到，参数学习的时候，感知机是一条一条的处理的训练数据的，每处理一条训练数据，参数就更新一次，先来看看权重更新的代码： 12345678910111213def _update_weights(self, input_vec, output, label, rate): ''' 按照感知器规则更新权重 ''' # 把input_vec[x1,x2,x3,...]和weights[w1,w2,w3,...]打包在一起 # 变成[(x1,w1),(x2,w2),(x3,w3),...] # 然后利用感知器规则更新权重 delta = label - output self.weights = map( lambda (x, w): w + rate * delta * x, zip(input_vec, self.weights)) # 更新bias self.bias += rate * delta 把所有的训练数据都循环处理一遍，就完成了一次迭代，通常，只处理一次参数是不能得到充分的学习的，训练的时候要根据模型的复杂程度进行多次迭代，每次迭代参数都会更新。 12345678910111213def _one_iteration(self, input_vecs, labels, rate): ''' 一次迭代，把所有的训练数据过一遍 ''' # 把输入和输出打包在一起，成为样本的列表[(input_vec, label), ...] # 而每个训练样本是(input_vec, label) samples = zip(input_vecs, labels) # 对每个样本，按照感知器规则更新权重 for (input_vec, label) in samples: # 计算感知器在当前权重下的输出 output = self.predict(input_vec) # 更新权重 self._update_weights(input_vec, output, label, rate) 上面的代码就是完成一次迭代的过程，首先用现有的感知机的参数，预测输入 \\(x\\) 对应的输出 \\(y\\), 然后调用上面的参数更新函数，更新参数。 我们这里用迭代次数控制算法的停止时间，得到训练的方法. 当然，实际当中也可以用误差小于某一个给定的值来作为算法终止的条件。为什么要有误差，而不是百分之百的匹配上呢? 这是因为，在机器学习当中，百分之百拟合了训练数据，往往意味着过拟合了，在测试数据并不一定表现好，而我们需要的是在测试集上表现好。 123456def train(self, input_vecs, labels, iteration, rate): ''' 输入训练数据：一组向量、与每个向量对应的label；以及训练轮数、学习率 ''' for i in range(iteration): self._one_iteration(input_vecs, labels, rate) 一个简单的感知机的实现就是这样，实际使用的时候，还可以添加一些模型可视化的方法，例如输出模型参数 \\(w\\) 和 \\(b\\) 的方法，显示每次迭代过程的方法等等。下面是完整的代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Perceptron(object): def __init__(self, input_num, activator): ''' 初始化感知器，设置输入参数的个数，以及激活函数。 激活函数的类型为double -&gt; double ''' self.activator = activator # 权重向量初始化为0 self.weights = [0.0 for _ in range(input_num)] # 偏置项初始化为0 self.bias = 0.0 def __str__(self): ''' 打印学习到的权重、偏置项 ''' return 'weights\\t:%s\\nbias\\t:%f\\n' % (self.weights, self.bias) def predict(self, input_vec): ''' 输入向量，输出感知器的计算结果 ''' # 把input_vec[x1,x2,x3...]和weights[w1,w2,w3,...]打包在一起 # 变成[(x1,w1),(x2,w2),(x3,w3),...] # 然后利用map函数计算[x1*w1, x2*w2, x3*w3] # 最后利用reduce求和 return self.activator( reduce(lambda a, b: a + b, map(lambda (x, w): x * w, zip(input_vec, self.weights)) , 0.0) + self.bias) def train(self, input_vecs, labels, iteration, rate): ''' 输入训练数据：一组向量、与每个向量对应的label；以及训练轮数、学习率 ''' for i in range(iteration): self._one_iteration(input_vecs, labels, rate) def _one_iteration(self, input_vecs, labels, rate): ''' 一次迭代，把所有的训练数据过一遍 ''' # 把输入和输出打包在一起，成为样本的列表[(input_vec, label), ...] # 而每个训练样本是(input_vec, label) samples = zip(input_vecs, labels) # 对每个样本，按照感知器规则更新权重 for (input_vec, label) in samples: # 计算感知器在当前权重下的输出 output = self.predict(input_vec) # 更新权重 self._update_weights(input_vec, output, label, rate) def _update_weights(self, input_vec, output, label, rate): ''' 按照感知器规则更新权重 ''' # 把input_vec[x1,x2,x3,...]和weights[w1,w2,w3,...]打包在一起 # 变成[(x1,w1),(x2,w2),(x3,w3),...] # 然后利用感知器规则更新权重 delta = label - output self.weights = map( lambda (x, w): w + rate * delta * x, zip(input_vec, self.weights)) # 更新bias self.bias += rate * delta 下面我们使用写好的代码实现一个计算and功能的感知机。 12345678910111213141516171819def and_f(x): ''' 定义激活函数f ''' return 1 if x &gt; 0 else 0if __name__ == '__main__': # 训练and感知器 X = [[0,0],[0,1],[1,0],[1,1]] y = [0,0,0,1] and_perception = Perceptron(2,and_f) and_perception.train(X,y,10,0.1) # 打印训练获得的权重 print and_perception # 测试 print '1 and 1 = %d' % and_perception.predict([1, 1]) print '0 and 0 = %d' % and_perception.predict([0, 0]) print '1 and 0 = %d' % and_perception.predict([1, 0]) print '0 and 1 = %d' % and_perception.predict([0, 1]) 输出类似这样子： 1234567weights :[0.2, 0.1]bias :-0.2000001 and 1 = 10 and 0 = 01 and 0 = 00 and 1 = 0 从中我们可以看出，对于and的计算全部正确。我们从训练好的模型中可以提取出实现该and功能的函数。 \\[ y = f(0.2x_1 + 0.1x_2 -0.2) \\] \\(f(x)\\) 就是上面代码自定义的函数，当 \\(x&gt;0\\) 时输出1，否则输出0. scikit-learn中的感知机 多数情况下我们不需要自己实现感知机，有很多已经写好的代码可以使用，scikit-learn中就实现了感知机。我们直接调用它的函数，看看会是什么结果。 1234567891011121314151617from sklearn import linear_modellmper = linear_model.Perceptron(n_iter=10)lmper.fit(X,y)print(lmper.coef_)print(lmper.intercept_)print '1 and 1 = %d' % lmper.predict([1, 1])print '0 and 0 = %d' % lmper.predict([0, 0])print '1 and 0 = %d' % lmper.predict([1, 0])print '0 and 1 = %d' % lmper.predict([0, 1])## output[[ 3. 2.]][-4.]1 and 1 = 10 and 0 = 01 and 0 = 00 and 1 = 0 我们可以得到，scikit-learn得到的可以用来计算and的函数是： \\[ y = f(3x_1+2x_2-4) \\] 虽然和我们自己实现的不一样，但是功能都是一样的。目前还没有明白激活函数在哪里设置，所以最终参数的不同可能和激活函数的设置有关。 keras 实现感知机 1234567891011121314151617181920212223242526272829X = [[0,0],[0,1],[1,0],[1,1]]y = [0,0,0,1]from keras.models import Sequentialfrom keras.layers import Dense, Dropoutfrom keras.optimizers import RMSpropimport numpy as npX = np.array(X)y = np.array(y)model = Sequential()model.add(Dense(1, activation='relu', input_shape=(2,)))model.compile(loss='mean_squared_error', optimizer='SGD', metrics=['accuracy'])print(model.summary())history = model.fit(X, y,batch_size=128, epochs=1)print(model.get_weights())# 测试print('1 and 1 = %d' % model.predict(np.array([1, 1]).reshape(1,2)))print('0 and 0 = %d' % model.predict(np.array([0, 0]).reshape(1,2)))print('1 and 0 = %d' % model.predict(np.array([1, 0]).reshape(1,2)))print('0 and 1 = %d' % model.predict(np.array([0, 1]).reshape(1,2)))# output[array([[-1.21217406], [-1.16362488]], dtype=float32), array([ 0.], dtype=float32)]1 and 1 = 00 and 0 = 01 and 0 = 00 and 1 = 0 使用神经网络训练的并没有达到最优的结果，可能和我们训练的样本过少有关系。我们同样得到了训练出来的感知机： \\[ y = f(-1.2121x_1-1.1636x_2+0) \\] 不过这里只有75%的准确率，现在还不清楚里面的原理。 感知机的扩展 上面我们介绍的感知机使用了如下的激活函数： \\[ f(x)=\\begin{cases} 0 &amp; \\text{x&gt;0}\\\\ 1 &amp; \\text{x&lt;=0} \\end{cases} \\] 这导致我们的输出智能是0,1,我们可以改变一下这个函数，使得输出的值是连续的，这样就可以用来解决回归的问题了。例如，我们直接使用 \\(f(x)=x\\) 来作为激活函数。这样，我们实现了下面这样的线性函数： \\[ y = w * x + b \\] 123456789101112131415161718192021def fx(x): return xX = [[5], [3], [8], [1.4], [10.1]]y = [5500, 2300, 7600, 1800, 11400]linear_perception = Perceptron(1,fx)linear_perception.train(X,y,10,0.1)print linear_perceptionprint 'Work 3.4 years, monthly salary = %.2f' % linear_perception.predict([3.4])print 'Work 15 years, monthly salary = %.2f' % linear_perception.predict([15])print 'Work 1.5 years, monthly salary = %.2f' % linear_perception.predict([1.5])print 'Work 6.3 years, monthly salary = %.2f' % linear_perception.predict([6.3])# outputweights :[765.63113396072]bias :-778.455331Work 3.4 years, monthly salary = 1824.69Work 15 years, monthly salary = 10706.01Work 1.5 years, monthly salary = 369.99Work 6.3 years, monthly salary = 4045.02 上面训练了一个简单的一次线性函数： \\[ y = 765x-778 \\] 更新规则的推导(梯度下降法) 上面介绍感知机的时候，我们直接给出了参数更新的方法，但是没有说明这个方法是如何得出来的，现在我们给出推导的方法。 \\[ w_i \\leftarrow w_i + \\triangle w_i \\\\ b \\leftarrow b + \\triangle b \\\\ 其中 \\\\ \\triangle w = \\beta (t-y) x_i \\\\ \\triangle b = \\beta (t-y) \\] 设模型的输出是 $ $, 真实的标签是 \\(y\\), 那么我们训练模型的目的是使得 \\(\\hat y\\) 尽可能的接近 \\(y\\), 那么，如何度量它们之间的接近程度呢？ 一个简单的想法就是使用平方和. \\[ E = \\sum_{i=1}^{n}( {\\hat y_i}-y_i )^2 \\] 有了损失函数，接下来我们的目标就是使得该函数达到极小值，这样 \\(\\hat y\\)和 \\(y\\) 之间就尽可能接近了。 如何求解函数的极小值呢，我们可以求函数的导数，令导数等于0，这样我们就能找到它的极值点。不幸的是，并不是所有的函数我们都能求解出导数的，所以求导数的方法并没有什么普适性，计算机有强大的计算能力，所以遇到这类问题，基本上都使用数值计算的方法解决。 我们直到一个函数的梯度表示一个函数上升最快的方向，那么她的反方向就是下降最快的方向，而梯度的计算就是函数对每一个变量的偏导数，这个我们可以事先计算出来。然后随机初始化一个 \\(x\\), 求解\\(f(x)\\) 的值，然后朝着梯度下降的方向更新 \\(x\\), 经过无数次迭代之后，我们就能找到函数的极小值点对应的那个 \\(x\\). $ y = f(w*x+b)$ , 令\\(x_0 = 1,w_0=b\\), 可以把它写成统一的形式\\(\\hat y = f(w*x)\\) , 这样我们最终的目标是求解 \\(w\\), 所以我们把 \\(E\\) 看作 \\(w\\) 的函数，这样优化函数变形为： \\[ E(w) = \\sum_{i=1}^n ({\\hat y_i}-y_i)^2 \\] 求偏导的时候2次方会有一个系数2，所以我们把函数乘以 \\(\\dfrac 1 2\\), 消除求导时候的系数，这样优化的目标函数变为： \\[ E(w) =\\dfrac 1 2 \\sum_{i=1}^n ({\\hat y_i}-y_i)^2 \\] 下面就是求这个函数对 \\(w\\) 的梯度了。首先我们复习一下链式求导法则。 \\[ \\dfrac {\\partial E(w)} {\\partial w} = \\dfrac {E(w)} {\\partial \\hat y} * \\dfrac {\\partial \\hat y} {\\partial w} \\] 根据以上的链式求导法则，我们可以求解得到目标函数的梯度： \\[ \\Delta {E(w)} = - \\sum_{i=1}^n (y^i-\\hat y^i)x \\] 有了函数的梯度，就可以按照梯度的方向更新参数了。 \\[ w_{new} = w_{old} + \\beta \\sum_{i=1}^n (y^i-\\hat y^i)x^i \\] 式子中，\\(y^i\\) 是真实的标签值，\\(x\\)是训练的样本， \\(\\beta\\)是学习率，也就是每次梯度下降的步长。这个步长的设置是一个技术活，太小的话，收敛太慢，太大的话，一不小心就过了，找不到最小的位置。 把上面感知机的参数更新规则拿过来对比： \\[ w_i \\leftarrow w_i + \\triangle w_i \\\\ b \\leftarrow b + \\triangle b \\\\ 其中 \\\\ \\triangle w = \\beta (t-y) x_i \\\\ \\triangle b = \\beta (t-y) \\] 我们发现二者是完全一致的， 原来，感知机也是按照梯度下降的方向更新参数的。 需要注意的是，我们上面介绍的是最朴素的梯度下降法，实际应用中，经常使用随机梯度下降法，就是每次更新参数的时候，并不是把所有的训练数据都遍历一边再计算一次更新，而是每一个样本都计算一次更新，这样可能会导致有使参数的更新不是朝着下降的方向，但是实际经验证明，总体趋势上还是下降的，并且这样的方法计算开销小，还很有可能收敛速度更快。","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"}],"tags":[{"name":"perception","slug":"perception","permalink":"http://ff120.github.io/hexoblog/tags/perception/"}]},{"title":"深度学习_Pandas使用技巧","slug":"技术/机器学习/机器学习_Pandas使用技巧","date":"2017-05-17T10:29:02.000Z","updated":"2019-03-28T00:54:57.821Z","comments":true,"path":"2017/05/17/技术/机器学习/机器学习_Pandas使用技巧/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/05/17/技术/机器学习/机器学习_Pandas使用技巧/","excerpt":"pandas 是提供一种类似表格结构的数据结构的Python工具包，使用它可以很方便的完成若干在电子表格中的操作。","text":"pandas 是提供一种类似表格结构的数据结构的Python工具包，使用它可以很方便的完成若干在电子表格中的操作。 安装 1conda install pandas 数据结构 引入 1import pandas as pd Series One-dimensional ndarray with axis labels (including time series). 123456789101112# 创建Seriess1 = pd.Series(5, index=['a'],name='s1')s2 = pd.Series(['first','second',],index=[0,1],name='s3')s3 = pd.Series(&#123;'a':1,'b':2,'c':3&#125;)# 获取s1[0] # 按照索引s3['a'] # 按照键值s2.index # 获得所有的索引s2.get('a','empty') # 使用get,不存在的键返回自定义的值s2[0:2] # 范围截取s1.name # 获得name属性s1.rename(\"different\") DataFrame a 2-dimensional labeled data structure with columns of potentially different types. 1234567891011121314151617181920212223242526# 创建d1 = &#123;'one' : ['one','two','third'], 'two' : [4,5,6]&#125;# 每个键值一列df1 = pd.DataFrame(d1)# list 中是 dictd2 = [&#123;'a':1,'b':2,'c':3&#125;,&#123;'a':1,'b':2,'c':3&#125;,&#123;'a':1,'b':2,'c':3&#125;]df2 = pd.DataFrame(d2,index=['aa','bb','cc'])d3 = np.array([[1,2,3],[4,5,6],[7,8,9]])df3 = pd.DataFrame(d3)# 获取df1.index # 行标号df1.columns # 列标号df2['a'] # 一列df2.head() # 显示部分信息# 修改del df2['a']df2.pop('a') # 删除一列df2['inserted'] = 'a' # 插入一列df2['insert2'] = [1,2,3]df2.insert(0,'between',[1,2,3]) # 指定插入的位置df2['aa'] # 对DataFrame的某一列进行one-hot编码 1234567891011121314from sklearn.preprocessing import OneHotEncoder# name 列的名称def one_hot_colum(small_data,name): enc = OneHotEncoder() data = small_data[name].reshape(len(small_data[name]),1) enc.fit(data) transformed_data = enc.transform(data).toarray() small_data.pop(name) for i in range(transformed_data.shape[1]): small_data.insert(small_data.shape[1],name+str(i),transformed_data[:,i]) return small_data 对DataFrame行进行切分和过滤 下面划分的数据集是腾讯高校算法大赛第一届比赛的数据，实现了按照天为单位划分数据集。总体的思路是使用isin()生成mask,使用mask筛选数据。 12345678910111213141516171819202122232425def split_data(data,train_data,test_data): \"\"\" 按照天划分数据集 :data, DataFrame 类型的数据 :train_data, 训练数据集，[17,18,19] :test_data,测试数据集,[30] \"\"\" times = np.unique( train['clickTime'] ) day = [] for i in range(14): day.append(times[24*60*i:24*60*(i+1)]) train_data = [i-17 for i in train_data ] test_data = [i-17 for i in test_data ] mask_train = np.array([False]*train.shape[0]) for i in train_data: mask = train['clickTime'].isin(day[i]) mask_train |= mask mask_test = np.array([False]*train.shape[0]) for i in test_data: mask = train['clickTime'].isin(day[i]) mask_test |= mask return data[mask_train],data[mask_test] 两个list生成DataFrame并按照某个list排序 12aa = pd.DataFrame(&#123;'feature':col,'importance':importance&#125;)bb= aa.sort_values(by='importance') DataFrame按照某一列的关键字合并 12train = pd.merge(dfTrain, dfAd, on=\"creativeID\")data = pd.merge(data, dfCvr, how=\"left\", on=\"keyid\") DataFrame随机选择n个样本 1dataframe.sample(n=selected_sample_num)","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"}],"tags":[{"name":"python","slug":"python","permalink":"http://ff120.github.io/hexoblog/tags/python/"},{"name":"pandas","slug":"pandas","permalink":"http://ff120.github.io/hexoblog/tags/pandas/"}]},{"title":"图片处理01-合并多张图片","slug":"技术/工具/图片处理/图片处理01-合并多张图片","date":"2017-05-17T10:15:34.000Z","updated":"2019-03-28T00:54:55.768Z","comments":true,"path":"2017/05/17/技术/工具/图片处理/图片处理01-合并多张图片/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/05/17/技术/工具/图片处理/图片处理01-合并多张图片/","excerpt":"找了很多工具都没有将PPT导出成长的PNG图片的，自己探索了一个流程，效果还可以。","text":"找了很多工具都没有将PPT导出成长的PNG图片的，自己探索了一个流程，效果还可以。 首先，把PPT导出成PNG图片，默认一张PPT就会生成一张PNG图片，然后使用一个Python的机器学习库可以实现把多张PNG图片拼接在一起。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from PIL import Imagedef mergei(files, output_file): \"\"\" 横向拼接 :param files:需要拼接的文件,list :param output_file: 拼接完成后的输出文件 :return：生成拼接后的新的图片 \"\"\" tot = len(files) img = Image.open(files[0]) w, h = img.size[0], img.size[1] merge_img = Image.new('RGB', (w * tot, h), 0xffffff) i = 0 for f in files: print(f) img = Image.open(f) merge_img.paste(img, (i, 0)) i += w merge_img.save(output_file)def mergej(files, output_file): \"\"\" 纵向拼接 :param files:需要拼接的文件,list :param output_file: 拼接完成后的输出文件 :return：生成拼接后的新的图片 \"\"\" tot = len(files) img = Image.open(files[0]) w, h = img.size[0], img.size[1] merge_img = Image.new('RGB', (w, h * tot), 0xffffff) j = 0 for f in files: print(f) img = Image.open(f) merge_img.paste(img, (0, j)) j += h merge_img.save(output_file)def listFiles(path): \"\"\" 枚举某个路径下的全部文件名，返回list :param path 路径 \"\"\" import os files = os.listdir(path) return filesif __name__=='__main__': files = listFiles(r'D:\\ML') os.chdir(r'D:\\ML') mergej(files, \"merge.png\")","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"工具","slug":"技术/工具","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/"},{"name":"图片处理","slug":"技术/工具/图片处理","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/图片处理/"}],"tags":[{"name":"合并图片","slug":"合并图片","permalink":"http://ff120.github.io/hexoblog/tags/合并图片/"}]},{"title":"机器学习_算法汇总","slug":"技术/机器学习/机器学习_算法汇总","date":"2017-05-15T13:49:51.000Z","updated":"2019-03-28T00:54:58.202Z","comments":true,"path":"2017/05/15/技术/机器学习/机器学习_算法汇总/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/05/15/技术/机器学习/机器学习_算法汇总/","excerpt":"机器学习是人工智能的一个分支,机器学习是实现人工智能的一个途径，即以机器学习为手段解决人工智能中的问题。机器学习算法是一类从数据中自动分析获得规律，并利用规律对未知数据进行预测的算法.机器学习已广泛应用于数据挖掘、计算机视觉、自然语言处理、生物特征识别、搜索引擎、医学诊断、检测信用卡欺诈、证券市场分析、DNA序列测序、语音和手写识别、战略游戏和机器人等领域。本文主要介绍机器学习的基础算法和一些适用的问题。","text":"机器学习是人工智能的一个分支,机器学习是实现人工智能的一个途径，即以机器学习为手段解决人工智能中的问题。机器学习算法是一类从数据中自动分析获得规律，并利用规律对未知数据进行预测的算法.机器学习已广泛应用于数据挖掘、计算机视觉、自然语言处理、生物特征识别、搜索引擎、医学诊断、检测信用卡欺诈、证券市场分析、DNA序列测序、语音和手写识别、战略游戏和机器人等领域。本文主要介绍机器学习的基础算法和一些适用的问题。 机器学习的应用领域： 监督学习 监督学习是给出特征和特征对应的标签，让算法学习其中蕴含的规律。利用训练好的模型预测新的特征的标签的一类算法的统称。监督学习是最常见的机器学习算法，也是发展最成熟的一类。 线性模型(linear model) 线性模型试图学得一个通过属性的线性组合来进行预测的函数： \\[ f(x)=w_1 x_1+x_2 x_2 + ... + w_d x_d + b \\] 线性模型中的\\(w\\)直观的表达了各个属性在预测过程中的重要性，所以线性模型有很好的可解释性。 如果在线性模型基础上，在输出之前用一个非线性的函数处理一下，就能得到非线性的决策边界，这样的模型叫做广义线性模型. 她有下面这样的形式： \\[ y = f(wx+b) \\] 其中，\\(f(x)\\) 是非线性的函数。当他是sigmoid函数的时候，这个模型叫做逻辑回归,当它是softmax函数的时候，这个模型叫做softmax回归。 逻辑回归 Logistic回归优点： 1、实现简单； 2、分类时计算量非常小，速度很快，存储资源低； 缺点： 1、容易欠拟合，一般准确度不太高 2、只能处理两分类问题（在此基础上衍生出来的softmax可以用于多分类），且必须线性可分； softmax回归 线性判别分析 决策树 根据树的结构进行决策，主要算法有ID3，C4.5. 决策树的优点：计算量简单，可解释性强，比较适合处理有缺失属性值的样本，能够处理不相关的特征； 缺点：容易过拟合（后续出现了随机森林，减小了过拟合现象）. K近邻 KNN算法的优点： 1. 思想简单，理论成熟，既可以用来做分类也可以用来做回归； 2. 可用于非线性分类； 3. 训练时间复杂度为O(n)； 4. 准确度高，对数据没有假设，对outlier不敏感； 缺点： 1. 计算量大； 2. 样本不平衡问题（即有些类别的样本数量很多，而其它样本的数量很少）； 3. 需要大量的内存； 支持向量机 SVM算法优点： – 可用于线性/非线性分类，也可以用于回归； 低泛化误差； 容易解释； 计算复杂度较低； 缺点： 对参数和核函数的选择比较敏感； 原始的SVM只比较擅长处理二分类问题； 相关向量机 贝叶斯方法 朴素贝叶斯 半朴素贝叶斯 贝叶斯网络 EM算法 神经网络 感知机 感知机是一种最简单的神经网络，单层神经网络。 径向基函数网络(Radial Basis Function) 一种单隐层的前馈神经网络，使用径向基函数作为隐层神经元激活函数，输出层是对隐层神经元的线性组合。 竞争型学习网络(competitive learning) 自组织映射网络(Self-Organizing Map) Elman网络 Elman是最常用的递归神经网络之一。 Boltzmann机 一种基于能量概念的模型。 卷积神经网络(CNN) 深度信念网络(DBN) 循环神经网络(RNN) 稀疏自编码(SAE) 集成学习(ensemble learning) 通过构建并结合多个分类器来完成学习任务。 Boosting方法 一类可以将若分类器提升为强分类器的算法。 adaboost Gradient Boosted Decision Tree 随机森林(Random Forest) 半监督学习 半监督学习是介于有监督学习和无监督学习之间的，它是指训练样本中只有少量是有标签的数据，大量数据是都是无标签的，要从这样的数据中学习出数据内在的规律，从而能够把哪些无标签的数据也推断出一个合理的标签。半监督学习几乎是最符合实际情况的一类算法，因为在实际中，很多时候都只有少量的有标签的数据，大量的都是无标签的数据。所以，半监督学习方法的研究对实际应用很重要。 半监督学习之所以可行，是基于一个基本的假设：相似的样本又有相似的输出。如果我们拥有少量的带标记的样本，恰巧这些样本均匀分布在每个类别中，这样我们就可以先使用聚类来确定哪些样本是相似的，然后从这些相似的样本中找出一个带标签的，所有的这一簇样本就都属于这个标签。这就是半监督学习的基本思想。当然，度量样本相似性的方法不止聚类一种，还有一种是流行假设(manifold assumption). 主动学习，纯半监督学习 和 直推式学习 三种方法都是针对的都是 训练集中少量样本是标记数据，大量样本是未标记数据 这种情况，不同是，主动学习(active learning)是指首先用已经标记的数据训练一个模型，然后使用这个模型去预测未标记的数据，把预测出来的数据和专家给出的标记结果做比较，更新模型，使得模型越来越好。可以看到，本质上，它还是利用有标记的数据进行学习的。 纯半监督学习 是指用训练集训练模型，用测试集测试效果，训练集是包含有标记数据和未标记数据的。 直推式学习 是指学习到的模型要预测的数据就是训练集中未标记的数据，只需要把训练集中未标记的数据预测准确就好，不需要再考虑其他的未标记数据。 生成式方法(generative methods) 这类方法假定所有的数据都是基于一个模型生成的。此类方法简单，易于实现，而且效果不错，但是，这必须保证之前的假设是正确的。如果假设是错误的，该方法会得到很差的结果。遗憾的是，现实的世界中的数据，你很难准确的知道它是基于什么样的模型生成的。也许根本就不是基于同一个模型生成的。 半监督支持向量机(semi-supervised support vector machine) 这是在支持向量机的算法基础上进行扩展得到的。它的基本思想是：寻找能把有标记的数据区分开，并且穿过数据的低密度区域的分类超平面。这显然是基于我们上面提到过的聚类假设，假设相似的样本会聚集在一起。这类方法有很多，例如*S3VM、S4VM、CS4VM、TSVM； 图论方法(graph-based methods) 我们把训练样本中每个样本对应图中的一个节点，而节点之间的边表示两个样本之间的相似性(相似性越强，边的权值越大)，我们把已经有标记的节点想象成已经染过色，而没有标记的节点还没有染色，这样问题转化成了在给定的图模型上为节点染色的问题。这类问题主要借助一类叫做标记传播算法(label propagation)的方法解决。 图论方法思路清晰，计算上可以有各种基于矩阵乘法的优化，但是其缺点很明显： 存储开销大，不适合处理大数据。 构图过程只考虑训练集，测试集中的样本到来的时候，难以判断其在图中的位置。 基于分歧的方法(disagreement-based methods) 多视图数据(multi-view data) 视图可能是从数据库中的术语借鉴过来的，一个视图就是一个属性的几何。我们可以把视图理解为某一个大的方面。例如针对电影数据来说，图像是一个视图，声音是一个视图，网上所有关于该电影的讨论也可以构成一个视图。把这些数据都收集起来放在一起，就构成了多视图数据。 协同训练(co-training) 协同训练是利用数据的多视图来进行训练的一类算法，它的基本假设是多视图数据的相容互补性。 相容是指通过任何一个视图推测出来的标签都应该是一样的，是匹配的。一个动作电影，只通过声音，只通过画面，都可以推断出是一个动作片(当然这不一定是真的)。 互补 是指通过一个视图的数据能够帮助另外一个视图的数据决定其标签。协同训练的过程是这样的：首先在每个视图数据上基于有标签的数据训练一个模型。然后，让每个模型去没有标记的数据中挑选自己最有把握分类的数据预测其标签，把预测出来标签的数据当作有标签的数据送给其他的分类器继续更新模型的参数，这样“互相学习，共同进步”，直到在所有视图数据上训练的模型都趋于稳定之后结束。 半监督聚类(semi-supervised clustering) 聚类虽然是一种典型的无监督算法，但是如果实现有一些有标记的数据，很有可能提高聚类算法的效果。例如，直到哪些样本之间必然属于同一类，直到哪些样本根本不可能在一起，或者直接直到某个样本属于什么类别。 这类方法主要是在聚类算法的基础上加上相应的约束实现的，主要有约束K均值(constrained k-means) 约束种子K均值(constrained seed k-means). 无监督学习 无监督学习的含义是训练数据不包含任何标签，既然不包含任何标签，那么无论如何也学习不到数据内部和标签的对应关系(没有标签嘛，怎么学得到)。所以，无监督学习主要是用来发现数据自身的内部规律，例如，哪些数据和哪些数据比较相似。无监督学习的应用主要在聚类上. Hierarchical methods BIRCH(Balanced Iterative Reducing and Clustering Using Hierarchies) ROCK(A Hierarchical Clustering Algorithm for Categorical Attributes) Chameleon(A Hierarchical Clustering Algorithm Using Dynamic Modeling) Partition-based methods k-means k-means++ kernel k-means k-medoids k-medians Density-based methods DBSCAN(Density-Based Spatial Clustering of Applications with Noise) OPTICS(Ordering Points To Identify Clustering Structure) DENCLUE WaveCluster Grid-based methods STING(Statistical Information Grid) CLIQUE(Clustering In Quest) Model-based methods GMM(Gaussian Mixture Models) SOM(Self Organized Maps) 强化学习 强化学习对于包含长期反馈的问题比短期反馈的表现更好。它在许多问题上得到应用，包括机器人控制、电梯调度、电信通讯、双陆棋和西洋跳棋。 Q Learning Sarsa Policy Gradients Actor-Critic Monte-Carlo Learning Deep Q network 规则学习(rule-base learning) 规则学习是最早开始研究的一类机器学习方法，它的基本思想是从数据中学习到一些基本的规则，用这些规则作用在新的数据上，决定新数据对应的输出。规则学习是白箱模型，每一步决策都会清晰的展现出来，算法学习得到的规则可以直接输出出来，对于一些简单的问题，我们甚至可以根据经验判断它学习的对不对。规则学习是最容易融合专家知识的机器学习方法。 规则学习的基本框架是序贯覆盖，CN2 采用集束搜索，是最早考虑过拟合问题的规则学习算法，归纳逻辑程序设计(ILP) 成为机器学习和知识工程的重要桥梁。 机器学习方法一开始是规则学习的天下，各种专家系统层出不穷，后来，统计学习方法逐渐占了上风，但是由于统计学习方法普遍都是黑箱模型，很难解释里面的原因，我们并不能直接从中学习得到知识。而且，在富含结构信息和领域知识的任务中，规则学习往往更适合。所以，未来的发展趋势是基于规则的学习方法 和 统计学习方法 的结合，使得我们的算法既有强大的学习能力，又能够教会我们数据中蕴含的知识，目前，这方便已经有了一些有益的探索。例如 概率归纳逻辑程序设计,关系贝叶斯网,贝叶斯逻辑程序,马尔科夫逻辑网. 其他算法 数据挖掘 Apriori FP Growth: FFM+GDBT+LR 神经风格迁移 genetic algorithm 模拟退火算法(Simulated annealing) 禁忌搜索(Tabu Search) 蚁群算法(Ant Colony Optimization) 粒子群优化(Particle Swarm Optimization) 引力搜索算法(GSA) 人工免疫算法 p scikit-learn 实现的机器学习算法: 一个PPT 机器学习算法汇总","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"}],"tags":[{"name":"ML","slug":"ML","permalink":"http://ff120.github.io/hexoblog/tags/ML/"}]},{"title":"机器学习_时间序列预测の广告效果预测","slug":"技术/机器学习/机器学习_时间序列预测の广告效果预测","date":"2017-05-15T01:15:08.000Z","updated":"2019-03-28T00:54:58.124Z","comments":true,"path":"2017/05/15/技术/机器学习/机器学习_时间序列预测の广告效果预测/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/05/15/技术/机器学习/机器学习_时间序列预测の广告效果预测/","excerpt":"预测问题在实际中的应用比较多，比如广告的点击率预测，转化率预测，未来的价格走势等等。这类问题通常有一个框架，数据预处理上也有很多相似之处。比如广告的点击率的预测，业内比较成熟的方法有，人工特征工程，依靠人工分析，提取出有效的特征，然后用逻辑回归或者其他简单的线性分类器分类。随着特征的增多和样本的增加，人工的方法不能满足要求，现在很多公司用的算法都是改进的GDBT特征提取+逻辑回归分类，或者GDBT+FFM+逻辑回归分类。","text":"预测问题在实际中的应用比较多，比如广告的点击率预测，转化率预测，未来的价格走势等等。这类问题通常有一个框架，数据预处理上也有很多相似之处。比如广告的点击率的预测，业内比较成熟的方法有，人工特征工程，依靠人工分析，提取出有效的特征，然后用逻辑回归或者其他简单的线性分类器分类。随着特征的增多和样本的增加，人工的方法不能满足要求，现在很多公司用的算法都是改进的GDBT特征提取+逻辑回归分类，或者GDBT+FFM+逻辑回归分类。 判断给定的数据集是否与时间关联 在很多线性模型中，都假设数据之间是独立的，如果数据之间不是时间独立的(有明显的随着时间变化的趋势)，很多预测模型的效果就会出现偏差。所以，拿到数据首先要检查一下数据的分布情况。 数据集 1234567891011121314151617# 判断时间序列数据是否有时间趋势# Augmented Dickey-Fuller test 用来检查数据集是否有时间趋势# 判断标准 p &lt; 0.05 认为没有时间依赖# p&gt;0.05 认为有时间依赖import osfrom pandas import Seriesfrom statsmodels.tsa.stattools import adfullerroot = r'D:\\deeplearning\\Daily Female Births'os.chdir(root)series = Series.from_csv('daily-total-female-births.csv', header=0)X = series.valuesresult = adfuller(X)print('ADF Statistic: %f' % result[0])print('p-value: %f' % result[1])print('Critical Values:')for key, value in result[4].items(): print('\\t%s: %.3f' % (key, value)) 这个是用Augmented Dickey–Fuller test做的假设检验，根据p值确定结果，p值小于某个阈值就可以认为原数据是时间独立的。 特征工程 点击率预测和转化率预测的题目，特征的选择往往最对最后的结果至关重要，这里有一个使用sklearn做特征处理的教程可以参考。 http://www.cnblogs.com/jasonfreak/p/5448385.html","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"}],"tags":[{"name":"时间序列","slug":"时间序列","permalink":"http://ff120.github.io/hexoblog/tags/时间序列/"},{"name":"预测算法","slug":"预测算法","permalink":"http://ff120.github.io/hexoblog/tags/预测算法/"}]},{"title":"深度学习_Scikit-Learn机器学习算法的使用","slug":"技术/机器学习/机器学习_Scikit-Learn使用技巧","date":"2017-05-14T10:51:20.000Z","updated":"2019-03-28T00:54:57.903Z","comments":true,"path":"2017/05/14/技术/机器学习/机器学习_Scikit-Learn使用技巧/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/05/14/技术/机器学习/机器学习_Scikit-Learn使用技巧/","excerpt":"scikit-learn是一个很受欢迎的机器学习方面的python工具包，它定义的一些范式和处理流程影响深远，所以，认识和了解一些这个工具包对于自己实现一些机器学习算法是很有帮助的。它已经实现了很多方法帮助我们便捷的处理数据，例如，划分数据集为训练集和验证集，交叉验证，数据预处理，归一化等等。","text":"scikit-learn是一个很受欢迎的机器学习方面的python工具包，它定义的一些范式和处理流程影响深远，所以，认识和了解一些这个工具包对于自己实现一些机器学习算法是很有帮助的。它已经实现了很多方法帮助我们便捷的处理数据，例如，划分数据集为训练集和验证集，交叉验证，数据预处理，归一化等等。 预测结果与真实结果的比较 123456789101112131415# 计算均方误差from sklearn import metricsrmse = sqrt(metrics.mean_squared_error(y_test, y_pred))# 计算准确率acc = metrics.accuracy_score(y_test, y_pred)# 混淆矩阵cm = metrics.confusion_matrix(y_test, y_pred)# classification_reportcr = metrics.classification_report(y_true, y_pred)# ROC AUC曲线from sklearn.metrics import roc_curve, auc 划分数据集 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from sklearn import cross_validationX_train, X_test, y_train, y_test = cross_validation.train_test_split(X,y,test_size=0.3, random_state=0)# 分折from sklearn.cross_validation import KFoldkf = KFold(n_samples, n_folds=2)for train, test in kf: print(\"%s %s\" % (train, test))# 保证不同的类别之间的均衡，这里需要用到标签labelsfrom sklearn.cross_validation import StratifiedKFoldlabels = [0, 0, 0, 0, 1, 1, 1, 1, 1, 1]skf = StratifiedKFold(labels, 3)for train, test in skf: print(\"%s %s\" % (train, test))# 留一交叉验证from sklearn.cross_validation import LeaveOneOutloo = LeaveOneOut(n_samples)for train, test in loo: print(\"%s %s\" % (train, test))# 留P交叉验证from sklearn.cross_validation import LeavePOutlpo = LeavePOut(n_samples, p=2)for train, test in lpo: print(\"%s %s\" % (train, test))# 按照额外提供的标签留一交叉验证,常用的情况是按照时间序列from sklearn.cross_validation import LeaveOneLabelOutlabels = [1, 1,1, 2, 2]lolo = LeaveOneLabelOut(labels)for train, test in lolo: print(\"%s %s\" % (train, test))# 按照额外提供的标签留P交叉验证from sklearn.cross_validation import LeavePLabelOutlabels = [1, 1, 2, 2, 3, 3,3]lplo = LeavePLabelOut(labels, p=2)for train, test in lplo: print(\"%s %s\" % (train, test))# 随机分组from sklearn.cross_validation import ShuffleSplitss = ShuffleSplit(16, n_iter=3, test_size=0.25,random_state=0)for train_index, test_index in ss: print(\"%s %s\" % (train_index, test_index))# 考虑类别均衡的随机分组from sklearn.cross_validation import StratifiedShuffleSplitimport numpy as npX = np.array([[1, 2], [3, 4], [1, 2], [3, 4]])y = np.array([0, 0, 1, 1])sss = StratifiedShuffleSplit(y, 3, test_size=0.5, random_state=0)for train, test in sss: print(\"%s %s\" % (train, test)) 特征选择方法 12345678910111213141516171819202122232425262728293031323334353637383940# 去除方差较小的特征from sklearn import feature_selectionvt = feature_selection.VarianceThreshold(threshold='')vt.fit(X_train)X_train_transformed = vt.transform(X_train)X_test_transformed = vt.transform(X_test)# 按照某种排序规则 选择前K个特征# 除了使用系统定义好的函数f_classif，还可以自己定义函数sk = SelectKBest(feature_selection.f_classif,k=100)sk.fit(X_train,y_train)X_train_transformed = sk.transform(X_train)X_test_transformed = sk.transform(X_test)# 递归特征消除rfecv = RFECV(estimator=svc, step=step, cv=StratifiedKFold(y, n_folds = n_folds),scoring='accuracy')rfecv.fit(X_train, y_train)X_train_transformed = rfecv.transform(X_train)X_test_transformed = rfecv.transform(y_train)# 使用L1做特征选择from sklearn.svm import LinearSVClsvc = LinearSVC(C=1, penalty=\"l1\", dual=False)lsvc.fit(X_train,y_train)X_train_transformed = lsvc.transform(X_train)X_test_transformed = lsvc.transform(y_train)# 基于树的特征选择from sklearn.ensemble import ExtraTreesClassifieretc = ExtraTreesClassifier()etc.fit(X_train, y_train)X_train_transformed = etc.transform(X_train)X_test_transformed = etc.transform(X_test)# 基于线性判别分析做特征选择from sklearn.discriminant_analysis import LinearDiscriminantAnalysislda = LinearDiscriminantAnalysis(solver='lsqr',shrinkage='auto')lda.fit(X_train, y_train)X_train_transformed = lda.transform(X_train)X_test_transformed = lda.transform(X_test) 1234567891011121314151617from sklearn.feature_selection import VarianceThresholdX = [[0, 0, 1], [0, 1, 0], [1, 0, 0], [0, 1, 1], [0, 1, 0], [0, 1, 1]]sel = VarianceThreshold(threshold=(.8 * (1 - .8)))&gt;&gt;&gt;sel&gt;&gt;&gt;VarianceThreshold(threshold=0.16)X2 = sel.fit_transform(X)&gt;&gt;&gt;X2&gt;&gt;&gt;array([[0, 1], [1, 0], [0, 0], [1, 1], [1, 0], [1, 1]]) 计算每维特征的方差 1234567891011121314a1 = np.array([0,0,1,0,0,0])&gt;&gt;&gt;a1.var()&gt;&gt;&gt;0.13888888888888892a2 = np.array([0,1,0,1,1,1])&gt;&gt;&gt;a2.var()&gt;&gt;&gt;Out[161]: 0.22222222222222224a3 = np.array([1,0,0,1,0,1])&gt;&gt;&gt;a3.var()&gt;&gt;&gt;Out[163]: 0.25 可以看到，方差小于0.16的只有第一维特征，所以X2保留下来的是原来的第二维和第三维特征。 &gt;这应该是最简单的特征选择方法了：假设某特征的特征值只有0和1，并且在所有输入样本中，95%的实例的该特征取值都是1，那就可以认为这个特征作用不大。如果100%都是1，那这个特征就没意义了。当特征值都是离散型变量的时候这种方法才能用，如果是连续型变量，就需要将连续变量离散化之后才能用，而且实际当中，一般不太会有95%以上都取某个值的特征存在，所以这种方法虽然简单但是不太好用。可以把它作为特征选择的预处理，先去掉那些取值变化小的特征，然后再从接下来提到的的特征选择方法中选择合适的进行进一步的特征选择。 Univariate feature selection （单变量特征选择） 主要使用统计的方法计算各个统计值，再根据一定的阈值筛选出符合要求的特征，去掉不符合要求的特征。 #### 主要的统计方法 - F值分类 f_classif - F值回归 f_regression - 卡方统计 chi2 (适用于非负特征值 和 稀疏特征值) 主要的选择策略 选择排名前K的特征 SelectKbest 选择前百分之几的特征 SelectPercentile SelectFpr Select features based on a false positive rate test. SelectFdr Select features based on an estimated false discovery rate. SelectFwe Select features based on family-wise error rate. GenericUnivariateSelect Univariate feature selector with configurable mode. false positive rate: FP / (FP + TP) 假设类别为0，1；记0为negative,1为positive, FPR就是实际的类别是0，但是分类器错误的预测为1的个数 与 分类器预测的类别为1的样本的总数（包括正确的预测为1和错误的预测为1） 的比值。 estimated false discovery rate: 错误的拒绝原假设的概率 family-wise error rate: 至少有一个检验犯第一类错误的概率 假设检验的两类错误： &gt; - 第一类错误：原假设是正确的，但是却被拒绝了。(用α表示） &gt; - 第二类错误：原假设是错误的，但是却被接受了。(用β表示) 具体应用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102from sklearn.datasets import load_irisfrom sklearn.feature_selection import SelectKBest#SelectKBest -- f_classiffrom sklearn.feature_selection import f_classifiris = load_iris()X, y = iris.data, iris.targetX_fitted = SelectKBest(f_classif, k=3).fit(X,y)print \"SelectKBest -- f_classif\"print X_fitted.scores_print X_fitted.pvalues_print X_fitted.get_support()X_transformed = X_fitted.transform(X)print X_transformed.shape#SelectKBest -- chi2from sklearn.feature_selection import chi2X_fitted_2 = SelectKBest(chi2, k=3).fit(X,y)print \"SelectKBest -- chi2\"print X_fitted_2.scores_print X_fitted_2.pvalues_print X_fitted_2.get_support()X_transformed_2 = X_fitted_2.transform(X)print X_transformed_2.shape#SelectPercentile -- f_classiffrom sklearn.feature_selection import SelectPercentilefrom sklearn.feature_selection import f_classifX_fitted_3 = SelectPercentile(f_classif, percentile=50).fit(X,y)print \"SelectPercentile -- f_classif\"print X_fitted_3.scores_print X_fitted_3.pvalues_print X_fitted_3.get_support()X_transformed_3 = X_fitted_3.transform(X)print X_transformed_3.shape#SelectPercentile -- chi2from sklearn.feature_selection import SelectPercentilefrom sklearn.feature_selection import chi2X_fitted_4 = SelectPercentile(chi2, percentile=50).fit(X,y)print \"SelectPercentile -- chi2\"print X_fitted_4.scores_print X_fitted_4.pvalues_print X_fitted_4.get_support()X_transformed_4 = X_fitted_4.transform(X)print X_transformed_4.shape#SelectFpr --- chi2from sklearn.feature_selection import SelectFprfrom sklearn.feature_selection import chi2X_fitted_5 = SelectFpr(chi2, alpha=2.50017968e-15).fit(X,y)print \"SelectFpr --- chi2\"print X_fitted_5.scores_print X_fitted_5.pvalues_print X_fitted_5.get_support()X_transformed_5 = X_fitted_5.transform(X)print X_transformed_5.shape#SelectFpr --- f_classiffrom sklearn.feature_selection import SelectFprfrom sklearn.feature_selection import f_classifX_fitted_6 = SelectFpr(f_classif, alpha=1.66966919e-31 ).fit(X,y)print \"SelectFpr --- f_classif\"print X_fitted_6.scores_print X_fitted_6.pvalues_print X_fitted_6.get_support()X_transformed_6 = X_fitted_6.transform(X)print X_transformed_6.shape# SelectFdr 和 SelectFwe 的用法和上面类似，只是选择特征时候的依据不同，真正决定得分不同的是#统计检验方法，从上面可以看到，使用f_classif的得出的参数都相同。&gt;&gt;&gt;SelectKBest -- f_classif[ 119.26450218 47.3644614 1179.0343277 959.32440573][ 1.66966919e-31 1.32791652e-16 3.05197580e-91 4.37695696e-85][ True False True True](150L, 3L)SelectKBest -- chi2[ 10.81782088 3.59449902 116.16984746 67.24482759][ 4.47651499e-03 1.65754167e-01 5.94344354e-26 2.50017968e-15][ True False True True](150L, 3L)SelectPercentile -- f_classif[ 119.26450218 47.3644614 1179.0343277 959.32440573][ 1.66966919e-31 1.32791652e-16 3.05197580e-91 4.37695696e-85][False False True True](150L, 2L)SelectPercentile -- chi2[ 10.81782088 3.59449902 116.16984746 67.24482759][ 4.47651499e-03 1.65754167e-01 5.94344354e-26 2.50017968e-15][False False True True](150L, 2L)SelectFpr --- chi2[ 10.81782088 3.59449902 116.16984746 67.24482759][ 4.47651499e-03 1.65754167e-01 5.94344354e-26 2.50017968e-15][False False True False](150L, 1L)SelectFpr --- f_classif[ 119.26450218 47.3644614 1179.0343277 959.32440573][ 1.66966919e-31 1.32791652e-16 3.05197580e-91 4.37695696e-85][False False True True](150L, 2L) Recursive feature elimination （递归特征消除） 使用某种方法，给每一维特征赋一个权重（例如线性回归的系数），去除系数最小的K个特征，然后在剩下的特征上重复上述方法，直到剩下的特征满足特征选择个数的要求。 123456789101112131415161718192021222324252627282930313233343536373839404142'''用SVM获得每个特征对分类结果的贡献程度，按照贡献程度从大到小排名，选出贡献程度最大的前K个特征作为特征选择的结果,使用SVM的时候，排名的依据是fit之后的coef_值。这里的估计器可以替换成任何其他方法，如GLM'''from sklearn.svm import SVCfrom sklearn.datasets import load_digitsfrom sklearn.feature_selection import RFEimport numpy as np# Load the digits datasetdigits = load_digits()X = digits.images.reshape((len(digits.images), -1))y = digits.targetprint \"原来的特征：\"print X.shape# Create the RFE object and rank each pixelsvc = SVC(kernel=\"linear\", C=1)rfe = RFE(estimator=svc, n_features_to_select=10, step=1)ref = rfe.fit(X, y)print \"选择的特征的个数\"print np.sum(ref._get_support_mask())print ref._get_support_mask()print rfe.ranking_&gt;&gt;&gt;原来的特征：(1797L, 64L)选择的特征的个数10[False False False False True False False False False False False False False False False False False False False False False True False False False False True False False False True False False False False False False False True False False False True False False True True False False False False False False True False False False False True False False False False False][55 41 22 14 1 8 25 42 48 28 21 34 5 23 35 43 45 32 10 6 19 1 30 44 46 36 1 9 11 29 1 50 54 33 16 26 20 7 1 53 52 31 1 2 4 1 1 49 47 38 17 27 15 1 13 39 51 40 1 18 24 12 3 37] 使用上面的方法，需要人为的确定最后输出的特征的个数，如果不知道需要多少特征才能达到好的效果，可以使用下面的交叉验证方法自动确定输出几个特征最优。 12345678910111213141516171819202122from sklearn.svm import SVCfrom sklearn.cross_validation import StratifiedKFoldfrom sklearn.feature_selection import RFECVfrom sklearn.datasets import make_classification#产生人工数据# Build a classification task using 3 informative featuresX, y = make_classification(n_samples=1000, n_features=25, n_informative=5, n_redundant=2, n_repeated=0, n_classes=8, n_clusters_per_class=1, random_state=0)# Create the RFE object and compute a cross-validated score.svc = SVC(kernel=\"linear\")# The \"accuracy\" scoring is proportional to the number of correct# classificationsrfecv = RFECV(estimator=svc, step=1, cv=StratifiedKFold(y, 5), scoring='accuracy')rfecv = rfecv.fit(X, y)print(\"Optimal number of features : %d\" % rfecv.n_features_)print(\"选择的特征：\")print rfecv.support_ Feature selection using SelectFromModel(从模型中选择特征) 许多估计模型在执行完fit方法以后都会有coef_参数，这个参数实际上是各个特征的权重，所以我们可以根据这个权重选择特征，把权重小的特征去除。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788print(__doc__)import matplotlib.pyplot as pltimport numpy as npfrom sklearn.datasets import load_bostonfrom sklearn.feature_selection import SelectFromModelfrom sklearn.linear_model import LassoCV# Load the boston dataset.boston = load_boston()X, y = boston['data'], boston['target']# We use the base estimator LassoCV since the L1 norm promotes sparsity of features.clf = LassoCV()clf.fit(X,y)# Set a minimum threshold of 0.25sfm = SelectFromModel(clf, threshold='mean',prefit=True)print X.shape#sfm = sfm.fit(X, y)print \"============LassoCV================\"print \"选择的特征\"print sfm._get_support_mask();n_features = sfm.transform(X).shape[1]print n_features# We use LinearSVCfrom sklearn.svm import LinearSVC#C 越小，选择的特征越少lsvc = LinearSVC(C=0.001, penalty=\"l1\", dual=False)y = y.astype(np.int64) #转换成整数，因为是分类器，不是回归lsvc.fit(X,y)model = SelectFromModel(lsvc, prefit=True)print \"============线性SVM===============================\"print \"选择的特征\"print model._get_support_mask();n_features = model.transform(X).shape[1]print n_featuresfrom sklearn import linear_modelclf = linear_model.LogisticRegression(C=0.001, penalty='l1', tol=1e-6)y = y.astype(np.int64) #转换成整数，因为是分类器，不是回归clf.fit(X,y)model = SelectFromModel(clf, prefit=True)print \"============逻辑回归===============================\"print \"选择的特征\"print model._get_support_mask();n_features = model.transform(X).shape[1]print n_featuresfrom sklearn.ensemble import ExtraTreesClassifierclf = ExtraTreesClassifier()y = y.astype(np.int64) #转换成整数，因为是分类器，不是回归clf = clf.fit(X, y)model = SelectFromModel(clf, prefit=True)print \"============基于树的特征选择===============================\"print clf.feature_importances_print \"选择的特征：\"print model._get_support_mask();n_features = model.transform(X).shape[1]print n_features&gt;&gt;&gt;(506L, 13L)============LassoCV================选择的特征[False False False False False True False True False False True False True]4============线性SVM===============================选择的特征[False True False False False False True False False True False True False]4============逻辑回归===============================选择的特征[False False False False False False False False False True False True False]2============基于树的特征选择===============================[ 0.12196356 0.02193675 0.03935991 0.01633832 0.0721041 0.13938681 0.11703915 0.10962258 0.03116833 0.04455059 0.04134067 0.1074465 0.13774273]选择的特征[ True False False False False True True True False False False True True]6 分类器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137# linear_modelfrom sklearn import linear_modellmlr = linear_model.LinearRegression()lmlr.fit(X_train,y_train)lmlr.coef_predicted_y = lmlr.predict(X_test)# L1 惩罚项lmr = linear_model.Ridge (alpha = .5)lmr.fit(X_train,y_train)lmr.coef_lmr.intercept_predicted_y = lmr.predict(X_test)lmrcv = linear_model.RidgeCV(alphas=[0.1, 0.5,1.0, 10.0]) # 自带交叉验证lmrcv.fit(X_train,y_train)lmrcv.alpha_predicted_y = lmrcv.predict(X_test)# L2 惩罚项lmla = linear_model.Lasso(alpha = 0.001)lmla.fit(X_train,y_train)predicted_y = lmla.predict(X_test)# L1 + L2 惩罚项的一个混合lmela = linear_model.ElasticNet(alpha=0.01,l1_ratio=0.9)lmela.fit(X_train,y_train)predicted_y = lmela.predict(X_test)\"\"\"Least Angle Regression : 适用于高维数据，缺点是对噪声比较敏感\"\"\"lmlar = linear_model.Lars(n_nonzero_coefs=10)lmlar.fit(X_train,y_train)predicted_y = lmlar.predict(X_test)\"\"\"BayesianRidge : Bayesian Ridge Regression小特征数目表现不佳\"\"\"lmbr = linear_model.BayesianRidge()lmbr.fit(X_train,y_train)lmbr.coef_predicted_y = lmbr.predict(X_test)\"\"\"ARDRegression : similar to BayesianRidge, but tend to sparse\"\"\"lmardr = linear_model.ARDRegression(compute_score=True)lmardr.fit(X_train, y_train)predicted_y = lmardr.predict(X_test)\"\"\"逻辑回归Logistic regression\"\"\"lmlr1 = linear_model.LogisticRegression(C=1, penalty='l1', tol=0.01)lmlr2 = linear_model.LogisticRegression(C=1, penalty='l2', tol=0.01)lmlr1.fit(X_train,y_train)predicted_y = lmlr1.predict(X_test)\"\"\"SGDClassifier\"\"\"lmsdg = linear_model.SGDClassifier()lmsdg.fit(X_train,y_train)predicted_y = lmsdg.predict(X_test)\"\"\"Perceptron : 感知机算法\"\"\"lmper = linear_model.Perceptron()lmper.fit(X_train,y_train)predicted_y = lmper.predict(X_test)\"\"\"PassiveAggressiveClassifier : similar to Perceptron but have peny\"\"\"lmpac = linear_model.PassiveAggressiveClassifier()lmpac.fit(X_train,y_test)predicted_y = lmpac.predict(X_test)\"\"\"Linear discriminant analysis &amp;&amp; quadratic discriminant analysis\"\"\"from sklearn.lda import LDAlda = LDA(solver=\"svd\", store_covariance=True)lda.fit(X, y)predicted_y = lda.predict(X_test)from sklearn.qda import QDAqda = QDA()qda.fit(X, y, store_covariances=True)predicted_y = qda.predict(X_test)\"\"\"Kernel ridge regression:combines Ridge Regression (linear least squares with l2-norm regularization)with the kernel trick\"\"\"from sklearn.kernel_ridge import KernelRidgekr = KernelRidge(alpha=0.1)kr.fit(X,y)predicted_y = kr.predict(X_test)\"\"\"Support Vector Machines : 支持向量机分类\"\"\"from sklearn import svmsvmsvc = svm.SVC(C=0.1,kernel='rbf')svmsvc.fit(X_train,y_train)svmsvc.score(X_test,y_test)\"\"\"Support Vector Regression.\"\"\"svmsvr = svm.SVR()svmsvr.fit(X_train,y_train)svmsvr.score(X_test,y_test)\"\"\"Nearest Neighbors : 最近邻\"\"\"from sklearn.neighbors import NearestNeighborsnbrs = NearestNeighbors(n_neighbors=2, algorithm='ball_tree').fit(X)distances, indices = nbrs.kneighbors(X)from sklearn.neighbors import KNeighborsClassifiernkc = KNeighborsClassifier(15, weights='uniform')nkc.fit(X_train,y_train)nkc.score(X_test,y_test)from sklearn.neighbors import NearestCentroidclf = NearestCentroid(shrink_threshold=0.1)clf.fit(X_train, y_train)clf.score(X_test,y_test) 支持向量机（SVM） 简介 scikit-learn支持稠密的(dense)和稀疏的（sparse）数据，但是当测试数据是稀疏的时候，训练数据必须也是稀疏的。为了达到最优的性能，建议稠密数据使用numpy.ndarray,稀疏数据使用scipy.sparse.csr_matrix and dtype=float64. 用途 分类（classfication） 回归 (regression) 离群点检测 (outliers detection) 优点 当特征维数很高时很有效(effective in high dimensional space) 当特征的维数远大于样本的数量的时候依然有效 使用的是训练点（training points）的子集进行决策函数（decision function）的计算，所以是内存高效的（memory efficient） 多种可供选择的核函数(kernel function)提高了算法的灵活性，核函数是可以根据自己的需要自定义的。 缺点 当特征的数量远大于样本的数量的时候，算法的性能会下降（poor performance） SVM不直接提供概率估计（probability estimates），而是使用一个五折交叉验证（five-fold cross-validation）,计算复杂性较高，一般不适合海量数据的处理。 使用方法 二分类 123456789101112131415161718192021222324252627282930#准备数据X = [[0, 0], [1, 1]]y = [0, 1]#引入支持向量机from sklearn import svm'''创建模型,这里有三种方法:svm.SVC(); svm.NuSVC(); svm.LinearSVC()'''clf = svm.SVC()'''训练数据，这里X是[n_samples,n_features],y是[n_labels]'''clf = clf.fit(X_train, y)#使用训练好的模型预测y_predicted = clf.predict(X_test)#获得训练好的模型的一些参数&gt;&gt;&gt; # get support vectors&gt;&gt;&gt; clf.support_vectors_array([[ 0., 0.], [ 1., 1.]])&gt;&gt;&gt; # get indices of support vectors&gt;&gt;&gt; clf.support_array([0, 1]...)&gt;&gt;&gt; # get number of support vectors for each class&gt;&gt;&gt; clf.n_support_array([1, 1]...)#get the params of the svm&gt;&gt;&gt;clf.coef_ 上面是最简单的支持向量机的使用方式，下一步还需要了解可以设置的各个参数是什么意思，如何设置，如何交叉验证，如何选择和函数。 多分类 12345678910111213141516171819202122from sklearn import svmX = [[0], [1], [2], [3]]Y = [0, 1, 2, 3]# \"one-against-one\"clf = svm.SVC(decision_function_shape='ovo')clf.fit(X, Y)'''one-against-one 就是一对一，假设这四类的名称为a,b,c,d.则需要训练区分(a,b)(a,c)(a,d)(b,c)(b,d)(c,d)的6种模型，所以one-against-one这种策略在做多分类问题的时候会生成n*(n-1)/2个模型，每个模型区分其中的两个类。'''dec = clf.decision_function([[1]])dec.shape[1] # 4 classes: 4*3/2 = 6''' \"one-vs-the-rest\" 就是一对余下所有的，假设四类的名称为a,b,c,d; 则需要训练区分(a,bcd),(b,acd)(c,abd)(d,abc)的4种模型，每个模型区分其中一个类，被除此类之外的所有类当作另外一个类处理。 这种策略在做多分类问题的时候会生成n个模型。'''clf.decision_function_shape = \"ovr\"dec = clf.decision_function([[1]])dec.shape[1] # 4 classes 一些补充说明：SVC和NuSVC实现了one-against-one(ovo)方法，LinearSVC实现了one-vs-test(ovr)和另外一个叫做Crammer and Singer的实现多分类的方法， 可以通过指定multi_class='crammer_singer'来使用它。不多实践证明，在使用LinearSVC的进行多分类的时候，优先选择one-vs-test(ovr)， 因为one-vs-test(ovr)和crammer_singer得到的结果差不多，但是前者的计算时间要短。 模型参数说明 LinearSVC 123456789101112from sklearn import svmX = [[0,1],[2,3]]y = [0, 1]clf = svm.LinearSVC()clf.fit(X,y)print clf&gt;&gt;&gt;LinearSVC(C=1.0, class_weight=None, dual=True, fit_intercept=True, intercept_scaling=1, loss='squared_hinge', max_iter=1000, multi_class='ovr', penalty='l2', random_state=None, tol=0.0001, verbose=0) 参数 - C：可选参数，类型float,默认为1.0；误差的惩罚参数 - class_weight: 类型dict,可选参数，默认每个class的权重都是1.用来设置每个class的权重。 - dual:默认为True,类型bool,当n_samples &gt; n_features时，设置成False. - fit_intercept: 可选参数，类型为bool,默认为True. 意思是为模型计算截距（intercept），当数据事先已经是centered的时候，可以设置成False，不计算截距。 - intercept_scaling： 可选参数，类型为float,默认为1.意思是截距是否缩放。 - loss: 类型string,只能取“hinge” 和 “squared_hinge”,默认取“squared_hinge”；定义SVM的损失函数，“hinge”是标准的SVM损失函数，“squared_hinge”是标准损失函数的平方。 - max_iter： 类型为int,默认为1000，模型最大的迭代次数。 - multi_class：类型string，只能取’ovr’ 和 ‘crammer_singer’ (默认值是’ovr’)，当计算多分类的时候，指定多分类采取的策略。‘ovr’是将其中一类和剩下所有类二分，默认用这个策略就好。 - penalty： 类型string,只能取’l1’ or ‘l2’ (默认值是’l2’)，l1使参数稀疏，l2使大部分参数接近为0但是不是0，详细信息参考“机器学习中的范数” - random_state： 只能取int seed, RandomState instance, None 三个中的一个，默认值是None,指定产生伪随机数的时候使用的种子（seed） - tol：可选参数，类型为float,默认值是1e-4,指定停止时候的允许的误差。 - verbose：类型为int,默认值是0，是否开启详细的输出，默认不要开启就好。如果开启，在多线程的时候可能运行不正确。 属性 - coef_：训练好之后的SVM模型中的参数的取值（就是系数），当是二分类的时候，shape=[n_features],多分类的时候，shape = [n_classes,n_features] - intercept_:截距，二分类的时候shape = [1] ,多分类的时候shape=[n_classes] SVC 123456789101112from sklearn import svmX = [[0,1],[2,3]]y = [0, 1]clf = svm.SVC()clf.fit(X,y)print clf&gt;&gt;&gt;SVC(C=1.0, cache_size=200, class_weight=None, coef0=0.0, decision_function_shape=None, degree=3, gamma='auto', kernel='rbf', max_iter=-1, probability=False, random_state=None, shrinking=True, tol=0.001, verbose=False) 参数 - C=1.0, 可选参数，类型float,默认为1.0；误差的惩罚参数 - cache_size=200, 定义模型计算时使用的缓存大小，单位MB。 - class_weight=None,类型dict,默认为None,可以设置成’balanced’，这样会根据y自动计算每个class的权重。还可以手动设置每个class的权重。 - coef0=0.0,可选参数，类型为float,默认为0.0，独立于核函数（kernel function）的参数，只在’poly’ and ‘sigmoid’的时候有影响。 - decision_function_shape=None, ’ovo’, ‘ovr’ or None, default=None - degree=3, 可选参数，类型为int,默认为3，多项式和函数的度，其他类型的和函数自动忽略该参数。 - gamma=‘auto’, 可选参数，类型为float,默认为‘auto’,默认取 1/n_features作为gamma的值。 - kernel=‘rbf’,可选参数，类型为string，默认值为‘rbf’,定义SVM所使用的核函数，可选择的项如下： - linear - poly - rbf - sigmoid - precomputed - a callable(一个回调函数) - max_iter=-1, 最大迭代次数，默认为-1，意思是无限制。 - probability=False, 可选参数，类型bool,默认值为False. 是否进行概率估计，使用之前需要先调用fit方法。 - random_state=None, 只能取int seed, RandomState instance, None 三个中的一个，默认值是None,指定产生伪随机数的时候使用的种子（seed） - shrinking=True,可选参数，类型boolean,默认值为True,是否开启“shrinking heuristic” - tol=0.001, 可选参数，类型为float,默认值是1e-4,指定停止时候的允许的误差。 - verbose=False，类型为int,默认值是0，是否开启详细的输出，默认不要开启就好。如果开启，在多线程的时候可能运行不正确。 属性 - support_ : array-like, shape = [n_SV]，支持向量的下标 - n_support_ : array-like, dtype=int32, shape = [n_class] 每个类的支持向量的个数。 - support_vectors_ ：shape = [n_SV, n_features]，支持向量(SVM确定了一个分类超平面，支持向量就是平移这个超平面，最先与数据集的交点。) - dual_coef_ : array, shape = [n_class-1, n_SV] 在决策函数（decision function）中支持向量的系数 - coef_ : array, shape = [n_class-1, n_features]，特征的权重，只在线性核的时候可用。 - intercept_ : array, shape = [n_class * (n_class-1) / 2]，决策函数（decision function）中的常量。 NuSVC 123456789101112from sklearn import svmX = [[0,1],[2,3]]y = [0, 1]clf = svm.NuSVC()clf.fit(X,y)print clf&gt;&gt;&gt;NuSVC(cache_size=200, class_weight=None, coef0=0.0, decision_function_shape=None, degree=3, gamma='auto', kernel='rbf', max_iter=-1, nu=0.5, probability=False, random_state=None, shrinking=True, tol=0.001, verbose=False) 参数 大部分都与SVC一样，只是使用了一个额外的参数控制支持向量（support vector）的个数。 - nu:可选参数，类型float，默认值是0.5，值必须要(0,1]之间。 属性 - support_ : array-like, shape = [n_SV]，支持向量的下标 - n_support_ : array-like, dtype=int32, shape = [n_class] 每个类的支持向量的个数。 - support_vectors_ ：shape = [n_SV, n_features]，支持向量 - dual_coef_ : array, shape = [n_class-1, n_SV] 在决策函数（decision function）中支持向量的系数 - coef_ : array, shape = [n_class-1, n_features]，特征的权重，只在线性核的时候可用。 - intercept_ : array, shape = [n_class * (n_class-1) / 2]，决策函数（decision function）中的常量。 查看训练好的模型的参数 决策函数（decision function） 核函数（kernel function） 优先使用‘rbf’调节参数，当特征的数量远远大于样本的数量的时候，考虑使用线性核函数。 随机梯度下降（Stochastic Gradient Descen） 分类，回归 ##### 简介 随机梯度下降法适用于特征数据大于10的5次方，样本数量大于10的5次方的大规模数据的处理领域。 用途 可以处理大规模数据和稀疏数据。 优点 高效 易于实现 缺点 需要很多超参数 对特征的缩放敏感 使用方法 1234567891011121314151617181920from sklearn.linear_model import SGDClassifierX = [[0., 0.], [1., 1.]]y = [0, 1]clf = SGDClassifier()clf.fit(X, y) #训练clf.predict([[2., 2.]]) #预测print clf&gt;&gt;&gt;SGDClassifier(alpha=0.0001, average=False, class_weight=None, epsilon=0.1, eta0=0.0, fit_intercept=True, l1_ratio=0.15, learning_rate='optimal', loss='hinge', n_iter=5, n_jobs=1, penalty='l2', power_t=0.5, random_state=None, shuffle=True, verbose=0, warm_start=False)&gt;&gt;&gt;clf.coef_ #模型系数&gt;&gt;&gt;Out[31]: array([[ 9.91080278, 9.91080278]])&gt;&gt;&gt;clf.intercept_ #截距&gt;&gt;&gt;array([-9.99002993]) 参数 - alpha=0.0001, - average=False, - class_weight=None, epsilon=0.1, - eta0=0.0, - fit_intercept=True, - l1_ratio=0.15, - learning_rate=‘optimal’, - loss=‘hinge’, - n_iter=5, n_jobs=1, - penalty=‘l2’, - power_t=0.5, - random_state=None, - shuffle=True, - verbose=0, - warm_start=False 属性 - coef_ : array, shape (1, n_features) if n_classes == 2 else (n_classes,n_features);Weights assigned to the features. intercept_ : array, shape (1,) if n_classes == 2 else (n_classes,);Constants in decision function. 最近邻方法（Nearest Neighbors） 如果一个样本在特征空间中的k个最相 似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别. 简介 scikit-learn实现了监督的和非监督的最近邻方法，决定最近邻的算法有ball_tree,kd_tree,brute,可以通过指定模型参数algorithm的值来指定到底使用哪一个算法。 主要功能是实现分类和回归。 用法 1234import numpy as npfrom sklearn.neighbors import NearestNeighborsX = np.array([[-1, -1], [-2, -1], [-3, -2], [1, 1], [2, 1], [3, 2]])nbrs = NearestNeighbors(n_neighbors=2, algorithm='ball_tree').fit(X) 模型持久化 1234from sklearn.externals import joblibfrom sklearn.linear_model import LogisticRegressionclf_l1_LR = LogisticRegression(C=0.1, penalty='l1', tol=0.01)joblib.dump(clf_l1_LR, 'LogisticRegression.model') 结果的可视化 12345678import matplotlib.pyplot as pltplt.figure()plt.title(\"VarianceThreshold For Feature Selection\")plt.xlabel(\"Number of features selected\")plt.ylabel(\"Cross validation score (nb of correct classifications)\")plt.plot(lsvc_feature_num, lsvc_score)plt.show() 数据预处理 scikit-learn提供了很多数据预处理的方法，使用的时候需要引入的包是preprocessing. 缩放scale 123456789101112131415from sklearn.preprocessing import StandardScalerfrom sklearn.preprocessing import MinMaxScaler# 根据最大值和最小值缩放到[0,1]范围min_max_scaler = MinMaxScaler()X_transformed = min_max_scaler.fit_transform(X)# 数据标准化，使得均值为0，方差为1ss = StandardScaler()X_transformed = ss.fit_transform(X)# 考虑离群点的缩放，首先排除离群点再缩放from sklearn.preprocessing import RobustScalerrobust_scaler = RobustScaler()X_transformed = robust_scaler.fit_transform(X) one-hot编码 对于离散的类别特征，可以使用one-hot编码来处理特征，这样处理之后的特征可以直接被一些学习器使用。该方法默认会根据类别的数量生成能够表示该类别的二进制编码。 123from sklearn.preprocessing import OneHotEncoderenc = OneHotEncoder()transformed_data = enc.transform(data).toarray() 特征组合 特征组合的一个最简单的尝试是生成多项式特征，例如，如果有两个特征x_1,x_2,多项式为2的特征会自动生成1, x1,x2,x1*x2,x12,x22 这些特征。 1234from sklearn.preprocessing import PolynomialFeaturespoly = PolynomialFeatures(2)X_transformed = poly.fit_transform(X)","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"}],"tags":[{"name":"python","slug":"python","permalink":"http://ff120.github.io/hexoblog/tags/python/"},{"name":"scikit-learn","slug":"scikit-learn","permalink":"http://ff120.github.io/hexoblog/tags/scikit-learn/"}]},{"title":"fMRI相关的资源汇总","slug":"技术/认知神经科学/fMRI相关的资源汇总","date":"2017-05-14T07:22:05.000Z","updated":"2019-03-28T00:54:59.470Z","comments":true,"path":"2017/05/14/技术/认知神经科学/fMRI相关的资源汇总/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/05/14/技术/认知神经科学/fMRI相关的资源汇总/","excerpt":"记录一些fMRI经常用到的网站和资源的下载地址。","text":"记录一些fMRI经常用到的网站和资源的下载地址。 研究机构和网站 一个致力于改进fMRI 数据获取和分析方法的组织：https://amri.ninds.nih.gov/index.html 美国国立卫生研究院神经科学研究所:https://www.nitrc.org 一个基于Python的神经影像数据的开源代码社区：http://nipy.org Open Science Framework:https://osf.io 公开数据库 老年痴呆证AD的公开数据库：http://adni.loni.usc.edu/data-samples The National Database for Autism Research (NDAR) autism spectrum disorders（ASD） 孤独症数据库(需要注册授权，申请吗，等待回复) https://www.nitrc.org/projects/ndarportal 34个公开fmri数据库:http://home.52brain.com/thread-28111-2-1.html 提供fMRI公开数据的一个网站: https://openfmri.org/dataset 静息态功能影像数据:http://fcon_1000.projects.nitrc.org/fcpClassic/FcpTable.html Autism spectrum disorder (ASD) : http://fcon_1000.projects.nitrc.org/indi/abide 精神分裂症:http://fcon_1000.projects.nitrc.org/indi/retro/cobre.html","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"认知神经科学","slug":"技术/认知神经科学","permalink":"http://ff120.github.io/hexoblog/categories/技术/认知神经科学/"}],"tags":[{"name":"fMRI","slug":"fMRI","permalink":"http://ff120.github.io/hexoblog/tags/fMRI/"}]},{"title":"深度学习_TensorFlow使用技巧","slug":"技术/机器学习/深度学习/深度学习_TensorFlow使用技巧","date":"2017-05-12T09:27:52.000Z","updated":"2019-03-28T00:54:58.296Z","comments":true,"path":"2017/05/12/技术/机器学习/深度学习/深度学习_TensorFlow使用技巧/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/05/12/技术/机器学习/深度学习/深度学习_TensorFlow使用技巧/","excerpt":"TensorFlow 基础使用。","text":"TensorFlow 基础使用。 定义变量和执行运算： 12345678910111213141516171819import tensorflow as tfnode1 = tf.constant(3.0, tf.float32)node2 = tf.constant(4.0) # also tf.float32 implicitlyprint(node1, node2)## 运行程序sess = tf.Session()print(sess.run([node1, node2]))node3 = tf.add(node1, node2)print(\"node3: \", node3)print(\"sess.run(node3): \",sess.run(node3))a = tf.placeholder(tf.float32)b = tf.placeholder(tf.float32)adder_node = a + b # + provides a shortcut for tf.add(a, b)print(sess.run(adder_node, &#123;a: 3, b:4.5&#125;))print(sess.run(adder_node, &#123;a: [1,3], b: [2, 4]&#125;)) 卷积 一维卷积 123456789101112131415161718192021222324252627import numpy as npimport tensorflow as tf# 输入的 feature_mapinput_feature_map = np.array([0,1,2,-1,1,-3,0]).astype(np.float32)# 卷积核filter_kernel = np.array([1,0,-1]).astype(np.float32)graph1 = tf.Graph()with graph1.as_default(): #inputs = [batch, in_width, in_channels] #filter = [filter_width, in_channels, out_channels] # reshape成需要的输入格式 f=tf.constant( input_feature_map.reshape(1,-1,1) ) g=tf.constant( filter_kernel.reshape(-1,1,1) ) conv1=tf.nn.conv1d( f,g, stride=1 , padding=\"VALID\",name=\"conv1\")with tf.Session(graph=graph1) as sess: sess.run(tf.global_variables_initializer()) result = (sess.run(conv1)) print(result[0]) sess.close() # 输出 [[-2.] # [ 2.] # [ 1.] # [ 2.] # [ 1.]] 用上面的代码计算的结果和例子中步长为1的一维卷积结果是一致的。把代码中的stride=1改为stride=2就可以得到例子中的另外一个结果： 123[[-2.] [ 1.] [ 1.]] 二维卷积 123456789101112131415161718192021222324252627import numpy as npimport tensorflow as tf# 输入的 feature_mapinput_feature_map = np.array([[3,3,2,1,0], [0,0,1,3,1], [3,1,2,2,3], [2,0,0,2,2], [2,0,0,0,1]]).astype(np.float32)filter_kernel = np.array([[0,1,2], [2,2,0], [0,1,2]]).astype(np.float32)graph1 = tf.Graph()with graph1.as_default(): #inputs = [batch, in_height, in_width, in_channels] #filter = [filter_height, filter_width, in_channels, out_channels] # reshape成需要的输入格式 f=tf.constant( input_feature_map.reshape(1,5,5,1) ) g=tf.constant( filter_kernel.reshape(3,3,1,1) ) conv2=tf.nn.conv2d( f,g, strides=[1,1,1,1] , padding=\"VALID\",name=\"conv1\")with tf.Session(graph=graph1) as sess: sess.run(tf.global_variables_initializer()) result = (sess.run(conv2)) print(result) sess.close() 得到的卷积结果： 这里附上使用theano计算的相同的二维卷积的代码和结果： 1234567891011121314151617181920212223from theano import *import theano.tensor as Tfrom theano.tensor.nnet import conv2dimport numpy as npinputs = T.tensor4('input')filters = T.tensor4('filters')input_feature_map = np.array([[3,3,2,1,0], [0,0,1,3,1], [3,1,2,2,3], [2,0,0,2,2], [2,0,0,0,1]]).reshape(1,1,5,5).astype(float)filter_map = np.array([[0,1,2], [2,2,0], [0,1,2]]).reshape(1,1,3,3).astype(float)output = conv2d( inputs, filters, input_shape=(1, 1, 5, 5), filter_shape=(1, 1, 3, 3), border_mode='valid', subsample=(1, 1))f = function([inputs, filters], output)out_feature_map = f(input_feature_map,filter_map) 这两个工具包具体的计算过程还没有弄明白，不知道为什么计算结果不一样。","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"},{"name":"深度学习","slug":"技术/机器学习/深度学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/深度学习/"}],"tags":[{"name":"ML","slug":"ML","permalink":"http://ff120.github.io/hexoblog/tags/ML/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://ff120.github.io/hexoblog/tags/TensorFlow/"}]},{"title":"使用3D卷积神经神经网络提取脑成像数据的特征","slug":"技术/认知神经科学/使用3D卷积神经神经网络提取脑成像数据的特征","date":"2017-05-11T11:42:49.000Z","updated":"2019-03-28T00:54:59.689Z","comments":true,"path":"2017/05/11/技术/认知神经科学/使用3D卷积神经神经网络提取脑成像数据的特征/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/05/11/技术/认知神经科学/使用3D卷积神经神经网络提取脑成像数据的特征/","excerpt":"3D 卷积神经网络可以捕获3D空间的约束信息，利用它可以将原始的fMRI数据转换到另外的特征空间。","text":"3D 卷积神经网络可以捕获3D空间的约束信息，利用它可以将原始的fMRI数据转换到另外的特征空间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180# -*- coding: utf-8 -*-\"\"\"Created on Thu May 11 19:40:32 2017@author: FF120\"\"\"import osimport nibabel as nibimport nilearnimport numpy as np############################################################################### 加载神经影像数据#############################################################################data_root = r'D:\\FMRI_ROOT\\YIYU\\4D_data\\funImg'os.chdir(data_root)lists_files = os.listdir()subjects = []subjects_data = []for i in range(len(lists_files)): img = nib.load(lists_files[i]) subjects.append(img) subjects_data.append(img.get_data())############################################################################### 配置autoencoder的结构## input_dim --&gt; encoding_dim --&gt; input_dim#############################################################################from keras.layers import Input, Densefrom keras.models import Model# 中间隐藏层的 神经元 数目encoding_dim = 150# 输入神经元的数目input_dim = 125# 输入层神经元的数目input_img = Input(shape=(input_dim,))# \"encoded\" is the encoded representation of the inputencoded = Dense(encoding_dim, activation='relu')(input_img)# \"decoded\" is the lossy reconstruction of the inputdecoded = Dense(input_dim, activation='sigmoid')(encoded)# this model maps an input to its reconstructionautoencoder = Model(input_img, decoded)# this model maps an input to its encoded representationencoder = Model(input_img, encoded)# create a placeholder for an encoded (32-dimensional) inputencoded_input = Input(shape=(encoding_dim,))# retrieve the last layer of the autoencoder modeldecoder_layer = autoencoder.layers[-1]# create the decoder modeldecoder = Model(encoded_input, decoder_layer(encoded_input))# 准备训练和测试用的数据# 卷积核的大小kernel_size = 5subject0_0 = subjects_data[0][:,:,:,0]# 每个scan取100个样本sample_num = 100list_kernels = []for subject in range(len(subjects_data)): subject_data = subjects_data[subject] for scan in range(subject_data.shape[3]): scan_data = subject_data[:,:,:,scan] x_ = (np.random.random(size=sample_num)*(64-kernel_size)).astype(int) y_ = (np.random.random(size=sample_num)*(64-kernel_size)).astype(int) z_ = (np.random.random(size=sample_num)*(36-kernel_size)).astype(int) for i in range(sample_num): kernel_one = scan_data[x_[i]:(x_[i]+kernel_size),y_[i]:(y_[i]+kernel_size),z_[i]:(z_[i]+kernel_size)] list_kernels.append(kernel_one)matrix_kernel = np.array(list_kernels)matrix_kernel = matrix_kernel.reshape((len(matrix_kernel), np.prod(matrix_kernel.shape[1:])))# 共抽取出来55*240*100 = 1320000个5*5*5的kernel，这个作为autoencoder的学习数据autoencoder.compile(optimizer='adadelta', loss='binary_crossentropy')autoencoder.fit(matrix_kernel, matrix_kernel, epochs=500, batch_size=100, shuffle=True)# 保存模型# 保存模型def save_model(model,name): ## fit完成之后，保存整个模型的配置 root_path = r'd:\\deeplearning' model_config = model.get_config() model_weight = model.get_weights() import pickle import os config_save_path = os.path.join(root_path,name+\"_config.txt\") weight_save_path = os.path.join(root_path,name+\"_weights.txt\") pickle.dump(model_config, open(config_save_path, 'wb')) pickle.dump(model_weight, open(weight_save_path, 'wb'))from models import model_from_jsondef load_model(name): root_path = r'd:\\deeplearning' import pickle import os config_save_path = os.path.join(root_path,name+\"_config.txt\") weight_save_path = os.path.join(root_path,name+\"_weights.txt\") model_config = pickle.load(open(config_save_path, 'rb')) model_weight = pickle.load(open(weight_save_path, 'rb')) model = Model.from_config(model_config) model.set_weights(model_weight) return modelmodel_save_path = r''save_model(autoencoder,'3-layer-autoencoder-for-mdd')## 获取训练好的模型的参数作为新的卷积网络的卷积核autoencoder = load_model('3-layer-autoencoder-for-mdd')weights = autoencoder.get_weights()[0]list_kernel_weights = []for i in range(weights.shape[1]): list_kernel_weights.append(weights[:,i].reshape(kernel_size,kernel_size,kernel_size))## 使用autoencoder初始化卷积核已经成功，下面开始使用3D卷积为图像降维，最终生成一个降维之后的特征# 卷积操作import numpy as npimport tensorflow as tf# 一幅图像一幅图像的卷积和池化def convM(one_scan,kernels): graph1 = tf.Graph() with graph1.as_default(): #inputs = [batch, in_depth, in_height, in_width, in_channels] #filter = [filter_depth, filter_height, filter_width, in_channels, # out_channels] # reshape成需要的输入格式 f=tf.constant( one_scan.reshape(1,64,64,36,1) ) g=tf.constant( kernels.reshape(5,5,5,1,150) ) # 3D 卷积操作 conv3=tf.nn.conv3d( f,g, strides=[1,1,1,1,1] , padding=\"VALID\",name=\"conv1\") # 池化操作 pooling3 = tf.nn.max_pool3d(conv3, ksize=[1,1,1,1,1], strides=[1,5,5,5,1], padding='VALID', name=None) with tf.Session(graph=graph1) as sess: sess.run(tf.global_variables_initializer()) result = (sess.run(pooling3)) return result sess.close()one_subject = subjects_data[0].astype(np.float32)one_scan = one_subject[0:,0:,0:,0].astype(np.float32)# 150 个 卷积核kernels = weights.reshape(5,5,5,150).astype(np.float32)## 使用循环处理每个被试和每个scanre_list_subjects=[]#num_su = len(subjects_data)#num_sc = su.shape[3]for subject in range( len(subjects_data) ): su = subjects_data[i] re_list_scan = [] for scan in range( su.shape[3] ): sc = su[0:,0:,0:,scan].astype(np.float32) re_sc = convM(sc,kernels) re_list_scan.append(re_sc) re_list_subjects.append(re_list_scan)feature_mat = np.asarray(re_list_subjects)os.chdir(r'D:\\deeplearning')np.save('3d_pool_feature_result',feature_mat)###得到卷积和池化之后的特征，处理成以后分类要用到的数据格式，并保存下来re_feature=[]for subject in re_list_subjects: for scan in subject: re_feature.append(scan.reshape(-1))feature_2d = np.asarray(re_feature)np.save('feature_2d_from_3d_pool',feature_mat)## 使用一种降维方法，使用svm完成分类","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"认知神经科学","slug":"技术/认知神经科学","permalink":"http://ff120.github.io/hexoblog/categories/技术/认知神经科学/"}],"tags":[{"name":"CNN","slug":"CNN","permalink":"http://ff120.github.io/hexoblog/tags/CNN/"},{"name":"feature extraction","slug":"feature-extraction","permalink":"http://ff120.github.io/hexoblog/tags/feature-extraction/"},{"name":"特征提取","slug":"特征提取","permalink":"http://ff120.github.io/hexoblog/tags/特征提取/"}]},{"title":"机器学习_时间序列预测分析算法","slug":"技术/机器学习/机器学习_时间序列预测分析算法","date":"2017-05-11T08:08:13.000Z","updated":"2019-03-28T00:54:58.174Z","comments":true,"path":"2017/05/11/技术/机器学习/机器学习_时间序列预测分析算法/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/05/11/技术/机器学习/机器学习_时间序列预测分析算法/","excerpt":"预测问题是机器学习中很重要的一个问题，它是根据过去已经存在的数据预测未来可能的情况。本文通过一个著名的波士顿抢劫案的数据集来说明预测问题的来龙去脉。","text":"预测问题是机器学习中很重要的一个问题，它是根据过去已经存在的数据预测未来可能的情况。本文通过一个著名的波士顿抢劫案的数据集来说明预测问题的来龙去脉。 AR自回归模型预测 数据集 Daily Female Births Dataset This dataset describes the number of daily female births in California in 1959. 它的结构很简单，每一行是一天的数据，每一行有两个数据，第一个是日期，第二个是人数。 用Python加载数据集 1234567from pandas import Seriesfrom matplotlib import pyplotfile_path = r'D:\\deeplearning\\Forecasting\\daily-total-female-births-in-cal.csv'series = Series.from_csv(file_path, header=0)print(series.head())series.plot()pyplot.show() series.plot()是pandas的Series自己提供的数据可视化方法。 选择一种预测模型 这里我们先选择使用最广泛的自回归模型来看看。 Autoregressive model 自回归模型（英语：Autoregressive model，简称AR模型），是统计上一种处理时间序列的方法，用同一变数例如x的之前各期，亦即\\(x_1\\)至 $ x_{t-1}$来预测本期 \\(x_\\) 的表现，并假设它们为一线性关系。因为这是从回归分析中的线性回归发展而来，只是不用x预测y，而是用x预测x（自己）；所以叫做自回归。 自回归模型被广泛运用在经济学、信息学、自然现象的预测上. 自回归模型（Autoregressive Model）是用自身做回归变量的过程，即利用前期若干时刻的随机变量的线性组合来描述以后某时刻随机变量的线性回归模型，它是时间序列中的一种常见形式. P阶自回归模型，记作AR(p),含义是序列中\\(x_t\\)是前p个序列\\((x_{t-6},x_{t-5},x_{t-4},x_{t-3},x_{t-2},x_{t-1})\\) 和误差项通过线性组合而成的。 优点与限制 必须具有自相关，自相关系数（\\(\\varphi _{i}\\)）是关键。如果自相关系数(R)小于0.5，则不宜采用，否则预测结果极不准确。 自回归只能适用于预测与自身前期相关的经济现象，即受自身历史因素影响较大的经济现象，如矿的开采量，各种自然资源产量等；对于受社会因素影响较大的经济现象，不宜采用自回归，而应改采可纳入其他变数的向量自回归模型。 使用AR模型的训练和测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344# 下面该选择用来预测的模型了，# 这里我们随便选择一个 AR 模型from statsmodels.tsa.ar_model import ARfrom sklearn.metrics import mean_squared_errorimport numpy# create a difference transform of the datasetdef difference(dataset): diff = list() for i in range(1, len(dataset)): value = dataset[i] - dataset[i - 1] diff.append(value) return numpy.array(diff)# Make a prediction give regression coefficients and lag obsdef predict(coef, history): yhat = coef[0] for i in range(1, len(coef)): yhat += coef[i] * history[-i] return yhat# split datasetX = difference(series.values)size = int(len(X) * 0.66)train, test = X[0:size], X[size:]# train autoregressionmodel = AR(train)model_fit = model.fit(maxlag=6, disp=False)window = model_fit.k_arcoef = model_fit.params# walk forward over time steps in testhistory = [train[i] for i in range(len(train))]predictions = list()for t in range(len(test)): yhat = predict(coef, history) obs = test[t] predictions.append(yhat) history.append(obs)error = mean_squared_error(test, predictions)print('Test MSE: %.3f' % error)# plotpyplot.plot(test)pyplot.plot(predictions, color='red')pyplot.show() 上面我们使用的是AR(6)模型。就是用前6个数据去预测第七个数据。如此循环，不断调整参数，减小损失函数。 保存训练好的模型，以便以后的使用： 123456# save model to filemodel_fit.save('ar_model.pkl')# save the differenced datasetnumpy.save('ar_data.npy', X)# save the last obnumpy.save('ar_obs.npy', [series.values[-1]]) 与之对应的加载模型的方法 12345678# load the AR model from filefrom statsmodels.tsa.ar_model import ARResultsimport numpyloaded = ARResults.load('ar_model.pkl')print(loaded.params)data = numpy.load('ar_data.npy')last_ob = numpy.load('ar_obs.npy')print(last_ob) 线性回归预测 使用神经网络实现简单的线性回归 数据集 The problem that we will look at in this tutorial is the Boston house price dataset. The dataset describes 13 numerical properties of houses in Boston suburbs and is concerned with modeling the price of houses in those suburbs in thousands of dollars. As such, this is a regression predictive modeling problem. Input attributes include things like crime rate, proportion of nonretail business acres, chemical concentrations and more. 数据集的详细说明 使用keras用简单的神经网络模拟线性回归 我们使用Keras构造一个简单的全连接的神经网络来模拟回归模型，做出预测。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# -*- coding: utf-8 -*-\"\"\"Created on Thu May 11 14:44:12 2017@author: FF120\"\"\"import numpyimport pandasfrom keras.models import Sequentialfrom keras.layers import Densefrom keras.wrappers.scikit_learn import KerasRegressorfrom sklearn.model_selection import cross_val_scorefrom sklearn.model_selection import KFoldfrom sklearn.preprocessing import StandardScalerfrom sklearn.pipeline import Pipeline# load datasetdata_file_path = r'D:\\deeplearning\\Boston house price dataset\\housing.data.txt'dataframe = pandas.read_csv(data_file_path, delim_whitespace=True, header=None)dataset = dataframe.values# split into input (X) and output (Y) variablesX = dataset[:,0:13]Y = dataset[:,13] # create model # 该模型一共有三层，第一层是输入，有13个神经元；第二层是也有13个神经元，激活函数是relu # 第三层只有一个神经元，是输出，没有激活函数model = Sequential()model.add(Dense(13, input_dim=13, kernel_initializer='normal', activation='relu'))model.add(Dense(1, kernel_initializer='normal')) # Compile modelmodel.compile(loss='mean_squared_error', optimizer='adam')## 划分训练集和测试集x_train = X[0:400,:]x_test = X[400:,:]y_train = Y[0:400]y_test = Y[400:]model.fit(x_train,y_train,epochs=1000,batch_size=10,shuffle=True,)predicted_y = model.predict(x_test)print(y_test)from matplotlib import pyplotpyplot.plot(predicted_y)pyplot.plot(y_test, color='red')pyplot.show() epochs = 1000 的时候的结果： epochs = 1500 的时候的结果： 我们可以借助keara提供的scikit-learn API来和scikit-learn互动，这样我们可以更加方便的使用scikit-learn实现的交叉验证方式来测试我们的神经网络。 首先，我们把定义神经网络模型的代码写成函数的形式： 123456789# define base modeldef baseline_model(): # create model model = Sequential() model.add(Dense(13, input_dim=13, kernel_initializer='normal', activation='relu')) model.add(Dense(1, kernel_initializer='normal')) # Compile model model.compile(loss='mean_squared_error', optimizer='adam') return mode 我们使用KerasRegressor来打通和scikit-learn的连接。’nb_epoch=100, batch_size=5, verbose=0’这些参数都是kears模型fit的时候需要的参数。 12# evaluate model with standardized datasetestimator = KerasRegressor(build_fn=baseline_model, nb_epoch=100, batch_size=5, verbose=0) K折交叉验证和结果的评估： 123kfold = KFold(n_splits=10, random_state=seed)results = cross_val_score(estimator, X, Y, cv=kfold)print(\"Results: %.2f (%.2f) MSE\" % (results.mean(), results.std())) 为了方便理解和描述，我们这里只是介绍一下交叉验证的实现方法，并不使用。我们还是使用上面完整一段代码里用的手工划分训练集和测试集的方法。 神经网络结构的调整和性能的比较 我们改变一下上面定义的神经网络的结构，看结果是不是会发生变化。 123model.add(Dense(13, input_dim=13, kernel_initializer='normal', activation='relu'))model.add(Dense(6, kernel_initializer='normal', activation='relu'))model.add(Dense(1, kernel_initializer='normal')) 原来的结构是13 inputs -&gt;13 -&gt; 1, 现在变成了13 inputs -&gt; 13 -&gt; 6 -&gt; 1. epochs = 1000 得到的结果是： 可以看到并没有太大的提高。我们再尝试使用更多的隐层神经元试试。 123model = Sequential()model.add(Dense(20, input_dim=13, kernel_initializer='normal', activation='relu'))model.add(Dense(1, kernel_initializer='normal')) 还是没有太大的提高，估计这种简单的模型也只能是这个水平了。 参考资料：http://machinelearningmastery.com/regression-tutorial-keras-deep-learning-library-python/ 参考文献： http://machinelearningmastery.com/make-predictions-time-series-forecasting-python http://machinelearningmastery.com/time-series-prediction-lstm-recurrent-neural-networks-python-keras http://machinelearningmastery.com/time-series-forecasting-long-short-term-memory-network-python","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"}],"tags":[{"name":"时间序列","slug":"时间序列","permalink":"http://ff120.github.io/hexoblog/tags/时间序列/"}]},{"title":"算法专题_计算几何","slug":"技术/数据结构和算法/算法专题_计算几何","date":"2017-05-11T04:06:58.000Z","updated":"2019-03-28T00:54:57.004Z","comments":true,"path":"2017/05/11/技术/数据结构和算法/算法专题_计算几何/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/05/11/技术/数据结构和算法/算法专题_计算几何/","excerpt":"算法题目当中经常涉及到一些几何题目。这类题目如果不事先了解一些知识，往往感觉很难有思路。本文总结算法中常见问题涉及到的主要知识。","text":"算法题目当中经常涉及到一些几何题目。这类题目如果不事先了解一些知识，往往感觉很难有思路。本文总结算法中常见问题涉及到的主要知识。 线段 点的凸组合 点 \\(p_1=(x_1,y_1)\\) 和 \\(p_2=(x_2,y_2)\\) 的凸组合定义为： 满足如下条件的任意点 \\(p_3\\) \\[ x_3 = \\alpha x_1 + (1-\\alpha) x_2 \\] \\[ y_3 = \\alpha y_1 + (1-\\alpha) y_2 \\] 其中，\\(0 &lt;= \\alpha &lt;= 1\\) 含义，\\(p_3\\) 位于点 \\(p_1\\) 和 \\(p_2\\) 组成的线段内，包含这两个端点。 我们用 \\(p_1 p_2\\) 表示线段，用 \\(p_1 \\longrightarrow p_2\\) 表示向量或者叫做有向线段。 我们先来解决第一个问题： 有向线段的旋转 给定两个有向线段 \\(p_0 \\longrightarrow p_1\\) 和 \\(p_0 \\longrightarrow p_2\\)，判断 \\(p_0 \\longrightarrow p_1\\) 是否在 \\(p_0 \\longrightarrow p_2\\) 的顺时针方向？ 叉积 先来了解一个概念，两个点的叉积就是两个点的行列式的值： \\[ p_1 \\times p_2 = det[x_1 x_2 ; y_1 y_2] = x_1y_2-x_2y_1 \\] 叉积的几何意义是 由点(0,0),p1,p2,p1+p2组成的平行四边形的有向面积。 结论 \\[ a = (p_1-p_0) \\times (p_2-p_0) \\] 如果a&gt;0,则 \\(p_0 \\longrightarrow p_1\\) 位于 \\(p_0 \\longrightarrow p_2\\) 的顺时针方向，如果a&lt;0,则位于逆时针方向。 线段相交","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"深度学习_限制波尔茨曼向量机(RBM)","slug":"技术/机器学习/深度学习/深度学习_限制波尔茨曼向量机(RBM)","date":"2017-05-10T04:34:57.000Z","updated":"2019-03-28T00:54:58.521Z","comments":true,"path":"2017/05/10/技术/机器学习/深度学习/深度学习_限制波尔茨曼向量机(RBM)/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/05/10/技术/机器学习/深度学习/深度学习_限制波尔茨曼向量机(RBM)/","excerpt":"本文主要介绍RBM相关的知识。包括能量函数，概率的观点，网络的结构等等。","text":"本文主要介绍RBM相关的知识。包括能量函数，概率的观点，网络的结构等等。 先来看看没有限制的波尔茨曼机是什么样子的。 原始的波尔茨曼机虽然有很多有趣的特性，但是由于连接过于复杂，很难实际应用（或者是有效的方法还没有被提出来，就像当年深度网络缺乏有效的训练方法一样）。一种限制连接形式的波尔茨曼机因为其简单的结构和有趣的性质得到了广泛的应用。看看它长什么样子。 这就是RBM，很像一个两层的全连接的神经网络。 我们用\\(v_i\\)来表示可视层的神经元,用\\(h_j\\)来表示隐藏层的神经元,用 \\(w_{ij}\\) 来表示两层之间的权重，用 \\(a_i\\) 来表示可视层的偏置，用 \\(b_j\\) 表示隐藏层的偏置,用 \\((v,h)\\) 表示一个RBM，那么我们可以定义一些经常要使用到的量. RBM的能量E定义为： \\[ E(v,h)=-\\sum_i{a_i v_i}-\\sum_j{b_j h_j}-\\sum_i\\sum_j{h_j w_{ij} v_i} \\] 在一般的玻尔兹曼机中，隐层和可见层之间的联合概率分布由能量函数给出: \\[ P(v,h) = \\dfrac 1 Z e^{-E(v,h)} \\] 其中， \\(Z\\) 为配分函数，定义为在节点的所有可能取值下$ e^{-E(v,h)} $的和（亦即使得概率分布和为1的归一化常数）. 类似地，可见层取值的边缘分布可通过对所有隐层配置求和得到: \\[ P(v)=\\dfrac 1 {Z} \\sum_h{e^{-E(v,h)}} \\] 可见层的配置v对于隐层配置h的条件概率如下: \\[ P(v|h)=\\prod_{i=1}^m P(v_i|h) \\] h对于v的条件概率为: \\[ P(h|v)=\\prod_{j=1}^n P(h_j|v) \\] 单个节点的激活概率为 \\[ P(h_j=1|v)=\\sigma(b_j+\\sum_{i=1}^m {w_{ij} v_i}) \\] \\[ P(v_i=1|h)=\\sigma(a_i+\\sum_{j=1}^n w_{ij}h_j) \\] 式中的\\(\\sigma\\)表示Logistic函数，： \\[ P(t)= \\dfrac 1 {1+e^{-t}} \\] 受限玻尔兹曼机的训练目标是针对某一训练集 \\({\\displaystyle V}\\)，最大化概率的乘积。其中， ${V} $被视为一矩阵，每个行向量作为一个可见单元向量 \\({\\displaystyle v}\\): \\[ \\arg\\max_W \\prod_{v \\in V} P(v) \\] 等价的，可以最大化它的对数函数： \\[ \\arg\\max_W \\mathbb{E} \\left[\\sum_{v \\in V} \\log P (v)\\right] \\] 训练受限玻尔兹曼机，即最优化权重矩阵 \\({\\displaystyle W}\\) . 波尔茨曼机也可以看作是 马尔科夫随机场的一种特殊情况。 RBM一个基本的训练方法叫做Contrastive Divergence，它的具体过程如下： 输入： 一个N行的矩阵\\(x_0\\)，每一行对应一个可视的神经元; 隐层单元的个数m,学习率\\(\\epsilon\\), 最大训练周期T。 输出：权重\\(W\\), 可视层的偏置\\(a\\), 隐藏层的偏置\\(b\\) 初始化： 权重\\(W\\),偏置\\(a\\),\\(b\\)随机初始化为较小的数值,令可视层的第一个状态\\(v_1 = x_0\\) 参数更新规则： \\(W = W + \\epsilon*( P(h_1=1|v_1 )v_1^T - P(h_2=1|v_2)v_2^T))\\) \\(a = a +\\epsilon*(v_1 - v_2)\\) \\(b = b + \\epsilon*(P(h_1=1|v_1)-P(h_2=1|v_2))\\) 下面用Python实现其中的计算步骤，这样能够对算法的每一步有一个比较详细的了解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191from __future__ import print_functionimport numpy as npclass RBM: def __init__(self, num_visible, num_hidden, learning_rate = 0.1): self.num_hidden = num_hidden self.num_visible = num_visible self.learning_rate = learning_rate # Initialize a weight matrix, of dimensions (num_visible x num_hidden), using # a Gaussian distribution with mean 0 and standard deviation 0.1. self.weights = 0.1 * np.random.randn(self.num_visible, self.num_hidden) # Insert weights for the bias units into the first row and first column. self.weights = np.insert(self.weights, 0, 0, axis = 0) self.weights = np.insert(self.weights, 0, 0, axis = 1) def train(self, data, max_epochs = 1000): \"\"\" Train the machine. Parameters ---------- data: A matrix where each row is a training example consisting of the states of visible units. \"\"\" # 也是可视层的神经元的数量 num_examples = data.shape[0] # Insert bias units of 1 into the first column. # data的第一列用来表示偏置，这里全部设置成1 data = np.insert(data, 0, 1, axis = 1) # max_epochs 就是最大的训练周期T for epoch in range(max_epochs): # Clamp to the data and sample from the hidden units. # (This is the \"positive CD phase\", aka the reality phase.) pos_hidden_activations = np.dot(data, self.weights) pos_hidden_probs = self._logistic(pos_hidden_activations) pos_hidden_states = pos_hidden_probs &gt; np.random.rand(num_examples, self.num_hidden + 1) # Note that we're using the activation *probabilities* of the hidden states, not the hidden states # themselves, when computing associations. We could also use the states; see section 3 of Hinton's # \"A Practical Guide to Training Restricted Boltzmann Machines\" for more. pos_associations = np.dot(data.T, pos_hidden_probs) # Reconstruct the visible units and sample again from the hidden units. # (This is the \"negative CD phase\", aka the daydreaming phase.) neg_visible_activations = np.dot(pos_hidden_states, self.weights.T) neg_visible_probs = self._logistic(neg_visible_activations) neg_visible_probs[:,0] = 1 # Fix the bias unit. neg_hidden_activations = np.dot(neg_visible_probs, self.weights) neg_hidden_probs = self._logistic(neg_hidden_activations) # Note, again, that we're using the activation *probabilities* when computing associations, not the states # themselves. neg_associations = np.dot(neg_visible_probs.T, neg_hidden_probs) # Update weights. self.weights += self.learning_rate * ((pos_associations - neg_associations) / num_examples) error = np.sum((data - neg_visible_probs) ** 2) print(\"Epoch %s: error is %s\" % (epoch, error)) def run_visible(self, data): \"\"\" Assuming the RBM has been trained (so that weights for the network have been learned), run the network on a set of visible units, to get a sample of the hidden units. Parameters ---------- data: A matrix where each row consists of the states of the visible units. Returns ------- hidden_states: A matrix where each row consists of the hidden units activated from the visible units in the data matrix passed in. \"\"\" num_examples = data.shape[0] # Create a matrix, where each row is to be the hidden units (plus a bias unit) # sampled from a training example. hidden_states = np.ones((num_examples, self.num_hidden + 1)) # Insert bias units of 1 into the first column of data. data = np.insert(data, 0, 1, axis = 1) # Calculate the activations of the hidden units. hidden_activations = np.dot(data, self.weights) # Calculate the probabilities of turning the hidden units on. hidden_probs = self._logistic(hidden_activations) # Turn the hidden units on with their specified probabilities. hidden_states[:,:] = hidden_probs &gt; np.random.rand(num_examples, self.num_hidden + 1) # Always fix the bias unit to 1. # hidden_states[:,0] = 1 # Ignore the bias units. hidden_states = hidden_states[:,1:] return hidden_states # TODO: Remove the code duplication between this method and `run_visible`? def run_hidden(self, data): \"\"\" Assuming the RBM has been trained (so that weights for the network have been learned), run the network on a set of hidden units, to get a sample of the visible units. Parameters ---------- data: A matrix where each row consists of the states of the hidden units. Returns ------- visible_states: A matrix where each row consists of the visible units activated from the hidden units in the data matrix passed in. \"\"\" num_examples = data.shape[0] # Create a matrix, where each row is to be the visible units (plus a bias unit) # sampled from a training example. visible_states = np.ones((num_examples, self.num_visible + 1)) # Insert bias units of 1 into the first column of data. data = np.insert(data, 0, 1, axis = 1) # Calculate the activations of the visible units. visible_activations = np.dot(data, self.weights.T) # Calculate the probabilities of turning the visible units on. visible_probs = self._logistic(visible_activations) # Turn the visible units on with their specified probabilities. visible_states[:,:] = visible_probs &gt; np.random.rand(num_examples, self.num_visible + 1) # Always fix the bias unit to 1. # visible_states[:,0] = 1 # Ignore the bias units. visible_states = visible_states[:,1:] return visible_states def daydream(self, num_samples): \"\"\" Randomly initialize the visible units once, and start running alternating Gibbs sampling steps (where each step consists of updating all the hidden units, and then updating all of the visible units), taking a sample of the visible units at each step. Note that we only initialize the network *once*, so these samples are correlated. Returns ------- samples: A matrix, where each row is a sample of the visible units produced while the network was daydreaming. \"\"\" # Create a matrix, where each row is to be a sample of of the visible units # (with an extra bias unit), initialized to all ones. samples = np.ones((num_samples, self.num_visible + 1)) # Take the first sample from a uniform distribution. samples[0,1:] = np.random.rand(self.num_visible) # Start the alternating Gibbs sampling. # Note that we keep the hidden units binary states, but leave the # visible units as real probabilities. See section 3 of Hinton's # \"A Practical Guide to Training Restricted Boltzmann Machines\" # for more on why. for i in range(1, num_samples): visible = samples[i-1,:] # Calculate the activations of the hidden units. hidden_activations = np.dot(visible, self.weights) # Calculate the probabilities of turning the hidden units on. hidden_probs = self._logistic(hidden_activations) # Turn the hidden units on with their specified probabilities. hidden_states = hidden_probs &gt; np.random.rand(self.num_hidden + 1) # Always fix the bias unit to 1. hidden_states[0] = 1 # Recalculate the probabilities that the visible units are on. visible_activations = np.dot(hidden_states, self.weights.T) visible_probs = self._logistic(visible_activations) visible_states = visible_probs &gt; np.random.rand(self.num_visible + 1) samples[i,:] = visible_states # Ignore the bias units (the first column), since they're always set to 1. return samples[:,1:] def _logistic(self, x): return 1.0 / (1 + np.exp(-x))if __name__ == '__main__': r = RBM(num_visible = 6, num_hidden = 2) training_data = np.array([[1,1,1,0,0,0],[1,0,1,0,0,0],[1,1,1,0,0,0],[0,0,1,1,1,0], [0,0,1,1,0,0],[0,0,1,1,1,0]]) r.train(training_data, max_epochs = 50) print(r.weights) user = np.array([[0,0,0,1,1,0]]) print(r.run_visible(user)) 参考文献 介绍+Python源代码：http://blog.echen.me/2011/07/18/introduction-to-restricted-boltzmann-machines/ 介绍+Python源代码：http://imonad.com/rbm/restricted-boltzmann-machine/","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"},{"name":"深度学习","slug":"技术/机器学习/深度学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/深度学习/"}],"tags":[{"name":"RBM","slug":"RBM","permalink":"http://ff120.github.io/hexoblog/tags/RBM/"},{"name":"限制波尔茨曼机","slug":"限制波尔茨曼机","permalink":"http://ff120.github.io/hexoblog/tags/限制波尔茨曼机/"}]},{"title":"深度学习_递归神经网络(RNN)","slug":"技术/机器学习/深度学习/深度学习_递归神经网络(RNN)","date":"2017-05-10T02:14:24.000Z","updated":"2019-03-28T00:54:58.497Z","comments":true,"path":"2017/05/10/技术/机器学习/深度学习/深度学习_递归神经网络(RNN)/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/05/10/技术/机器学习/深度学习/深度学习_递归神经网络(RNN)/","excerpt":"递归神经网络，或者循环神经网络，英文名称Recurrent Neural Networks，是一种神经元上带环的神经网络。它的结构允许保留信息，传统的神经网络做不到这一点，这也许是传统的神经网络的主要缺点之一。递归神经网络主要的应用领域是语音识别，语言建模，翻译，图像字幕…","text":"递归神经网络，或者循环神经网络，英文名称Recurrent Neural Networks，是一种神经元上带环的神经网络。它的结构允许保留信息，传统的神经网络做不到这一点，这也许是传统的神经网络的主要缺点之一。递归神经网络主要的应用领域是语音识别，语言建模，翻译，图像字幕… 递归神经网络的神经元模型： 神经元上的自传递(那个环)允许信息在网络训练的不同步骤之间保留信息。其实这个模型并不复杂，因为可以把它展开成一系列普通的神经元，如下图， 上图中每一个神经元表示一个状态，从一个状态到下一个状态时，神经元保存的信息可以传递下去。 RNN的基本考量是可以利用之前的信息加强对现在的信息的理解，例如用一个完整视频的前几帧辅助识别后面几帧出现的内容，再比如，用一个电影的前半个小时的剧情预测后面的剧情。如果RNN能够实现这些，无疑会是非常有用的。 普通的RNN只能处理时间上接近的联系，比如用前一帧的信息预测后一帧，后两帧，但是无法处理时间上很长的联系，例如用一个小时之前的一帧预测现在的一帧。这是因为梯度随着层数的加深会很快消失，类似神经网络中遇到的那样。 有一种特殊结构的RNN网络可以克服上面的问题，使得长时间的联系可以实现，该网络的名字叫做LSTM(Long Short Term Memory networks)。 LSTM Long Short Term Memory networks, 是一种特殊的RNN， 普通的RNN在神经元自己的环上从一个步骤到下一个步骤的时候，都会经过一个简单函数的处理，类似\\(x2 = tanh(x1)\\); 而LSTM与之不同的是有一个更为复杂的处理，这是这个处理保证了它可以保留长期的信息。 下面我们详细介绍这个复杂的处理过程。 最上面的水平线保持了原来的数据的不变性（只经过了简单的线性变换），这个叫做cell state. 这样的图标表示一个simoid神经元，输出范围是[0,1]. 上面的图展示了每一步的计算过程，其中*表示的是向量的乘法。 除了这种标准的结构，还有许多其他的变种，适用于不同的情况。 参考文献： http://colah.github.io/posts/2015-08-Understanding-LSTMs/","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"},{"name":"深度学习","slug":"技术/机器学习/深度学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/深度学习/"}],"tags":[{"name":"RNN","slug":"RNN","permalink":"http://ff120.github.io/hexoblog/tags/RNN/"},{"name":"递归神经网络","slug":"递归神经网络","permalink":"http://ff120.github.io/hexoblog/tags/递归神经网络/"}]},{"title":"算法专题_素数问题","slug":"技术/数据结构和算法/算法专题_素数问题","date":"2017-05-09T02:16:54.000Z","updated":"2019-03-28T00:54:56.951Z","comments":true,"path":"2017/05/09/技术/数据结构和算法/算法专题_素数问题/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/05/09/技术/数据结构和算法/算法专题_素数问题/","excerpt":"只有两个因子的数叫做素数，也叫质数。例如2，3，5，7，11….素数经常用在密码学中，所以涉及素数的运算也是会经常遇到的。","text":"只有两个因子的数叫做素数，也叫质数。例如2，3，5，7，11….素数经常用在密码学中，所以涉及素数的运算也是会经常遇到的。 素性测试 测试一个数是否是素数 判断一个数是否是素数，我们就要找到它所有的因子，看是不是只有1和它本身。具体思路是从2开始，一直到$ n$, 如果都不能整除n，那么n就是素数。 12345678bool isPrime(int n)&#123; for(int i=2;i&lt;=sqrt(n);i++)&#123; if(n%i==0)&#123; return false; &#125; &#125; return true;&#125; 找出n以内的所有素数 如果是找出很多素数，如果从1开始一个一个做素性测试，那么开销就太高了，也没有必要，因为大多数都不是素数。 我们直到2是素数，那么所有2的倍数，4，6，8就都不是素数，因为其至少含有一个因子2. 同理，3的所有倍数也不是素数。 同理，5的所有倍数也不是素数。 这样考虑，每当我们确定一个素数的时候，就可以确定一大批数不是素数，这些肯定不是素数的数就不用再做素性测试了。 以这样的思路求n以内的素数的方法叫做埃氏筛法。 123456789101112131415161718192021// n 以内的素数int sieve(int n,vector&lt;int&gt; &amp;prime)&#123; int p=0; // is_prime[0] 表示数字0 是不是素数 // is_print[1] 表示数字1是不是素数 // is_print[n] 表示数字n是不是素数 vector&lt;bool&gt; is_prime(n+1,true); is_prime[0] = false; //0 不是素数， is_prime[1] = false; //1 不是素数 for(int i=2;i&lt;=n;i++)&#123; // 初始的时候，2是素数，is_prime[1]对应2 if(is_prime[i])&#123; prime.push_back(i); p++; for(int j=i*2;j&lt;=n;j += i)&#123; is_prime[j] = false; &#125; &#125; &#125; return p;&#125; 找出区间[a,b)内的所有素数 直接利用上面的结论，可以找出b以内的所有素数，然后只取大于a的部分就可以了。 除此之外，我们还可以利用上面算法的思想，在区间[a,b)内使用埃氏筛法。 我们准备两个区间[2,\\(\\sqrt b\\)) 和 [a,b), 然后在区间[2,\\(\\sqrt b\\))用埃氏筛法选择素数，同时在[a,b)删除相应的倍数，最后得到的就是[a,b)区间内的素数。 12345678910111213141516171819202122int segment_sieve(int a,int b,vector&lt;int&gt; &amp;prime)&#123; vector&lt;bool&gt; is_prime; //is_prime 指示0...sqrt(b)内是否是素数 for(int i=0; i*i &lt; b;i++)&#123; is_prime.push_back(true); &#125; // //is_prime_ab 指示[a,b])内是否是素数 vector&lt;bool&gt; is_prime_ab(b-a,true); int p=0; for(int i=2;i*i&lt;b;i++)&#123; if(is_prime[i])&#123; p++; for(int j=2*i;j*j&lt;b;j += i)&#123; is_prime[j] = false; &#125; for(int j=max(2,(a+i-1)/i)*i;j&lt;b;j += i)&#123; is_prime_ab[j-a] = false; &#125; &#125; &#125; return p;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"素数","slug":"素数","permalink":"http://ff120.github.io/hexoblog/tags/素数/"},{"name":"质数","slug":"质数","permalink":"http://ff120.github.io/hexoblog/tags/质数/"}]},{"title":"算法专题_模运算","slug":"技术/数据结构和算法/算法专题_模运算","date":"2017-05-08T08:16:17.000Z","updated":"2019-03-28T00:54:56.858Z","comments":true,"path":"2017/05/08/技术/数据结构和算法/算法专题_模运算/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/05/08/技术/数据结构和算法/算法专题_模运算/","excerpt":"模运算是指对一个数求余数的过程。涉及到比较大的数字时，通常会涉及到取模运算。了解一些模运算的性质是有好处的。我们把a 和 b 除以 m 之后所得到的余数相等记作$ a b(mod m)$.","text":"模运算是指对一个数求余数的过程。涉及到比较大的数字时，通常会涉及到取模运算。了解一些模运算的性质是有好处的。我们把a 和 b 除以 m 之后所得到的余数相等记作$ a b(mod m)$. 基本的模运算定律 如果$ a b(mod m)$ 且 $ c d(mod m)$, 那么有 - $ {a+b} $ - $ {a-b} $ - $ {a b} $ $ a b(mod m)$ 说明 \\(a = km + b\\), 另外： \\((a+b) \\% c = (a\\%c+b\\%c)\\%c\\) \\((a-b) \\% c = (a\\%c-b\\%c)\\%c\\) \\((a \\times b) \\% c = (a\\%c \\times b\\%c)\\%c\\) \\(a^b\\space\\%c = (a\\%c)^b \\space \\% c\\) 最后一条规则在求大数的幂的模的时候非常有用。例如： \\[ 62^{65} \\% 133 = 62 \\times 62^{64} \\% 133 = 62 \\times (62^2)^{32} \\% 133 = 62 \\times 3844^{32} \\% 133 = 62 \\times (3844 \\% 133)^{32} \\% 133 = 62 \\times 120^{32} \\% 133 = 62 \\times 36^{16} \\% 133 = 62 \\times 99^8 \\% 133 = 62 \\times 92^4 \\% 133 = 62 \\times 85^2 \\% 133 = 62 \\times 43 \\% 133 = 2666 \\% 133 = 6 \\] 逆元 考虑如何求解$ ax b(mod m)\\(.中的\\)x\\(,如果是等式，\\)ax=b\\(,那么求解\\)x\\(,非常容易，\\)x = a^{-1}*b\\(,如果a是实数，那么\\)a^{-1} = 1 a$. 所以，求解x的关键是求出在取模运算意义下的a的倒数，这里称作逆元。 假设a的逆元是x，那么有\\(ax \\equiv 1(mod \\space m)\\), 就是\\(ax=km+1\\),转换一下就是求使得\\(ax-km=1\\)成立的\\(x\\),其中a，m是一个已知数，k是正整数。 我们先来看一个更一般的问题的解法。a,b,x,y,都是整数，a,b,已知，求\\(ax+by=1\\)成立的x,y. 1234567891011121314151617181920int extgcd(int a,int b,int &amp;x,int &amp;y)&#123; int d = a; if( b != 0)&#123; d = extgcd(b,a%b,y,x); y = y - (a/b)*x; &#125;else&#123; x =1; y = 0; &#125; return d;&#125;int main()&#123; int a = 4,b=11; int x,y; cout&lt;&lt;extgcd(a,b,x,y)&lt;&lt;endl; cout&lt;&lt;x&lt;&lt;endl; cout&lt;&lt;y&lt;&lt;endl; return 0;&#125; 这样利用辗转相除法的扩展，可以解析的求解出x和y,比先确定一个数字再去求解另外一个数字要好。 下面来看求解逆元的方法： 12345678910int mod_inverse(int a,int m)&#123; int x,y; extgcd(a,m,x,y); return (m+x%m)%m;&#125;int main()&#123; cout&lt;&lt;mod_inverse(3,20)&lt;&lt;endl; return 0;&#125; 上面，我们直接求解得出了\\(3(mod \\space 20)\\)的逆元， 是7. 以上是利用扩展的辗转相除法求解逆元的过程。 求逆元还有其他的方法。 费马小定理 如果\\(p\\)是素数，那么对于任意的整数\\(x\\),都有\\(x^p \\equiv x(mod \\space p)\\), 随便举几个例子，\\(2^3 (mod\\space3) \\equiv 2\\),\\(8^5 (mod\\space5) \\equiv 8\\) 如果x无法被p整除，还有一个规律成立，\\(x^{p-1} \\equiv 1(mod\\space p)\\),利用这条性质，也可以求一个数的逆元。等式两边都乘以\\(x^{-1}\\),得到\\(x^{-1} = x^{p-2}(mod \\space p)\\), 所以在p是素数的时候（很多情况下都是如此），一个数的逆元，就等于这个数的p-2次方(mod p), 所以，使用快速幂运算就能求出逆元。 在p不是素数的时候，其实也有类似的定理可以使用，这里我们不做讨论了。因为程序设计题一般情况下给出的都会是素数。 a的b次方模m 1234567891011121314long long Montgomery(long long a,long long b,long long m)&#123; long long r=1; a %=m; while(b&gt;1) &#123; if((b&amp;1)!=0) r = (r*a)%m; a = (a*a)%m; b/=2; &#125; return (r*a)%m;&#125; n!(mod p) 和排列组合数模P 先来看一个具体的例子，求10！mod 4; 10! = 10x9x8x7x6x5x4x3x2x1 mod 4 = 2 x 1 x (2x4) x 3 x 2 x 1 x (1x4) x 3 x 2 x 1 mod p = 2x1x(3x2x1)x2 x (2x4)x(1x4) = 2x6x2 x (2x4)x(1x4) = 6x4x2x4x1x4 = 0 通过上面的计算过程我们可以发现，其实n!里面的所有数可以分成两个部分，一部分是能够被p整除的，这类要单独拿出来，另外一类是不能被p整除的，这类mod p之后就会呈现出周期性，最终形成\\(a^b\\)这种形式。 下面具体看一下n! mod p的代码实现： 123456789101112131415161718192021222324252627int mod_fact(int n,int p,int &amp;e)&#123; //e 的含义是n!能够迭代整除p的次数。 vector&lt;int&gt; fact(p,0); vector&lt;int&gt; nfact(p,1); //计算i的阶乘 for(int i=1;i&lt;p;i++)&#123; nfact[i] *= nfact[i-1]*i; &#125; for(int i=1;i&lt;p;i++)&#123; fact[i] = nfact[i] % p; &#125; e = 0; if(n==0) return 1; int res = mod_fact(n/p,p,e); e += n/p; if(n/p % 2 != 0)&#123; return res*(p-fact[n%p])%p; &#125; return res*(fact[n%p])%p;&#125;int main()&#123; int e; cout&lt;&lt;mod_fact(5,7,e)&lt;&lt;endl; cout&lt;&lt;e&lt;&lt;endl; return 0;&#125; 知道了如何计算阶乘的模，计算排列和组合结果的模也就不成问题了。 求\\(C^k_n = \\dfrac{n!}{k!(n-k)!} (mod\\space p)\\) 123456789int mod_comb(int n,int k,int p)&#123; if(n&lt;0 || k&lt;0|| n&lt;k) return 0; int e1,e2,e3; int a1 = mod_fact(n,p,e1); int a2 = mod_fact(k,p,e2); int a3 = mod_fact(n-k,p,e3); if(e1 &gt; e2+e3) return 0; return a1* mod_inverse(a2*a3%p,p)%p;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"mod","slug":"mod","permalink":"http://ff120.github.io/hexoblog/tags/mod/"},{"name":"模","slug":"模","permalink":"http://ff120.github.io/hexoblog/tags/模/"}]},{"title":"Kickstart Round B 2017","slug":"技术/数据结构和算法/Kickstart-Round-B-2017","date":"2017-05-07T08:16:13.000Z","updated":"2019-03-28T00:54:55.940Z","comments":true,"path":"2017/05/07/技术/数据结构和算法/Kickstart-Round-B-2017/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/05/07/技术/数据结构和算法/Kickstart-Round-B-2017/","excerpt":"谷歌codejam:https://codejam.withgoogle.com/codejam/contest/11304486/dashboard.","text":"谷歌codejam:https://codejam.withgoogle.com/codejam/contest/11304486/dashboard. problem A 小规模测试文件：https://drive.google.com/open?id=0B2aHWGYn_JL-WFhaWVMxaXpxWVk 大规模测试文件：https://drive.google.com/open?id=0B2aHWGYn_JL-X1BoUlUzZFptQzQ 因为给出的序列是有序的，我们用i表示开始的元素，用j表示结束的元素，比如对于例子[3,6,7,9]来说，i=0,j=2表示以3开始，以7结束的属于[3,6,7,9]的子集的数量，所有这样的子集都有相同的差值7-3=4,所以差值乘以数量就是结果。 现在问题的关键就是以i开头的，j结尾的子集的数量的确定。 先来 看[3,6]，只有[3,6], 1个 看[3,7]，有[3,7],[3,6,7]; 2个 看[3,9], 有[3,9],[3,6,9],[3,7,9],[3,6,7,9]； 4个 看[6,7],有[6,7]; 1个 看[6,9],有[6,7],[6,7,9]; 2个。 我们发现，子集的数量只与i和j的距离有关系。此关系是\\(2^{j-i-1}\\) 利用这个规律，我们可以简单的编写一下程序计算结果：假设一个实例数据存储在v[]中。num是v的长度。sum=0; 123456for(int i=0;i&lt;num;i++)&#123; for(int j=i+1;j&lt;num;j++)&#123; sum = (sum + ( (v[i]-v[j]) * 2^[j-i-1] ) % mod ) % mod; &#125;&#125;cout&lt;&lt;sum&lt;&lt;endl; 仔细观察上面的代码，我们发现每次都要计算\\(2^i\\),这是一个耗时的操作，尤其是当i很大的时候。我们可以事先计算出所有需要的值存储在一个数组中，这样只需要计算一次就可以了。那么我们需要计算到2的多少次方呢？我们查看最大的那组的数据规模，发现N最大是10000，所以只要稍微大于10000就可以了。这里设置maxn = 10005; 123456const int maxn = 10005;long long p[maxn];p[0]=1;for(int i=1; i&lt;maxn; i++)&#123; p[i]=p[i-1]*2 % mod;&#125; 我们对比一下优化前后的运行时间： 1234567891011121314151617181920212223242526long long two_n(long long n)&#123; long long ret = 1; for(long long i=0;i&lt;n;i++)&#123; ret = (ret * 2 ) % mod; &#125; return ret;&#125;int main()&#123; long long p[maxn]; auto start_time = clock(); p[0]=1; for(int i=1; i&lt;maxn; i++)&#123; p[i]=p[i-1]*2 % mod; &#125; auto end_time = clock(); cout&lt;&lt;end_time - start_time &lt;&lt;endl; long long q[maxn]; auto s = clock(); long double two = 2.0; for(int i=0;i&lt;maxn;i++)&#123; q[i] = two_n(i); &#125; auto e = clock(); cout&lt;&lt; e - s &lt;&lt;endl; return 0; 在maxn=10005的情况下，输出是0，363. 单位是毫秒。 可以看到，这个差距还是相当大的，maxn越大，越明显。 这样的时间复杂度其实已经可以解决这个问题了。 完整的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;cmath&gt;using namespace std;const int mod = 1000000007;const int maxn = 10005;long long p[maxn];void run()&#123; int num ; cin&gt;&gt;num; vector&lt;int&gt; v(num,0); p[0]=1; for(int i=1; i&lt;maxn; i++)&#123; p[i]=p[i-1]*2 % mod; &#125; for(int i=num-1;i&gt;=0;i--)&#123; cin&gt;&gt;v[i]; &#125; // 完成读取数据 //遍历组合 long long sum = 0; for(int i=0;i&lt;num;i++)&#123; for(int j=i+1;j&lt;num;j++)&#123; sum = (sum + ( (v[i]-v[j]) * p[j-i-1] ) % mod ) % mod; &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl;&#125;int main()&#123; freopen(\"d:/A-large-practice.in\",\"r\",stdin); freopen(\"d:/A-large-practice.out\",\"w\",stdout); int T,cas=0; cin&gt;&gt;T; while (T--)&#123; cout&lt;&lt;\"Case #\"&lt;&lt;++cas&lt;&lt;\": \"; run(); &#125; return 0;&#125; 这里还有另外一个版本的代码，貌似效率更高一些，但是还不是很明白原理： 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;#define f(x, y, z) for(int x = (y); x &lt;= (z); ++x)#define g(x, y, z) for(int x = (y); x &lt; (z); ++x)#define h(x, y, z) for(int x = (y); x &gt;= (z); --x)typedef long long ll;#define MOD 1000000007int pow2[10007];int main()&#123; pow2[0] = 1; f(i, 1, 10003) pow2[i] = pow2[i - 1] * 2 % MOD; int T; cin &gt;&gt; T; f(_, 1, T) &#123; int n, ans = 0; cin &gt;&gt; n; f(i, 1, n) &#123; int x; cin &gt;&gt; x; ans = ((ll) pow2[i - 1] * x + ans) % MOD; ans = (((ll) -pow2[n - i] * x + ans) % MOD + MOD) % MOD; &#125; printf(\"Case #%d: %d\\n\", _, ans); &#125;&#125; problem B 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 50000 + 10;const int MODULO = 1000000007;int N;double x[MAXN], y[MAXN], w[MAXN];double a[MAXN];int Order[MAXN];bool Cmp(const int&amp; x, const int&amp; y)&#123; return a[x] &lt; a[y];&#125;double GetMin()&#123; double leftw = 0, rightw = 0, cur = 0; for (int i = 0; i &lt; N; i ++) &#123; cur += (a[Order[i]] - a[Order[0]]) * w[Order[i]]; rightw += w[Order[i]]; &#125; double ans = cur; for (int i = 1; i &lt; N; i ++) &#123; leftw += w[Order[i - 1]]; rightw -= w[Order[i - 1]]; cur += leftw * (a[Order[i]] - a[Order[i - 1]]); cur -= rightw * (a[Order[i]] - a[Order[i - 1]]); if (cur &lt; ans) ans = cur; &#125; return ans;&#125;void Work()&#123; scanf(\"%d\", &amp;N); for (int i = 0; i &lt; N; i ++) &#123; scanf(\"%lf%lf%lf\", &amp;x[i], &amp;y[i], &amp;w[i]); Order[i] = i; &#125; double Ans = 0; for (int i = 0; i &lt; N; i ++) a[i] = (x[i] + y[i]) * 0.5; sort(Order, Order + N, Cmp); Ans += GetMin(); for (int i = 0; i &lt; N; i ++) a[i] = (x[i] - y[i]) * 0.5; sort(Order, Order + N, Cmp); Ans += GetMin(); printf(\"%.8lf\\n\", Ans);&#125;int main()&#123; freopen(\"d:/B-small_test.in\", \"r\", stdin); //freopen(\"d:/B-large.out\", \"w\", stdout); int Cases; scanf(\"%d\", &amp;Cases); for (int Case = 1; Case &lt;= Cases; Case ++) &#123; printf(\"Case #%d: \", Case); fprintf(stderr, \"Case #%d: \\n\", Case); Work(); fflush(stdout); &#125; return 0;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"算法专题_霍夫曼编码(哈夫曼编码)","slug":"技术/数据结构和算法/算法专题_霍夫曼编码","date":"2017-05-06T14:46:06.000Z","updated":"2019-03-28T00:54:57.341Z","comments":true,"path":"2017/05/06/技术/数据结构和算法/算法专题_霍夫曼编码/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/05/06/技术/数据结构和算法/算法专题_霍夫曼编码/","excerpt":"霍夫曼编码是一种无损编码方法，它是无损编码方案中最优的，基本思想是给出现频率高的字符以较短的编码，给出现频率低的字符以长的编码。本文将介绍霍夫曼编码的算法步骤和具体实现。","text":"霍夫曼编码是一种无损编码方法，它是无损编码方案中最优的，基本思想是给出现频率高的字符以较短的编码，给出现频率低的字符以长的编码。本文将介绍霍夫曼编码的算法步骤和具体实现。 二叉霍夫曼编码 前缀码： 没有任何一个编码是其他编码的前缀，这样的一套编码体系叫做前缀码。例如a的编码是010，那么不会存在编码是0，01，0101，0100，010**的字符。前缀码确保了解码时的唯一性。 霍夫曼编码的算法步骤： 1. 统计每个字符出现的频率，按照频率从大到小排序。 2. 找到出现频率最小的两个字符，把这两个字符作为左右孩子，添加一个节点作为它们共同的父亲节点，父亲节点的值是这两个字符频率的和。 3. 重复步骤2直到总概率为1为之。 4. 以上步骤构造了一颗二叉树，二叉树根的概率是1.从根开始，递归的标记每个节点，左孩子标记为0，右孩子标记为1，直到到达叶节点。 5. 从跟出发到每个叶节点经过的0–1路径就是该字符的编码。 下面看一个具体的例子： 假设一个文件中只包含a,b,c,d,e,f六种字符，它们的出现频率如下表所示： a b c d e f 出现次数 45 13 12 16 9 5 出现频率 0.45 0.13 0.12 0.16 0.09 0.05 第一步，找到频率最小的两个，应该是e,f,我们把e和f的根记作ef，这个时候构造了一个二叉树，二叉树的根是ef,频率是(9+5)/100 = 0.14. 第二步，用ef代替e和f之后，继续寻找最小的两个节点，这个时候是b,c,我们把b和c的根记作bc,这个bc的频率是(12+13)/100 = 0.25. 第三步，继续寻找频率最低的节点，这个时候是d和ef. 我们把d和ef的根记作def,它的频率是(16+14)/100 = 0.3. 第四步，继续寻找频率最小的两个值合并，这个时候是bc和def,我们记作bcdef,它的频率是0.55. 第五步，继续寻找频率最小的两个值合并，这个时候只剩下两个值了，就是a和bcde,它们和的频率是1. 可以看到，我们最终形成了一颗二叉树，调整一下位置，使之更好看一些。编号之后的情况是这个样子： 从中可以得到每个字符的编码： a b c d e f 00 0100 0101 0111 01100 01101 这就是整个霍夫曼编码过程。除了使用二进制编码，其实还可以使用多种不同的进制编码，只要扩展分支的数目就可以了。 N叉霍夫曼编码 举例来说，还是上面的例子，如果编码的数字允许使用0，1，2三个数字。那么霍夫曼编码的步骤变为： 设字符数量为K，则第一次选择num = K-2*[(K-1)/2],[]代表下取整的意思。这里K=6，所以第一次寻找2个频率最低的字符，e,f.如果num=0,取2，如果num=1,取3. 把找出来的字符的概率合并作为新的一项加入到队列中，原来的删掉，继续用1中的方法寻找直到最后剩下三个为止。 具体到这个问题，具体的过程为： 这个时候，得到的最优编码是： a d c b e f 0 2 10 12 110 111 于此，我们可以很容易的推广到N叉霍夫曼编码，思想是一样的，都是贪心法和前缀码。 二叉哈夫曼编码的实现 下面给出二叉霍夫曼编码的C++实现的版本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364struct Node&#123; int label; // 节点的编码， 0 或者 1 char c; // 节点表示的字符 Node* left; Node* right; Node() : label(-1),left(nullptr), right(nullptr)&#123;&#125; Node(char cc) : label(-1), c(cc),left(nullptr), right(nullptr)&#123;&#125; Node(int la) : label(la),left(nullptr), right(nullptr)&#123;&#125;&#125;;/** * 输出字符的编码 * @param root * @param s * @param re */void dfs(Node* root,string &amp;s,map&lt;char,string&gt; &amp;re)&#123; if(!root) return; if(!root-&gt;left &amp;&amp; !root-&gt;right)&#123; re[root-&gt;c] = s + to_string(root-&gt;label); s.clear(); return; &#125;else&#123; s += to_string( root-&gt;label ); string s1(s); string s2(s); if(root-&gt;left) dfs(root-&gt;left,s1,re); if(root-&gt;right) dfs(root-&gt;right,s2,re); &#125;&#125;/** * 哈夫曼编码 * @param source 每个字符出现的频率 * @return 每个字符对应的二进制编码 */map&lt;char,string&gt; huff(map&lt;char,double&gt; &amp;source)&#123; // 1. 初始化数据结构 multimap&lt;double,Node*&gt; tree; for(auto iter : source)&#123; Node *newNode = new Node(iter.first); tree.insert(make_pair(iter.second,newNode)); &#125; // 2. 构建哈夫曼树 Node* newNode; while( tree.size() &gt; 1)&#123; auto ff = tree.begin(); auto ss = ++(tree.begin()); newNode = new Node(); newNode-&gt;left = ff-&gt;second; ff-&gt;second-&gt;label = 0; // 左子树编码为0 newNode-&gt;right = ss-&gt;second; ss-&gt;second-&gt;label = 1; // 右子树编码为1 tree.insert(make_pair(ff-&gt;first+ss-&gt;first,newNode)); tree.erase(ff); tree.erase(ss); &#125; newNode-&gt;label = 0; // 根节点编码为0 // 3. 输出每个叶子节点的编码 Node* root = newNode; string tmp = \"\"; map&lt;char,string&gt; re; dfs(root,tmp,re); return re;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"霍夫曼编码","slug":"霍夫曼编码","permalink":"http://ff120.github.io/hexoblog/tags/霍夫曼编码/"}]},{"title":"算法专题_最小生成树","slug":"技术/数据结构和算法/算法专题_最小生成树","date":"2017-05-06T12:31:49.000Z","updated":"2019-03-28T00:54:56.781Z","comments":true,"path":"2017/05/06/技术/数据结构和算法/算法专题_最小生成树/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/05/06/技术/数据结构和算法/算法专题_最小生成树/","excerpt":"生成树，是指图的一个最小连通的子图，该子图少一条边，就会不连通，多一条边，就会有环。 最小生成树，是指边有权值的情况下，找到权值的总和最小的那个连通子图。","text":"生成树，是指图的一个最小连通的子图，该子图少一条边，就会不连通，多一条边，就会有环。 最小生成树，是指边有权值的情况下，找到权值的总和最小的那个连通子图。 如图，边上的数值如果代表距离的话，求最小生成树，就是求一个用最短的距离把所有点连接起来的方案。 我们通过仔细观察实验可以得出，最小的生成树是这样的。 上面是一个最小生成树的实例，那么我们依照怎样的规则得出来的最小生成树呢，总不能靠看吧？ 其实，这个问题用贪心法就可以解决。 Kruskal算法 对于给定的无向有权图$ G=(V,E)\\(，Kruskal算法描述如下： &gt; 1. 构造空集合A，并将图G中所有点加入集合A，此时A为有|V|棵树的森林。 &gt; 2. 将图\\)G\\(中所有边按照权重进行排序，形成有序集合\\)B$。 &gt; 3. 对于步骤2中排序后集合B中权重最小的边（u，v），尝试将（u，v）以及点u、v加入到集合A中。 &gt; 4. 如果步骤3中尝试加入的点和边，对于图A而言，不形成回路，则添加点u、v及边（u，v），否则不添加。 &gt; 5. 将步骤3处理的边（u，v）从集合B中删除。 &gt; 6. 判断此时作为图的集合A，是否满足边的数量等于|V|-1（也即满足最小生成树的要求），如果是，则找到最小生成树，如果不是，则转至步骤3。 上面给出的例子，如果按照Kruskal算法，过程是下面这个样子的。 初始化的时候，A集合包含所有的顶点，B集合包含按照权值从小到达排序好的边。 第一次，添加1–&gt;2, 得到 第二次，添加1–&gt;3,得到 第三次，添加4–&gt;6，得到 第四次，添加5–&gt;6,得到 第五次，应该添加2–&gt;3,但是如果添加了2–&gt;3就形成的回路，所以该次不添加，从集合B中删除2–&gt;3,继续看下一个。 第六次，应该添加4–&gt;5,但是如果添加了，就形成了回路，所以也应该跳过。 第七次，应该添加3–&gt;4,得到 此时，所有的点都已经连通，所以算法结束。最小生成树找出来了。 分析整个过程，判断连通与否 和 判断算法是否结束 是每一步操作都要检查的，所以必须要有高效的方法。 判断算法是否结束可以用A的边的数目是否达到了顶点的数目-1， 判断联通性就要用到并查集了。并查集是一种多个树组成的数据结构，可以方便的查出同组不同组的问题。 使用并查集实现的Kruskal算法如下： 12 prime算法 对于图G=（V，E），Prim算法描述如下： &gt; 1. 给定空集合A，以及任何一点v0属于{V}，将v0加入集合A中，此时A={v0}。 &gt; 2. 对于集合A中的任意一点u，以及V-A中任意一点w，找到权重最小的边（u，w），常识将（u，w）加入集合A。 &gt; 3. 判断步骤2中的边（u，w）是否使图A形成回路，如果形成回路，则不加入A，否则将点w和边（u，w）加入A。 &gt; 4. 判断此时图G中所有点{V}是否已经全部加入到集合A中，如果是，则最小生成树已经找到，退出；否则，转步骤2。 上面的例子用prime算法来做的过程是： 初始化的时候，A是空的，V包含了所有的点。 第一步，从V中任意找一个点加入集合A中； 第二步，找到4和其余的顶点之间权重最小的边，是4–6, 第三步，找到4，6和其余的顶点之间权重最小的边，5–6， 第四步，找到4，5，6和其余的顶点之间权重最小的边，4–3 第五步，找到3，4，5，6和其余的顶点之间权重最小的边，1–3 第六步，找到1，3，4，5，6和2之间权重最小的边，1–2， 此时，所有的顶点都加入了集合A，算法结束。 可以看到，结果和上面的Kruskal算法算法是一致的。一个是从边来考虑，一个是从顶点来考虑，二者实际上都是贪心法的思路。 prime算法的核心是找到两个集合之间权重最小的边，这个可以用堆实现。 prime算法的一种实现： 12","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"树","slug":"树","permalink":"http://ff120.github.io/hexoblog/tags/树/"},{"name":"最小生成树","slug":"最小生成树","permalink":"http://ff120.github.io/hexoblog/tags/最小生成树/"}]},{"title":"算法专题_图之最短路径","slug":"技术/数据结构和算法/算法专题_图之最短路径","date":"2017-05-06T05:51:25.000Z","updated":"2019-03-28T00:54:56.507Z","comments":true,"path":"2017/05/06/技术/数据结构和算法/算法专题_图之最短路径/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/05/06/技术/数据结构和算法/算法专题_图之最短路径/","excerpt":"最短路径问题是图论中的一种重要的问题。关于这个问题的详细描述，可以参考一本书《迷茫的旅行商》，书中介绍了各式各样的路径规划问题，还有各种可能的解法，和整个问题的发展历史。看完能对该问题有一个很好的理解，也能够明白，计算机算法是如何在尚不直到该问题的解决方法的时候，一步一步扩展解题的规模，从而使得现在大部分的问题都可以在能够接受的时间复杂度内解决。这里，我们只介绍几个简单的求最短路径的算法，是在算法题目中经常出现的。","text":"最短路径问题是图论中的一种重要的问题。关于这个问题的详细描述，可以参考一本书《迷茫的旅行商》，书中介绍了各式各样的路径规划问题，还有各种可能的解法，和整个问题的发展历史。看完能对该问题有一个很好的理解，也能够明白，计算机算法是如何在尚不直到该问题的解决方法的时候，一步一步扩展解题的规模，从而使得现在大部分的问题都可以在能够接受的时间复杂度内解决。这里，我们只介绍几个简单的求最短路径的算法，是在算法题目中经常出现的。 多源最短路径问题 在一个图中，找到任意两个点之间的最短路径问题，叫做多源最短路径。 如下图，1，2，3，4表示4个城市，线上的数字表示该路程的距离，求任意两个城市的最短路径是多少。 先来考虑如何才能确定两点之间的最短路径。比如求从城市1到城市3的最短路径，我们可以使用深度优先搜索或者广度优先搜索的方式，从节点1出发，搜索到节点3未知，然后记录所有路径中的最小值，就是1到3的最短路径。 floyd-Warshall 算法 使用宽度优先或者深度优先的方式求两个顶点之间的最短路径还可以，时间复杂度上可以接受，但是求多源最短路问题就显得太复杂了。那么有没有更好的方法呢？ 设想一下，从a到b的路程是l,如何缩短这个路程呢？只能试试能不能找到其他的路从a到b，看其他的所有路程中有没有比当前这条路短的。 这就是floyd-Warshall算法的思想。 我们把上面的图存储成下面这种形式：称为e. floyd-Warshall 算法可以表述为： 123456789for(int k=1;k&lt;=n;k++)&#123; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(e[i][j]&gt;e[i][k]+e[k][j])&#123; e[i][j] = e[i][k]+e[k][j]; &#125; &#125; &#125;&#125; 具体到这个例子，我们看一下这个算法是如何工作的。 开始的时候，k=1,i=1,j=1,2,3,4; 循环里面比较的是： e[1][1] &gt; e[1][1] + e[1][1] e[1][2] &gt; e[1][1] + e[1][2] e[1][3] &gt; e[1][1] + e[1][3] e[1][4] &gt; e[1][1] + e[1][4] 然后，k=1,i=2,j=1,2,3,4; 循环里面比较的是： e[2][1] &gt; e[2][1] + e[1][1] e[2][2] &gt; e[2][1] + e[1][2] e[2][3] &gt; e[2][1] + e[1][3] e[2][4] &gt; e[2][1] + e[1][4] 然后，k=1,i=3,j=1,2,3,4;循环里面的比较是： e[3][1] &gt; e[3][1] + e[1][1] e[3][2] &gt; e[3][1] + e[1][2] e[3][3] &gt; e[3][1] + e[1][3] e[3][4] &gt; e[3][1] + e[1][4] 然后，k=1,i=4,j=1,2,3,4;循环里面的比较是： e[4][1] &gt; e[4][1] + e[1][1] e[4][2] &gt; e[4][1] + e[1][2] e[4][3] &gt; e[4][1] + e[1][3] e[4][4] &gt; e[4][1] + e[1][4] 可以看到，当k=1的时候，遍历了每个节点到每个节点的连接，把通过节点1中转的情况全部尝试了一遍，看有没有任何两个节点之间通过节点1中转之后路程会变短。如果会，就把路程更新成这个更短的路程。 K=1执行完之后矩阵的更新情况： K=2的时候就好理解了。就是尝试经过节点2进行中转。 因为已经是经过节点1中转过后的数据了。所以相当于原始数据经过节点1和节点2中转之后获得的最短的距离。 K=2执行完之后矩阵的更新情况： k=3的时候同样的道理，经过节点3中转，k=4的时候经过节点4中转。这样最后获得的更新之后的矩阵e就存储了任意两个节点之间的最短路径。 K=3执行完之后矩阵的更新情况： K=4执行完之后矩阵的更新情况： 这就是floyd-Warshall 算法，其实非常简单，就是逐个尝试使用节点中转是否可以较少距离，然后更新距离。 单源最短路径问题 上面求的是任意两个点的最短距离，如果求某一个点到其余各个点的最短距离，还有效率更高的方法。 求一个特定的点到其他点的最短路径，就是单源最短路问题。 Dijkstr 算法 算法的基本思想： 每次找到离源点最近的一个点，以这个点为顶点进行扩展，最终得到源点到其余各点的最短路径。具体的步骤是： 1. 初始化：将所有的顶点分为两部分，已知最短路径的顶点集合P和未知最短路径的顶点集合Q。开始的时候，P中只有源点，因为开始的时候只能直到源点到源点的距离最近，是0. 其余所有的点属于集合Q。 2. 设置源点到自己的距离为0.设置源点能够直接到达（不经过别的节点）的顶点的距离为e源点到该点的距离。把所有源点不能直接到达的节点的值设置为无穷大。 3. 在集合Q中选择一个离源点距离最近的点加入到P，同时从Q中删除该节点，假设这个节点是u,考察u能到达的所有节点，看是否从源点通过u到达这些节点比原来的距离近，如果近，就更新这个值。 4. 重复第三步直到Q为空。 我们举例说明该算法的具体过程： 初始化，P集合中只有源点1，Q集合中是剩下的所有节点。distance数据初始化成图中的样子。 找到结合Q中距离源点最近的节点，是2，加入到P中，2可以到达3和4.此时到3的距离distance中是12，到4的距离distance中是无穷大，如果通过节点2中转，可以得到到3的距离等于10，小于原来的12，到4的距离是4，小于原来的无穷大，所以更新这两个距离。 从集合Q中找一个到集合P最近的节点，是4，把4加入P，同时从Q中删除4，4能够到达的节点是3，5，6，考察通过4能够减少原来distance中的距离。从源点通过4达到3距离是8，比原来的10小，更新；从源点通过4到达5，距离是17，比原来的无穷大小，更新；从源点通过4到达6，距离是19，比原来的无穷大小，更新； 从集合Q中选出距离源点最近的节点，是3，把3加入结合P，同时从集合Q中删除3.看通过3能够使得distance中的各个距离缩小。3只能到达5，从源点通过3到达5的距离是13，小于原来的17，更新； 从集合Q中继续选择距离源点最近的点，是5，加入P，从Q中删除；5只能到达6，通过5到达6距离变成了17，小于原来的19，更新； 集合Q中只剩下一个节点，将它加入P集合，通过它不能达到任何节点，所以算法结束。 此时的distance存储的就是最终的结果。 注意，该算法的时间复杂度是O(N^2)，如果使用邻接表来存储图，时间复杂度可以是O(M),M是边的数量，可以看到，该算法非常高效，但是不能解决带负权边的问题，如果要解的问题权重有负值，可以考虑使用下面提到的方法。 Bellman-Ford 算法 该算法核心代码： 1234567for(int k=1;k&lt;=n-1;k++)&#123; for(i=1;i&lt;=m;i++)&#123; if( distance[[v[i]]] &gt; distance[u[i]] + w[i] )&#123; distance[[v[i]]] = distance[u[i]] + w[i] &#125; &#125;&#125; 代码当中，n是节点的个数，m是边的个数，distance是记录源点到各个点的最短距离的数组，u,v,w是三个数组，用来存储边的信息，对于边i来说，u[i]是这变的起点，v[i]是这条边的终点，w[i]是这条边的权重。所以， 123if( distance[[v[i]]] &gt; distance[u[i]] + w[i] )&#123; distance[[v[i]]] = distance[u[i]] + w[i]&#125; 这段代码的含义就是：如果从源点到节点v[i]的距离 大于 经过节点u[i]再到v[i]的距离，就更新源点到节点v[i]的距离为 distance[u[i]] + w[i]. 这里的操作和dijstra算法是一样的含义。通俗的理解就是，如果通过第i条边能使距离变短，就更新。 那么，所有的边都松弛一边之后会是什么样子呢。为什么最外层还有一个n-1次的循环呢？ 让我们通过具体的实例看一下具体情况。 空心小圆圈上的数字是边的编号，distance数组被初始化了。我们用上面的代码进行一轮运算：K=1， i= 1…m 这里m等于5，因为只有5条边。 i = 1, u[1]=2, v[1]=3, distance[v[1]]无穷大，distance[u[1]]+w[1]还是无穷大，所以本次不更新distance数组。 i = 2, distance[v[2]]=无穷，而distance[u[2]]+w[2]=-3,所以distance[v[2]]=-3 i = 3, distance[v[3]]=无穷，而distance[u[3]]+w[3]=5,所以distance[3]=5, i = 4, distance[v[4]]=5，而distance[u[4]]+w[4]=无穷,所以本次不更新。 i = 5, distance[v[5]]=无穷，而distance[u[5]]+w[5]=无穷，所以本次不更新。 从上面可以看出，所有的边都松弛了一边，但是并没有得到答案，目前为止，我们只得到了源点到2的最短距离，源点到3目前还不是最短距离。所以可以假定，每次遍历一边所有的边，至少能够确定一个顶点的最短距离，所以最多循环顶点的个数减1次就可以了。需要注意的是，并不一定每次遍历一遍边只能确定一个顶点的最短距离，所以n-1次只是上限，如果超过了n-1次，distance数组还在发生变化，那么说明图中存在负权回路，存在负权回路的图是没有最短路径的，因为每绕一圈路径都会缩短。 K=2 完成之后的情况： k=3 完成之后的情况： k=4 完成之后的情况： 可以看到，此时已经没有变化了，算法在与上一次相比，distance没有变化之后其实就可以提前结束了。 参考文献： 带权最短路：http://www.renfei.org/blog/weighted-shortest-path.html","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"图","slug":"图","permalink":"http://ff120.github.io/hexoblog/tags/图/"},{"name":"最短路径","slug":"最短路径","permalink":"http://ff120.github.io/hexoblog/tags/最短路径/"}]},{"title":"VISIO的使用01-基础入门","slug":"技术/工具/Visio/VISIO的使用01-基础入门","date":"2017-05-05T07:31:44.000Z","updated":"2019-03-28T00:54:55.630Z","comments":true,"path":"2017/05/05/技术/工具/Visio/VISIO的使用01-基础入门/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/05/05/技术/工具/Visio/VISIO的使用01-基础入门/","excerpt":"visio是一个适用于绘制各种流程图，示意图的工具，提供了大量的元件和模版，比直接使用word或者画图绘制图形要方便许多。","text":"visio是一个适用于绘制各种流程图，示意图的工具，提供了大量的元件和模版，比直接使用word或者画图绘制图形要方便许多。","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"工具","slug":"技术/工具","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/"},{"name":"Visio","slug":"技术/工具/Visio","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/Visio/"}],"tags":[{"name":"visio","slug":"visio","permalink":"http://ff120.github.io/hexoblog/tags/visio/"}]},{"title":"算法专题_图之网络流","slug":"技术/数据结构和算法/算法专题_图之网络流","date":"2017-05-05T07:29:25.000Z","updated":"2019-03-28T00:54:56.532Z","comments":true,"path":"2017/05/05/技术/数据结构和算法/算法专题_图之网络流/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/05/05/技术/数据结构和算法/算法专题_图之网络流/","excerpt":"有一个自来水管道运输系统，起点是s，终点是t，途中经过的管道都有一个最大的容量。求从s到t的最大水流量是多少？ 网络最大流问题是网络的另一个基本问题。许多系统包含了流量问题。例如交通系统有车流量，金融系统有现金流，控制系统有信息流等。许多流问题主要是确定这类系统网络所能承受的最大流量以及如何达到这个最大流量。","text":"有一个自来水管道运输系统，起点是s，终点是t，途中经过的管道都有一个最大的容量。求从s到t的最大水流量是多少？ 网络最大流问题是网络的另一个基本问题。许多系统包含了流量问题。例如交通系统有车流量，金融系统有现金流，控制系统有信息流等。许多流问题主要是确定这类系统网络所能承受的最大流量以及如何达到这个最大流量。 先介绍最大流问题额一般模型。 如图，要求从s到t的最大流是多少。我们可以很容易的看出该网络的最大流是4，s–&gt;1 == 2 并且 s–&gt;2 = 2. 线段上的数据表示线段上的最大容量，s表示起点，术语叫做源点(source),t是终点，术语叫做汇点(sink),边的容量记作\\(c\\),实际边上流过的具体的值记作\\(f\\). 最大流问题就是最大化从s出发的流量。 流网络的值 有时候，我们会提到流网络的大小，这个时候是指所有从源点出发的流之和。 Ford-Fulkerson 网络最大流问题比较常见的是Ford-Fulkerson解法。该方法依赖于三种重要思想：残留网络，增广路径和割。 增广路径 增广路径可以看做是从源点s到汇点t之间的一条路径，沿该路径可以压入更多的流，从而增加流的值。 举个例子来说明下，如图所示，每条红线就代表了一条增广路径，当前s到t的流量为3。 当然这并不是该网络的最大流，根据寻找增广路径的算法我们其实还可以继续寻找增广路径，最终的最大流网络如下图所示，最大流为4。 残留网络(Residual Graph) 给定一个具体的流，除了这个流之外，网络上还能容纳的流叫做这个流对应的残留网络。可以简单的把残留网络理解为整个网络减去当前的流网络。 残留网络的具体计算方法： 给定一个流网络G和一个流，流的残留网\\(G_f\\)拥有与原网相同的顶点。原流网络中每条边将对应残留网中一条或者两条边，对于原流网络中的任意边(u, v)，流量为f(u, v)，容量为c(u, v)： - 如果f(u, v) &gt; 0，则在残留网中包含一条容量为f(u, v)的边(v, u); - 如果f(u, v) &lt; c(u, v)，则在残留网中包含一条容量为c(u, v) - f(u, v)的边(u, v)。 如上图所示，开始的时候，所有的流都为0，此时满足第二条，f(u,v) = 0 &lt; c(u,v).所以残留网络与原来的网络相同。 在当前的残留网络（与原网络相同）随意确定一条增广路径，假设是0--&gt;1--&gt;3--&gt;5，该路径的最大流量是2. f(0,1)&gt;0, 残留网络中有一条边(1,0) = 2, f(0,1) = c(0,1), 所以没有从0到1的边。 c(1,3)&gt;f(1,3)&gt;0, 所以残留网络中有两条边,(1,3)=3-2=1, (3,1)=f(1,3)=2. c(3,5) = f(3,5)&gt;0, 所以残留网络中有一条边，(5,2) = 2. 整个残留网络的变化如有图所示。 再从残留网络中找一条增广路径，这次我们找0--&gt;2--&gt;4--&gt;5,最大流量是1. 按照残留网络的规则，计算之后的残留网络如右图所示。 继续从残留网络中找增广路径，可以寻找到一条0--&gt;2--&gt;3--&gt;1--&gt;4--&gt;5的路径，注意3--&gt;1就是原来的1--&gt;3减去1，最大的流量是1. 根据上面的规则调整残留网络，如右图所示。 此时，残留网络中再也找不到任何一条从0到5的增广路径，所以过程结束，这个时候，我们发现，我们已经找到了最大流。上图左边所示的就是该网络的最大流，和我们最初的直观印象是一样的。 割 设整个图的顶点集合是V。所谓图的割，指的是边的集合，指的是对于某个顶点集合\\(S \\subseteq V\\) ,从S出发指向S外部的那些边的集合，记为割(S,V). 所以割是指一些边的集合。 这些边上的容量之和被称为割的容量。 最小割问题 对于给定的网络，为了保证没有从s到t的路径，需要删去的边的总容量最小是多少。其中\\(s \\in S\\) 且 \\(t \\in {V/S}\\). 最大流最小割定理 一个网中所有流中的最大值等于所有割中的最小容量。 其实这个定理很容易从道理上想明白，一旦超出最小割，便总有边超出了边的容量，也就不存在可行的流了。 用上面用过的图来说明一下割的相关概念： 如图，流网络的一个割为s:{0,1,2},t:{3,4,5}, 通过割的流量定义为从s到t的所有流量之和(从t到s的流量记作负值)，所以这个割的流量是：2+1=3 割的容量记作所有从s到t的边的容量之和，所以是3+1+1+1 = 6. 从上面的定义可以简单的得到一点，任何一个割的流量都小于等于割的容量。 将上面的割的图形增加一个虚拟的节点s’，绘制成下面的形式：f1是流入S的流量，f2是从S到T的流量，f3是从T到S的流量。一个节点的流入流量等于流出的流量，所以有f2 = f1 + f3. 从这个图可以清晰的看出，流网络的值等于f1, 而割的流量等于f2-f3. 所以有流网络的值等于割的流量值。 最大流最小割定理定理的证明：http://www.cnblogs.com/luweiseu/archive/2012/07/14/2591573.html Ford-Fulkerson算法的实现 上面介绍残留网络的时候已经将的很清楚了，Ford-Fulkerson算法就是不断更新残留网络，从中找出可行的流，直到无法从残留网络中找出可行的流为止。 所以，简单的算法步骤可以表述为： &gt; 1. 初始化流flow = 0; &gt; 2. while(condition){ &gt; flow += path-flow &gt; } &gt; 此处的condition为 存在从s到t的增广路径，path-flow为该增广路径的值。 &gt; 3. 输出flow. 可以看出，算法的主要部分在寻找增广路径上面。 参考文章：http://www.geeksforgeeks.org/ford-fulkerson-algorithm-for-maximum-flow-problem/ 程序以这个实例作为输入： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118// C++ program for implementation of Ford Fulkerson algorithm#include &lt;iostream&gt;#include &lt;limits.h&gt;#include &lt;string.h&gt;#include &lt;queue&gt;using namespace std;// Number of vertices in given graph#define V 6/* Returns true if there is a path from source 's' to sink 't' in residual graph. Also fills parent[] to store the path */// 使用宽度优先搜索搜索残留网络之中是否有增广路径bool bfs(int rGraph[V][V], int s, int t, int parent[])&#123; // Create a visited array and mark all vertices as not visited bool visited[V]; memset(visited, 0, sizeof(visited)); // Create a queue, enqueue source vertex and mark source vertex // as visited queue &lt;int&gt; q; q.push(s); visited[s] = true; parent[s] = -1; // Standard BFS Loop 宽度优先搜索 while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int v=0; v&lt;V; v++) &#123; if (visited[v]==false &amp;&amp; rGraph[u][v] &gt; 0) &#123; q.push(v); parent[v] = u; visited[v] = true; &#125; &#125; &#125; // If we reached sink in BFS starting from source, then return // true, else false return (visited[t] == true);&#125;// Returns the maximum flow from s to t in the given graphint fordFulkerson(int graph[V][V], int s, int t)&#123; int u, v; // Create a residual graph and fill the residual graph with // given capacities in the original graph as residual capacities // in residual graph int rGraph[V][V]; // Residual graph where rGraph[i][j] indicates // residual capacity of edge from i to j (if there // is an edge. If rGraph[i][j] is 0, then there is not) // 初始化残留网络，刚开始的时候，残留网络和初始网络一致，见上面的讲解 for (u = 0; u &lt; V; u++) for (v = 0; v &lt; V; v++) rGraph[u][v] = graph[u][v]; int parent[V]; // This array is filled by BFS and to store path int max_flow = 0; // There is no flow initially // Augment the flow while tere is path from source to sink //bfs(rGraph, s, t, parent) 实现了判断残留网络中是否存在增广路径 while (bfs(rGraph, s, t, parent)) &#123; // Find minimum residual capacity of the edges along the // path filled by BFS. Or we can say find the maximum flow // through the path found. int path_flow = INT_MAX; //找到path_flow的值，path_flow的值等于增广路径中最小的边的容量。 for (v=t; v!=s; v=parent[v]) &#123; u = parent[v]; path_flow = min(path_flow, rGraph[u][v]); &#125; // update residual capacities of the edges and reverse edges // along the path //更新残留网络 for (v=t; v != s; v=parent[v]) &#123; u = parent[v]; rGraph[u][v] -= path_flow; rGraph[v][u] += path_flow; &#125; // Add path flow to overall flow max_flow += path_flow; &#125; // Return the overall flow return max_flow;&#125;// Driver program to test above functionsint main()&#123; // Let us create a graph shown in the above example int graph[V][V] = &#123; &#123;0, 16, 13, 0, 0, 0&#125;, &#123;0, 0, 10, 12, 0, 0&#125;, &#123;0, 4, 0, 0, 14, 0&#125;, &#123;0, 0, 9, 0, 0, 20&#125;, &#123;0, 0, 0, 7, 0, 4&#125;, &#123;0, 0, 0, 0, 0, 0&#125; &#125;; cout &lt;&lt; \"The maximum possible flow is \" &lt;&lt; fordFulkerson(graph, 0, 5); return 0;&#125; 以上代码搜索增广路径使用的BFS，实际上还可以使用DFS，PFS等方法，参考文章： http://www.cnblogs.com/luweiseu/archive/2012/07/14/2591573.html 参考文献 http://www.cnblogs.com/luweiseu/archive/2012/07/14/2591573.html http://www.acmerblog.com/ford-fulkerson-6135.html http://blog.csdn.net/smartxxyx/article/details/9293805 http://www.geeksforgeeks.org/ford-fulkerson-algorithm-for-maximum-flow-problem/ Dinic算法 Dinic是一种比Ford-Fulkerson效率更高的算法，当数据较大的时候，可以考虑使用Dinic算法。 顶点的层次 在残留网络中，把顶点距离源点的距离定义为节点的层次，源点的层次为0，和源点直接相连的节点的层次是1. 分层： 将残留网络中所有节点的层次标记出来的过程。（注意不是所有的网络都可以分层） 层次网络：对残留网络进行分层后，删去比汇点Vt层次更高的顶点和与汇点Vt同层的顶点(保留Vt)，并删去这些顶点相关联的弧，再删去从某层顶点指向同层顶点和低层顶点的弧，所剩余的各条弧的容量与残留网络中的容量相同，这样得到的网络就是残留网络的子网络，称为层次网络，记为G’‘(V’‘,E’’)。 根据层次网络定义，层次网络中任意的一条弧，有满足level(u)+1 == level(v)，这条弧也叫允许弧。直观的说，层次网络是建立在残留网络基础之上的一张“最短路径图”。从源点开始，在层次网络中沿着边不管怎么走，到达一个终点之后，经过的路径一定是终点在残留网络中的最短路径。 Dinic算法的思想 Dinic算法的思想也是分阶段地在层次网络中增广。它与最短增广路算法不同之处是：最短增广路每个阶段执行完一次BFS增广后，要重新启动BFS从源点Vs开始寻找另一条增广路;而在Dinic算法中，只需一次DFS过程就可以实现多次增广，这是Dinic算法的巧妙之处。Dinic算法具体步骤如下: （1）初始化容量网络和网络流。 （2）构造残留网络和层次网络，若汇点不再层次网络中，则算法结束。 （3）在层次网络中用一次DFS过程进行增广，DFS执行完毕，该阶段的增广也执行完毕。 （4）转步骤（2）。 在Dinic的算法步骤中，只有第（3）步与最短增广路相同。在下面实例中，将会发现DFS过程将会使算法的效率有非常大的提高。 DFS增广过程示意： Dinic算法实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int MAXN = 210;const int MAXM = 210*210;const int INF = 0x3f3f3f3f;struct Edge&#123; int v, f; int next;&#125;edge[MAXM];int n, m;int cnt;int first[MAXN], level[MAXN];int q[MAXN];void init()&#123; cnt = 0; memset(first, -1, sizeof(first));&#125;void read_graph(int u, int v, int f)&#123; edge[cnt].v = v, edge[cnt].f = f; edge[cnt].next = first[u], first[u] = cnt++; edge[cnt].v = u, edge[cnt].f = 0; //增加一条反向弧，容量为0 edge[cnt].next = first[v], first[v] = cnt++;&#125;int bfs(int s, int t) //构建层次网络&#123; memset(level, 0, sizeof(level)); level[s] = 1; int front = 0, rear = 1; q[front] = s; while(front &lt; rear) &#123; int x = q[front++]; if(x == t) return 1; for(int e = first[x]; e != -1; e = edge[e].next) &#123; int v = edge[e].v, f = edge[e].f; if(!level[v] &amp;&amp; f) &#123; level[v] = level[x] + 1; q[rear++] = v; &#125; &#125; &#125; return 0;&#125;int dfs(int u, int maxf, int t)&#123; if(u == t) return maxf; int ret = 0; for(int e = first[u]; e != -1; e = edge[e].next) &#123; int v = edge[e].v, f = edge[e].f; if(level[u] + 1 == level[v] &amp;&amp; f) &#123; int Min = min(maxf-ret, f); f = dfs(v, Min, t); edge[e].f -= f; edge[e^1].f += f; ret += f; if(ret == maxf) return ret; &#125; &#125; return ret;&#125;int Dinic(int s, int t) //Dinic&#123; int ans = 0; while(bfs(s, t)) ans += dfs(s, INF, t); return ans;&#125; 参考文献 https://comzyh.com/blog/archives/568/ http://blog.csdn.net/wall_f/article/details/8207595 http://www.cnblogs.com/y-clever/p/6308820.html http://blog.csdn.net/u012914220/article/details/23865829 http://blog.csdn.net/pi9nc/article/details/23339111 http://www.nocow.cn/index.php/Dinic#.E7.AE.97.E6.B3.95.E6.B5.81.E7.A8.8B 2017ISAP 算法 ：http://www.renfei.org/blog/isap.html","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"图","slug":"图","permalink":"http://ff120.github.io/hexoblog/tags/图/"},{"name":"网络流","slug":"网络流","permalink":"http://ff120.github.io/hexoblog/tags/网络流/"}]},{"title":"图片处理02-一寸照片","slug":"技术/工具/图片处理/图片处理02-一寸照片","date":"2017-05-05T03:35:13.000Z","updated":"2019-03-28T00:54:55.790Z","comments":true,"path":"2017/05/05/技术/工具/图片处理/图片处理02-一寸照片/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/05/05/技术/工具/图片处理/图片处理02-一寸照片/","excerpt":"学会一些对照片的简单处理方法是每个人都应该掌握的技能。比如，修改图片的尺寸，修改图片占用的空间的大小，修改图片的底色。制作标准的一寸照片，二寸照片等等。这些在很多需要个人简历的地方都用的到。","text":"学会一些对照片的简单处理方法是每个人都应该掌握的技能。比如，修改图片的尺寸，修改图片占用的空间的大小，修改图片的底色。制作标准的一寸照片，二寸照片等等。这些在很多需要个人简历的地方都用的到。 图像处理软件有很多，最专业的要属photoshop了。但是，如果只是简单的处理数据，没有必要使用这么庞大和复杂的软件。美图秀秀就能满足要求。软件不到30M，安装也很快。 美图秀秀制作一寸照片 下载安装美图秀秀 下载地址：http://xiuxiu.meitu.com/ 更换照片的背景 打开美化图片，选择一张图片进来。 选择抠图笔–自动抠图，在人像上画线，软件会自动找到边缘，把人像抠出来。 单击完成抠图，会出现下面这样的界面： 选择背景颜色： 制作好的照片： 最后一张是使用图案作为背景的。 更改照片的格式和KB大小 很多网站上传图片的时候都有文件格式的限制和文件大小的限制。我们手里的图片很可能不满足要求。使用美图秀秀可以方便的更改文件的格式和大小。 除此之外，还有一种更简单的把图像KB大小变小的方法，就是打开图像，用QQ截图截取，然后保存，一般情况下图像都能降到十几KB。 photoshop制作一寸照片","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"工具","slug":"技术/工具","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/"},{"name":"图片处理","slug":"技术/工具/图片处理","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/图片处理/"}],"tags":[{"name":"美图秀秀","slug":"美图秀秀","permalink":"http://ff120.github.io/hexoblog/tags/美图秀秀/"},{"name":"一寸照片","slug":"一寸照片","permalink":"http://ff120.github.io/hexoblog/tags/一寸照片/"},{"name":"换背景","slug":"换背景","permalink":"http://ff120.github.io/hexoblog/tags/换背景/"}]},{"title":"Hexo的使用03-迁移","slug":"技术/工具/Hexo/Hexo的使用03-迁移","date":"2017-05-04T16:10:05.000Z","updated":"2019-03-28T00:54:55.520Z","comments":true,"path":"2017/05/05/技术/工具/Hexo/Hexo的使用03-迁移/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/05/05/技术/工具/Hexo/Hexo的使用03-迁移/","excerpt":"hexo目前还没有全自动的一键迁移功能，所以要移动位置的时候需要重新执行一边流程。把这个流程记录下来，便于以后再次迁移的时候使用。","text":"hexo目前还没有全自动的一键迁移功能，所以要移动位置的时候需要重新执行一边流程。把这个流程记录下来，便于以后再次迁移的时候使用。 建站 找一个目录，命令行切换到该目录下。 npm install -g hexo-cli, 安装主程序。 hexo version, 查看安装的版本 hexo init ., 在当前目录下建立站点，该过程会安装许多相关的文件。 hexo s，打开hexo的服务器，然后在浏览器输入http://localhost:4000/,查看效果。 安装需要的插件 npm install hexo-deployer-git --save npm install hexo-generator-feed --save npm install hexo-generator-search --save 更新成以前的配置 主配置文件和整个主题文件夹全部拷贝过来，覆盖原来的文件。 拷贝博客数据 把source文件加整个复制过来覆盖。 完成 此时本地的环境就搭建好了，只是还没有和远程的仓库连接起来。 hexo g生成public目录。 将public部署到远程。 解决hexo和latex的冲突问题 https://github.com/hexojs/hexo/issues/524 使用pandoc会出现其他的问题，因为markdown语法会有少许的不同，这个是最令人头疼的事情。 http://shomy.top/2016/10/22/hexo-markdown-mathjax/ 适用了N中方法，最后发现，还是修改源码的方法最靠谱，不会有格式上的太大的变化。","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"工具","slug":"技术/工具","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/"},{"name":"Hexo","slug":"技术/工具/Hexo","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://ff120.github.io/hexoblog/tags/hexo/"}]},{"title":"机器学习_Matlab使用技巧","slug":"技术/机器学习/机器学习_Matlab使用技巧","date":"2017-05-04T13:20:58.000Z","updated":"2019-03-28T00:54:57.770Z","comments":true,"path":"2017/05/04/技术/机器学习/机器学习_Matlab使用技巧/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/05/04/技术/机器学习/机器学习_Matlab使用技巧/","excerpt":"记录一些Matlab常用的操作，以便日后查阅。","text":"记录一些Matlab常用的操作，以便日后查阅。 发出声音 12sp=actxserver('SAPI.SpVoice');sp.Speak('第一个被试处理完了！') 计时 123tic; % 开始计时....toc % 停止计时 输出重定向到文件 123diary 文件路径 % 输出重定向到文件...diary off; % 从diary 到diary off 之间的输出都重定向到文件中去了。 颜色控制 生成颜色 Matlab中可以很方便的生成各种不同的颜色，在Matlab中叫做颜色映像。 例如想要获得 从 蓝色 到 红色 渐变的 100 中颜色，可以输入： a = jet(100), a会是一个100 * 3的矩阵， 值都在0 – 1 之间，0表示黑色，1表示白色。 3 个列分别表示R， G ， B 三个通道的取值。 不同的颜色映像： 生成的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041color_num = 64;M = hsv(color_num);colormap(M);colorbar();%pcolor(M);M = hot(color_num);colormap(M);colorbar();M = cool(color_num);colormap(M);colorbar();M = pink(color_num);colormap(M);colorbar();M = bone(color_num);colormap(M);colorbar();M = jet(color_num);colormap(M);colorbar();M = copper(color_num);colormap(M);colorbar();M = prism(color_num);colormap(M);colorbar();M = flag(color_num);colormap(M);colorbar();M = gray(color_num);colormap(M);colorbar(); 设置颜色 使用colormap(M)指定画图的时候使用的颜色映像，M是上面生成的n*3的矩阵。 显示colorbar 函数colorbar();可以显示当前的colorbar. 不同的jet(n)得到的颜色： 不同的HSV(n)得到的颜色： 颜色矩阵 函数pcolor(A),可以把矩阵A以用颜色代表数值大小的方式显示出来。该函数默认情况下不使用最后一行和最后一列，所以要完整的打印出整个矩阵的颜色，在使用之前要增加一行，增加一列。 1234567891011121314151617% 准备数据map=2*(rand(4)-0.5);% 增加一行和一列clear add_cow;clear add_col;maxV = max(max(map));minV = min(min(map));va = (maxV + minV) /2;add_cow(1,[1:size(map,2)]) = va;map = [map;add_cow];add_col([1:(size(map,1))],1) = va;map = [map,add_col];% 打印M = jet(color_num);colormap(M);pcolor(map); 不同的颜色映象打印出来的矩阵： 读写文件 读取Excel 12file = 'D:\\FMRI_ROOT\\YIYU\\features_dcm_origin.xls'data = xlsread(file,'Sheet1'); 写入Excel 1xlswrite(file,data,'Sheet2'); 写入的时候需要确保文件不被其他资源占用，否则可能出现写入失败的情况。 写文本文件 123fid=fopen('D:\\colors.txt','w+');fprintf(fid,'写入的内容');fclose(fid); 随机生成数字 12rand(n) % n*n的矩阵rand(m,n) % m*n的矩阵","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"http://ff120.github.io/hexoblog/tags/matlab/"}]},{"title":"GIT的使用01-基本功能","slug":"技术/工具/Git/GIT的使用01-基本功能","date":"2017-05-04T10:41:45.000Z","updated":"2019-03-28T00:54:55.445Z","comments":true,"path":"2017/05/04/技术/工具/Git/GIT的使用01-基本功能/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/05/04/技术/工具/Git/GIT的使用01-基本功能/","excerpt":"版本控制工具主要有SVN和git, 目前git已经全面超越了SVN, 成为最优秀的版本管理工具。一切文本文档都可以用git来管理，使用git能够以最小的存储代价，追踪记录每一次对文件的修改，并且能够在需要的时候，恢复到任意一个版本。 除此之外，多人协作也是git的一个重要应用，它可以方便的完成分支和合并，提高团队合作的效率。","text":"版本控制工具主要有SVN和git, 目前git已经全面超越了SVN, 成为最优秀的版本管理工具。一切文本文档都可以用git来管理，使用git能够以最小的存储代价，追踪记录每一次对文件的修改，并且能够在需要的时候，恢复到任意一个版本。 除此之外，多人协作也是git的一个重要应用，它可以方便的完成分支和合并，提高团队合作的效率。 目前基于git的开放源代码托管平台国内主要是(coding.net)[coding.net],免费提供私有仓库。国外主要是github,两者的功能基本一样，都提供代码管理和Page服务，所以两者都可以用来托管静态博客。 目前应用git较多的领域是一个是编程领域，包括代码版本的管理，文档的管理；另一个就是图书出版领域，有很多写书的人就是利用git管理自己的内容的。有不少工具提供了将文本格式格式化成书籍的工具，最常见的一种是markdown.PREVIEW 安装 git提供了Windows的安装包，所以直接下载安装就可以了。初学git,最好使用命令，放弃图形界面，这样能更深入的理解内部的原理，这对以后复杂的版本管理，分支合并等内容有好处。 使用 克隆别人的仓库 1git clone 仓库地址 如果是公开仓库，直接克隆成功，如果是私有仓库，按照提示输入用户名和密码。 修改之后提交到远程 123git add -A #添加所有新添加的文件git commit -a -m \"提交说明\" #提交修改到本地git仓库git push origin master # 提交本地仓库到远程的master分支 保持和远程仓库一致 1git pull pull之后可能会出现冲突的情况，这个时候git会提示你有哪些文件冲突了，你需要子集修改冲突的文件，然后重新提交。 记住密码 修改.git目录中的config将其中的[remote &quot;origin&quot;]修改为 1url = https://[username]:[password]@github.com/... example for rememner git password 进一步学习 git的几个简单的命令足够日常使用，如果项进一步学习，可以参考一下资料： git简明指南 ProGit","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"工具","slug":"技术/工具","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/"},{"name":"Git","slug":"技术/工具/Git","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://ff120.github.io/hexoblog/tags/git/"}]},{"title":"JetBrainsCLion的使用01-入门","slug":"技术/工具/编程IDE/JetBrainsCLion/JetBrainsCLion的使用01-入门","date":"2017-05-04T10:07:21.000Z","updated":"2019-03-28T00:54:55.605Z","comments":true,"path":"2017/05/04/技术/工具/编程IDE/JetBrainsCLion/JetBrainsCLion的使用01-入门/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/05/04/技术/工具/编程IDE/JetBrainsCLion/JetBrainsCLion的使用01-入门/","excerpt":"c++的IDE有很多，微软的Visual Studio, 跨平台的codeblocks, 全能的eclipse, 还有就是jetbrains的Clion。 这些我都用过，感觉用着最自然的，花费学习时间最少的就是Clion了，他的调试功能也是非常好用，变量的显示很直观。","text":"c++的IDE有很多，微软的Visual Studio, 跨平台的codeblocks, 全能的eclipse, 还有就是jetbrains的Clion。 这些我都用过，感觉用着最自然的，花费学习时间最少的就是Clion了，他的调试功能也是非常好用，变量的显示很直观。 安装CLion 这个软件不是免费的，但是破解方法已经出了，所以可以从官方网站上下载，适用30天，到期再破解就可以了。下载地址：https://www.jetbrains.com/clion/ 配置编译器 file-&gt;setting-&gt;Build,Execution,Deployment选择Toolchains,可以看到右侧支持两种C++编译器，MinGW和Cygwin, 如果你的电脑上已经安装了任何一种，直接指定该软件的根目录就可以了，软件会自动探测相应的编译器，在线面给出版本。 安装MinGW Windows平台下建议安装TDM-GCC,提供Windows下的安装包，安装完成之后直接就能使用，而且他提供了管理工具，以后安装和卸载相关的软件包也比较方便，安装的时候选择最简单的包含C++的编译器就可以。 安装完成后把安装的目录填在上面配置的位置就可以了。 安装cygwin 下载cygwin按照指示安装即可。 字体和外观的调整 jetbrains系列的软件都不支持使用Ctrl+鼠标滚轮的方式调整字体的大小，这点不太方便。默认的字体和背景可能不太舒服，调整字体和外观的选项都在file-&gt;setting-&gt;Editor中。 调试 调试非常方便，只要在左侧单击，出现红色的小圆点，代表断点，然后不要点RUN,而是点DEBUG，就进入了调试模式，程序会运行到断点处等待用户的操作。","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"工具","slug":"技术/工具","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/"},{"name":"编程IDE","slug":"技术/工具/编程IDE","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/编程IDE/"},{"name":"JetBrainsCLion","slug":"技术/工具/编程IDE/JetBrainsCLion","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/编程IDE/JetBrainsCLion/"}],"tags":[{"name":"cLion","slug":"cLion","permalink":"http://ff120.github.io/hexoblog/tags/cLion/"},{"name":"c++","slug":"c","permalink":"http://ff120.github.io/hexoblog/tags/c/"}]},{"title":"fMRI中常用的工具包","slug":"技术/认知神经科学/fMRI中常用的工具包","date":"2017-05-02T02:47:38.000Z","updated":"2019-03-28T00:54:59.457Z","comments":true,"path":"2017/05/02/技术/认知神经科学/fMRI中常用的工具包/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/05/02/技术/认知神经科学/fMRI中常用的工具包/","excerpt":"fMRI分析的各个阶段用到的工具包和画图工具。","text":"fMRI分析的各个阶段用到的工具包和画图工具。 实验设计 psychopy PsychoPy is an open-source application allowing you run a wide range of neuroscience, psychology and psychophysics experiments. It’s a free, powerful alternative to Presentation™ or e-Prime™, written in Python (a free alternative to Matlab™ ). PsychoPy is unique in giving you a choice of interface: use the Builder interface to build rich, flexible experiments easily or use the Coder interface to write extremely powerful experiments in the widely-used Python programming language. The best of both worlds! 一个用于刺激呈现的工具包，可以保住设计实验，处理图像和声音的呈现方式，有基于matlab的版本。 数据预处理和统计分析 SPM SPM 基于matlab的工具包，可以完成fMRI原始数据格式的转换，时间层校正，头动校正，配准，分割，平滑等预处理操作。可以进行个体水平和组水平的统计分析。可以做DCM。除此之外，还能提供一些图像之间运算的小工具，例如图像之间的加减乘除。 AFNI AFNI (Analysis of Functional NeuroImages) is a set of C programs for processing, analyzing, and displaying functional MRI (FMRI) data - a technique for mapping human brain activity. It runs on Unix+X11+Motif systems, including SGI, Solaris, Linux, and Mac OS X. It is available free (in C source code format, and some precompiled binaries) for research purposes. FSL FSL is a comprehensive library of analysis tools for FMRI, MRI and DTI brain imaging data. It runs on Apple and PCs (both Linux, and Windows via a Virtual Machine), and is very easy to install. Most of the tools can be run both from the command line and as GUIs (“point-and-click” graphical user interfaces) NeuroDebian 一个集成了大部分神经科学领域Linux系统下的工具的虚拟机镜像。里面包含的软件的列表可以参考：http://neuro.debian.net/pkgs.html DPABI a toolbox for Data Processing &amp; Analysis for Brain Imaging. 静息态脑网络的相关数据和工具：http://rfmri.org/。 NiBabel 提供读写神经影像数据格式的接口，基于python. ROI和Mask制作和查看 freeroi FreeROI is a versatile image processing software developed for neuroimaging data. Its goal is to provide a user-friendly interface for neuroimaging researchers to visualize and analyze their data, especially in defining region of interest (ROI) for ROI analysis. xjview 一个基于Matlab和SPM的用于查看激活的工具，可以Load不同的大脑地图从而实现显示激活的脑区的名称。还可以根据激活保存成Mask. WFU_PickAtlas 基于Matlab和SPM的ROI制作工具。支持导入不同的大脑地图制作各个脑区的Mask。也支持以某个MNI坐标为中心，制作球形，方形的mask. 功能连接 CONN 一个用来做静息态和任务态功能核磁成像数据的功能连接(functional connectivity)的工具包，包括去噪，first_level,second_level分析，支持region-to-region, seed-to-region, voxel-to-voxel等水平的功能连接分析，结果的展示也很漂亮。 ### REST 主要功能是用来做静息态数据的功能连接，也提供了图像计算的一些方法，可以用来计算图像乘以激活之后的Mask。还提供了可视化图像的界面，可以用来查看图像。 ### C-PAC The Configurable Pipeline for the Analysis of Connectomes (C-PAC) is a configurable, open-source, Nipype-based, automated processing pipeline for resting state functional MRI (R-fMRI) data, for use by both novice and expert users ### wiki上处理功能连接的工具包的列表 &lt;https://en.wikipedia.org/wiki/List_of_functional_connectivity_software &gt; MVPA MVPA The MVPA Toolbox is a set of Matlab tools to facilitate multi-voxel pattern analysis of fMRI neuroimaging data. The aim is to create a set of open source functions in a widely-used language to facilitate exploration of multi-voxel pattern analysis techniques and to reduce the ‘startup costs’ for knowledgeable users eager to apply pattern classification algorithms to their imaging data. By developing the toolbox in the Matlab environment, users are able to take advantage of the vast array of existing functions. The data structures used and generated by the toolbox are designed to facilitate exploration and further script development. pyMVPA PyMVPA is a Python package intended to ease statistical learning analyses of large datasets. It offers an extensible framework with a high-level interface to a broad range of algorithms for classification, regression, feature selection, data import and export. It is designed to integrate well with related software packages, such as scikit-learn, shogun, MDP, etc. While it is not limited to the neuroimaging domain, it is eminently suited for such datasets. PyMVPA is free software and requires nothing but free-software to run. pyMVPA windows 安装包的地址：http://www.lfd.uci.edu/~gohlke/pythonlibs/ CoSMoMVPA A multi-modal, multi-variate pattern analysis (MVPA) toolbox in Matlab / GNU Octave for cognitive neuroscientists. SignalChange marsbar marsbar是基于Matlab的一个计算SignalChange的工具。里面定义了一种.mat的ROI格式，可以和.nii的ROI格式之间进行转换。里面提供了将一个多标签Mask分割成多个单独的mask的方法，当然，反过来也可以实现。 group ICA 分析 gift 一个使用很广泛的用来做组水平的ICA的工具。 DCM TAPAS 大量平行DCM的计算。 绘图 Origin Origin是由OriginLab公司开发的一个科学绘图、数据分析软件，支持在Microsoft Windows下运行。Origin支持各种各样的2D/3D图形。Origin中的数据分析功能包括统计，信号处理，曲线拟合以及峰值分析。Origin中的曲线拟合是采用基于Levernberg-Marquardt算法（LMA）的非线性最小二乘法拟合。Origin强大的数据导入功能，支持多种格式的数据，包括ASCII , Excel, NI TDM, DIADem, NetCDF, SPC，等等。图形输出格式多样，例如JPEG，GIF，EPS，TIFF等。内置的查询工具可通过ADO访问数据库数据。 EXCEL 各种条形图，柱状图，扇形图都可以用EXCEL来画。 Matlab Matlab可以绘制各种2D，3D图形。很多基于Matlab的工具包画出的图形都是基于Matlab的画图功能。但是想用Matlab画出好看的图需要直接编写代码。 Matplotlib Matplotlib is a Python 2D plotting library which produces publication quality figures in a variety of hardcopy formats and interactive environments across platforms. Matplotlib can be used in Python scripts, the Python and IPython shell, the jupyter notebook, web application servers, and four graphical user interface toolkits. 以上几个都是通用的绘图工具，适用于绘制各种图形。在认知神经科学的绘图中，经常需要以大脑为背景绘制图像。下面介绍几个实现了在大脑皮层或者大脑的展开层绘制图像的工具。 BRAT Brainnetome fMRI toolkit (brat) refers to the construction and assessment of brain network used to evaluated brain network architecture about fMRI imaging data. These ideas have been instantiated in software that is called Brainnetome fRMI toolkit(brat). The brat package has been designed for the analysis of brain network based on spm (http://www.fil.ion.ucl.ac.uk/spm/). The images can from different cohorts, or time-series from the same subject. The current release is designed for the analysis of fMRI, EEG. It includes the proprecessing steps, functional connectivity analysis, network analysis and network view etc. 使用它可以很方便的绘制出类似下面这样的图： BrainNet Viewer BrainNet Viewer is a brain network visualization tool, which can help researchers to visualize structural and functional connectivity patterns from different levels in a quick, easy, and flexible way. 一个类似上面的那样可以绘制脑区位置和大脑功能连接的工具，比上面的工具好用，选项多一些，配置更方便。 pycortex 一个基于python的绘制大脑展开皮层的工具。绘制的图形类似下面这样： FreeSurfer 一个绘制皮层图像的工具，包含一些分析的方法。是由麻省总医院（Massachusetts General Hospital）的Bruce Fischl和同事开发的处理MRI解剖图像的软件包。虽然它实际上不是fMRI分析工具，但是因为它可以很容易地自动生成皮层表面模型和解剖分割图，因此近几年也越来越流行。这些模型可以用来进行基于皮层表面的被试间配准，这通常比常规的被试间的三维大脑配准更精确(见第4章)。它也可以导入FSL或者SPM处理过的统计结果，将它们投射在重建的皮层表面，这样可以进行基于皮层表面的组分析.产生的图像类似下面这样： caret 类似freesurfer，可以绘制类似下面的图形，可以看到，这个更好看一些。 circos 一个常用来可视化基因组的工具包，可以用来画各种环状图形。 BrainBrowser 一个大脑的浏览器，各种视角看大脑。 cbrain 一个基于浏览器的脑影像分析工具集合。 pysurfer PySurfer is a Python library for visualizing cortical surface representations of neuroimaging data. The package is primarily intended for use with Freesurfer, but it can plot data that are drawn from a variety of sources. PySurfer extends Mayavi’s powerful rendering engine with a high-level interface for working with MRI and MEG data. 纤维束绘制工具 http://www.med.unc.edu/psych/research/niral/download","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"认知神经科学","slug":"技术/认知神经科学","permalink":"http://ff120.github.io/hexoblog/categories/技术/认知神经科学/"}],"tags":[{"name":"fMRI","slug":"fMRI","permalink":"http://ff120.github.io/hexoblog/tags/fMRI/"},{"name":"toolboxhexo","slug":"toolboxhexo","permalink":"http://ff120.github.io/hexoblog/tags/toolboxhexo/"}]},{"title":"算法专题_一维数组","slug":"技术/数据结构和算法/算法专题_一维数组","date":"2017-05-02T02:08:54.000Z","updated":"2019-03-28T00:54:56.285Z","comments":true,"path":"2017/05/02/技术/数据结构和算法/算法专题_一维数组/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/05/02/技术/数据结构和算法/算法专题_一维数组/","excerpt":"算法题型中经常涉及到一个序列的问题，可能是一个整数数组，也可能是一个字符串。这类问题涵盖的面非常广,可以考察的知识点也非常多，但是总有一些处理的思想和技巧是不变的。这里，我把遇到的这类问题总结在一起，一遍能够从中发现规律，灵活掌握解题的技巧。","text":"算法题型中经常涉及到一个序列的问题，可能是一个整数数组，也可能是一个字符串。这类问题涵盖的面非常广,可以考察的知识点也非常多，但是总有一些处理的思想和技巧是不变的。这里，我把遇到的这类问题总结在一起，一遍能够从中发现规律，灵活掌握解题的技巧。 跳跃游戏 2017-03-21_103300.png 思路 如果采用遍历的方法，复杂度与数组的长度和数组元素的大小相关，数组中元素的大小会在很大程度上影响时间复杂度，例如数组元素都是1，代表每次都只能向后一步，那么结果就是n,如果数组的第一个元素就是n,那么一步就可以到达数组的结尾。所以这显然不是一个好的办法.考虑数组array的一个区间[0,i],截止到i位置的时候，能够到达的最远的位置是next.考虑如何求解next的值.初始的时候,next=0,i=0的时候，能够到达的最远位置是i+array[i],这个时候next=i+array[i].当i=1的时候，能够到达的最远位置可能是i+array[i],也可能是next,所以我们要取这两个元素的最大值作为next的值.这样只需要遍历一遍数组,我们就得到了每个元素可以达到的最远的位置.最后需要得到的结果是跳跃的次数,那么什么时候需要跳跃呢?设置一个变量current表示当前所在的位置,当current小于i的时候,说明我们已经遍历到了大于current的位置，这个时候就需要跳跃,jump++,然后更新current = next指向最新的位置. 具体实现如下。 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;/** * 跳跃游戏 * @param v * @return */int getMin(vector&lt;int&gt; v)&#123; if(v.empty()) return 0; int jump = 0; int current = 0; int next = 0; for(int i=0;i&lt;v.size();++i)&#123; if(current &lt; i)&#123; ++jump; current = next; // 判断数组中有小于等于0的时候的情况 if(v[current] &lt;= 0 &amp;&amp; current &lt; v.size()-1 &amp;&amp; current &lt; i)&#123; // 遇到0，跳不过去，返回-1 return -1; &#125; &#125; next = max(next,i+v[i]); &#125; return jump;&#125;int main() &#123; vector&lt;int&gt; v = &#123;3,2,3,1,1,4&#125;; int re = getMin(v); cout&lt;&lt;re&lt;&lt;endl; return 0;&#125; 子数组的最大累加和 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;/** * 子数组的最大累加和问题 * @return */int getMaxSum(vector&lt;int&gt; v)&#123; if(v.empty())&#123;return 0;&#125; int sum = 0; //遍历到v[i]的累加和 int maxValue = -10000; // 遍历到v[i]时最大的累加和 for(int i=0;i&lt;v.size();i++)&#123; sum += v[i]; if(sum &lt; 0)&#123; sum = 0; &#125; maxValue = max(maxValue,sum); &#125; return maxValue;&#125;int main() &#123; vector&lt;int&gt; v = &#123;1,-2,3,5,-2,6,-1&#125;; cout&lt;&lt;getMaxSum(v)&lt;&lt;endl; return 0;&#125; 子数组的最大累加和(动态规划) HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1). 本题使用简单的动态规划算法，时间复杂度O(N)即可达到题目的要求。 思路 首先想最一般的方法。对于一个n个元素的数组，它的所有的连续子数组有 \\(N=\\dfrac {n(n+1)} 2\\). 如果用暴力的方法，需要循环N次。每次循环的操作是求解一个区间内元素的和。每次都求和有点浪费时间，这个过程可以优化成预先求解出前k个数的和的数组存储在sum中，这样，假如某次循环我们要求解[i,j]区间的和，直接计算sum[j]-sum[i-1]即可。这样算下来，暴力求解的时间复杂度是O(N)+O(n)=O(N). 仔细考虑这个问题，其实可以拆解成一个小规模的问题和一个递推的规则。假设我们已经知道以第k个元素结尾的子数组的最大和是sumk,那么以第k+1个元素结尾的子数组的最大和就只有两种情况：只有第k+1个元素和sumk+array[k+1]. 只需要比较这两个数字的大小就可以确定第k+1个元素结尾的子数组的最大和了。需要注意的是，之所以能用这样的策略，是题目中限定了必须是连续的子数组，所以以k结尾的数组和以k+1结尾的数组是有关联的。下面是用该动态规划的方法解题的代码，时间复杂度是O(n). 1234567891011121314int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123; if(array.size() == 1) return array[0]; //用动态规划，可以在O(n)的时间内获得答案 //设dp[i]表示以i结尾的所有序列的最大的那个和 vector&lt;int&gt; dp(array.size(),0); // 以第一个元素结尾的所有序列只有array[0]一种，所以无论它是正数，负数，还是零，最大的结果都是array[0] dp[0] = array[0]; int maxSum = -1000000; for(int i=0;i&lt;array.size();i++)&#123; dp[i] = max(array[i],dp[i-1]+array[i]); maxSum = maxSum &lt; dp[i] ? dp[i] : maxSum; &#125; return maxSum;&#125; 滑动窗口子数组最大值 2017-03-21_090951.png 思路 首先容易想到的是暴力的方法,对于长度是n窗口宽度是w的题目来说，需要O(n-m+1)*O(m)的时间复杂度。仔细分析暴力的方法就会发现，窗口每次移动一个位置，有一个元素退出窗口，一个元素进来，如果这两个元素都不是最大值，那么遍历整个窗口内的元素寻找最大值的操作就不是必要的。所以，改进的方式是记录窗口的最大值和最小值。每次滑动窗口的时候，维护这个最大值和最小值即可。这样时间复杂度可以降低到O(n).窗口最大值和最小值的维护方案：维护一个宽度是w的滑动窗口的双端队列结构。始终在队列的尾部保存最大值的下标，始终在队尾保存最小值的下标。从头到位扫描数组，每扫描一个数，就按照相应的规则更新双端队列，把超出范围的下标出队，找到当前的最大值保存下来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;iostream&gt;#include &lt;deque&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; getMaxs(vector&lt;int&gt; v,int w)&#123; deque&lt;int&gt; q; vector&lt;int&gt; result; for(int i=0;i&lt;int(v.size());++i)&#123; if(v.empty())&#123; v.push_back(i); &#125; else if(v[i]&lt;=v[q.back()])&#123; v.push_back(i); &#125; else&#123; v.pop_back(); if(v.empty())&#123; v.push_back(i); &#125; else&#123; while(v[q.back()]&lt;=v[i])&#123; q.pop_back(); if(q.empty())&#123; q.push_back(i); break; &#125; &#125; q.push_back(i); &#125; &#125; if(i-w == q.front())&#123; q.pop_front(); &#125; if(i&gt;=w-1)&#123; result.insert(result.end(),v[q.front()]); &#125; &#125; return result;&#125;/** * 求滑动窗口做最大值,改进的分支逻辑，减少了if判断 * @param v * @param w * @return */vector&lt;int&gt; getMaxes2(vector&lt;int&gt; v, int w)&#123; vector&lt;int&gt; result; // store result deque&lt;int&gt; d; //store index of the array for(int i=0;i&lt;v.size();++i)&#123; if(!d.empty() &amp;&amp; v[d.back()]&lt;=v[i])&#123; while(v[d.back()&lt;=v[i]] &amp;&amp; !d.empty())&#123; d.pop_back(); &#125; d.push_back(i); &#125; else&#123; d.push_back(i); &#125; if(i-w == d.front())&#123; d.pop_front(); &#125; // 记录结果 if(i&gt;=w-1)&#123; result.insert(result.end(),v[d.front()]); &#125; &#125; return result;&#125;/** * 求滑动窗口最小值 * @param v * @param w * @return */vector&lt;int&gt; getMines(vector&lt;int&gt; v,int w)&#123; vector&lt;int&gt; result; deque&lt;int&gt; min; for(int i=0;i&lt;v.size();++i)&#123; if(!min.empty() &amp;&amp; v[min.back()]&gt;=v[i])&#123; while(!min.empty() &amp;&amp; v[min.back()]&gt;=v[i])&#123; min.pop_back(); &#125; min.push_back(i); &#125; else&#123; min.push_back(i); &#125; if(i-w ==min.front())&#123; min.pop_front(); &#125; //记录结果 if(i&gt;=w-1)&#123; result.insert(result.end(),v[min.front()]); &#125; &#125; return result;&#125;int main() &#123; std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl; return 0;&#125; 如果要求滑动窗口的最小值，只需要在判断大小的时候改变一下即可。 快速求数组连续子数组的最大值和最小值的差 2017-03-21_091927.png 思路 使用两个队列维护区间[i,j]的最大值和最小值。这样根据滑动窗口子数组最大值中提到的方法,我们可以高效的计算出区间内最大值和最小值。但是长度为n的数组子数组有N个，不能在O(n)的时间内解决。注意到这里其实有隐含的规律在，如果发现这个规律，可以避免很多不必要的计算，如果有区间[i,j]不满足条件max-min&lt;=somevalue，那么所有包含这个区间的子数组都不可能满足这个条件,因为更大的区间的最大值肯定大于等于max,最小值肯定小于等于min. 应用这个规则，就可以在O(n)的时间内解决问题了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;deque&gt;/** * 求一个数组的子数组最大值和最小值的差 * @return */int main() &#123; vector&lt;int&gt; v = &#123;6,5,4,3&#125;; int num=3; int count = 0; for(int i=0;i&lt;v.size();++i)&#123; int j = i; deque&lt;int&gt; max; deque&lt;int&gt; min; while(j&lt;v.size())&#123; // 维护max if(!max.empty() &amp;&amp; v[max.front()]&lt;=v[j])&#123; while(!max.empty() &amp;&amp; v[max.front()&lt;=v[j]])&#123; max.pop_back(); &#125; max.push_back(j); &#125; else&#123; max.push_back(j); &#125; //维护min if(!min.empty() &amp;&amp; v[min.front()]&gt;=v[j])&#123; while(!min.empty() &amp;&amp; v[min.front()&gt;=v[j]])&#123; min.pop_back(); &#125; min.push_back(j); &#125; else&#123; min.push_back(j); &#125; //判断当前数组是否满足条件，如果该数组不满足条件，那么所有包含该数组的将全部不满足条件 if(v[max.front()]-v[min.front()]&gt;num)&#123; count+=j-i; break; &#125; if(j==v.size()-1)&#123; count+=j-i+1; &#125; ++j; &#125;// while(!max.empty())&#123;// max.pop_back();// &#125;// while(!min.empty())&#123;// min.pop_back();// &#125; &#125; cout&lt;&lt;count&lt;&lt;endl; return 0;&#125; 最长递增子序列 2017-03-21_092428.png 思路 长度为n的数组的所有的子序列的个数是\\(2^n-1\\), 所以暴力的方法是不用考虑的，除非n特别小的情况下。考虑递增子序列的生成过程，只有新的数字比原来递增子序列的最后一个值大的时候，递增子序列才可以增长1，我们用dp[i]表示在以i结尾的时候，最长的递增子序列长度是leni,那么以i+1结尾的最长递增子序列就很容易求得：如果array[i+1]大于递增子序列的末尾元素，就+1，否则就是原来的leni. 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;/** * 最长递增子序列 * 给定数组arr,返回arr的最长递增子序列。 * e.g. arr = [2,1,5,3,6,4,8,9,7] 返回 1,3,4,8,9 或 2，3，4，8，9 * @param v * @return */vector&lt;int&gt; getIncrease(vector&lt;int&gt; v)&#123; vector&lt;int&gt; dp(v.size(),1);//dp的第一个元素为1，表示以第一个元素结果时，最长递增子序列的长度是1，只包括自己 for(int i=1;i&lt;v.size();++i)&#123; for(int j=i-1;j&gt;=0;--j)&#123; dp[i] = 1; if(v[j]&lt;v[i])&#123; dp[i] = max(dp[i],dp[j]+1); &#125; &#125; &#125; for(int i=0;i&lt;v.size();++i)&#123; cout&lt;&lt;dp[i]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl;&#125;int main() &#123; vector&lt;int&gt; v = &#123;2,1,5,3,6,4,8,9,7&#125;; getIncrease(v); cout&lt;&lt;endl; return 0;&#125; 排成一条线的纸牌博弈问题 2017-03-21_102624.png 时间复杂度O(N^2), 空间复杂度O(N^2) 生成两个大小N*N的矩阵 N1的dp[i][j]表示arr[i…j]这个排列上如果A先拿，最终能得到什么分数。 N2的dp[i][j]表示arr[i…j]这个排列上如果B后拿，最终能得到什么分数。 12 数组中的最长连续序列 2017-03-21_104858.png 思路 容易想到，先排序在遍历一遍，就可以知道最长的连续序列有多长，但是最快速的排序算法也要O(nlogn)的时间复杂度，显然不满足要求。所以，本题不可能是使用排序的方法解决。如果要在O(n)的时间内解决，必须遍历数组常数次。考虑遍历到每个数组元素的时候的操作,比如我们处理的某个数组元素是a，这个时候要判断的是a-1,a-2,…a+1,a+2,…是否在这个数组中，直到有不在数组中的时候，停止计数，这就是所有包含该数字的连续序列的最长的长度。然后处理下一个数字。假设能够在O(1)的时间内判断一个数字是否存在数组中(使用哈希表存储)，O(n)的时间内就能解决这个问题。具体实现参考下面的代码。 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;unordered_set&gt;#include &lt;vector&gt;using namespace std;/** * 数组中最长连续序列 * @param v * @return */int getMaxSeries(vector&lt;int&gt; v)&#123; unordered_set&lt;int&gt; hs; for(auto i : v)&#123; hs.insert(i); &#125; int sum = 0; for(int i=0;i&lt;v.size();i++)&#123; int count = 1; int left=v[i]-1; while(hs.erase(left))&#123; count++; left--; &#125; int right=v[i]+1; while(hs.erase(right))&#123; count++; right++; &#125; sum = max(sum,count); &#125; return sum;&#125; 计算数组的小和 2017-03-21_133320.png 思路 采用一个数组sum[i]记录数组array[i]对应的小和，当array[i+1]&gt;array[i]的时候，sum[i+1]=sum[i]+array[i],当array[i+1]&lt;array[i]的时候，需要回溯到第一个小于array[i+1]的位置，假设是j,sum[i+1]=sum[j]+array[j]. 使用这种方法，时间复杂度最坏不会超过O(n^2). 使用一种归并排序的思想，时间复杂度可以控制在O（N*logN）,但是不如上面的方法简单直接。 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int getMinSum(vector&lt;int&gt; v)&#123; vector&lt;int&gt; sum(v.size(),0); int minSum = 0; sum[0]=v[0]; minSum += sum[0]; for(int i=1;i&lt;v.size();i++)&#123; if(v[i]&gt;v[i-1])&#123; sum[i] = v[i-1]+sum[i-1]; &#125;else&#123; int j=i-1; while(v[j]&gt;v[i])&#123; j--; &#125; if(j&gt;=0)&#123; sum[i] = v[j] + sum[j]; &#125; &#125; minSum += sum[i]; &#125; return minSum;&#125; 在数组中找到一个局部最小的位置(二分法的应用) 2017-03-21_141706.png 最容易想到的解法：从头开始遍历数组，一旦遇到a[i-1]&gt;a[i] &amp;&amp; a[i]&lt;a[i+1]的位置,终止遍历,输出i. 最坏的情况下时间复杂度是O(N). 当一个问题在二分之后，可以明确的知道要求解的结果必定在某一侧时，就可以利用二分法来降低算法的时间复杂度.具体到这个问题,array[0]&lt;array[1]时,array[0]就是局部小,array[n-2]&gt;array[n-1],array[n-1]就是局部小. 我们讨论区间[1,n-2]的情况. 找到这个区间的中间元素mid=(left+right)/2,如果array[mid]&gt;array[mid-1]，那么局部极小值肯定在mid的左侧,领left=mid-1,继续二分查找.同理,如果array[mid]&gt;array[mid]+1,那么局部极小值一定出现在mid的右侧.为什么呢? 假设我们已经得到了一个左侧的区间[0,mid],其中0是数组的第一个元素，mid是中间元素，得到array[mid]&gt;array[mid-1],且有a[0]&gt;a[1].可知,两头元素大，中间元素小，局部最小值一定在这个区间,接下来继续使用二分法,直到找出这个元素即可。因为本体要求的是找出任意一个局部极小值，所以可以使用这样的方法来加快速度,如果是要找出所有的局部极小值，二分的方法就没有优势了。 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;/** * 找到任意一个局部最小的位置并返回索引 * 从左边开始，如果第二个数比第一个数小，第二个数是局部最小 * 从右边开始，如果第二个数比第一个数小，第二个数是局部最小 * 如果数组是空 ，没有局部最小 * 如果数组只有一个数，这个数就是局部最小 * else 局部最小就是两边挨着的数都比它大 * 这里规定这个数组任意相邻的数都不相等 * @param v * @return */int getMinPart(vector&lt;int&gt; v)&#123; if(v.empty()) return -1; if(v.size() == 1) return v[0]; if(v[0]&gt;v[1]) return 1; if(v[v.size()-1]&lt;v[v.size()-2]) return v.size()-2; for(int i=2;i&lt;=v.size()-2;++i)&#123; if(v[i-1]&gt;v[i] &amp;&amp; v[i] &lt; v[i+1])&#123; return i; &#125; &#125; return -1; // 如果没有局部最小值，返回-1&#125;int main() &#123; vector&lt;int&gt; v = &#123;1,2,1,4,3,5&#125;; cout&lt;&lt;getMinPart2(v)&lt;&lt;endl; return 0;&#125; 数组中子数组的最大累乘积 2017-03-21_150344.png 解法： 分别求以v[i]结尾的子数组的最大累成积，dp[i], dp[i]可以由dp[i-1]求出来，所以整体的时间复杂度是O（N） 因为最后的结果是求做大累乘积，而dp[i]只和dp[i-1]有关系，所以可以不用维护动态规划表， 空间复杂度可以降低到O（1） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;/** * 求数组的最大子数组累乘积 * 暴力的方法，就是枚举所有的子数组，计算子数组的累乘，然后取最大值 * @param v * @return */double getMaxC(vector&lt;double&gt; v)&#123; if(v.empty()) return 0; double maxC = -1000; double sum = 1; for(int i=0;i&lt;v.size();++i)&#123; sum = 1; for(int j=i;j&lt;v.size();++j)&#123; sum = sum * v[j]; maxC = max(maxC,sum); &#125; &#125; return maxC;&#125;/** * 暴力的方法需要的时间复杂度是2重循环，是O(N**2) * 下面用记录最大累乘和最小累乘值的方法做，时间复杂度是O(N) * 1. 所有的子数组必然以v[i]结尾，首先计算v[0]结尾的最大值和最小值，都是v[0] * 2. 以v[i]结尾的数组的最大值的情况有这样几种； * max*v[i] ; min*v[i], v[i] 分别对应 v[i]正，负 和dp[i-1]是0的情况 * @return */double getMaxC2(vector&lt;double&gt; v)&#123; if(v.empty()) return 0; double maxValue = v[0]; double minValue = v[0]; double dpi = v[0]; // 存放前一个的结果 double maxEnd = 0; double minEnd = 0; for(int i=1;i&lt;v.size();++i)&#123; maxEnd = maxValue * v[i]; minEnd = minValue * v[i]; maxValue = max(max(maxEnd,minEnd),v[i]); minValue = min(min(maxEnd,minEnd),v[i]); dpi = max(dpi,maxValue); &#125; return dpi;&#125;int main() &#123; vector&lt;double&gt; v=&#123;-2.5,4,0,3,0.5,-8,8,-1&#125;; cout&lt;&lt;getMaxC(v)&lt;&lt;endl; cout&lt;&lt;getMaxC2(v); return 0;&#125; 不包含本位置位的累乘数组 2017-03-21_161407.png 如果可以使用除法，那么问题很简单，先求累乘，再除以v[i]. (不包含0的情况) 如果数组中有一个0，则0位置上是累乘，其他位置是0 如果数组中有两个及以上的0， 则所有位置都是0； 如果不能使用除法运算，可以考虑除去自己的乘积，就是从左边乘到v[i-1] 再从右边乘到v[i+1]; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;/** * 不包含本位置位的累乘数组,可以使用除法 */vector&lt;int&gt; getC(vector&lt;int&gt; v)&#123; int sum = 1; for(auto i : v)&#123; sum *= i; &#125; for(int i = 0;i&lt;v.size();++i)&#123; v[i] = sum / v[i] ; &#125; return v;&#125;void printVecor(vector&lt;int&gt; v)&#123; for(auto i : v)&#123; cout&lt;&lt;i&lt;&lt;\" \"; &#125; cout&lt;&lt;endl;&#125;/** * 不使用除法的版本 * @param v * @return */vector&lt;int&gt; getC2(vector&lt;int&gt; v)&#123; vector&lt;int&gt; lr; vector&lt;int&gt; rl; int lrsum = 1; int rlsum = 1; for(int i=0;i&lt;v.size();i++)&#123; lrsum *= v[i]; lr.push_back(lrsum); rlsum *= v[v.size()-1-i]; rl.push_back(rlsum); &#125; vector&lt;int&gt; rl2; for(int i=v.size()-1;i&gt;=0;--i)&#123; rl2.push_back(rl[i]); &#125; v[0] = rl2[1]; v[v.size()-1] = lr[v.size()-2]; for(int i=1;i&lt;v.size()-1;++i)&#123; v[i] = lr[i-1] * rl2[i+1]; &#125; return v;&#125;/** * 减少空间复杂度的版本 * @param v * @return */vector&lt;int&gt; getC3(vector&lt;int&gt; v)&#123; if(v.empty()) return &#123;&#125;; vector&lt;int&gt; re(v); re[0] = v[0]; for(int i=1;i&lt;v.size()-1;++i)&#123; re[i] = re[i-1] * v[i]; &#125; int tmp =1; for(int i=v.size()-1;i&gt;0;--i)&#123; re[i] = re[i-1] * tmp ; tmp *= v[i]; &#125; re[0] = tmp; return re;&#125;int main() &#123; vector&lt;int&gt; v = &#123;2,3,1,4&#125;; auto result = getC(v); auto result2 = getC2(v); auto result3 = getC3(v); printVecor(result); printVecor(result2); printVecor(result3); return 0;&#125; 数组的partition调整 都用到了用下标指示不同的分区的思想。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void setV(vector&lt;int&gt; &amp;v)&#123; int u = 0; for(int i=1;i&lt;v.size();++i)&#123; if(v[i]&gt;v[u])&#123; swap(v[i],v[u+1]); u++; &#125; &#125;&#125;void sortV(vector&lt;int&gt; &amp;v)&#123; if(v.empty()) return; int left = -1; int index = 0; int right = v.size(); while(index &lt; right)&#123; if(v[index] == 0)&#123; swap(v[++left],v[index++]); &#125;else if(v[index] == 2)&#123; swap(v[index],v[--right]); &#125;else&#123; index++; &#125; &#125;&#125;void print(vector&lt;int&gt; v)&#123; for(auto a: v)&#123; cout&lt;&lt;a&lt;&lt;\" \"; &#125; cout&lt;&lt;endl;&#125;int main() &#123; vector&lt;int&gt; v = &#123;1,2,2,3,3,4,4,4,5,6,7&#125;; setV(v); print(v); vector&lt;int&gt; v2 = &#123;1,0,1,0,1,1,1,2,2,0,0&#125;; sortV(v2); print(v2); return 0;&#125; 数组中未出现的最小正整数 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;/** * 给定一个无序的整形数组，找到数组中未出现的最小正整数。 * @param v * @return */int missNum(vector&lt;int&gt; v)&#123; int l = 0; int r = v.size(); while(l&lt;r)&#123; if(v[l] == l+1)&#123; l++; &#125;else if(v[l] &lt;= l || v[l] &gt; r || v[v[l]-l] == v[l])&#123; v[l] = v[--r]; &#125;else&#123; swap(v[l],v[v[l]-l]); &#125; &#125; return l+1;&#125;int main() &#123; vector&lt;int&gt; v1 = &#123;-1,2,3,4&#125;; vector&lt;int&gt; v2 = &#123;1,2,3,4&#125;; cout&lt;&lt;missNum(v1)&lt;&lt;endl; cout&lt;&lt;missNum(v2)&lt;&lt;endl; return 0;&#125; 数组排序之后相邻数字的最大差值 2017-03-21_213346.png 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;limits&gt;using namespace std;// 计算数num应该放入哪个桶里面int bucket(long num,long len,long min,long max)&#123; return (int) ( (num-min)*len/(max-min) );&#125;int maxGap(vector&lt;int&gt; v)&#123; if(v.empty() || v.size() &lt; 2) return 0; int len = v.size(); int minValue = INT32_MAX; int maxValue = INT32_MIN; for(int i=0;i&lt;len;++i)&#123; minValue = min(minValue,v[i]); maxValue = max(maxValue,v[i]); &#125; if(minValue == maxValue) return 0; //如果数组的最大值==最小值，说明只有一种元素，那间隔为0 vector&lt;bool&gt; hasNum(len+1,0); vector&lt;int&gt; maxes(len+1,0); vector&lt;int&gt; mines(len+1,0); int bid = 0; for(int i=0;i&lt;len;++i)&#123; bid = bucket(v[i],len,minValue,maxValue); mines[bid] = hasNum[bid] ? min(mines[bid],v[i]) : v[i]; maxes[bid] = hasNum[bid] ? max(maxes[bid],v[i]) : v[i]; hasNum[bid] = true; &#125; int res = 0; int lastMax = 0; int i = 0; while(i&lt;=len)&#123; if(hasNum[i++])&#123; lastMax = maxes[i-1]; break; &#125; &#125; for(;i&lt;=len;i++)&#123; if(hasNum[i])&#123; res = max(res,mines[i]-lastMax); lastMax = maxes[i]; &#125; &#125; return res;&#125;void print(vector&lt;bool&gt; v)&#123; for(auto a:v)&#123; cout&lt;&lt;a&lt;&lt;\" \"; &#125; cout&lt;&lt;endl;&#125;int main() &#123; vector&lt;int&gt; v = &#123;9,3,1,10&#125;; cout&lt;&lt;maxGap(v)&lt;&lt;endl; return 0;&#125; 找到出现50%以上的数字 思路就是每次删除两个不同的数字，那么最后一定会剩下那个出现次数大于一半的数字。 1234567891011121314151617181920212223242526272829/* * 选出数组中出现次数大于一半的数 */int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int cand = -1; int count = 0; int len = nums.size(); for (int i = 0; i &lt; len; i++) &#123; if (count == 0) &#123; count = 1; cand = nums[i]; &#125; else if (nums[i] == cand) count++; else count--; &#125; int times = 0; for(int i=0;i&lt;len;i++)&#123; if(nums[i] == cand)&#123; times ++; &#125; &#125; if(times &gt; len /2)&#123;return cand;&#125; return 0; &#125; 找到出现次数在N/K次以上的数字 每次删除数组中K个不同的数字。 1234567891011121314151617181920212223242526272829/** * 每次删除数组中K个不同的数字，返回剩下的数字 * @return */vector&lt;int&gt; deleteK(vector&lt;int&gt; v,int k)&#123; vector&lt;int&gt; result; map&lt;int,int&gt; record; // key : cands value: times for(int i=0;i&lt;v.size();++i)&#123; if(record.find(v[i]) != record.end())&#123; record[v[i]] ++; &#125; else if(record.size() == k-1)&#123; //所有候选减1，并把是0的删除 for(auto aa : record)&#123; aa.second--; if(aa.second == 0)&#123; record.erase(aa.first); &#125; &#125; &#125; else&#123; record[v[i]] = 1; &#125; &#125; for(auto ss : record)&#123; cout&lt;&lt;ss.first&lt;&lt;\" \"&lt;&lt;ss.second&lt;&lt;endl; &#125; return result;&#125; 求直方图的最大连续面积 题目：给定一个正整数数组arr,把每个数字看作直方图的高，宽度都是1，返回连续的最大面积。 例如，arr = [2,3,4,2,7,8,4] 返回 17 ，7和8组成的面积是14，最大。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;using namespace std;/** * 直方图求面积的题 * @return */int main() &#123; vector&lt;int&gt; v=&#123;3,4,5,4,3,6&#125;; stack&lt;int&gt; s; vector&lt;int&gt; result; for(int i=0;i&lt;v.size();++i)&#123; if(s.empty()||v[s.top()]&lt;v[i])&#123; s.push(i); &#125; else&#123; while( !s.empty() &amp;&amp;v[s.top()]&gt;=v[i])&#123; int j = s.top(); s.pop(); int k = s.empty()?-1:s.top(); int area = (i-k-1)*v[j]; result.insert(result.end(),area); &#125; s.push(i); &#125; &#125; for(auto i:result)&#123; cout&lt;&lt;i&lt;&lt;endl; &#125; auto a=max(result.begin(),result.end()); return 0;&#125;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;/**Largest Rectangle in Histogram*/using namespace std;class Solution&#123;public: int largestRetangleArea(vector&lt;int&gt; &amp;height)&#123; stack&lt;int&gt; s; height.push_back(0); int result = 0; for(int i=0;i&lt;height.size();)&#123; if(s.empty() || height[i]&gt;height[s.top()])&#123; s.push(i++); &#125; else&#123; int tmp = s.top(); s.pop(); result = max(result,height[tmp]*(s.empty()?i:1 -s.top()-1)); &#125; &#125; return result; &#125;&#125;;int main()&#123; vector&lt;int&gt; a = &#123;1,2,3,4,5,6&#125;; Solution s; cout&lt;&lt;s.largestRetangleArea(a)&lt;&lt;endl; return 0;&#125;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;/**Largest Rectangle in Histogram*/using namespace std;class Solution&#123;public: int largestRetangleArea(vector&lt;int&gt; &amp;height)&#123; stack&lt;int&gt; s; height.push_back(0); int result = 0; for(int i=0;i&lt;height.size();)&#123; if(s.empty() || height[i]&gt;height[s.top()])&#123; s.push(i++); &#125; else&#123; int tmp = s.top(); s.pop(); result = max(result,height[tmp]*(s.empty()?i:1 -s.top()-1)); &#125; &#125; return result; &#125;&#125;;int main()&#123; vector&lt;int&gt; a = &#123;1,2,3,4,5,6&#125;; Solution s; cout&lt;&lt;s.largestRetangleArea(a)&lt;&lt;endl; return 0;&#125; 换钱的最少货币数量 原问题和补充问题都可以用动态规划做。 原问题的dp[i][j]表示 在可以任意使用arr[0…i]货币的情况下，做成面值j需要 的最小货币数量 补充问题的dp[i][j]表示，在可以任意使用arr[0…i]的情况下，组成面值j所需要的 最小张数，注意这里的每个数字仅代表一张，不能重复使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;/** *给定数组arr, 整数aim arr中的整数不重复，每个数字代表一种面值的货币，求组成aim的最少张数 * e.g. arr=[5,2,3] aim = 20 输出 4 * arr=[3,5] aim=2 找不开的情况输出-1 * @param v * @param aim * @return */ int getMin(vector&lt;int&gt; v, int aim)&#123; vector&lt;vector&lt;int&gt; &gt; dp(v.size(),vector&lt;int&gt;(aim+1)); //初始化第一列 for(int i=0;i&lt;v.size();++i)&#123; dp[i][0] = 0; &#125; //初始化第一行,不能找开的情况设置为1000,只要这个数是整数并且足够大就可以。 for(int j=1;j&lt;=aim;++j)&#123; dp[0][j] = j%v[0]==0 ? j / v[0] : 1000; &#125; for(int i=1;i&lt;v.size();++i)&#123; for(int j=1;j&lt;=aim;++j)&#123; if(dp[i][j-v[i]]&lt;0 &amp;&amp; dp[i-1][j])&#123; dp[i][j] = 1000; &#125; else if(dp[i][j-v[i]]&lt;0) &#123; dp[i][j] = dp[i - 1][j]; &#125; else&#123; dp[i][j] = min(dp[i - 1][j], dp[i][j - v[i]] + 1); &#125; &#125; &#125; //输出动态规划表格 for(int i=0;i&lt;dp.size();++i)&#123; for(int j=0;j&lt;dp[0].size();++j)&#123; cout&lt;&lt;dp[i][j]&lt;&lt;\"\\t\"; &#125; cout&lt;&lt;endl; &#125; return dp[v.size()-1][aim];&#125;int main() &#123; vector&lt;int&gt; v = &#123;5,2,3&#125;; int aim = 8; std::cout &lt;&lt;getMin(v,aim)&lt;&lt; std::endl; return 0;&#125;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;/** * 给定整数数组arr 和 整数aim arr中的数字可以重复，每个数字代表一张相应面额的货币， * 求组成aim的最少张数 * e.g. arr=[5,2,3] aim=20 无法组成 * arr = [5,2,5,3] aim = 10 输出2 * arr = [5,2,5,3] aim = 0 输出0 * @param v * @param aim * @return */int getMin(vector&lt;int&gt; v,int aim)&#123; vector&lt;vector&lt;int&gt; &gt; dp(v.size(),vector&lt;int&gt;(aim+1)); //初始化第一列 for(int i=0;i&lt;v.size();++i)&#123; dp[i][0] = 0; //组成0需要任何货币0张就够了 &#125; //初始化第一行 for(int j=1;j&lt;=aim;++j)&#123; // 除了能组成和v[0]一样面值的货币，其他的都无法组成，因为v[0]只有一张 dp[0][j] = j == v[0] ? 1 : 10000; &#125; for(int i=1;i&lt;v.size();++i)&#123; for(int j=1;j&lt;=aim;++j)&#123; if(dp[i-1][j-v[i]]&lt;0)&#123; dp[i][j] = dp[i-1][j]; &#125; else&#123; dp[i][j] = min(dp[i-1][j],dp[i-1][j-v[i]]+1); &#125; &#125; &#125; // 打印动态规划表格 for(int i=0;i&lt;dp.size();++i)&#123; for(int j=0;j&lt;dp[0].size();++j)&#123; cout&lt;&lt;dp[i][j]&lt;&lt;\"\\t\"; &#125; cout&lt;&lt;endl; &#125; return dp[v.size()-1][aim];&#125;int main() &#123; vector&lt;int&gt; v = &#123;5,2,5,3&#125;; int aim = 7; std::cout &lt;&lt; getMin(v,aim)&lt;&lt; std::endl; return 0;&#125; 换钱的方法数 使用动态规划的方法，dp[i][j]表示在使用arr[0…i]货币的情况下，组成j有多少中情况。 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int getNum(vector&lt;int&gt; v,int aim)&#123; vector&lt;vector&lt;int&gt; &gt; dp(v.size(),vector&lt;int&gt;(aim+1)); //初始化第一列 for(int i=0;i&lt;v.size();++i)&#123; dp[i][0] = 1; &#125; //初始化第一行 for(int j=1;j&lt;=aim;j++)&#123; dp[0][j] = j%v[0]==0 ? 1 : 0; &#125; for(int i=1;i&lt;v.size();++i)&#123; for(int j=1;j&lt;=aim;++j)&#123; dp[i][j] = j-v[i]&gt;=0 ? dp[i-1][j]+dp[i][j-v[i]] : dp[i-1][j]; &#125; &#125; //打印动态规划表格 for(int i=0;i&lt;dp.size();++i)&#123; for(int j=0;j&lt;dp[0].size();++j)&#123; cout&lt;&lt;dp[i][j]&lt;&lt;\"\\t\"; &#125; cout&lt;&lt;endl; &#125; return dp[v.size()-1][aim];&#125;int main() &#123; vector&lt;int&gt; v = &#123;5,2,3,7&#125;; int aim = 7; std::cout &lt;&lt; getNum(v,aim) &lt;&lt; std::endl; return 0;&#125; 判断字符数组中是否所有的字符都只出现一次 2017-03-22_111143.png 使用哈希表统计字符个数即可 第二个要求，使用非递归的方式实现堆排序，然后统计相邻的字符是否重复就可以了。 数组中两个字符串的最小距离 找到最长回文子串 统计数组中每个数字前面比自己小的数字有多少个 保证都是正整数，没有重复的数字，例如输入 [2,7,4,6,5,3,1] 输出：[0,1,1,2,2,1,0] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Node&#123;public: Node(int _start, int _end) : start(_start), end(_end), left(nullptr), right(nullptr), cnt(0) &#123;&#125; int start, end; Node *left, *right; int cnt;&#125;;class Solution &#123;public: /** * @param A: An integer array * @return: Count the number of element before this element 'ai' is * smaller than it and return count number array */ vector&lt;int&gt; countOfSmallerNumberII(vector&lt;int&gt; &amp;A) &#123; // write your code here Node *root = build(0, 20000); vector&lt;int&gt; res; for (int i = 0; i &lt; A.size(); i++) &#123; int cnt = query(root, 0, A[i] - 1); res.push_back(cnt); // 更新计数下标是i的计数 modify(root, A[i]); &#125; return res; &#125;private: Node *build(int start, int end) &#123; if (start &gt; end) &#123; return NULL; &#125; if (start == end) &#123; return new Node(start, end); &#125; int mid = start + ((end - start) &gt;&gt; 1); Node *root = new Node(start, end); root-&gt;left = build(start, mid); root-&gt;right = build(mid + 1, end); return root; &#125; void modify(Node *root, int idx)&#123; if (root == NULL) &#123; return; &#125; if (root-&gt;start == root-&gt;end &amp;&amp; root-&gt;start == idx) &#123; ++(root-&gt;cnt); return; &#125; int mid = root-&gt;start + ((root-&gt;end - root-&gt;start) &gt;&gt; 1); if (mid &gt;= idx) &#123; modify(root-&gt;left, idx); &#125; else &#123; modify(root-&gt;right, idx); &#125; root-&gt;cnt = root-&gt;left-&gt;cnt + (root-&gt;right ? root-&gt;right-&gt;cnt : 0); &#125; int query(Node *root, int start, int end) &#123; if (root-&gt;end &lt; start || root-&gt;start &gt; end) &#123; return 0; &#125; if (root-&gt;start &gt;= start &amp;&amp; root-&gt;end &lt;= end) &#123; return root-&gt;cnt; &#125; int mid = root-&gt;start + ((root-&gt;end - root-&gt;start) &gt;&gt; 1); if (mid &gt;= end) &#123; return query(root-&gt;left, start, end); &#125; if (mid &lt; start) &#123; return query(root-&gt;right, start, end); &#125; int leftRes = query(root-&gt;left, start, mid); int rightRes = query(root-&gt;right, mid + 1, end); return leftRes + rightRes; &#125;&#125;;int main() &#123; vector&lt;int&gt; v = &#123;2,7,4,6,5,3,1&#125;; Solution s; auto re = s.countOfSmallerNumberII(v); return 0;&#125; 统计数组中每个数字后面比自己小的数字有多少个 保证都是正整数，没有重复的数字，例如输入 [2,7,4,6,5,3,1] 输出：[1,5,2,3,2,1,0] 这个可以调用上面的函数实现 12345678910111213vector&lt;int&gt; countOfSmallerNumberBack(vector&lt;int&gt; &amp;A)&#123; vector&lt;int&gt; tmp(A); int len = A.size(); for(int i=0;i&lt;len;i++)&#123; tmp[i] = A[len-1-i]; &#125; vector&lt;int&gt; re = countOfSmallerNumberII(tmp); vector&lt;int&gt; result(re); for(int i=0;i&lt;len;i++)&#123; result[i] = re[len-1-i]; &#125; return result; &#125; 一个有重复数字的整数数组，求包含所有的数字的最短的连续序列的长度 123456789101112131415161718192021222324252627282930int getMinUnique(vector&lt;int&gt; v)&#123; int len = v.size(); //统计独立的数字的个数 set&lt;int&gt; se; for(int i=0;i&lt;v.size();i++)&#123; se.insert(v[i]); &#125; int ulen = se.size(); int s = 0; int t = 0; int num = 0; map&lt;int,int&gt; count; int res = len; // 存放结果，最坏的情况下是数组的长度，结果肯定不会大于这个值 for(;;)&#123; while(t&lt;len &amp;&amp; num &lt;ulen)&#123; if(count[v[t++]]++ == 0)&#123; num ++; &#125; &#125; if(num &lt; ulen) break; res = min(res,t-s); if(--count[v[s++]] == 0)&#123; num--; &#125; &#125; return res;&#125; 连续整数和 每一个正整数 N 都能表示成若干个连续正整数的和，例如10可以表示成1+2+3+4，15可以表示成4+5+6，8可以表示成8本身。我们称这种表示方法为SCI(Sum of Consecutive Integers)表示法。 小Hi发现一个整数可能有很多种SCI表示，例如15可以表示成1+2+3+4+5，4+5+6，7+8以及15本身。小Hi想知道N的所有SCI表示中，最多能包含多少个连续正整数。例如1+2+3+4+5是15包含正整数最多的表示。 hihocoder 1453 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;/** * 返回整数n的所有SCI表示法 * 就是连续整数和等于n * * 思路是利用等差数列的求和公式 * @param n * @return */int SCI(int num)&#123; double maxn = sqrt(2*num); int max_n = (int)(maxn + 1); // i个连续的数字的和是num,求首元素 for(int i = max_n; i&gt;=2; --i)&#123; if(2*num % i == 0)&#123; int a02 = 2*num / i + 1 - i; if(a02 &lt; 2) continue; if(a02 % 2 == 0)&#123; int a0 = a02 / 2; return i; &#125; &#125; &#125; return 1;&#125;int main()&#123; int T,num; cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; num; int re = SCI(num); cout&lt;&lt;re&lt;&lt;endl; &#125; return 0;&#125; 集合的子集问题 给定一个包含N个整数的集合S={A1, A2, … AN}，以及一个给定的整数K，请计算有多少个S的子集满足其中的最大值与最小值的和小于等于K。 例如对于S={4, 2, 5, 8}以及K=7,满足的条件的子集有以下4个:{2}, {2, 4}, {2, 5}, {2, 4, 5}。 hihocoder 1546 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;long long Montgomery(long long a,long long b,long long m)&#123; if(b == 0) return 1; if(b &lt; 0) return -1; long long r=1; a %=m; while(b&gt;1) &#123; if((b&amp;1)!=0) r = (r*a)%m; a = (a*a)%m; b/=2; &#125; return (r*a)%m;&#125;long long min_max(vector&lt;int&gt; &amp;v,int k)&#123; if(v.empty()) return 0; sort(v.begin(),v.end()); int l = 0, r = v.size() - 1, m = 1000000007; long long res = 0; while(l &lt;= r)&#123; if(v[l] + v[r] &lt;= k)&#123; long long sum = Montgomery(2,(r-l),m); res = (res + sum ) % m; l++; &#125;else&#123; r--; &#125; &#125; return res;&#125;int main()&#123; int n,k; cin &gt;&gt; n&gt;&gt; k; vector&lt;int&gt; v(n,0); for (int i = 0; i &lt; n; ++i) &#123; cin&gt;&gt;v[i]; &#125; auto re = min_max(v,k); cout&lt;&lt;re&lt;&lt;endl; return 0;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"深度学习_使用autoencoder自动提取特征","slug":"技术/机器学习/深度学习/深度学习_使用autoencoder自动提取特征","date":"2017-04-27T11:19:11.000Z","updated":"2019-03-28T00:54:58.345Z","comments":true,"path":"2017/04/27/技术/机器学习/深度学习/深度学习_使用autoencoder自动提取特征/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/04/27/技术/机器学习/深度学习/深度学习_使用autoencoder自动提取特征/","excerpt":"autoencoder自动提取特征的原理是使用输入数据作为输出标签训练数据，中间层的神经元的数目小于特征数目，使用中间层的神经元的输出作为特征，这样就达成一个特征空间变换和降维的目的。本质上它是通过一种非线性的变换函数在转换特征空间。","text":"autoencoder自动提取特征的原理是使用输入数据作为输出标签训练数据，中间层的神经元的数目小于特征数目，使用中间层的神经元的输出作为特征，这样就达成一个特征空间变换和降维的目的。本质上它是通过一种非线性的变换函数在转换特征空间。 实现一个最简单的自动特征提取器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# 准备数据X_root = r'd:/X.npy'X = np.load(X_root)root = r'D:\\FMRI_ROOT\\YIYU\\CONN\\conn_project04\\meresult'#####################y_path = r'y.npy'# 加载数据转成python格式data_root = os.path.join(root,'data')y = np.load(os.path.join(data_root,y_path))from sklearn import cross_validationtest_size = 0.3X_train, X_test, y_train, y_test = cross_validation.train_test_split(X,y,test_size=test_size, random_state=0)print(X_train.shape, y_train.shape)print(X_test.shape, y_test.shape)############################################################################################################################################################### 定义神经网络的结构encoding_dim = 10# this is our input placeholderinput_img = Input(shape=(4298,))encoded = Dense(1000, activation='relu')(input_img)encoded = Dense(100, activation='relu')(encoded)encoded = Dense(encoding_dim, activation='relu')(encoded)decoded = Dense(100, activation='relu')(encoded)decoded = Dense(1000, activation='relu')(decoded)decoded = Dense(4298, activation='sigmoid')(decoded)autoencoder = Model(input_img, decoded)encoder = Model(input_img, encoded)encoded_input = Input(shape=(encoding_dim,))decoder_layer1 = autoencoder.layers[-3](encoded_input)decoder_layer2 = autoencoder.layers[-2](decoder_layer1)decoder_layer3 = autoencoder.layers[-1](decoder_layer2)decoder = Model(encoded_input, decoder_layer3)autoencoder.compile(optimizer='adadelta', loss='binary_crossentropy')autoencoder.fit(X_train, X_train, epochs=100, batch_size=256, shuffle=True, validation_data=(X_test, X_test))save_model(autoencoder,'autoencoder')save_model(encoder,'encoder')save_model(decoder,'decoder')## 加载保存的模型autoencoder = load_model(\"autoencoder\")encoder = load_model(\"encoder\")decoder = load_model(\"decoder\")## 使用训练好的模型encoded_imgs = encoder.predict(X_test)decoded_imgs = decoder.predict(encoded_imgs)## 使用分类器分类from sklearn.svm import SVCsvc_linear = SVC(C=1,kernel=\"linear\")from sklearn.cross_validation import KFoldcv = KFold(y_test.shape[0], n_folds=10)score_linear_svc = []for train,test in cv: # ---------------------------------------------------------- svc_linear.fit(encoded_imgs[train],y_test[train]) score_linear_svc.append( svc_linear.score(encoded_imgs[test],y_test[test]) )print(np.mean(score_linear_svc))","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"},{"name":"深度学习","slug":"技术/机器学习/深度学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/深度学习/"}],"tags":[{"name":"autoencoder","slug":"autoencoder","permalink":"http://ff120.github.io/hexoblog/tags/autoencoder/"},{"name":"fmri","slug":"fmri","permalink":"http://ff120.github.io/hexoblog/tags/fmri/"}]},{"title":"深度学习_卷积神经网络","slug":"技术/机器学习/深度学习/深度学习_卷积神经网络","date":"2017-04-20T11:08:23.000Z","updated":"2019-03-28T00:54:58.424Z","comments":true,"path":"2017/04/20/技术/机器学习/深度学习/深度学习_卷积神经网络/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/04/20/技术/机器学习/深度学习/深度学习_卷积神经网络/","excerpt":"卷积神经网络不同于前面介绍的反向传播算法中介绍的神经网络，那样的神经网络是全连接的，层与层之间每两个节点之间都有连接。这样的网络层数多了之后，参数就会指数级增长，变得难以训练。 卷积神经网络是以一定的规则规定了层与层之间的连接，只有满足特定要求的连接才存在，不满足的不存在。卷积神经网络比较擅长处理输入是图像的数据。","text":"卷积神经网络不同于前面介绍的反向传播算法中介绍的神经网络，那样的神经网络是全连接的，层与层之间每两个节点之间都有连接。这样的网络层数多了之后，参数就会指数级增长，变得难以训练。 卷积神经网络是以一定的规则规定了层与层之间的连接，只有满足特定要求的连接才存在，不满足的不存在。卷积神经网络比较擅长处理输入是图像的数据。 卷积 参考内容：https://arxiv.org/pdf/1603.07285.pdf 卷积网络中的概念： http://www.datakit.cn/blog/2016/03/23/bp_cnn.html 简单卷积的计算： 卷积核： 计算过程： 上面示例的卷积叫做2-D convolution,通过这个例子，我们也可以很容易明白3-D convolution甚至N-D convolution的含义。 下面介绍几个符号的含义： input feature map : 上图中亮蓝色所示的数据。 output feature maps : 上图中输出的3*3的矩阵 \\(n\\) : number of output feature maps; \\(m\\) : number of input feature maps; \\(k_j\\) : kernel size along axis j: \\(i_j\\) : input size along axis j, \\(s_j\\) : stride (distance between two consecutive positions of the kernel) along axis j, \\(p_j\\) : zero padding (number of zeros concatenated at the beginning and at the end of an axis) along axis j. 下面看一个具体的例子： \\(N = 2, i_1 = i_2 = 5, k_1 = k_2 = 3, s_1 = s_2 = 2, p_1 = p_2 = 1\\) 解析上面参数的含义： \\(i_1 = i_2 = 5\\) ： 说明input feature maps是一个5*5的矩阵。 \\(k_1 = k_2 = 3\\) : 说明kernel是一个3*3的矩阵 \\(s_1 = s_2 = 2\\) : 说明在水平方向和在竖直方向上，kernel每次移动2个单元的距离。 \\(p_1 = p_2 = 1\\) : 说明在水平方向和竖直方向上各有一个单位的padding. \\(N = 2\\) : 说明有2个output feature maps 具体的实例和计算的过程可以看下图： pooling 除了卷积之外，cnn还有一个核心的概念，子抽样(subsampling)，一般用pooling来表示。pooling的种类有很多种，主要是用一个特征来表达一个局部特征，这样使得参数大为减少。常见的有max pooling和mean pooling，L2 pooling。max pooling就是用局部特征的最大值来表达这个区域的特征。 各种类型的卷积的计算 一维卷积 1234567891011121314151617import numpy as np# 计算1D卷积# a array_like, (m,)# b array_like, (n,)# stride 步长def conv1D(a,b,stride=1): klen = kernel_a.shape[0] result=[] for i in range(0,a.shape[0]-klen+1,stride): result.append(sum(a[i:(i+klen)]*kernel_a)) return resulta = np.array([0,1,2,-1,1,-3,0])b = np.array([1,0,-1])resultl = conv1D(a,b,stride=1)resultr = conv1D(a,b,stride=2) 二维卷积 一个最简单的例子： 步长是2的一个例子： 三维卷积","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"},{"name":"深度学习","slug":"技术/机器学习/深度学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/深度学习/"}],"tags":[{"name":"CNN","slug":"CNN","permalink":"http://ff120.github.io/hexoblog/tags/CNN/"}]},{"title":"深度学习_使用keras实现autoencoder","slug":"技术/机器学习/深度学习/深度学习_使用keras实现autoencoder","date":"2017-04-20T08:31:16.000Z","updated":"2019-03-28T00:54:58.370Z","comments":true,"path":"2017/04/20/技术/机器学习/深度学习/深度学习_使用keras实现autoencoder/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/04/20/技术/机器学习/深度学习/深度学习_使用keras实现autoencoder/","excerpt":"autoencoder是利用神经网络来自动提取有意义的特征的一种方法，它的基本思想是这样的： 输入和输出层拥有一样的神经元的数目，都等于数据的输入维数。中间拥有若干个隐含层，隐含层的神经元的数目要小于输入维数。使用输入作为输出训练整个神经网络，最后会得到一个\\(f(x)=x\\)的等式。观察训练好的神经网络，最后的输出是经过比输入的数据的维数更少的数据得到的，所以，中间隐含层的数据表示就是原来输入数据的某种抽象，因为压缩了数据的维数，所以是一种降维的方法。当然，也可以使输入输出的维数远远小于中间隐含层的维数，这样会得到低维数据的高维表示。","text":"autoencoder是利用神经网络来自动提取有意义的特征的一种方法，它的基本思想是这样的： 输入和输出层拥有一样的神经元的数目，都等于数据的输入维数。中间拥有若干个隐含层，隐含层的神经元的数目要小于输入维数。使用输入作为输出训练整个神经网络，最后会得到一个\\(f(x)=x\\)的等式。观察训练好的神经网络，最后的输出是经过比输入的数据的维数更少的数据得到的，所以，中间隐含层的数据表示就是原来输入数据的某种抽象，因为压缩了数据的维数，所以是一种降维的方法。当然，也可以使输入输出的维数远远小于中间隐含层的维数，这样会得到低维数据的高维表示。 参考资料：https://blog.keras.io/building-autoencoders-in-keras.html keras是一个抽象层次较高的深度学习框架，它以theano和tensorflow作为后端实现，使用她可以很方便的实现多种不同的autoencoder. ## 最简单的单层编码解码机 我们使用手写数字识别的数据构造一个简单的自动编码机。目的是给数据降维。我们构造一个三层的神经网络，输入层包含28*28 = 784 个神经元，中间的隐含层包含4*4 = 16 个神经元,输出层包含28*28 = 784 个神经元。然后把手写数字识别的数据去掉标签，后者说是把标签设置为自己的输入，然后训练该神经网络，就会得到一个把28*28的灰度图像映射到4*4的灰度图像的映射，通过后面两层神经网络，我们可以根据4*4的数据恢复原来的28*28的图像，如果恢复的图像的质量还不错，就能够说明神经网络自动学习到的压缩方法确实是很不错的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118from keras.datasets import mnistfrom keras.layers import Input, Densefrom keras.models import Modelimport numpy as npimport pickleimport osfrom keras import regularizersdef save_model(model,name): ## fit完成之后，保存整个模型的配置 root_path = r'd:\\deeplearning' model_config = model.get_config() model_weight = model.get_weights() config_save_path = os.path.join(root_path,name+\"_config.txt\") weight_save_path = os.path.join(root_path,name+\"_weights.txt\") pickle.dump(model_config, open(config_save_path, 'wb')) pickle.dump(model_weight, open(weight_save_path, 'wb'))def load_model(name): root_path = r'd:\\deeplearning' config_save_path = os.path.join(root_path,name+\"_config.txt\") weight_save_path = os.path.join(root_path,name+\"_weights.txt\") model_config = pickle.load(open(config_save_path, 'rb')) model_weight = pickle.load(open(weight_save_path, 'rb')) model = Model.from_config(model_config) model.set_weights(model_weight) return model## 加载数据(x_train, _), (x_test, _) = mnist.load_data()# 把数据缩放到 0 -- 1x_train = x_train.astype('float32') / 255.x_test = x_test.astype('float32') / 255.x_train = x_train.reshape((len(x_train), np.prod(x_train.shape[1:])))x_test = x_test.reshape((len(x_test), np.prod(x_test.shape[1:])))print(x_train.shape)print(x_test.shape)############################################################################################################################################################### this is the size of our encoded representations# 将784维的数据压缩到32维encoding_dim = 16 # 32 floats -&gt; compression of factor 24.5, assuming the input is 784 floats# this is our input placeholderinput_img = Input(shape=(784,))# \"encoded\" is the encoded representation of the input# 新建了一个32个网络节点，激活函数使用relu的层，注意在此层前面应该是输入层，拥有784个神经元的节点。#encoded = Dense(encoding_dim, activation='relu')(input_img)# 在压缩层添加稀疏的限制。在没有任何限制，只用节点的数目限制的时候，结果和PCA的结果十分类似# 但是当加入稀疏优化之后，就不一样了encoded = Dense(encoding_dim, activation='relu',activity_regularizer=regularizers.l1(10e-5))(input_img)# \"decoded\" is the lossy reconstruction of the input# 在encoded的后面，新建了一个拥有784个节点的神经网络层，作为解码层。decoded = Dense(784, activation='sigmoid')(encoded)# this model maps an input to its reconstructionautoencoder = Model(input_img, decoded)# 现在autoencoder是这样的一个神经网络，输入包含784个节点，紧接着是32个节点的第一个隐含层，然后是784个节点的输出层。encoder = Model(input_img, encoded)# encoder 以784个节点作为输入层，以32个节点作为输出层，没有中间的隐含层，这就是一个最简单的感知机的模型。# create a placeholder for an encoded (32-dimensional) inputencoded_input = Input(shape=(encoding_dim,))# retrieve the last layer of the autoencoder model# 找到上面创建的神经网络的最后一层，也就是输出层。decoder_layer = autoencoder.layers[-1]# create the decoder modeldecoder = Model(encoded_input, decoder_layer(encoded_input))# 现在decoder 是以32个维度输入，以784个维度输出的简单的神经网络，需要注意的是，encoder和decorder都是上面定义的autoencoder神经网络的# 的一部分，只是用了新的变量名称把其中的一部分网络提取出来了。所以，对应的网络参数是一样的，因为本来指代的就是同一个网络的不同部分。autoencoder.compile(optimizer='adadelta', loss='binary_crossentropy')##x训练过程，注意到这里并不是没有标签，而是把子集的输入作为了输出，所以这不是无监督学习。而是有监督学习## 这里通常叫做自监督学习。autoencoder.fit(x_train, x_train, epochs=50, batch_size=256, shuffle=True, validation_data=(x_test, x_test))save_model(autoencoder,'autoencoder')save_model(encoder,'encoder')save_model(decoder,'decoder')## 加载保存的模型autoencoder = load_model(\"autoencoder\")encoder = load_model(\"encoder\")decoder = load_model(\"decoder\")## 这样，保存的模型包括结构和参数就都回来了。# encode and decode some digits# note that we take them from the *test* setencoded_imgs = encoder.predict(x_test) # 会利用上面训练好的网络，输出32维的数据decoded_imgs = decoder.predict(encoded_imgs) # 会利用训练好的网络，输出784维的数据。# use Matplotlib (don't ask)import matplotlib.pyplot as plt# 设置显示前多少个数据n = 12 # how many digits we will displayplt.figure(figsize=(20, 4))for i in range(n): # display original ax = plt.subplot(2, n, i + 1) plt.imshow(x_test[i].reshape(28, 28)) plt.gray() ax.get_xaxis().set_visible(False) ax.get_yaxis().set_visible(False) # display reconstruction ax = plt.subplot(2, n, i + 1 + n) plt.imshow(decoded_imgs[i].reshape(28, 28)) plt.gray() ax.get_xaxis().set_visible(False) ax.get_yaxis().set_visible(False)plt.show() 多层的编码解码机 单层神经网络的处理能力是有限的，无论编码还是解码，我们都可以使用多个层来提高映射，或者说数据表征空间转换的能力。下面我们建立一个多层的神经网络，让每层的神经元的数量逐渐减少再逐渐增大，这样可以实现一个分层的数据压缩，数据降维。 我们建立的神经网络的形式是这样的(784--&gt;128--&gt;64--&gt;32--&gt;64--&gt;128--&gt;784),包含输入层，输出层在内，一共有7层。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107# -*- coding: utf-8 -*-\"\"\"Created on Thu Apr 20 11:30:40 2017@author: FF120\"\"\"from keras.datasets import mnistfrom keras.layers import Input, Densefrom keras.models import Modelimport numpy as npimport pickleimport osfrom keras import regularizersdef save_model(model,name): ## fit完成之后，保存整个模型的配置 root_path = r'd:\\deeplearning' model_config = model.get_config() model_weight = model.get_weights() config_save_path = os.path.join(root_path,name+\"_config.txt\") weight_save_path = os.path.join(root_path,name+\"_weights.txt\") pickle.dump(model_config, open(config_save_path, 'wb')) pickle.dump(model_weight, open(weight_save_path, 'wb'))def load_model(name): root_path = r'd:\\deeplearning' config_save_path = os.path.join(root_path,name+\"_config.txt\") weight_save_path = os.path.join(root_path,name+\"_weights.txt\") model_config = pickle.load(open(config_save_path, 'rb')) model_weight = pickle.load(open(weight_save_path, 'rb')) model = Model.from_config(model_config) model.set_weights(model_weight) return model## 加载数据(x_train, _), (x_test, _) = mnist.load_data()# 把数据缩放到 0 -- 1x_train = x_train.astype('float32') / 255.x_test = x_test.astype('float32') / 255.x_train = x_train.reshape((len(x_train), np.prod(x_train.shape[1:])))x_test = x_test.reshape((len(x_test), np.prod(x_test.shape[1:])))print(x_train.shape)print(x_test.shape)##############################################################################################################################################################encoding_dim = 32# this is our input placeholderinput_img = Input(shape=(784,))encoded = Dense(128, activation='relu')(input_img)encoded = Dense(64, activation='relu')(encoded)encoded = Dense(encoding_dim, activation='relu')(encoded)decoded = Dense(64, activation='relu')(encoded)decoded = Dense(128, activation='relu')(decoded)decoded = Dense(784, activation='sigmoid')(decoded)autoencoder = Model(input_img, decoded)encoder = Model(input_img, encoded)encoded_input = Input(shape=(32,))decoder_layer1 = autoencoder.layers[-3](encoded_input)decoder_layer2 = autoencoder.layers[-2](decoder_layer1)decoder_layer3 = autoencoder.layers[-1](decoder_layer2)decoder = Model(encoded_input, decoder_layer3)autoencoder.compile(optimizer='adadelta', loss='binary_crossentropy')autoencoder.fit(x_train, x_train, epochs=50, batch_size=256, shuffle=True, validation_data=(x_test, x_test))save_model(autoencoder,'autoencoder')save_model(encoder,'encoder')save_model(decoder,'decoder')## 加载保存的模型autoencoder = load_model(\"autoencoder\")encoder = load_model(\"encoder\")decoder = load_model(\"decoder\")encoded_imgs = encoder.predict(x_test)decoded_imgs = decoder.predict(encoded_imgs)import matplotlib.pyplot as pltn = 10 # how many digits we will displayplt.figure(figsize=(20, 4))for i in range(n): # display original ax = plt.subplot(2, n, i + 1) plt.imshow(x_test[i].reshape(28, 28)) plt.gray() ax.get_xaxis().set_visible(False) ax.get_yaxis().set_visible(False) # display reconstruction ax = plt.subplot(2, n, i + 1 + n) plt.imshow(decoded_imgs[i].reshape(28, 28)) plt.gray() ax.get_xaxis().set_visible(False) ax.get_yaxis().set_visible(False)plt.show() 上面的代码以中间神经元数目最少的作为分割，前面的作为编码机，后面的作为解码机，前后正好是对称的。当然，这并不是必须的，你也可以让中间的任何一层作为分割，前面作为编码机，后面的作为解码机。这样会实现不同的压缩表示层级。 我们把中间层向前推进一层，再看结果： 1234567891011121314151617181920input_img = Input(shape=(784,))encoded = Dense(128, activation='relu')(input_img)encoded = Dense(64, activation='relu')(encoded)decoded = Dense(32, activation='relu')(encoded)decoded = Dense(64, activation='relu')(decoded)decoded = Dense(128, activation='relu')(decoded)decoded = Dense(784, activation='sigmoid')(decoded)autoencoder = Model(input_img, decoded)encoder = Model(input_img, encoded)encoded_input = Input(shape=(64,))decoder_layer0 = autoencoder.layers[-4](encoded_input)decoder_layer1 = autoencoder.layers[-3](decoder_layer0)decoder_layer2 = autoencoder.layers[-2](decoder_layer1)decoder_layer3 = autoencoder.layers[-1](decoder_layer2)decoder = Model(encoded_input, decoder_layer3) 卷积神经网络的autoencoder 处理图像的时候，使用卷积神经网络通常可以有更好的效果。所以，我们尝试使用卷积神经网络做autoencoder,看看数据压缩的效果如何。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374from keras.layers import Input, Dense, Conv2D, MaxPooling2D, UpSampling2Dfrom keras.models import Modelfrom keras import backend as Kimport matplotlib.pyplot as pltfrom keras.callbacks import TensorBoardfrom keras.datasets import mnistimport numpy as np(x_train, _), (x_test, _) = mnist.load_data()x_train = x_train.astype('float32') / 255.x_test = x_test.astype('float32') / 255.x_train = np.reshape(x_train, (len(x_train), 28, 28, 1)) # adapt this if using `channels_first` image data formatx_test = np.reshape(x_test, (len(x_test), 28, 28, 1)) # adapt this if using `channels_first` image data format## 28*28的图像，只有1个通道，黑白图像input_img = Input(shape=(28, 28, 1)) # adapt this if using `channels_first` image data format# 定义一个卷积核是3*3的层x = Conv2D(16, (3, 3), activation='relu', padding='same')(input_img)# 定义一个pooling层，取2*2区域内的最大值x = MaxPooling2D((2, 2), padding='same')(x)# 定义一个3*3的核x = Conv2D(8, (3, 3), activation='relu', padding='same')(x)x = MaxPooling2D((2, 2), padding='same')(x)# 定义一个pooling层，取2*2区域内的最大值x = Conv2D(8, (3, 3), activation='relu', padding='same')(x)encoded = MaxPooling2D((2, 2), padding='same')(x)# at this point the representation is (4, 4, 8) i.e. 128-dimensionalx = Conv2D(8, (3, 3), activation='relu', padding='same')(encoded)x = UpSampling2D((2, 2))(x)x = Conv2D(8, (3, 3), activation='relu', padding='same')(x)x = UpSampling2D((2, 2))(x)x = Conv2D(16, (3, 3), activation='relu')(x)x = UpSampling2D((2, 2))(x)decoded = Conv2D(1, (3, 3), activation='sigmoid', padding='same')(x)autoencoder = Model(input_img, decoded)autoencoder.compile(optimizer='adadelta', loss='binary_crossentropy')autoencoder.fit(x_train, x_train, epochs=1, batch_size=128, shuffle=True, validation_data=(x_test, x_test), callbacks=[TensorBoard(log_dir='d:/log')])decoded_imgs = autoencoder.predict(x_test)n = 10plt.figure(figsize=(20, 4))for i in range(n): # display original ax = plt.subplot(2, n, i) plt.imshow(x_test[i].reshape(28, 28)) plt.gray() ax.get_xaxis().set_visible(False) ax.get_yaxis().set_visible(False) # display reconstruction ax = plt.subplot(2, n, i + n) plt.imshow(decoded_imgs[i].reshape(28, 28)) plt.gray() ax.get_xaxis().set_visible(False) ax.get_yaxis().set_visible(False)plt.show()from keras.utils import plot_modelplot_model(autoencoder, to_file='model.png') 上面的代码建立了一个这样的模型： input--&gt;Conv2D--&gt;MaxPooling2D--&gt;Conv2D--&gt;MaxPooling2D--&gt;Conv2D--&gt;MaxPooling2D(encoded)--&gt;Conv2D--&gt;UpSampling2D--&gt;Conv2D--&gt;UpSampling2D--&gt;Conv2D--&gt;UpSampling2D--&gt;Conv2D(decoded) 一共有14层网络。使用下面的语句可以打印出这些结构： 12from keras.utils import plot_modelplot_model(autoencoder, to_file='model.png') 1","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"},{"name":"深度学习","slug":"技术/机器学习/深度学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/深度学习/"}],"tags":[{"name":"keras","slug":"keras","permalink":"http://ff120.github.io/hexoblog/tags/keras/"},{"name":"autoencoder","slug":"autoencoder","permalink":"http://ff120.github.io/hexoblog/tags/autoencoder/"}]},{"title":"深度学习_Keras使用技巧","slug":"技术/机器学习/深度学习/深度学习_Keras使用技巧","date":"2017-04-19T14:06:50.000Z","updated":"2019-03-28T00:54:58.271Z","comments":true,"path":"2017/04/19/技术/机器学习/深度学习/深度学习_Keras使用技巧/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/04/19/技术/机器学习/深度学习/深度学习_Keras使用技巧/","excerpt":"keras是一个构建在更高水平上的深度学习框架，类似scikit-learn,他提供了高级的抽象的接口，使得你在不了解具体细节的基础上，就可以定义和使用各种神经网络算法完成某个具体的工作。","text":"keras是一个构建在更高水平上的深度学习框架，类似scikit-learn,他提供了高级的抽象的接口，使得你在不了解具体细节的基础上，就可以定义和使用各种神经网络算法完成某个具体的工作。 ## 模型的可视化 http://blog.csdn.net/u014749291/article/details/54891087 123456789101112Traceback (most recent call last): File \"&lt;ipython-input-7-779239671584&gt;\", line 1, in &lt;module&gt; SVG(model_to_dot(model).create(prog='dot', format='svg')) File \"C:\\ProgramData\\Anaconda3\\envs\\python35\\lib\\site-packages\\keras-2.0.3-py3.5.egg\\keras\\utils\\vis_utils.py\", line 35, in model_to_dot _check_pydot() File \"C:\\ProgramData\\Anaconda3\\envs\\python35\\lib\\site-packages\\keras-2.0.3-py3.5.egg\\keras\\utils\\vis_utils.py\", line 17, in _check_pydot raise ImportError('Failed to import pydot. You must install pydot'ImportError: Failed to import pydot. You must install pydot and graphviz for `pydotprint` to work. 如果是在Windows平台测试，很容易出现上述问题，下载相应的软件安装，再设置环境变量就可以了。 显示模型的信息： model.summary(); 获得模型训练好的参数信息: model.get_weights() 保存模型的图片到本地： from keras.utils import plot_model plot_model(model, to_file='model.png') model.layers is a flattened list of the layers comprising the model graph. model.inputs is the list of input tensors. model.outputs is the list of output tensors. 利用TensorBoard 实现模型的和计算过程的可视化 如果keras使用的是tensorflow作为后端的框架，我们可以借助TensorBoard实现高级一些的可视化。keras实现的可视化功能有限，不能满足深入研究和调试代码的要求。 官方教程 打开TensorBoard : 打开cmd,执行activate python35激活安装了tensorflow的环境，然后执行tensorboard --logdir=path/to/logs,在本地浏览器打开http://localhost:6006/可以看到下面的界面： ## 模型持久化 模型的存储和模型的加载在编程中经常会用到，毕竟训练出一个模型常常需要很长的时间。模型的关键信息其实就两个方面，结构和参数。结构可以用一些结构化的字符串来表示，参数直接用numpy的结构就可以。keras分别提供了保存结构和保存参数的方法。 获得模型结构的方法： 12345678910# 保存成json格式字符串from models import model_from_jsonjson_string = model.to_json()# 保存成 yaml格式的字符串from models import model_from_yamlyaml_string = model.to_yaml()# 使用变量的形式返回结构的信息，可以自己使用其他工具序列化为字符串。model.get_config() 获得模型的参数的方法： 12# 只保存模型的参数，不保存模型的结构model.save_weights(filepath) 从已经保存的结构恢复模型的方法： 12345678910from models import model_from_jsonmodel = model_from_json(json_string)from models import model_from_yamlmodel = model_from_yaml(yaml_string)# 从配置信息恢复模型model = Model.from_config(config)# or, for Sequential:model = Sequential.from_config(config) 为模型设置参数的方法： 12# 这里的model要和加载的权重保存的时候的模型结构一致。model.load_weights(filepath, by_name=False) 我习惯使用的方法是： 1234567891011121314151617181920212223242526from keras.models import Model# 保存模型def save_model(model,name): ## fit完成之后，保存整个模型的配置 root_path = r'd:\\deeplearning' model_config = model.get_config() model_weight = model.get_weights() import pickle import os config_save_path = os.path.join(root_path,name+\"_config.txt\") weight_save_path = os.path.join(root_path,name+\"_weights.txt\") pickle.dump(model_config, open(config_save_path, 'wb')) pickle.dump(model_weight, open(weight_save_path, 'wb'))# 加载模型def load_model(name): root_path = r'd:\\deeplearning' import pickle import os config_save_path = os.path.join(root_path,name+\"_config.txt\") weight_save_path = os.path.join(root_path,name+\"_weights.txt\") model_config = pickle.load(open(config_save_path, 'rb')) model_weight = pickle.load(open(weight_save_path, 'rb')) model = Model.from_config(model_config) model.set_weights(model_weight) return model","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"},{"name":"深度学习","slug":"技术/机器学习/深度学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/深度学习/"}],"tags":[{"name":"keras","slug":"keras","permalink":"http://ff120.github.io/hexoblog/tags/keras/"}]},{"title":"深度学习_反向传播算法及简单实例","slug":"技术/机器学习/深度学习/深度学习_反向传播算法及简单实例","date":"2017-04-19T02:22:48.000Z","updated":"2019-03-28T00:54:58.450Z","comments":true,"path":"2017/04/19/技术/机器学习/深度学习/深度学习_反向传播算法及简单实例/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/04/19/技术/机器学习/深度学习/深度学习_反向传播算法及简单实例/","excerpt":"反向传播算法入门资源索引： http://www.52nlp.cn/tag/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95python%E4%BB%A3%E7%A0%81","text":"反向传播算法入门资源索引： http://www.52nlp.cn/tag/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95python%E4%BB%A3%E7%A0%81 一个简单的三层网络： 下面我们以上面的简单的三层的神经网络说明BP算法的计算过程。 初始的输入参数是： \\(x_1\\) \\(x_2\\) \\(x_3\\) \\(w_{14}\\) \\(w_{15}\\) \\(w_{24}\\) \\(w_25\\) \\(w_{34}\\) \\(w_{35}\\) \\(w_{46}\\) \\(w_{56}\\) \\(b_4\\) \\(b_5\\) \\(b_6\\) 1 0 1 0.2 -0.3 0.4 0.1 -0.5 0.2 -0.3 -0.2 -0.4 0.2 0.1 该神经网络接受一个三维的向量作为输入[x1,x2,x3],输出只有一个数字，这里设置为不是0，就是1.示例给出的数据[1,0,1]对应的类别是1. 定义好了网络的结构，给出了初始的网络参数的值( \\(w_{14}\\)|\\(w_{15}\\)|\\(w_{24}\\)|\\(w_25\\)|\\(w_{34}\\)|\\(w_{35}\\)|\\(w_{46}\\)|\\(w_{56}\\)|\\(b_4\\)|\\(b_5\\)|\\(b_6\\)| ),都是该神经网络的参数。现在的目标是使得该神经网络在输入是[1,0,1]时，输出是1,或者至少是十分接近1. 首先计算一下在初始化参数的情况下，神经网络的输出是什么。 神经元输出的计算过程。 在这里，激活函数我们使用sigmiod函数： \\[ f(x) = \\dfrac 1 {1+e^{-x}} \\] 我们将第i个神经元在激活函数作用之前的输出记作的输出记作 \\(I_i\\) ,在激活函数作用之后的值记 \\(O_i\\) 计算过程如下： \\[ I_4 = x_1*w_{14}+x_2*w_{24}+x_3*w_{34}+b_4 = 1*0.2+0*0.4+1*(-0.5)+(-0.4) = -0.7 \\] \\[ I_5 = x_1*w_{15}+x_2*w_{25}+x_3*w_{35}+b_5 = 1*(-0.3)+0*0.1+1*0.2+0.2 = 0.1 \\] \\[ I_6 = O_4*w_{46}+O_5*w_{56}+b_6 = 0.331812*(-0.3)+0.524979*(-0.2)+0.1 = -0.104539 \\] \\[ O_4 = f(I_4) = \\dfrac 1 {1+e^{-(-0.7)}} = 0.331812 \\] \\[ O_5 = f(I_5) = \\dfrac 1 {1+e^{-0.1}} = 0.524979 \\] \\[ O_6 = f(I_6) = \\dfrac 1 {1+e^{-(-0.104539)}} = 0.473889 \\] 可以看到，初始化的参数对[1,0,1]的输出是0.473899，而我们期望的输出是1。 所以，必须使用某种办法调整参数，才可以达到我们的期望。 我们定义误差如下： \\[ E = \\frac12 (target - O_6)^2 \\] 用平方误差来度量输出和期望的输出之间的差距。那么接下来我们希望调整神经网络的参数，使得E尽快的缩小，这样我们就可以使神经网络尽快的达到我们期望的输出。首先考虑如何改变\\(w_{46}\\)才能使得误差减小。这里我求 $ $ , 导数对应的方向函数上升下降的速度是最快的，我们使用偏导数找到最快的下降方向，按照这样的方式更新神经网络的权重参数和偏置参数。 \\[ \\frac {\\partial E} {\\partial w_{46}} = \\frac {\\partial E} {\\partial O_6} * \\frac {\\partial O_6} {\\partial I_6} * \\frac {\\partial I_6} {\\partial w_{46}} \\] 上面应用了求导的链式法则，将对\\(w_{46}\\)的偏导数表示成了已知的数据。下面我们一步一步求出这个偏导数的表达式并得出参数的更新规则。 \\[ E = \\frac12 (target - O_6)^2 \\] \\[ \\frac {\\partial E} {\\partial O_6} = -\\frac12*2(target-O_6) = O_6 - target = 0.473889 - 1 = -0.526111 \\] \\[ O_6 = f(I_6) = \\frac {1} {1+e^{-I_6}} \\] \\[ \\frac {\\partial O_6} {\\partial I_6} {} = e^{-I_6}*(\\frac {1} {1+e^{-I_6}})^{2} = O_6 * (1-O_6) = 0.473889 * (1-0.473889) = 0.249318 \\] \\[ I_6 = O_4*w_{46}+O_5*w_{56}+b_6 \\] \\[ \\frac {\\partial I_6} {\\partial w_{46}} = O_4 = 0.331812 \\] 综合上面的所有公式，可以推导出最终的参数更新公式是： \\[ \\frac {\\partial E} {\\partial w_{46}} = (O_6 - target) * (O_6*(1-O_6))*O_4=(-0.526111)*0.249318*0.331812= -0.043523 \\] 我们定义一个学习率\\(l\\),表示参数更新的速度，这里设定为0.9；然后定义参数按照下面的方式更新： \\[ w^+_{46} = w_{46} - l * \\frac {\\partial E} {\\partial w_{46}} = -0.3 - 0.9*(-0.043523) = -0.260829 \\] 下面总结一下上面提到的公式，需要注意的是，我这里举例的神经网络只有一个输出，所有偏导数和导数是一样的。但是通常的神经网络都有多个输出。在有多个输出的时候，我们定义E等于多个输出节点的E的和。这样，多个节点的输出就和单个节点的输出不太一样。我们定义输出节点的错误率为： \\[ E_i = O_i*(1-O_i)*(target-O_i) \\] 我们定义隐藏层的节点的错误率为： \\[ E_i = O_i*(1-O_i)*( \\sum E_k*w_{jk}) \\] 这样，每次参数的更新就可以写成下面的形式： \\[ \\Delta w_{ij} = l * E_j * O_i \\] 偏置的更新定义如下： \\[ \\Delta b_j = l * E_j \\] 不断的应用以上的公式更新权重参数和偏置，直到错误率到达一个很小的水平，停止训练。这个时候，神经网络对输入[1,0,1]的输出已经非常接近正确答案1了。 第一轮权重和偏置的更新是： 了解了反向传播算法，就掌握了神经网络参数学习的方法，我们就可以写出自己的神经网络了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127# -*- coding: utf-8 -*-import numpy as np# 全连接层实现类class FullConnectedLayer(object): def __init__(self, input_size, output_size, activator): ''' 构造函数 input_size: 本层输入向量的维度 output_size: 本层输出向量的维度 activator: 激活函数 ''' self.input_size = input_size self.output_size = output_size self.activator = activator # 权重数组W self.W = np.random.uniform(-0.1, 0.1, (output_size, input_size)) # 偏置项b self.b = np.zeros((output_size, 1)) # 输出向量 self.output = np.zeros((output_size, 1)) def forward(self, input_array): ''' 前向计算 input_array: 输入向量，维度必须等于input_size ''' # 式2 self.input = input_array self.output = self.activator.forward( np.dot(self.W, input_array) + self.b) def backward(self, delta_array): ''' 反向计算W和b的梯度 delta_array: 从上一层传递过来的误差项 ''' # 式8 self.delta = self.activator.backward(self.input) * np.dot( self.W.T, delta_array) self.W_grad = np.dot(delta_array, self.input.T) self.b_grad = delta_array def update(self, learning_rate): ''' 使用梯度下降算法更新权重 ''' self.W += learning_rate * self.W_grad self.b += learning_rate * self.b_grad# Sigmoid激活函数类class SigmoidActivator(object): def forward(self, weighted_input): return 1.0 / (1.0 + np.exp(-weighted_input)) def backward(self, output): return output * (1 - output)# 神经网络类class Network(object): def __init__(self, layers): ''' 构造函数 ''' self.layers = [] for i in range(len(layers) - 1): self.layers.append( FullConnectedLayer( layers[i], layers[i+1], SigmoidActivator() ) ) def predict(self, sample): ''' 使用神经网络实现预测 sample: 输入样本 ''' output = sample for layer in self.layers: layer.forward(output) output = layer.output return output def train(self, labels, data_set, rate, epoch): ''' 训练函数 labels: 样本标签 data_set: 输入样本 rate: 学习速率 epoch: 训练轮数 ''' for i in range(epoch): for d in range(len(data_set)): self.train_one_sample(labels[d], data_set[d], rate) def train_one_sample(self, label, sample, rate): self.predict(sample) self.calc_gradient(label) self.update_weight(rate) def calc_gradient(self, label): delta = self.layers[-1].activator.backward( self.layers[-1].output ) * (label - self.layers[-1].output) for layer in self.layers[::-1]: layer.backward(delta) delta = layer.delta return delta def update_weight(self, rate): for layer in self.layers: layer.update(rate)def train_and_evaluate(): last_error_ratio = 1.0 epoch = 0 train_data_set, train_labels = get_training_data_set() test_data_set, test_labels = get_test_data_set() network = Network([784, 300, 10]) while True: epoch += 1 network.train(train_labels, train_data_set, 0.3, 1) print('%s epoch %d finished' % (now(), epoch) ) if epoch % 10 == 0: error_ratio = evaluate(network, test_data_set, test_labels) print('%s after epoch %d, error ratio is %f' % (now(), epoch, error_ratio) ) if error_ratio &gt; last_error_ratio: break else: last_error_ratio = error_ratioif __name__ == '__main__': train_and_evaluate()","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"},{"name":"深度学习","slug":"技术/机器学习/深度学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/深度学习/"}],"tags":[{"name":"BP","slug":"BP","permalink":"http://ff120.github.io/hexoblog/tags/BP/"}]},{"title":"Anaconda的使用01-基础","slug":"技术/工具/编程IDE/Anaconda/Anaconda的使用01-基础","date":"2017-04-18T12:11:12.000Z","updated":"2019-03-28T00:54:55.422Z","comments":true,"path":"2017/04/18/技术/工具/编程IDE/Anaconda/Anaconda的使用01-基础/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/04/18/技术/工具/编程IDE/Anaconda/Anaconda的使用01-基础/","excerpt":"anaconda是一个python的集成环境，自带了许多常用的python包，所以安装它是学习python最简便的方法。anaconda提供conda命令，可以创建多个相互隔离的不同的python工作环境，十分方便。","text":"anaconda是一个python的集成环境，自带了许多常用的python包，所以安装它是学习python最简便的方法。anaconda提供conda命令，可以创建多个相互隔离的不同的python工作环境，十分方便。 ## 安装 下载python3.6版本的安装包，直接双击安装即可，所有选项选择默认就行。软件安装好之后，Windows的命令窗口应该可以直接执行python,ipython,conda,pip等命令。 conda 查看当前安装的环境 conda info -e 创建一个名称为python35的环境： conda create --name python35 python=3.5 删除这个环境： conda remove -n python35 --all 激活某个环境： activate python35 退出某个环境：deactivate 复制某个环境：conda create -n python35_copy --clone python35 查看conda的版本:conda --version 更新conda： conda update conda 查看当前环境中安装的包和版本号： conda list 一次安装anaconda集成包：conda install anaconda 更新anaconda的版本： conda update anaconda 更改conda的镜像： 123456# 添加Anaconda的TUNA镜像conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/# TUNA的help中镜像地址加有引号，需要去掉# 设置搜索时显示通道地址conda config --set show_channel_urls yes 配置python2.7 和python 3.5两个工作环境 conda create --name python35 python=3.5 activate python35 conda install anaconda spyder 这样就打开了python3.5的spyder工作环境。conda install anaconda是安装anaconda所有的包，如果用不到这么多，可以不必执行这一步，因为安装太多的包比较耗时。 conda create --name python27 python=2.7 activate python27 conda install anaconda spyder 这样就打开了python3.5的spyder工作环境。","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"工具","slug":"技术/工具","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/"},{"name":"编程IDE","slug":"技术/工具/编程IDE","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/编程IDE/"},{"name":"Anaconda","slug":"技术/工具/编程IDE/Anaconda","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/编程IDE/Anaconda/"}],"tags":[{"name":"python","slug":"python","permalink":"http://ff120.github.io/hexoblog/tags/python/"},{"name":"anaconda","slug":"anaconda","permalink":"http://ff120.github.io/hexoblog/tags/anaconda/"}]},{"title":"深度学习__利用神经网络识别手写数字","slug":"技术/机器学习/深度学习/深度学习_利用神经网络识别手写数字","date":"2017-04-18T11:36:09.000Z","updated":"2019-03-28T00:54:58.401Z","comments":true,"path":"2017/04/18/技术/机器学习/深度学习/深度学习_利用神经网络识别手写数字/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/04/18/技术/机器学习/深度学习/深度学习_利用神经网络识别手写数字/","excerpt":"文章翻译自英文文章。学习神经网络的入门教程。","text":"文章翻译自英文文章。学习神经网络的入门教程。 人类视觉系统是大自然的一大奇迹。 考虑下面的手写数字序列： 大部分人能够毫不费力的识别出这些数字是 504192。这种简单性只是一个幻觉。在我们大脑各半球，有一个主要的视觉皮层，即V1，它包含1.4亿个神经元以及数以百亿的神经元连接。而且人类不只是有V1，还有一系列的视觉皮层——V2,V3,V4和V5，它们能够执行更加复杂的图像处理。我们可以将大脑想象成一台超级计算机，在几亿年的进化中不断改进，最终非常适合理解这个视觉世界。要识别手写数字不是一件非常容易的事。然而，我们人类却能非常惊人的通过我们的眼睛理解所看到的一切，但是几乎所有的工作都是在不知不觉中完成的，以至于我们不会赞叹我们的视觉系统解决的问题有多么艰难。 神经网络用不同的方法来处理这个问题。它的思想就是利用大量的手写数字（训练样本），然后开发出一套从训练样本中进行学习的系统。换句话说，神经网络使用样本来自动推理出识别手写数字的规则。此外，通过增加训练样本规模，神经网络能学到手写体的更多规则从而提升它的识别精度。因此在我们像上面一样只有100张训练数字同时，有可能我们能通过成千上万更多的训练样本来构建更好的手写识别算法。 本章我们将编写一段计算机程序来实现一个能识别手写数字的神经网络。这个程序大概有74行，而且没有使用其他特别的神经网络库，但是这段程序能够具有96%的数字识别精度，而且没有人工干预。此外，在后面的章节中我们将改进算法达到99%以上的精度。实际上，最好的商业神经网络已经很好的应用在银行支票处理以及邮局识别地址等。 我们专注在手写体识别是因为它是一个很好的学习神经网络的原型问题。做为一个原型，它刚好合适：识别手写数字是一个挑战，不是那么容易，而它也不需要一个极其复杂的方案或者巨大的计算能力。此外，它也是开发更多高级技术的好方法，比如深度学习。因此整本书我们将不断重复回到手写识别这个问题。这本书的后面，我们将讨论这些算法思想如何应用到计算机视觉的其他问题，还包括语言识别、自然语言处理和其他领域。 当然，如果本章只是写一个识别手写数字的计算机程序，那么将非常短小！在编写过程中，我们将介绍很多神经网络的关键思想，包括人工神经网络的两大类别（感知器和sigmoid神经元）以及神经网络标准学习算法，即随机梯度下降。整个过程我们将关注在阐述为什么这样处理是有效的，从而让你构建起神经网络直觉。这比只陈述基础的机制更加冗长，但这对更深入理解所学到的内容是值得的。在这些收获上，本章结束你将明白深度学习是什么，且它为什么这么重要。 感知器(Perceptrons) 什么是神经网络？在开始之前，我将介绍一种人工的神经元，即感知器(perceptron)。感知器是由Frank Rosenblatt 在上世纪50到60年代发明的 , 灵感来源于 Warren McCulloch 和 Walter Pitts 的早期工作。今天人工神经网络使用更加通用的其他模型，本书以及许多现代的神经网络工作中，主要的神经网络模型是sigmoid神经元。 我们将很快讨论sigmoid神经元，但是为了更好了解它的原理，我们首先要理解感知器。 那么感知器如何工作呢？一个感知器获取几个二进制输入\\(x_1, x_2, \\ldots\\)，并且产生一个二进制数出： 在这个例子中，感知器具有三个输入\\(x_1, x_2, x_3\\)。通常它会具有更多或更少的输入。Rosenblatt 提出了一个简单规则来计算最后数出。他引入了权重(weights) \\(w_1,w_2,\\ldots\\)，这些实数表示各个输入对输出的重要性。这个神经元输出(output) \\(0\\) 或者 \\(1\\) 是由这些输入的加权求和 \\(\\sum_j w_j x_j\\) 是否大于或者小于某一个阈值(threshold)。不像这些权重，阈值是这个神经元的实数参数。将它们放入更加精确的代数术语中： 这就是一个感知器如何工作的全部内容！ 这是一个基础的数学模型。你可以这么理解感知器，它是一个通过加权凭据来进行决策的设备。让我们来看这个例子，可能它不是一个真实的例子，但是非常好理解，后面我们将很快进入真实的例子。假设周末到了，你听说在你所在的城市将有一个奶酪节，你很喜欢吃奶酪，并且正决定是否要去参加这个节日，你可能会通过以下三个方面来权衡你的决定: 天气好吗？ 你的男(女)朋友是否愿意陪你去？ 是否这个活动距离公共交通很近？（你自己没车） 我们将这三个因素用对应的二进制变量\\(x_1, x_2\\)和\\(x_3\\)表示。比如，当天气还不错时，我们有\\(x_1 = 1\\) ，天气不好时\\(x_1 = 0\\)；相似的，如果男或女朋友愿意去，\\(x_2 = 1\\)，否则\\(x_2 = 0\\)；对于公共交通\\(x_3\\)同理赋值。 现在假设奶酪是你的最爱，以致于即便你的男或女朋友不感兴趣而且去那里也不太方便，你仍然非常想去参加这个节日活动。但是也许你真的讨厌坏天气，而且如果天气很糟，你也没办法去。你能使用感知器来模拟这类决策。一种决策方式是，让天气权重 \\(w_1 = 6\\)，其他条件权重分别为\\(w_2 = 2\\)，\\(w_3 = 2\\)。权重\\(w_1\\)值越大表示天气影响最大，比起男或女朋友加入或者交通距离的影响都大。最后，假设你选择5做为感知器阈值，按照这种选择，这个感知器就能实现这个决策模型：当天气好时候输出\\(1\\)，天气不好时候输出\\(0\\)，无论你男或女朋友是否愿意去，或者交通是否比较近。 通过更改权重和阈值，我们能得到不同的决策模型。例如，我们将阈值设为\\(3\\)，那么感知器会在以下条件满足时决定去参加活动：如果天气很好、或者男(女)朋友愿意去并且交通很近。换句话说，它将是决策的不同模型，阈值越低，表明你越想去参加这个节日活动。 显然，这个感知器不是人类决策的完整模型！但是这个例子说明了一个感知器如何能将各种凭据进行加权和来制定决策，而且一个复杂的感知器网络能做出非常微妙的决策： 在这个网络中，第一列感知器（我们称其为第一层感知器）通过加权输入凭据来做出三个非常简单的决策。那第二列感知器是什么呢？其中每一个感知器都是通过将第一列的决策结果进行加权和来做出自己的决策。通过这种方式，第二层感知器能够比第一层感知器做出更加复杂和抽象层的决策。第三层感知器能做出更加复杂的决策，以此类推，更多层感知器能够进行更加复杂的决策。在这个网络中，第一列感知器（我们称其为第一层感知器）通过加权输入凭据来做出三个非常简单的决策。那第二列感知器是什么呢？其中每一个感知器都是通过将第一列的决策结果进行加权和来做出自己的决策。通过这种方式，第二层感知器能够比第一层感知器做出更加复杂和抽象层的决策。第三层感知器能做出更加复杂的决策，以此类推，更多层感知器能够进行更加复杂的决策。 顺便说一句，当我们定义感知器时，它们都只有一个输出。但上面的网络中，这些感知器看上去有多个输出。实际上，它们也仍然只有一个输出，只不过为了更好的表明这些感知器输出被其他感知器所使用，因此采用了多个输出的箭头线表示，这比起绘制一条输出线然后分裂开更好一些。","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"},{"name":"深度学习","slug":"技术/机器学习/深度学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/深度学习/"}],"tags":[{"name":"deep_learning","slug":"deep-learning","permalink":"http://ff120.github.io/hexoblog/tags/deep-learning/"}]},{"title":"深度学习_基本概念","slug":"技术/机器学习/深度学习/深度学习_基本概念","date":"2017-04-18T03:16:47.000Z","updated":"2019-03-28T00:54:58.473Z","comments":true,"path":"2017/04/18/技术/机器学习/深度学习/深度学习_基本概念/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/04/18/技术/机器学习/深度学习/深度学习_基本概念/","excerpt":"深度学习应该了解的内容。","text":"深度学习应该了解的内容。 深度学习的应用领域 深度学习得到越来越快的发展，这是因为深度学习是最有希望解决一些普通算法难以解决的问题，让我们来看一看都有哪些问题是目前还没有解决，但是有望可以借助深度学习方法的进步解决的。 黑白图像的自动着色 我们都知道，把彩色图像变成黑白图像很容易，但是要把黑白图像变成彩色图像就不那么容易了（颜色信息从那里来？），这个问题以前都是靠手工着色的方式解决的，但是这样的方法费时费力还需要专业的人才。 目前使用ImageNet训练的多层的卷积神经网络可以达到的水平如下图： 自动为电影添加声音 为无声电影添加配音应该是一个更加困难的问题，但是深度学习的方法已经做出了一些有益的尝试。现在能够做到的是一些简单的动作的配音，例如视频中出现一个敲击的动作，可以配上一个敲击的声音，当然，这需要大量的训练样本去学习什么样的场景对应什么样的声音。这个方面主要是CNN和LSTM. 自动机器翻译 自动翻译文字 从一种语言翻译到另外一种语言，这样的软件早就有，而且有了很多年了。但是翻译的水平始终无法与人工翻译相提并论。深度学习技术的发展有希望改变这一点，自动机器翻译的水平不断提高，直逼人工翻译的水平。这个领域使用的神经网络是Stacked networks of large LSTM recurrent neural networks. 翻译图像中的文字 识别图像中的文字一直以来都是一个比较实际的问题，在各种场合下都有应用。最常见的比如车牌的识别，名片的识别，信用卡号码的识别。以前用图像处理的算法解决这个问题的时候，大多是局限在某一个具体的场景，例如车牌识别，图像大小基本固定，背景颜色基本固定，文字只有很有限的几个，这种情况下普通的算法也能得到很好的效果。但是实际应用的时候往往情况比这个复杂的多，这个领域使用的神经网络主要是CNN. 物体分类和检测 识别一个图像中的物体的类别，或者各个物体的类别也是意见很困难的事情。因为类别往往有无穷多种。 Object Classification 比如判断一副图像属于1000个类别中的哪一类。目前ImageNet上已经能够做到很高的准确率。 Object Detection 识别图像中的各个对象并标记出来。 手写笔迹的自动生成 我们知道，一个人的签名可以证明身份，这是因为假设了一个前提：每个人的笔迹都有唯一性，并且可以鉴别出来。这个任务就是要打破这个前提，让电脑可以根据一个人的笔迹风格，生成出具有相同风格的笔迹。到那个时候，签名估计就没什么用了。 当然，目前这方面还很弱。 文本的自动生成 这是一个更加令人兴奋的领域。可以借助机器自动句子，段落，甚至论文。主要使用的神经网络是Large recurrent neural networks. 当然，这个目前还没有什么突破，具体的成果可以参考http://karpathy.github.io/ 图像理解 该任务是自动生成一段对图像的描述性文字，类似我们小时候玩的那种看图说话。这个领域已经取得了一些令人惊叹的成果，目前的水平如下图： Automatic Game Playing This is a task where a model learns how to play a computer game based only on the pixels on the screen. This very difficult task is the domain of deep reinforcement models and is the breakthrough that DeepMind (now part of google) is renown for achieving. 深度学习中的概念 神经网络中的一个函数： 将负无穷到正无穷的范围压缩到0–1的函数： 下图中的神经网络使用上面的激活函数。 神经网络的结构一旦定义，就定义了一组函数。神经网络的参数一旦确定，就确定了一个函数，对于特定的输入，产生特定的输出。 输出层的处理，归一化0–1的范围。 张量(tensor) 张量，或tensor，是本文档会经常出现的一个词汇，在此稍作解释。 使用这个词汇的目的是为了表述统一，张量可以看作是向量、矩阵的自然推广，我们用张量来表示广泛的数据类型。 规模最小的张量是0阶张量，即标量，也就是一个数。 当我们把一些数有序的排列起来，就形成了1阶张量，也就是一个向量 如果我们继续把一组向量有序的排列起来，就形成了2阶张量，也就是一个矩阵 把矩阵摞起来，就是3阶张量，我们可以称为一个立方体，具有3个颜色通道的彩色图片就是一个这样的立方体 把立方体摞起来，好吧这次我们真的没有给它起别名了，就叫4阶张量了，不要去试图想像4阶张量是什么样子，它就是个数学上的概念。 张量的阶数有时候也称为维度，或者轴，轴这个词翻译自英文axis。譬如一个矩阵[[1,2],[3,4]]，是一个2阶张量，有两个维度或轴，沿着第0个轴（为了与python的计数方式一致，本文档维度和轴从0算起）你看到的是[1,2]，[3,4]两个向量，沿着第1个轴你看到的是[1,3]，[2,4]两个向量。 要理解沿着某个轴的意思，可以运行如下的代码： 12345678import numpy as npa = np.array([[1,2],[3,4]])sum0 = np.sum(a, axis=0)sum1 = np.sum(a, axis=1)print sum0print sum1 平方误差和交叉熵 激活函数 作用在神经元上，对神经元上的数据进行处理的函数。在神经网络发展的早期，神经元上的数据没有经过任何处理，或者只经过线性的处理，可以认为这个时候的激活函数是\\(y=x\\),或者(-1|1),(0|1)等阶跃函数。 #### sigmod激活函数 \\[ f(x) = \\dfrac 1 {1 + e^x} \\] 它的作用是把 \\(-\\infty\\) 到 \\(+\\infty\\) 映射到[0,1]范围内.函数主要在[-4,4]之间，两侧接近0和1.由于Sigmoid函数所具有的性质, 它常和单位阶跃函数用于构造人工神经网络; 另外心理学中的学习曲线的形状也和Sigmoid函数比较类似. 主要用于隐层神经元输出。 tanh 激活函数 \\[ tanh(x) = 2sigmoid(2x)-1 \\] 实际应用中，tanh 会比 sigmoid 更好. Softmax 激活函数 主要用于多分类神经网络输出。 Softmax适合多分类的情况。 #### ReLu(Rectified Linear Units)激活函数 深度学习中，我们一般使用ReLU作为中间隐层神经元的激活函数，AlexNet中提出用ReLU来替代传统的激活函数是深度学习的一大进步。 2001年，神经科学家Dayan、Abott从生物学角度，模拟出了脑神经元接受信号更精确的激活模型，该模型如下图所示： Softplus Softplus函数，Softplus函数是Logistic-Sigmoid函数原函数 \\[ softplus(x) = log(1+e^x) \\] Rectifier \\[ f(x) = max(0,x) \\] 综合速率和效率，DL中大部分激活函数应该选择ReLu. ## 深度学习工具 ### keras keras中文文档 keras官方文档 github开源代码 安装 下载源代码 解压缩 切换到解压缩之后的目录，包含文件setup.py的路径，执行安装命令python setup.py install. 打开python环境，输入import keras,如果没有报错，证明安装成功。 如果以上步骤出现问题，很可能是缺少需要的软件包。keras后端使用tensorflow或者theano，所以二者必须使用安装其中之一。如果没有安装tensorfolw,则会有下面的报错信息： 1234567891011Using TensorFlow backend.Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; File \"C:\\Anaconda2\\lib\\site-packages\\keras-2.0.3-py2.7.egg\\keras\\__init__.py\", line 3, in &lt;module&gt; from . import activations File \"C:\\Anaconda2\\lib\\site-packages\\keras-2.0.3-py2.7.egg\\keras\\activations.py\", line 3, in &lt;module&gt; from . import backend as K File \"C:\\Anaconda2\\lib\\site-packages\\keras-2.0.3-py2.7.egg\\keras\\backend\\__init__.py\", line 73, in &lt;module&gt; 如果已经安装了theano,可以切换keras的后端。 在TensorFlow和theano之间切换 官方文档 找到配置文件$HOME/.keras/keras.json,如果还没有，创建该文件。 123456&#123; \"epsilon\": 1e-07, \"floatx\": \"float32\", \"image_data_format\": \"channels_last\", \"backend\": \"tensorflow\"&#125; backend指定了使用哪一个，可使用的关键字是tensorflow和theano,修改保存即可。 安装tensorflow 如果之前两个软件包都没有安装，那么必须要安装一个才能继续使用keras. 官方安装教程 我们只是用来学习，所以先安装一个不支持GPU的版本，这个版本需要的条件少，容易安装成功。关于完整的安装教程，可以参照官方文档。 下载安装Anaconda 创建一个tensorflow环境：conda create -n tensorflow; 123Fetching package metadata ...........Solving package specifications:Package plan for installation in environment C:\\Anaconda2\\envs\\tensorflow: 激活该环境：activate tensorflow 安装cpu-only版本的tensorflow: 1pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/windows/cpu/tensorflow-1.0.1-cp35-cp35m-win_amd64.whl 如果出现下面的错误： tensorflow-1.0.1-cp35-cp35m-win_amd64.whl is not a supported wheel on this platf orm.;可能是因为你的python环境不是3.5，目前tensorflow在windows上只支持python 3.5. anaconda创建一个python 3.5的环境：&gt;conda create --name tensorflow35 python=3.5,然后激活该环境activate tensorflow35.然后再执行第四步的安装语句。 成功安装之后会有successful的字样。Successfully installed appdirs-1.4.3 numpy-1.12.1 packaging-16.8 protobuf-3.2.0 pyparsing-2.2.0 setuptools-35.0.0 six-1.10.0 tensorflow-1.0.1 wheel-0.29.0. 测试安装是否成功：进入python环境执行import tensorflow as tf，没有报错证明安装成功。 安装完tensorflow之后，重新执行上面的安装keras的所有步骤，即可成功安装keras. 12&gt;&gt;&gt; import kerasUsing TensorFlow backend. 出现上面的提示，没有任何的报错信息，证明安装成功。 安装theano 12conda install mingw libpythonpip insall theano keras配置文件 位置： C:\\Users\\FF120\\.keras\\keras.json; 内容： 123456&#123; \"epsilon\": 1e-07, \"floatx\": \"float32\", \"image_data_format\": \"channels_last\", \"backend\": \"tensorflow\"&#125; backend : 用来指定keras使用的后端实现，可选的关键字是tensorflow,theano; image_data_format: 用来指定图像输入参数的格式，可选的关键字是channels_first,channels_last,详细的叙述参看下面。 &gt; 在如何表示一组彩色图片的问题上，Theano和TensorFlow发生了分歧，’th’模式，也即Theano模式会把100张RGB三通道的16×32（高为16宽为32）彩色图表示为下面这种形式（100,3,16,32），Caffe采取的也是这种方式。第0个维度是样本维，代表样本的数目，第1个维度是通道维，代表颜色通道数。后面两个就是高和宽了。这种theano风格的数据组织方法，称为“channels_first”，即通道维靠前。 &gt; 而TensorFlow，的表达形式是（100,16,32,3），即把通道维放在了最后，这种数据组织方式称为“channels_last”。 keras模型 接受张量作为输入然后输出张量的实体都叫做模型，keras中有两种模型。一种是最简单的Sequential,它是单输入单输出，一条路通到底，层与层之间只有相邻关系，跨层连接统统没有。这种模型编译速度快，操作上也比较简单。 还有一种是functional model API,这个模型支持多输入多输出，层与层之间想怎么连怎么连，但是编译速度慢。 keras编程概念 batch_size 深度学习的优化算法，说白了就是梯度下降。每次的参数更新有两种方式。 第一种，遍历全部数据集算一次损失函数，然后算函数对各个参数的梯度，更新梯度。这种方法每更新一次参数都要把数据集里的所有样本都看一遍，计算量开销大，计算速度慢，不支持在线学习，这称为Batch gradient descent，批梯度下降。 另一种，每看一个数据就算一下损失函数，然后求梯度更新参数，这个称为随机梯度下降，stochastic gradient descent。这个方法速度比较快，但是收敛性能不太好，可能在最优点附近晃来晃去，hit不到最优点。两次参数的更新也有可能互相抵消掉，造成目标函数震荡的比较剧烈。 为了克服两种方法的缺点，现在一般采用的是一种折中手段，mini-batch gradient decent，小批的梯度下降，这种方法把数据分为若干个批，按批来更新参数，这样，一个批中的一组数据共同决定了本次梯度的方向，下降起来就不容易跑偏，减少了随机性。另一方面因为批的样本数与整个数据集相比小了很多，计算量也不是很大。 基本上现在的梯度下降都是基于mini-batch的，所以Keras的模块中经常会出现batch_size，就是指这个。 顺便说一句，Keras中用的优化器SGD是stochastic gradient descent的缩写，但不代表是一个样本就更新一回，还是基于mini-batch的。 layers Dense 普通的全连接的神经网络层。 Dropout 一个简单的避免神经网络的训练过程中过拟合的方法，具体的还不是太懂，参考论文：Dropout: A Simple Way to Prevent Neural Networks from Overfitting 深度学习资料 https://ljalphabeta.gitbooks.io/neural-networks-and-deep-learning-notes/content/chapter6.html http://www.tensorfly.cn/home/?p=80 http://neuralnetworksanddeeplearning.com/chap2.html http://ufldl.stanford.edu/wiki/index.php/UFLDL_Tutorial http://www.pyimagesearch.com/2014/09/22/getting-started-deep-learning-python","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"},{"name":"深度学习","slug":"技术/机器学习/深度学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/深度学习/"}],"tags":[{"name":"deep_learning","slug":"deep-learning","permalink":"http://ff120.github.io/hexoblog/tags/deep-learning/"}]},{"title":"算法专题_算法总结","slug":"技术/数据结构和算法/算法专题_算法总结","date":"2017-04-17T13:53:30.000Z","updated":"2019-03-28T00:54:56.908Z","comments":true,"path":"2017/04/17/技术/数据结构和算法/算法专题_算法总结/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/04/17/技术/数据结构和算法/算法专题_算法总结/","excerpt":"从宏观上总结都有哪些算法，每种算法各自适用解决什么样的问题。","text":"从宏观上总结都有哪些算法，每种算法各自适用解决什么样的问题。 - 分治法 - 随机化方法 - 递归技术 - 动态规划 - 贪心算法 - 摊还分析","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"算法专题_排序算法","slug":"技术/数据结构和算法/算法专题_排序算法","date":"2017-04-16T11:31:24.000Z","updated":"2019-03-28T00:54:56.733Z","comments":true,"path":"2017/04/16/技术/数据结构和算法/算法专题_排序算法/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/04/16/技术/数据结构和算法/算法专题_排序算法/","excerpt":"排序算法，是将无序数据变为有序的一种算法。通常分为内部排序和外部排序。内部排序是指所有待排序的数据都在内存中，都可以直接访问得到。 外部排序是指数据存储在外部，通常都涉及大量的数据的排序问题，这里我们先不讨论。本文主要介绍主要的内部排序算法。","text":"排序算法，是将无序数据变为有序的一种算法。通常分为内部排序和外部排序。内部排序是指所有待排序的数据都在内存中，都可以直接访问得到。 外部排序是指数据存储在外部，通常都涉及大量的数据的排序问题，这里我们先不讨论。本文主要介绍主要的内部排序算法。 内部排序按照算法思想的不同，可以分为以下几种类型： 插入排序 选择排序 交换排序 归并排序 基数排序 比较排序 如果排序算法中元素的顺序的确定依赖元素之间的比较，那么这类排序算法称作比较排序。 插入排序 插入排序的思想是将一个元素插入到一个已经排序好的序列中，在插入的时候逐个比较带插入元素和有序的序列，找到新插入元素的合适位置，插入到序列中。 直接插入排序 最简单的插入排序，直接使用插入排序的思想而没有经过任何的优化过程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;void print(vector&lt;int&gt; v,int i)&#123; int count = 0; for(auto a : v)&#123; if(count == i)&#123; cout&lt;&lt;\" : \"; &#125; cout&lt;&lt;a&lt;&lt;\" \"; count ++; &#125; cout&lt;&lt;endl;&#125;vector&lt;int&gt; SimpleInsertSort(vector&lt;int&gt; &amp;a)&#123; int n = a.size(); // 每次循环，都假设i前面的数字已经排序好了，i是要插入到已排序序列的数字，i之后的数字都是未排序的。 for(int i = 1; i&lt;n; i++)&#123; // 打印当前的状态 print(a,i); // 找到当前数字i应当插入的位置 int curValue = a[i]; int ii = i; if(a[ii]&lt;a[0])&#123; //应当插入首位 while(ii-1&gt;=0)&#123; a[ii] = a[ii-1]; ii--; &#125; a[0] = curValue; &#125;else if(a[ii]&gt;=a[ii-1])&#123; //应当插入末尾 continue; //如果应该插入的位置是有序列表的末尾，则什么都不用做。 &#125;else&#123; for(int j=0;j&lt;ii-1;j++)&#123; if(a[ii]&gt;=a[j] &amp;&amp; a[ii]&lt;a[j+1])&#123; //应当插入j之后 while(ii-1&gt;j)&#123; a[ii] = a[ii-1]; ii--; &#125; a[ii] = curValue; &#125; &#125; &#125; &#125; print(a,a.size()); return a;&#125;int main() &#123; vector&lt;int&gt; v = &#123;49,38,65,97,76,13,27,49&#125;; auto re = SimpleInsertSort(v); return 0;&#125; 运行结果： 1234567849 : 38 65 97 76 13 27 4938 49 : 65 97 76 13 27 4938 49 65 : 97 76 13 27 4938 49 65 97 : 76 13 27 4938 49 65 76 97 : 13 27 4913 38 49 65 76 97 : 27 4913 27 38 49 65 76 97 : 4913 27 38 49 49 65 76 97 简单插入排序的时间复杂度是o(n^2); 折半插入排序(二分插入排序) 简单插入排序没有经过任何的过程优化，我们仔细分析简单插入排序的过程，寻找元素应该插入的位置这一过程是可以优化的。因为是在有序序列中查找，所以可以使用二分查找方法缩短查找的时间。该方法被叫做二分插入排序。 STL中lower_bound(a.begin(),a.end()+ii,a[i]);实现了二分查找算法，我们直接使用它替换原来的循环语句查找出插入位置即可。 12345678910111213141516171819//使用二分查找方法搜索应该插入的位置，此方法叫做二分插入排序// for(int j=0;j&lt;ii-1;j++)&#123;// if(a[ii]&gt;=a[j] &amp;&amp; a[ii]&lt;a[j+1])&#123;// //应当插入j之后// while(ii-1&gt;j)&#123;// a[ii] = a[ii-1];// ii--;// &#125;// a[ii] = curValue;// &#125;// &#125;auto index = lower_bound(a.begin(),a.begin()+ii,a[ii]);//应当插入j之后的位置int j = distance(a.begin(),index)-1;while(ii-1&gt;j)&#123; a[ii] = a[ii-1]; ii--;&#125;a[ii] = curValue; 二路插入排序 缩小增量排序（希尔排序） 简单选择排序 在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。 二元选择排序 简单选择排序，每趟循环只能确定一个元素排序后的定位。我们可以考虑改进为每趟循环确定两个元素（当前趟最大和最小记录）的位置,从而减少排序所需的循环次数。改进后对n个数据进行排序，最多只需进行[n/2]趟循环即可。 堆排序 堆排序就是使用堆维护数据的有序结构，主要的问题是的建堆的操作和堆调整的操作。 交换排序 冒泡排序 冒泡排序总是交换相邻的两个值。 在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。 12345678910111213141516171819202122232425262728293031323334void print(vector&lt;int&gt; v,int i)&#123; int count = 0; for(auto a : v)&#123; if(count == i)&#123; cout&lt;&lt;\" | \"; &#125; cout&lt;&lt;a&lt;&lt;\" \"; count ++; &#125; cout&lt;&lt;endl;&#125;//冒泡排序vector&lt;int&gt; sortTop(vector&lt;int&gt; &amp;v)&#123; int tmp; for(int j=v.size()-1;j&gt;0;j--)&#123; print(v,j+1); for(int i=0;i&lt;j;i++)&#123; if(v[i+1] &lt; v[i])&#123; tmp = v[i]; v[i] = v[i+1]; v[i+1] = tmp; &#125; &#125; &#125; return v;&#125;int main() &#123; vector&lt;int&gt; v = &#123;49,38,65,97,76,13,27,12&#125;; auto a = sortTop(v); print(a); return 0;&#125; 运行结果： 1234567849 38 65 97 76 13 27 1238 49 65 76 13 27 12 | 9738 49 65 13 27 12 | 76 9738 49 13 27 12 | 65 76 9738 13 27 12 | 49 65 76 9713 27 12 | 38 49 65 76 9713 12 | 27 38 49 65 76 9712 13 27 38 49 65 76 97 | 线性时间排序 比较排序依赖元素之间的比较，所以最优的算法的时间复杂度也不会低于O(n*logn);归并排序，堆排序和快速排序都可以达到这一水平。还有一些不依赖元素之间的比较确定元素顺序的排序算法可以达到更低的时间复杂度。例如：计数排序，基数排序和桶排序。 计数排序 计数排序的基本思想是： 开辟一个与最大数的值大小一样的数组，然后把每个数字放到对应的数组中，自然而然就有序了。例如对[9,23,2,100,34,398,5]排序，开辟一个a[399]的数组，然后令a[9] = 1;a[23] = 1;a[2]=1;a[100] = 1; a[34] = 1;a[398] = 1;a[5] = 1;然后从头开始把有值的元素取出来就自然有了顺序。如果有元素的值相等，例如有2个100，只需要让a[100] = 2就行了。下面看看如何取出排序好的数据。 1234567891011121314151617181920212223//计数排序vector&lt;int&gt; countSort(vector&lt;int&gt; &amp;v)&#123; //1.找到最大值，开辟数组 if(v.empty()) return v; int maxValue = v[0]; for(int i=1;i&lt;v.size();i++)&#123; maxValue = v[i] &gt; maxValue ? v[i] : maxValue; &#125; //2. 开辟对应的数组并计数 vector&lt;int&gt; b(maxValue + 1,0); for(int i=0;i&lt;v.size();i++)&#123; b[v[i]] = b[v[i]] + 1; &#125; //3. 取出结果 v.clear(); for(int i=0;i&lt;b.size();i++)&#123; while(b[i]&gt;0)&#123; v.push_back(i); b[i] = b[i] - 1; &#125; &#125; return v;&#125; 上面的代码只能处理非负数的情况。需要注意的是，计数排序当处理有大量重复数字，而数据的范围不大的时候很有用。 ### 基数排序(桶排序) 桶排序是一种时间复杂度可以达到O(n)的排序算法，但是它使用的空间较多，也有较大的限制条件，不适用于所有情况下的排序，只适用特定的情况下的排序。 一种更一般的算法思想是分桶法。它的思想是把元素按照一定的范围分别放在对应的桶中，然后再做相应的处理。分组后处理的复杂度就会降低很多，然后再想办法把每个桶中的结果合并起来。 基数排序专门针对的是整数的排序，（因为字符串也是整数表示的，所以字符串的排序也可以使用桶排序）。这里固定的把桶定为10个，分别对应数字0–9.首先按照个位数字入桶，然后按照十位数字，然后按照百位数字，…直到最高位数字，然后按照顺序取出来就是了。下面以[521 310 72 373 15 546 385 856 187 147]为例子说明具体的过程。 12345678910111213141516171819202122232425262728293031323334353637383940414243// 返回a的第i位数字，// i = 0 个位// i = 1 十位int gg(int a,int i)&#123; int re; while(i&gt;=0)&#123; re = a % 10; a = a / 10; i--; &#125; return re;&#125;vector&lt;int&gt; baseSort(vector&lt;int&gt; &amp;v)&#123; if(v.empty()) return v; int maxValue = v[0]; //找到最大值 for(int i=0;i&lt;v.size();i++)&#123; maxValue = v[i] &gt; maxValue ? v[i] : maxValue; &#125; int high = 0; // 获得最高位，需要循环这么多次 while(maxValue)&#123; maxValue /= 10; high ++; &#125; // i = 0 按照个位入桶，收集 // i = 1 按照十位入桶，收集 // ... for(int i=0;i&lt;high;i++)&#123; vector&lt;vector&lt;int&gt;&gt; t(10,vector&lt;int&gt;(0)); // 入桶操作 for(int j=0;j&lt;v.size();j++)&#123; t[ gg(v[j],i) ].push_back(v[j]); &#125; // 从0号桶开始按照顺序收集 v.clear(); for(auto a : t)&#123; for(auto b : a)&#123; v.push_back(b); &#125; &#125; &#125; return v;&#125; 后记 说明： 当原表有序或基本有序时，直接插入排序和冒泡排序将大大减少比较次数和移动记录的次数，时间复杂度可降至O（n）； 而快速排序则相反，当原表基本有序时，将蜕化为冒泡排序，时间复杂度提高为O（n2）； 原表是否有序，对简单选择排序、堆排序、归并排序和基数排序的时间复杂度影响不大。","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"SPM中函数的修改和使用","slug":"技术/认知神经科学/SPM中函数的修改和使用","date":"2017-04-14T02:52:58.000Z","updated":"2019-03-28T00:54:59.577Z","comments":true,"path":"2017/04/14/技术/认知神经科学/SPM中函数的修改和使用/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/04/14/技术/认知神经科学/SPM中函数的修改和使用/","excerpt":"SPM是处理脑成像数据的一个综合性软件，基于matlab实现，里面有大量的函数都可以抽取出来单独使用完成某一个功能。使用其中的函数工作可以大大提高分析处理数据的便捷性，便于实现批量处理和大规模数据处理。","text":"SPM是处理脑成像数据的一个综合性软件，基于matlab实现，里面有大量的函数都可以抽取出来单独使用完成某一个功能。使用其中的函数工作可以大大提高分析处理数据的便捷性，便于实现批量处理和大规模数据处理。 ### 获得窗口的句柄保存下窗口正在显示的图像 123Fgraph = spm_figure('GetWin','Graphics');h1 = figure(Fgraph);print(h1,Input_VOINames,'-dpng');% 打印出PNG图片，还可以输出其他的格式，参考Matlab的print函数。 打印SPM头信息，包括时间和日期以及执行的函数名称 123spm('FnBanner',mfilename,SVNid);% SPM8: spm_imcalc_extend (v3691) 22:17:00 - 16/11/2016% ======================================================================== 获得文件P的头信息 123P = &#123;'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\pre_processing\\20160911002\\ep2d_bold_moco_p2_rest_0006\\af20160911002-182750-00006-00006-1.img', 'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\pre_processing\\20160911002\\ep2d_bold_moco_p2_rest_0006\\af20160911002-182750-00006-00006-1.img'&#125;;header = spm_vol(P); 获得图像某个坐标的值 123V = &#123;'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\first_level\\20160911002\\beta_0001.img'&#125;;XYZ = [13;48;2];Y = spm_get_data(V,XYZ); ROI的定义 SPM中Region of Interest(ROI)的定义使用的是函数spm_ROI.m,在SPM工具包中查找该名称即可找到它。 SPM中的函数默认都是通过交互的方式获得需要的参数的，类似这样的形式，spm_input('VOI definition...','!+1','b',def,[],1);，当我们需要批量处理的时候，只需要找到相关的参数，注释掉spm_input...，以传入参数替代即可。例如，假如我们想要修改spm_ROI.m使它能够根据输入的MNI坐标定义一个球形的ROI,可以这样修改： 1. 找到下面这段代码： 1234567891011121314151617if ~isfield(xY,'def') def = &#123;'sphere','box','cluster','mask'&#125;; if isfield(xY,'rej') if ~isfield(xY,'M') xY.rej = &#123;xY.rej&#123;:&#125; 'cluster'&#125;; end else if isfield(xY,'M') xY.rej = &#123;&#125;; else xY.rej = &#123;'cluster'&#125;; end end [q, i] = setdiff(def,xY.rej); def = def(sort(i)); xY.def = spm_input('VOI definition...','!+1','b',def,[],1);end 其中最后一条语句xY.def = spm_input('VOI definition...','!+1','b',def,[],1);是定义需要什么类型的ROI的，原来的代码里面需要用户输入，这里我们把这句话注视掉，用xY.def = input_xyz;代替；这里需要注意的是，input_xyz是3行1列的列向量，表示MNI坐标。当不知道数据的格式的时候，最好在matlab命令窗口执行修改之前的spm_input(),查看返回的是什么类型的数据。 2. 然后找到下面的代码： 12345678910case 'sphere' %---------------------------------------------------------------------- if ~isfield(xY,'xyz') || isempty(xY.xyz) xY.xyz = spm_input('sphere centre [x y z] &#123;mm&#125;',... '!+0','r','0 0 0',3); end if ~isfield(xY,'spec') xY.spec = spm_input('sphere radius (mm)','!+0','r',0,1,[0,Inf]); end xY.str = sprintf('%0.1fmm sphere',xY.spec); 这段代码是当上面定义了要使用球形的ROI时，球形ROI需要的一些参数。可以揽到，这里也是用交互的方式输入的参数，这里我们修改成传入参数的形式。 xY.xyz = input_xyz; xY.spec = input_radius; 该函数原来的调用方式是[xY, XYZmm, j] = spm_ROI(xY, XYZmm),由于我们新加入了传入参数，所以我们修改原来的函数为下面这样的形式：[xY, XYZmm, j] = spm_ROI_extend(xY, XYZmm,input_def,input_xyz,input_radius), 最后，最好把新加入的参数的含义写在下面的注释中，这样就可以使用help spm_ROI查看到该函数的使用方法。另外，自己改写的函数最好换一个名字。 一个完整的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183function [xY, XYZmm, j] = spm_ROI_extend(xY, XYZmm,input_def,input_xyz,input_radius)% Region of Interest specification% input_def : one of &#123;'sphere','box','cluster','mask'&#125;;e.g. sphere% input_xyz : MNI_cor, e.g. [2;2;2]% input_radius : r of sphere, e.g. 12% FORMAT xY = spm_ROI(xY)% xY - VOI structure% xY.def - VOI definition [sphere, box, mask, cluster, all]% xY.rej - cell array of disabled VOI definition options% xY.xyz - centre of VOI &#123;mm&#125;% xY.spec - VOI definition parameters% xY.str - description of the VOI%% FORMAT [xY, XYZmm, j] = spm_ROI(xY, XYZmm)% XYZmm - [3xm] locations of voxels &#123;mm&#125;% If an image filename, an spm_vol structure or a NIfTI object is% given instead, XYZmm will be initialised to all voxels within% the field of view of that image.%% XYZmm - [3xn] filtered locations of voxels &#123;mm&#125; (m&gt;=n) within VOI xY% j - [1xn] indices of input locations XYZmm within VOI xY%__________________________________________________________________________% Copyright (C) 2008-2014 Wellcome Trust Centre for Neuroimaging% Karl Friston, Guillaume Flandin% $Id: spm_ROI.m 6079 2014-06-30 18:25:37Z spm $if nargin &lt; 2 &amp;&amp; nargout &gt; 1 error('Too many output arguments.');endtry, xY; catch, xY = []; end%-Specify ROI%==========================================================================if ~isfield(xY,'def') def = &#123;'sphere','box','cluster','mask'&#125;; if isfield(xY,'rej') if ~isfield(xY,'M') xY.rej = &#123;xY.rej&#123;:&#125; 'cluster'&#125;; end else if isfield(xY,'M') xY.rej = &#123;&#125;; else xY.rej = &#123;'cluster'&#125;; end end [q, i] = setdiff(def,xY.rej); def = def(sort(i)); %xY.def = spm_input('VOI definition...','!+1','b',def,[],1); xY.def = input_def; %========&#123;'sphere','box','cluster','mask'&#125;;==============================================end%-ROI parameters%--------------------------------------------------------------------------switch lower(xY.def) case 'sphere' %---------------------------------------------------------------------- if ~isfield(xY,'xyz') || isempty(xY.xyz) %xY.xyz = spm_input('sphere centre [x y z] &#123;mm&#125;',... % '!+0','r','0 0 0',3); xY.xyz = input_xyz; %=========[2;2;2]============================================= end if ~isfield(xY,'spec') %xY.spec = spm_input('sphere radius (mm)','!+0','r',0,1,[0,Inf]); xY.spec = input_radius; % ============12====================================== end xY.str = sprintf('%0.1fmm sphere',xY.spec); case 'box' %---------------------------------------------------------------------- if ~isfield(xY,'xyz') || isempty(xY.xyz) xY.xyz = spm_input('box centre [x y z] &#123;mm&#125;',... '!+0','r','0 0 0',3); end if ~isfield(xY,'spec') xY.spec = spm_input('box dimensions [x y z] &#123;mm&#125;',... '!+0','r','0 0 0',3); end if length(xY.spec) &lt; 3 xY.spec = xY.spec(1)*[1 1 1]; end xY.str = sprintf('%0.1f x %0.1f x %0.1f mm box',xY.spec); case 'mask' %---------------------------------------------------------------------- if ~isfield(xY,'spec') xY.spec = spm_vol(spm_select(1,'image','Specify Mask')); else if ~isstruct(xY.spec) xY.spec = spm_vol(xY.spec); end end str = spm_file(xY.spec.fname,'short30'); str = regexprep(str, &#123;'\\\\' '\\^' '_' '&#123;' '&#125;'&#125;, ... &#123;'\\\\\\\\' '\\\\^' '\\\\_' '\\\\&#123;' '\\\\&#125;'&#125;); % Escape TeX special characters xY.str = sprintf('image mask: %s',str); case 'cluster' %---------------------------------------------------------------------- if ~isfield(xY,'xyz') || isempty(xY.xyz) xY.xyz = spm_input('seed voxel [x y z] &#123;mm&#125;',... '!+0','r','0 0 0',3); end if ~isfield(xY,'M') xY.M = spm_input('affine transformation matrix',... '!+0','r','0 0 0',[4 4]); end xY.spec = []; xY.str = sprintf('cluster (seed voxel: %0.1f %0.1f %0.1f)',xY.xyz); case 'all' %---------------------------------------------------------------------- xY.str = 'all'; otherwise %---------------------------------------------------------------------- error('Unknown VOI type.');endif nargin &lt; 2, return; end%-'Estimate' ROI%==========================================================================%-Argument check%--------------------------------------------------------------------------if ischar(XYZmm) &amp;&amp; isempty(XYZmm) XYZmm = spm_select(1,'image','Specify Image');endif ischar(XYZmm), XYZmm = spm_vol(XYZmm); endif isa(XYZmm,'nifti') XYZmm = struct('dim',size(XYZmm.dat), 'mat',XYZmm.mat);endif isstruct(XYZmm) % spm_vol [R,C,P] = ndgrid(1:XYZmm.dim(1),1:XYZmm.dim(2),1:XYZmm.dim(3)); RCP = [R(:)';C(:)';P(:)';ones(1,numel(R))]; XYZmm = XYZmm.mat(1:3,:)*RCP; clear R C P RCPendif isempty(XYZmm), XYZmm = zeros(3,0); end%-Filter location of voxels%--------------------------------------------------------------------------Q = ones(1,size(XYZmm,2));switch lower(xY.def) case 'sphere' %---------------------------------------------------------------------- j = find(sum((XYZmm - xY.xyz*Q).^2) &lt;= xY.spec^2); case 'box' %---------------------------------------------------------------------- j = find(all(abs(XYZmm - xY.xyz*Q) &lt;= xY.spec(:)*Q/2)); case 'mask' %---------------------------------------------------------------------- XYZ = xY.spec.mat \\ [XYZmm; Q]; j = find(spm_sample_vol(xY.spec, XYZ(1,:), XYZ(2,:), XYZ(3,:),0) &gt; 0); case 'cluster' %---------------------------------------------------------------------- [x, i] = spm_XYZreg('NearestXYZ',xY.xyz,XYZmm); XYZ = round(xY.M \\ [XYZmm; Q]); A = spm_clusters(XYZ); j = find(A == A(i)); case 'all' %---------------------------------------------------------------------- j = 1:size(XYZmm,2); otherwise %---------------------------------------------------------------------- error('Unknown VOI type.');endXYZmm = XYZmm(:,j);if strcmpi(xY.def,'mask') &amp;&amp; ~isempty(XYZmm), xY.xyz = mean(XYZmm,2); end 根据SPM.mat获得SPM，xSPM等结构数据 Compute a specified and thresholded SPM following estimation 实现上面图形界面所定义的操作，选择一个Contrast, 定义一个P值的大小，得到相关的图像结构信息，SPM中的函数是spm_getSPM, 函数调用的原型是[SPM,xSPM] = spm_getSPM(varargin), 它的主要作用是通过SPM.mat文件获得SPM,xSPM等结构，这两种结构在后在许多方法中作为输入参数。 SPM中Result面板中对应的函数 想实现这个面板中的一些操作功能，可以查看对应的函数spm_result_ui; 1234% FORMAT [hreg,xSPM,SPM] = spm_results_ui('Setup',xSPM)% Query SPM and setup GUI using a xSPM input structure. This allows to run% results setup without user interaction. See spm_getSPM for details of% allowed fields. 抽取时间序列函数 在结果面板中抽取时间序列的操作主要涉及到两个函数，spm_regions和spm_ROI;最核心的定义ROI的代码在spm_ROI中。 附上一个可以根据输入的坐标抽取球形VOI的修改版代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233function [Y,xY] = spm_regions_extend(xSPM,SPM,hReg,xY,Input_VOINames,Input_is,input_def,input_xyz,input_radius)% VOI time-series extraction of adjusted data (&amp; local eigenimage analysis)% FORMAT [Y xY] = spm_regions(xSPM,SPM,hReg,[xY]);% FORMAT [Y xY] = spm_regions(xSPM,SPM,hReg,[xY],Input_VOIName,Input_i)% Input_VOIName : 抽取的VOI的名称% Input_i : adjust_contrst 这里选择那个F-All的,整数，1 是dont adjust, 2 是F-All.% Input_VOI_path : 抽取VOI所使用的Mask的路径;% Input_is : Input_i% input_def : ROI类型的定义,sphere% input_xyz : MNI 坐标% input_radius : 半径if nargin &lt; 4, xY = []; endif nargin &gt; 5 Input_VOIName = Input_VOINames; Input_i =Input_is; xY = [];end%-Get figure handles%--------------------------------------------------------------------------Finter = spm_figure('FindWin','Interactive');if isempty(Finter), noGraph = 1; else noGraph = 0; endheader = get(Finter,'Name');set(Finter,'Name','VOI time-series extraction');if ~noGraph, Fgraph = spm_figure('GetWin','Graphics'); end%-Find nearest voxel [Euclidean distance] in point list%--------------------------------------------------------------------------% if isempty(xSPM.XYZmm)% spm('alert!','No suprathreshold voxels!',mfilename,0);% Y = []; xY = [];% return% end% try% xyz = xY.xyz;% catch% xyz = spm_XYZreg('NearestXYZ',...% spm_XYZreg('GetCoords',hReg),xSPM.XYZmm);% xY.xyz = xyz;% end% and update GUI location%--------------------------------------------------------------------------%spm_XYZreg('SetCoords',xyz,hReg);%-Get adjustment options and VOI name%--------------------------------------------------------------------------% if ~noGraph% if ~isempty(xY.xyz)% posstr = sprintf('at [%3.0f %3.0f %3.0f]',xY.xyz);% else% posstr = '';% end% spm_input(posstr,1,'d','VOI time-series extraction');% endif ~isfield(xY,'name') xY.name = Input_VOIName; %name of region char字符串类型 ========================================================================endif ~isfield(xY,'Ic') q = 0; Con = &#123;'&lt;don''t adjust&gt;'&#125;; for i = 1:length(SPM.xCon) if strcmp(SPM.xCon(i).STAT,'F') q(end + 1) = i; Con&#123;end + 1&#125; = SPM.xCon(i).name; end end i = Input_i; % adjust_contrst 这里选择那个F-All的,整数，1 是dont adjust, 2 是F-All. ===================================================================== xY.Ic = q(i);end%-If fMRI data then ask user to select session%--------------------------------------------------------------------------if isfield(SPM,'Sess') &amp;&amp; ~isfield(xY,'Sess') s = length(SPM.Sess); if s &gt; 1 s = spm_input('which session','!+1','n1',s,s); end xY.Sess = s;end%-Specify VOI%--------------------------------------------------------------------------xY.M = xSPM.M;[xY, xY.XYZmm, Q] = spm_ROI_extend(xY, xSPM.XYZmm,input_def,input_xyz,input_radius);%--------------------------------------------------------------------try, xY = rmfield(xY,'M'); endtry, xY = rmfield(xY,'rej'); endif isempty(xY.XYZmm) warning('Empty region.'); Y = []; return;end%-Extract required data from results files%==========================================================================spm('Pointer','Watch')%-Get raw data, whiten and filter%--------------------------------------------------------------------------y = spm_get_data(SPM.xY.VY,xSPM.XYZ(:,Q));y = spm_filter(SPM.xX.K,SPM.xX.W*y);%-Computation%==========================================================================%-Remove null space of contrast%--------------------------------------------------------------------------if xY.Ic %-Parameter estimates: beta = xX.pKX*xX.K*y %---------------------------------------------------------------------- beta = spm_get_data(SPM.Vbeta,xSPM.XYZ(:,Q)); %-subtract Y0 = XO*beta, Y = Yc + Y0 + e %---------------------------------------------------------------------- y = y - spm_FcUtil('Y0',SPM.xCon(xY.Ic),SPM.xX.xKXs,beta);end%-Confounds%--------------------------------------------------------------------------xY.X0 = SPM.xX.xKXs.X(:,[SPM.xX.iB SPM.xX.iG]);%-Extract session-specific rows from data and confounds%--------------------------------------------------------------------------try i = SPM.Sess(xY.Sess).row; y = y(i,:); xY.X0 = xY.X0(i,:);end% and add session-specific filter confounds%--------------------------------------------------------------------------try xY.X0 = [xY.X0 SPM.xX.K(xY.Sess).X0];endtry xY.X0 = [xY.X0 SPM.xX.K(xY.Sess).KH]; % Compatibility checkend%-Remove null space of X0%--------------------------------------------------------------------------xY.X0 = xY.X0(:,any(xY.X0));%-Compute regional response in terms of first eigenvariate%--------------------------------------------------------------------------[m n] = size(y);if m &gt; n [v s v] = svd(y'*y); s = diag(s); v = v(:,1); u = y*v/sqrt(s(1));else [u s u] = svd(y*y'); s = diag(s); u = u(:,1); v = y'*u/sqrt(s(1));endd = sign(sum(v));u = u*d;v = v*d;Y = u*sqrt(s(1)/n);%-Set in structure%--------------------------------------------------------------------------xY.y = y;xY.u = Y;xY.v = v;xY.s = s;%-Display VOI weighting and eigenvariate%==========================================================================if ~noGraph % show position %---------------------------------------------------------------------- spm_results_ui('Clear',Fgraph); h1 = figure(Fgraph); subplot(2,2,3) spm_dcm_display(xY) % show dynamics %---------------------------------------------------------------------- subplot(2,2,4) try plot(SPM.xY.RT*[1:length(xY.u)],Y) str = 'time (seconds&#125;'; catch plot(Y) str = 'scan'; end title(['1st eigenvariate: ' xY.name],'FontSize',10) if strcmpi(xY.def,'mask') [p,n,e] = fileparts(xY.spec.fname); posstr = sprintf('from mask %s', [n e]); else posstr = sprintf('at [%3.0f %3.0f %3.0f]',xY.xyz); end str = &#123; str;' ';... sprintf('%d voxels in VOI %s',length(Q),posstr);... sprintf('Variance: %0.2f%%',s(1)*100/sum(s))&#125;; xlabel(str) axis tight squareend%-Save%==========================================================================str = ['VOI_' xY.name '.mat'];if isfield(xY,'Sess') &amp;&amp; isfield(SPM,'Sess') str = sprintf('VOI_%s_%i.mat',xY.name,xY.Sess);endif spm_check_version('matlab','7') &gt;= 0 save(fullfile(SPM.swd,str),'-V6','Y','xY')else save(fullfile(SPM.swd,str),'Y','xY')endfprintf(' VOI saved as %s\\n',spm_str_manip(fullfile(SPM.swd,str),'k55'));%-Reset title%--------------------------------------------------------------------------set(Finter,'Name',header);spm('Pointer','Arrow')print(h1,Input_VOINames,'-dpng');% 打印出PNG图片，还可以输出其他的格式，参考Matlab的print函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183function [xY, XYZmm, j] = spm_ROI_extend(xY, XYZmm,input_def,input_xyz,input_radius)% Region of Interest specification% input_def : one of &#123;'sphere','box','cluster','mask'&#125;;e.g. sphere% input_xyz : MNI_cor, e.g. [2;2;2]% input_radius : r of sphere, e.g. 12% FORMAT xY = spm_ROI(xY)% xY - VOI structure% xY.def - VOI definition [sphere, box, mask, cluster, all]% xY.rej - cell array of disabled VOI definition options% xY.xyz - centre of VOI &#123;mm&#125;% xY.spec - VOI definition parameters% xY.str - description of the VOI%% FORMAT [xY, XYZmm, j] = spm_ROI(xY, XYZmm)% XYZmm - [3xm] locations of voxels &#123;mm&#125;% If an image filename, an spm_vol structure or a NIfTI object is% given instead, XYZmm will be initialised to all voxels within% the field of view of that image.%% XYZmm - [3xn] filtered locations of voxels &#123;mm&#125; (m&gt;=n) within VOI xY% j - [1xn] indices of input locations XYZmm within VOI xY%__________________________________________________________________________% Copyright (C) 2008-2014 Wellcome Trust Centre for Neuroimaging% Karl Friston, Guillaume Flandin% $Id: spm_ROI.m 6079 2014-06-30 18:25:37Z spm $if nargin &lt; 2 &amp;&amp; nargout &gt; 1 error('Too many output arguments.');endtry, xY; catch, xY = []; end%-Specify ROI%==========================================================================if ~isfield(xY,'def') def = &#123;'sphere','box','cluster','mask'&#125;; if isfield(xY,'rej') if ~isfield(xY,'M') xY.rej = &#123;xY.rej&#123;:&#125; 'cluster'&#125;; end else if isfield(xY,'M') xY.rej = &#123;&#125;; else xY.rej = &#123;'cluster'&#125;; end end [q, i] = setdiff(def,xY.rej); def = def(sort(i)); %xY.def = spm_input('VOI definition...','!+1','b',def,[],1); xY.def = input_def; %========&#123;'sphere','box','cluster','mask'&#125;;==============================================end%-ROI parameters%--------------------------------------------------------------------------switch lower(xY.def) case 'sphere' %---------------------------------------------------------------------- if ~isfield(xY,'xyz') || isempty(xY.xyz) %xY.xyz = spm_input('sphere centre [x y z] &#123;mm&#125;',... % '!+0','r','0 0 0',3); xY.xyz = input_xyz; %=========[2;2;2]============================================= end if ~isfield(xY,'spec') %xY.spec = spm_input('sphere radius (mm)','!+0','r',0,1,[0,Inf]); xY.spec = input_radius; % ============12====================================== end xY.str = sprintf('%0.1fmm sphere',xY.spec); case 'box' %---------------------------------------------------------------------- if ~isfield(xY,'xyz') || isempty(xY.xyz) xY.xyz = spm_input('box centre [x y z] &#123;mm&#125;',... '!+0','r','0 0 0',3); end if ~isfield(xY,'spec') xY.spec = spm_input('box dimensions [x y z] &#123;mm&#125;',... '!+0','r','0 0 0',3); end if length(xY.spec) &lt; 3 xY.spec = xY.spec(1)*[1 1 1]; end xY.str = sprintf('%0.1f x %0.1f x %0.1f mm box',xY.spec); case 'mask' %---------------------------------------------------------------------- if ~isfield(xY,'spec') xY.spec = spm_vol(spm_select(1,'image','Specify Mask')); else if ~isstruct(xY.spec) xY.spec = spm_vol(xY.spec); end end str = spm_file(xY.spec.fname,'short30'); str = regexprep(str, &#123;'\\\\' '\\^' '_' '&#123;' '&#125;'&#125;, ... &#123;'\\\\\\\\' '\\\\^' '\\\\_' '\\\\&#123;' '\\\\&#125;'&#125;); % Escape TeX special characters xY.str = sprintf('image mask: %s',str); case 'cluster' %---------------------------------------------------------------------- if ~isfield(xY,'xyz') || isempty(xY.xyz) xY.xyz = spm_input('seed voxel [x y z] &#123;mm&#125;',... '!+0','r','0 0 0',3); end if ~isfield(xY,'M') xY.M = spm_input('affine transformation matrix',... '!+0','r','0 0 0',[4 4]); end xY.spec = []; xY.str = sprintf('cluster (seed voxel: %0.1f %0.1f %0.1f)',xY.xyz); case 'all' %---------------------------------------------------------------------- xY.str = 'all'; otherwise %---------------------------------------------------------------------- error('Unknown VOI type.');endif nargin &lt; 2, return; end%-'Estimate' ROI%==========================================================================%-Argument check%--------------------------------------------------------------------------if ischar(XYZmm) &amp;&amp; isempty(XYZmm) XYZmm = spm_select(1,'image','Specify Image');endif ischar(XYZmm), XYZmm = spm_vol(XYZmm); endif isa(XYZmm,'nifti') XYZmm = struct('dim',size(XYZmm.dat), 'mat',XYZmm.mat);endif isstruct(XYZmm) % spm_vol [R,C,P] = ndgrid(1:XYZmm.dim(1),1:XYZmm.dim(2),1:XYZmm.dim(3)); RCP = [R(:)';C(:)';P(:)';ones(1,numel(R))]; XYZmm = XYZmm.mat(1:3,:)*RCP; clear R C P RCPendif isempty(XYZmm), XYZmm = zeros(3,0); end%-Filter location of voxels%--------------------------------------------------------------------------Q = ones(1,size(XYZmm,2));switch lower(xY.def) case 'sphere' %---------------------------------------------------------------------- j = find(sum((XYZmm - xY.xyz*Q).^2) &lt;= xY.spec^2); case 'box' %---------------------------------------------------------------------- j = find(all(abs(XYZmm - xY.xyz*Q) &lt;= xY.spec(:)*Q/2)); case 'mask' %---------------------------------------------------------------------- XYZ = xY.spec.mat \\ [XYZmm; Q]; j = find(spm_sample_vol(xY.spec, XYZ(1,:), XYZ(2,:), XYZ(3,:),0) &gt; 0); case 'cluster' %---------------------------------------------------------------------- [x, i] = spm_XYZreg('NearestXYZ',xY.xyz,XYZmm); XYZ = round(xY.M \\ [XYZmm; Q]); A = spm_clusters(XYZ); j = find(A == A(i)); case 'all' %---------------------------------------------------------------------- j = 1:size(XYZmm,2); otherwise %---------------------------------------------------------------------- error('Unknown VOI type.');endXYZmm = XYZmm(:,j);if strcmpi(xY.def,'mask') &amp;&amp; ~isempty(XYZmm), xY.xyz = mean(XYZmm,2); end 调用上面两个函数的实现创建VOI的功能： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function createVOI(spmT_filepath,spm_mat_path)% 功能： 使用特定的Mask抽取VOI。% spm_mat_path : SPM.mat的完整路径，需要是做完FirstLevel之后的SPM.mat;% Input_u : 抽取时间序列时使用的P值，一般默认是0.001，当抽取失败的时候，，适当调大可以确保成功；% -----------------------------------------------------------------------------------------% 配置信息：% contrast_name ： First_Level时候设置的contrast,这里的顺序很重要，因为程序中使用数字表示每个contrast的；% InputMask ： appying mask : 0 none ; 1 contrast ; 2 image ;默认是整数 0% InputthresDesc : p value adjustment to control: 'FWE' or 'none'% Input_k : extend threshold &#123;voxel&#125; 0 ; 默认是0% xx_mask_path : 抽取的VOI使用的mask的绝对路径% VOI_Mask ：抽取的VOI使用的mask的绝对路径% Input_is ： adjust_contrst 这里选择那个F-All的,整数，1 是dont adjust, 2 是F-All，3个数字分别对应三个Mask的adjust_contrst。%spmT_filepath = 'D:\\FMRI_ROOT\\YANTAI2\\ANALYSIS\\first_level_dcm_4class\\HC\\20160911002\\spmF_0001.nii';%spm_mat_path = 'D:\\FMRI_ROOT\\YANTAI2\\ANALYSIS\\first_level_dcm_4class\\HC\\20160911002\\SPM.mat';%xjview(spmT_filepath);input_xyz_LMGN = [-12;-24;-8];input_xyz_LA1 = [-54;-14;2];input_xyz_LV1 = [-6;-74;6];xyz_LMGN = find_peak_co(spmT_filepath,input_xyz_LMGN);xyz_LA1 = find_peak_co(spmT_filepath,input_xyz_LA1);xyz_LV1 = find_peak_co(spmT_filepath,input_xyz_LV1);Ic = 1; % 要使用的contrast的编号，这里1是第一个contrast,这里是F contrastInputMask = 0; % 不使用maskInputthresDesc = 'none';Input_u = 0.05; % 抽取VOI时使用的P值Input_k = 0;empty_bit='';Input_is = 2;input_def = 'sphere';input_radius = 12;VOI_name = 'LMGN'; %生成的VOI的名称input_xyz = xyz_LMGN;[SPM,xSPM] = spm_getSPM_extend(spm_mat_path,Ic,InputMask,InputthresDesc,Input_u,Input_k);[hReg,xSPM,SPM] = spm_result_ui_extend('Setup',xSPM);[Y xY] = spm_regions_extend(xSPM,SPM,hReg,empty_bit,VOI_name,Input_is,input_def,input_xyz,input_radius);VOI_name = 'LA1'; %生成的VOI的名称input_xyz = xyz_LA1;[SPM,xSPM] = spm_getSPM_extend(spm_mat_path,Ic,InputMask,InputthresDesc,Input_u,Input_k);[hReg,xSPM,SPM] = spm_result_ui_extend('Setup',xSPM);[Y xY] = spm_regions_extend(xSPM,SPM,hReg,empty_bit,VOI_name,Input_is,input_def,input_xyz,input_radius);VOI_name = 'LV1'; %生成的VOI的名称input_xyz = xyz_LV1;[SPM,xSPM] = spm_getSPM_extend(spm_mat_path,Ic,InputMask,InputthresDesc,Input_u,Input_k);[hReg,xSPM,SPM] = spm_result_ui_extend('Setup',xSPM);[Y xY] = spm_regions_extend(xSPM,SPM,hReg,empty_bit,VOI_name,Input_is,input_def,input_xyz,input_radius);","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"认知神经科学","slug":"技术/认知神经科学","permalink":"http://ff120.github.io/hexoblog/categories/技术/认知神经科学/"}],"tags":[{"name":"SPM","slug":"SPM","permalink":"http://ff120.github.io/hexoblog/tags/SPM/"}]},{"title":"XJVIEW的使用技巧","slug":"技术/认知神经科学/XJVIEW的使用技巧","date":"2017-04-14T01:53:17.000Z","updated":"2019-03-28T00:54:59.637Z","comments":true,"path":"2017/04/14/技术/认知神经科学/XJVIEW的使用技巧/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/04/14/技术/认知神经科学/XJVIEW的使用技巧/","excerpt":"xjview是用来查看大脑激活图像的比较好用的软件，它基于matlab和SPM开发而成。如果需要批量处理一些数据，可能设计到提取里面的代码。下面介绍一些xjview的命令用法。","text":"xjview是用来查看大脑激活图像的比较好用的软件，它基于matlab和SPM开发而成。如果需要批量处理一些数据，可能设计到提取里面的代码。下面介绍一些xjview的命令用法。 ### 显示激活图像 12spmT_filepath = 'D:\\spmF_0001.nii';xjview(spmT_filepath); %显示一幅激活图像，显示多幅可以用逗号隔开 找到激活最大值 1234567h = spm_mip_ui('FindMIPax');% loc - String defining jump: 'dntmv' - don't move% 'nrvox' - nearest suprathreshold voxel% 'nrmax' - nearest local maxima% 'glmax' - global maximaloc = 'glmax';xyz = spm_mip_ui('Jump',h,loc); % 更换loc参数，实现不同的找到最大值的方法。 根据某个坐标找到局部激活最大值 1234h = spm_mip_ui('FindMIPax');hC = 0;[xyz,d] = spm_mip_ui('SetCoords',[-14,-26,-6],h,hC);% xyz是找出来的坐标，d是移动的距离 查看某个坐标在图像中的位置 1xjview([20 10 1],[10]); % 后面的[10]是赋值给该点的激活强度，为了颜色的显示。","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"认知神经科学","slug":"技术/认知神经科学","permalink":"http://ff120.github.io/hexoblog/categories/技术/认知神经科学/"}],"tags":[{"name":"XJVIEW","slug":"XJVIEW","permalink":"http://ff120.github.io/hexoblog/tags/XJVIEW/"}]},{"title":"DCM模型的定义和估计","slug":"技术/认知神经科学/DCM模型的定义和估计","date":"2017-04-13T11:30:53.000Z","updated":"2019-03-28T00:54:59.443Z","comments":true,"path":"2017/04/13/技术/认知神经科学/DCM模型的定义和估计/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/04/13/技术/认知神经科学/DCM模型的定义和估计/","excerpt":"DCM，中文名称动态因果模型，是一种用来研究脑区之间因果关系的一种模型。它从神经元水平建模，一般使用双线性模型表达神经元的响应。可以用来验证哪个模型与实验的数据最匹配。","text":"DCM，中文名称动态因果模型，是一种用来研究脑区之间因果关系的一种模型。它从神经元水平建模，一般使用双线性模型表达神经元的响应。可以用来验证哪个模型与实验的数据最匹配。 ## VOI抽取 DCM模型的定义需要得到感兴趣脑区的VOI，所以VOI的抽取是DCM模型定义的第一步。 DCM模型的定义 12345678910111213141516171819202122232425262728293031function DCM = create_dcm(subject_path,VOIs,Input_a,Input_b,Input_c,name)%功能： 定义DCM模型，需要先做完抽取VOI，在FirstLevel文件夹下面VOI_开头的文件；%subject_path : First_Level 被试目录， eg.D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\first_level_dcm_w_whole\\20160716002\\%condition_name : SPM.mat 设计矩阵中定义的条件，这里用来给生成的DCM命名。%---------------------------------------------------------------%-配置----------------------------------------------------------%Input_a : DCM模型矩阵，需要更改模型的时候，修改这个矩阵%Input_b : 调节输入%Input_c : 外界输入%-配置结束------------------------------------------------------%subject_path = 'D:\\FMRI_ROOT\\YANTAI2\\ANALYSIS\\first_level_dcm_4class\\CB\\20161215002\\';cd(subject_path);spmmatfile = [subject_path,'SPM.mat'];%name ='FULL'; % 生成的DCM模型的名称；condition_mask = [1,1,1,1];TE = 0.04; % TE%Input_a = [1,1,1;1,1,1;1,1,1]; % 定义DCM模型的连接矩阵%Input_b = [0,0,0;0,0,0;0,0,0]; % 定义调节参数%Input_c = [1,1,1,1;0,0,0,0;0,0,0,0]; % 定义输入参数% 获得VOI%------------------------------------------------%VOIs=&#123;'D:\\FMRI_ROOT\\YANTAI2\\ANALYSIS\\first_level_dcm_4class\\CB\\20161215002\\VOI_LMGN_1.mat'; % 'D:\\FMRI_ROOT\\YANTAI2\\ANALYSIS\\first_level_dcm_4class\\CB\\20161215002\\VOI_LA1_1.mat'; % 'D:\\FMRI_ROOT\\YANTAI2\\ANALYSIS\\first_level_dcm_4class\\CB\\20161215002\\VOI_LV1_1.mat'&#125;;%-------------------------------------------------DCM = spm_dcm_specify_extend(spmmatfile,name,VOIs,condition_mask,TE,Input_a,Input_b,Input_c);clear name;clear VOIs;clear condition_mask;%spm_dcm_estimate(DCM); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376function DCM = spm_dcm_specify_extend(spmmatfile,name,VOIs,condition_mask,TE,Input_a,Input_b,Input_c)% Specify inputs of a DCM% FORMAT [DCM] = spm_dcm_specify%% DCM - the DCM structure (see spm_dcm_ui)%__________________________________________________________________________% Copyright (C) 2008 Wellcome Trust Centre for Neuroimaging% Karl Friston% $Id: spm_dcm_specify.m 4185 2011-02-01 18:46:18Z guillaume $%-Interactive window%--------------------------------------------------------------------------Finter = spm_figure('GetWin','Interactive');bcolor = get(Finter,'color');WS = spm('WinScale');dx = 20;spm_input('Specify DCM:... ',1,'d');%==========================================================================% Get design and directory%==========================================================================%[spmmatfile, sts] = spm_select(1,'^SPM\\.mat$','Select SPM.mat');%spmmatfile = 'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\first_level_dcm_w_whole\\20160716002\\SPM.mat';sts = 1;if ~sts, DCM = []; return; endswd = spm_str_manip(spmmatfile,'H');try load(fullfile(swd,'SPM.mat'))catch error(['Cannot read ' fullfile(swd,'SPM.mat')]);end%==========================================================================% Name%==========================================================================%name = spm_input('name for DCM_???.mat','+1','s');%name = 'HG_DCM';%==========================================================================% Outputs%==========================================================================%-Get cell array of region structures%--------------------------------------------------------------------------% VOI1_path = 'd:\\fmri_root\\yantai\\aNALYSIS\\first_level_dcm_w_whole\\20160716002\\VOI_HG_DW_1.mat';% VOI2_path = 'd:\\fmri_root\\yantai\\aNALYSIS\\first_level_dcm_w_whole\\20160716002\\VOI_MFG_DW_1.mat';% VOI3_path = 'd:\\fmri_root\\yantai\\aNALYSIS\\first_level_dcm_w_whole\\20160716002\\VOI_STG_DW_1.mat';% VOIs = &#123;VOI1_path;VOI2_path;VOI3_path&#125;;%P = cellstr(spm_select([1 8],'^VOI.*\\.mat$',&#123;'select VOIs'&#125;,'',swd));P = VOIs;m = numel(P);for i = 1:m p = load(P&#123;i&#125;,'xY'); xY(i) = p.xY;end%==========================================================================% Inputs%==========================================================================%-Get (nc) 'causes' or inputs U%--------------------------------------------------------------------------spm_input('Input specification:... ',1,'d');Sess = SPM.Sess(xY(1).Sess);%condition_mask = [1,0,0,0]; % 閰嶇疆鍖呭惈鍝釜鏉′欢锛屼笉鍖呭惈鍝釜鏉′欢锛?if isempty(Sess.U) % spontaneous activity, i.e. no stimuli nc = 0; U = [];else % with stimuli U.dt = Sess.U(1).dt; u = length(Sess.U); U.name = &#123;&#125;; U.u = []; for i = 1:u %i 鏄潯浠剁殑缂栧彿 1锛?JX锛? 2锛?DW 3锛?RL 4锛?ZR for j = 1:length(Sess.U(i).name) str = ['include ' Sess.U(i).name&#123;j&#125; '?']; % include JX if condition_mask(i)%spm_input(str,'+1','y/n',[1 0],1) include JX20 ,yes 1 ; no 0; U.u = [U.u Sess.U(i).u(33:end,j)]; U.name&#123;end + 1&#125; = Sess.U(i).name&#123;j&#125;; end end end nc = size(U.u,2);end%==========================================================================% Timings%==========================================================================spm_input('Timing information:... ',-1,'d');%-Slice timings%--------------------------------------------------------------------------RT = SPM.xY.RT;%delays = spm_input('Slice timings [s]','+1','r', repmat(RT,1,m),m,[0 RT]);delays = repmat(RT,1,m)';%-Echo time (TE) of data acquisition%--------------------------------------------------------------------------%TE = 0.04; %==================================================================鑷繁杈撳叆TE鐨勫?====================TE_ok = 0;while ~TE_ok %TE = spm_input('Echo time, TE [s]', '+1', 'r', TE); if ~TE || (TE &lt; 0) || (TE &gt; 0.1) str = &#123; 'Extreme value for TE or TE undefined.',... 'Please re-enter TE (in seconds!)'&#125;; spm_input(str,'+1','bd','OK',[1],1); else TE_ok = 1; endend%==========================================================================% Model options%==========================================================================if nc % there are inputs spm_input('Model options:... ',-1,'d'); %options.nonlinear = spm_input('modulatory effects','+1','b',&#123;'bilinear','nonlinear'&#125;,[0 1],1); options.nonlinear = 0; %modulatory effects : 0: bilinear , 1: nonlinear %options.two_state = spm_input('states per region', '+1','b',&#123;'one','two'&#125;,[0 1],1); options.two_state = 0 ; % states per region ; 0: one ; 1 : two %options.stochastic = spm_input('stochastic effects','+1','b',&#123;'no','yes'&#125;,[0 1],1); options.stochastic = 0 ; %stochastic effects; 0 : no ; 1 : yes, %options.centre = spm_input('centre input', '+1','b',&#123;'no','yes'&#125;,[0 1],1); options.centre = 0 ; % centre input ; 0 : no 1: yes; options.endogenous = 0;else options.nonlinear = 0; options.two_state = 0; options.stochastic = 1; options.centre = 1; options.endogenous = 1;end%==========================================================================% Graph connections%==========================================================================a = zeros(m,m);if options.endogenous b = zeros(m,m,1); c = zeros(m,1);else b = zeros(m,m,nc); c = zeros(m,nc);endd = zeros(m,m,0);%-Intrinsic connections (A matrix)%==========================================================================%-Buttons and labels%--------------------------------------------------------------------------spm_input('Specify intrinsic connections from',1,'d')spm_input('to',3,'d')for i = 1:m str = sprintf('%s %i',xY(i).name,i); h1(i) = uicontrol(Finter,'String',str,... 'Style','text',... 'FontSize',10,... 'BackgroundColor',bcolor,... 'HorizontalAlignment','right',... 'Position',[080 350-dx*i 080 020].*WS); h2(i) = uicontrol(Finter,'String',sprintf('%i',i),... 'Style','text',... 'FontSize',10,... 'BackgroundColor',bcolor,... 'Position',[180+dx*i 350 010 020].*WS);endfor i = 1:m for j = 1:m h3(i,j) = uicontrol(Finter,... 'Position',[180+dx*j 350-dx*i 020 020].*WS,... 'BackgroundColor',bcolor,... 'Style','radiobutton'); if i == j set(h3(i,j),'Value',1,... 'enable','off'); else set(h3(i,j),'enable','on','TooltipString', ... sprintf('from %s to %s',xY(j).name,xY(i).name)); end if nc &amp;&amp; i~=j set(h3(i,j),'Value',0); else set(h3(i,j),'Value',1); end endenduicontrol(Finter,'String','done','Position', [300 100 060 020].*WS,... 'Callback', 'uiresume(gcbf)');%uiwait(Finter);%-Get a a 灏辨槸DCM妯″瀷鐨勮繛鎺ョ煩闃?%--------------------------------------------------------------------------%for i = 1:m% for j = 1:m% a(i,j) = get(h3(i,j),'Value');% end%end%a = [1,1,1;1,1,1;1,1,1]; %=========================================================瀹氫箟鐨凞CM妯″瀷锛屾澶勬湁涓変釜鑺傜偣锛屾墍浠ユ槸3*3鐨勭煩闃碉紱a = Input_a;delete(findobj(get(Finter,'Children'),'flat'));%-Effects of causes (B and C matrices)%==========================================================================uicontrol(Finter,'String','done','Position', [300 100 060 020].*WS,... 'Callback', 'uiresume(gcbf)');for k = 1:nc %-Buttons and labels %---------------------------------------------------------------------- str = sprintf(... 'Effects of %-12s on regions... and connections',... U.name&#123;k&#125;); spm_input(str,1,'d'); % Effects of JX on regions... and connections for i = 1:m h1(i) = uicontrol(Finter,'String',xY(i).name,... 'Style','text',... 'BackgroundColor',bcolor,... 'FontSize',10,... 'Position',[080 350-dx*i 080 020].*WS); h2(i) = uicontrol(Finter,... 'Position',[160 360-dx*i 020 020].*WS,... 'BackgroundColor',bcolor,... 'Style','radiobutton'); end for i = 1:m for j = 1:m if a(i,j) == 1 % Allow modulation of intrinsic connections %---------------------------------------------------------- h3(i,j) = uicontrol(Finter,... 'Position',[220+dx*j 360-dx*i 020 020].*WS,... 'BackgroundColor',bcolor,... 'Style','radiobutton'); set(h3(i,j),'TooltipString', ... sprintf('from %s to %s',xY(j).name,xY(i).name)); end end end %uiwait(Finter); %-Get c 灏辨槸宸﹁竟鐨勭涓?垪锛屼唬琛ㄨ緭鍏ュ姞鍦ㄩ偅涓剳鍖轰笂锛? * 1 %---------------------------------------------------------------------- %for i = 1:m %c(i,k) = get(h2(i),'Value'); %end %c = [1,0,0]; c = Input_c; %-Get b allowing any 2nd order effects 3*3 鐨勭煩闃碉紝浠ｈ〃璋冭妭鍙橀噺鍦ㄥ摢鏉＄嚎涓娿?杩欓噷鏈変笁涓尯鍩燂紝鎵?互鏄?*3 %---------------------------------------------------------------------- % for i = 1:m % for j = 1:m % if a(i,j)==1 % b(i,j,k) = get(h3(i,j),'Value'); % end % end % end %b = [0,0,0;0,0,0;0,0,0]; b = Input_b; delete([h1(:); h2(:); h3(a==1)])enddelete(findobj(get(Finter,'Children'),'flat'));%-Effects of nonlinear modulations (D matrices)%==========================================================================if options.nonlinear uicontrol(Finter,'String','done','Position', [300 100 060 020].*WS,... 'Callback', 'uiresume(gcbf)'); for k = 1:m %-Buttons and labels %------------------------------------------------------------------ str = sprintf('Effects of %-12s activity on connections',xY(k).name); spm_input(str,1,'d'); for i = 1:m for j = 1:m if a(i,j)==1 % Allow modulation of intrinsic connections %------------------------------------------------------ h4(i,j) = uicontrol(Finter,... 'Position',[220+dx*j 360-dx*i 020 020].*WS,... 'BackgroundColor',bcolor,... 'Style','radiobutton'); end end end uiwait(Finter); %-Get d allowing any 2nd order effects %------------------------------------------------------------------ for i = 1:m for j = 1:m if a(i,j)==1 d(i,j,k) = get(h4(i,j),'Value'); end end end delete(h4(a==1)) endenddelete(findobj(get(Finter,'Children'),'flat'));spm_input('Thank you',1,'d')%==========================================================================% Response%==========================================================================%-Response variables &amp; confounds (NB: the data have been whitened)%--------------------------------------------------------------------------n = length(xY); % number of regionsv = length(xY(1).u); % number of time pointsY.dt = SPM.xY.RT;Y.X0 = xY(1).X0;for i = 1:n Y.y(:,i) = xY(i).u; Y.name&#123;i&#125; = xY(i).name;end%-Error precision components (one for each region) - i.i.d. (because of W)%--------------------------------------------------------------------------Y.Q = spm_Ce(ones(1,n)*v);%==========================================================================% DCM structure%==========================================================================% Endogenous input specificationif isempty(U) U.u = zeros(v,1); U.name = &#123;'null'&#125;;end%-Store all variables in DCM structure%--------------------------------------------------------------------------DCM.a = a;DCM.b = b;DCM.c = c;DCM.d = d;DCM.U = U;DCM.Y = Y;DCM.xY = xY;DCM.v = v;DCM.n = n;DCM.TE = TE;DCM.delays = delays;DCM.options = options;%-Save%--------------------------------------------------------------------------if spm_check_version('matlab','7') &gt;= 0 save(fullfile(swd,['DCM_' name '.mat']),'-V6','DCM');else save(fullfile(swd,['DCM_' name '.mat']),'DCM');end DCM模型的估计 1234567891011121314% 估计DCM模型first_level_path = 'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\first_level_dcm_w_whole\\';cd(first_level_path);dir_path = dir('2016*');for i = 1: size(dir_path,1) subject_path = [first_level_path,dir_path(i).name]; cd(subject_path); dcm_models_path = dir('DCM*'); for j = 1:size(dcm_models_path,1) dcm_model_path = [subject_path,'\\',dcm_models_path(j).name]; spm_dcm_estimate(dcm_model_path); endend DCM模型的贝叶斯选择","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"认知神经科学","slug":"技术/认知神经科学","permalink":"http://ff120.github.io/hexoblog/categories/技术/认知神经科学/"}],"tags":[{"name":"DCM","slug":"DCM","permalink":"http://ff120.github.io/hexoblog/tags/DCM/"}]},{"title":"使用SPM做Second_Level分析","slug":"技术/认知神经科学/使用SPM做Second-Level分析","date":"2017-04-13T03:11:29.000Z","updated":"2019-03-28T00:54:59.739Z","comments":true,"path":"2017/04/13/技术/认知神经科学/使用SPM做Second-Level分析/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/04/13/技术/认知神经科学/使用SPM做Second-Level分析/","excerpt":"组水平分析是用来查看组水平上的结果的。","text":"组水平分析是用来查看组水平上的结果的。 选择定义Second_Level按钮 Directory选择结果要存放的位置，Design下的选择单样本T检验，Scans选择做完first_level之后的某一个类别下的同一组的不同被试的con*开头的文件。这些都定义好之后单击运行按钮。 上面是运行之后的结果。以上步骤是定义设计矩阵的过程，该过程完成之后会在文件夹内生成SPM.mat文件。 单击估计，选择刚刚生成的SPM.mat文件。 估计完之后，会生成一些结果文件。 然后单击result,定义Contrast,这里只需要定义一个T-contrat,设置为1就可以了。 完成之后会生成spmT*文件。使用xjview就可以看到组水平的激活情况了。","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"认知神经科学","slug":"技术/认知神经科学","permalink":"http://ff120.github.io/hexoblog/categories/技术/认知神经科学/"}],"tags":[{"name":"SPM,Second_Level","slug":"SPM-Second-Level","permalink":"http://ff120.github.io/hexoblog/tags/SPM-Second-Level/"}]},{"title":"Hexo的使用04-数学公式","slug":"技术/工具/Hexo/Hexo的使用04-数学公式","date":"2017-04-12T08:36:21.000Z","updated":"2019-03-28T00:54:55.544Z","comments":true,"path":"2017/04/12/技术/工具/Hexo/Hexo的使用04-数学公式/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/04/12/技术/工具/Hexo/Hexo的使用04-数学公式/","excerpt":"数学公式是我们经常需要使用到的表达工具，只是用键盘上的符号有时候很难表达清楚想要表达的公式，格式也不是很友好。Hexo可以支持Latex公式的显示，我们只需要经过简单的配置就可以使Hexo支持Latex公式的显示。当然，通过使用atom的插件，Latex公式的实时预览也很容易实现，这样本地写作环境和提交之后的格式就是完全一致的。","text":"数学公式是我们经常需要使用到的表达工具，只是用键盘上的符号有时候很难表达清楚想要表达的公式，格式也不是很友好。Hexo可以支持Latex公式的显示，我们只需要经过简单的配置就可以使Hexo支持Latex公式的显示。当然，通过使用atom的插件，Latex公式的实时预览也很容易实现，这样本地写作环境和提交之后的格式就是完全一致的。 安装可以实时预览公式的atom插件 https://atom.io/packages/markdown-preview-enhanced 安装hexo-math https://github.com/akfish/hexo-math 常用的表示 希腊字母 名称 Tex书写形式 效果 alpha \\(\\alpha\\) beta \\(\\beta\\) gamma \\(\\gamma\\) theta \\(\\theta\\) mu \\(\\mu\\) pi \\(\\pi\\) rho \\(\\rho\\) sigma \\(\\sigma\\) phi \\(\\phi\\) omega \\(\\omega\\) chi \\(\\chi\\) psi \\(\\psi\\) 上标和下标 上标用^表示，下标用_表示，需要注意的是，这里的上标和下标的作用范围是紧紧跟在后面的字母或者数字，如果需要多个，需要用{}括起来。例如：x^56会得到\\(x^56\\),想要得到正确的结果，需要这样书写，x^{56},这样得到的结果就是\\(x^{56}\\). 在不用括号会引起歧义的地方必须使用括号，否则编译无法通过，例如x^5^6. 括号 小括号和中括号没有用来表示特殊的含义，所以可以直接使用。大括号的使用需要使用转义字符。 数学运算 书写格式 显示效果 \\(\\arcsin(xy)\\) \\(\\sin(x^5)\\) \\(\\arccos(x-y)\\) \\(\\cos(xyz)\\) \\(\\arctan(xy)\\) \\(\\arg()\\) \\(\\cosh\\) \\(sinh\\) \\(tanh\\) \\(\\int\\) \\(\\iint\\) \\(\\iiint\\) \\(\\oint\\) \\(\\coprod\\) \\(\\bigvee\\) \\(\\bigwedge\\) \\(\\biguplus\\) \\(\\bigcap\\) \\(\\bigcup\\) \\(\\intop\\) \\(\\prod\\) \\(\\sum\\) \\(\\bigoplus\\) \\(\\smallint\\) \\(\\bigodot\\) \\(\\odot\\) \\(\\bigotimes\\) \\(\\bigsqcup\\) 逻辑运算符 书写格式 显示效果 \\(\\forall\\) \\(\\exists\\) \\(\\nexists\\) \\(\\therefore\\) \\(\\because\\) 分数 书写格式 显示效果 示例 {10}frac{56}{78} \\({10}\\frac{56}{78}\\) 489 \\(4\\dfrac89\\) 5434 \\(54\\over34\\) 1089 \\(10\\tfrac89\\) 大括号 123456$$f(x)=\\begin&#123;cases&#125; 0 &amp; \\text&#123;x&gt;0&#125;\\\\ 1 &amp; \\text&#123;x&lt;=0&#125; \\end&#123;cases&#125;$$ \\[ f(x)=\\begin{cases} 0 &amp; \\text{x&gt;0}\\\\ 1 &amp; \\text{x&lt;=0} \\end{cases} \\] 公式详细的简介： http://mlworks.cn/posts/introduction-to-mathjax-and-latex-expression/ Katex支持的所有操作符： https://github.com/Khan/KaTeX/wiki/Function-Support-in-KaTeX latex手写符号识别系统： http://detexify.kirelabs.org/classify.html","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"工具","slug":"技术/工具","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/"},{"name":"Hexo","slug":"技术/工具/Hexo","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://ff120.github.io/hexoblog/tags/hexo/"},{"name":"latex","slug":"latex","permalink":"http://ff120.github.io/hexoblog/tags/latex/"}]},{"title":"Hexo的使用05-Atom编辑器","slug":"技术/工具/Hexo/Hexo的使用05-Atom编辑器","date":"2017-04-12T02:51:29.000Z","updated":"2019-03-28T00:54:55.559Z","comments":true,"path":"2017/04/12/技术/工具/Hexo/Hexo的使用05-Atom编辑器/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/04/12/技术/工具/Hexo/Hexo的使用05-Atom编辑器/","excerpt":"自从开始使用hexo写博客以来，一直在寻找一款合适的编辑器，至少实现以下功能： markdown语法的着色 markdown中代码块的着色和编程提示 实时预览 根据标题生成目录 在编辑器中执行hexo new, hexo d,hexo g,hexo clean等命令 在编辑器中执行git相关的操作 可视化的界面显示文件修改的异同 导出markdown为带书签的PDF，样式可以自定义 直到遇到atom，上述功能轻松就实现了，还有许多其他扩展的功能可以使用。","text":"自从开始使用hexo写博客以来，一直在寻找一款合适的编辑器，至少实现以下功能： markdown语法的着色 markdown中代码块的着色和编程提示 实时预览 根据标题生成目录 在编辑器中执行hexo new, hexo d,hexo g,hexo clean等命令 在编辑器中执行git相关的操作 可视化的界面显示文件修改的异同 导出markdown为带书签的PDF，样式可以自定义 直到遇到atom，上述功能轻松就实现了，还有许多其他扩展的功能可以使用。 安装atom 下载atom, 安装完成之后默认支持markdown功能，支持实时预览。 安装markdown增强预览工具，支持latex的预览 Ctrl+,打开配置页面，在install中搜索markdown-preview-plus，安装。使用文档：https://atom.io/packages/markdown-preview-plus 支持hexo命令的配置 Ctrl+,打开配置页面，在install中搜索atom-hexo，安装之后即可使用。atom的命令窗口与sublimeText一样，是Ctrl+Shift+P. atom-hexo插件的使用文档：https://atom.io/packages/atom-hexo 为了使生成的文件自带头部标签信息，还需要安装hexo-front-matter插件，使用方法：https://atom.io/packages/hexo-front-matter 增加目录功能 在扩展安装页面搜索markdown相关的扩展，把需要的都安装上。可以实现添加目录，导出PDF等各种功能扩展。 扩展git操作 安装git-plus扩展，可以在命令窗口执行相关的操作。 增加miniView插件 安装minimap扩展，可以看到整个页面的缩略图。使用教程：https://atom.io/packages/minimap 高亮选中的内容 安装highlight-selected插件","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"工具","slug":"技术/工具","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/"},{"name":"Hexo","slug":"技术/工具/Hexo","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://ff120.github.io/hexoblog/tags/hexo/"},{"name":"atom","slug":"atom","permalink":"http://ff120.github.io/hexoblog/tags/atom/"}]},{"title":"算法专题_栈和队列","slug":"技术/数据结构和算法/算法专题_栈和队列","date":"2017-04-12T02:07:18.000Z","updated":"2019-03-28T00:54:56.806Z","comments":true,"path":"2017/04/12/技术/数据结构和算法/算法专题_栈和队列/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/04/12/技术/数据结构和算法/算法专题_栈和队列/","excerpt":"栈是一种实现了后进先出的规则的数据结构。C++里面有实现stack.使用的时候include &lt;stack&gt;,支持的操作有push(),pop(),top();需要注意的是，pop的作用是弹出栈顶元素，而不会返回栈顶元素，实现返回栈顶元素并弹出的操作应该是int a = s.top(); s.pop();. 队列是一种先进先出的数据结构。C++里面有两种实现， 一种是普通的队列queue,使用的时候include&lt;queue&gt;,支持的操作和栈类似，push(),pop(),top()分别实现数据的入队，出队和读取队列的头部元素。deque实现了双端队列，支持从两端入队和出队.使用的时候include&lt;deque&gt;。","text":"栈是一种实现了后进先出的规则的数据结构。C++里面有实现stack.使用的时候include &lt;stack&gt;,支持的操作有push(),pop(),top();需要注意的是，pop的作用是弹出栈顶元素，而不会返回栈顶元素，实现返回栈顶元素并弹出的操作应该是int a = s.top(); s.pop();. 队列是一种先进先出的数据结构。C++里面有两种实现， 一种是普通的队列queue,使用的时候include&lt;queue&gt;,支持的操作和栈类似，push(),pop(),top()分别实现数据的入队，出队和读取队列的头部元素。deque实现了双端队列，支持从两端入队和出队.使用的时候include&lt;deque&gt;。 有效的括号序列 有效的括号序列 使用栈存储所有的左括号，一旦遇到右括号就与栈顶的元素比较，如果匹配，弹出栈顶元素，继续，如果不匹配，直接返回false. 12345678910111213141516171819202122bool isValidParentheses(string&amp; s) &#123; // 括号匹配问题 stack&lt;char&gt; cc; map&lt;char,char&gt; m; m['('] = ')'; m['['] = ']'; m['&#123;'] = '&#125;'; for(int i=0;i&lt;s.size();++i)&#123; if(s[i] == '(' || s[i] == '['|| s[i]=='&#123;')&#123; cc.push(s[i]); &#125; if(s[i] == ')' || s[i] == ']' || s[i] == '&#125;')&#123; char tmp = cc.top(); if(m[tmp] != s[i])&#123; return false; &#125; cc.pop(); &#125; &#125; if(cc.empty()) return true; return false;&#125; 逆波兰表达式求值 求逆波兰表达式的值。在逆波兰表达法中，其有效的运算符号包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰计数表达。 逆波兰表达式求值 12345678910111213141516171819202122232425// 运算符只考虑了加减乘除template&lt;typename T&gt;T compute(T first, T second,string op)&#123; if(op == \"+\") return first + second; if(op == \"-\") return first - second; if(op == \"*\") return first * second; if(op == \"/\" &amp;&amp; second != 0) return first / second; return -1000; // 说明输入的数据有问题&#125;int evalRPN(vector&lt;string&gt; &amp;tokens) &#123; // write your code here stack&lt;int &gt; s; set&lt;string&gt; op = &#123;\"+\",\"-\",\"*\",\"/\"&#125;; // 都是双目运算符，处理逻辑是相同的 for(size_t i=0;i&lt;tokens.size();i++)&#123; if(op.count(tokens[i]) &gt; 0)&#123; int first=0,second=0; if(!s.empty())&#123; first = s.top() ; s.pop(); &#125; if(!s.empty())&#123; second = s.top() ; s.pop(); &#125; s.push(compute(second,first,tokens[i])); &#125;else&#123; s.push(stoi(tokens[i])); &#125; &#125; return s.top();&#125; 中缀表达式转换成后缀表达式 利用栈将中缀表达式转换成后缀表达式的步骤(逆波兰表达式)： 初始化栈cc为空用来存放运算符，初始化string s为空用来存储转换之后的逆波兰表达式； 从头到尾扫描中缀表达式，遇到数字直接输出到s. 遇到运算符，如果当前的栈cc为空，则直接入栈；如果遇到的是左括号，直接入栈；如果遇到的运算符的优先级低于栈顶的元素，直接入栈； 如果遇到的运算符的优先级小于等于当前栈顶的元素，那么持续输出栈顶元素，直到栈顶元素的运算优先级小于当前元素 或者 栈为空 为止。循环退出后将当前运算符入栈。 如果遇到的是右括号，持续输出栈顶元素，直到遇到左括号，左括号弹出，但不输出到s. 将表达式转换为逆波兰表达式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263bool isNumber(string &amp;s)&#123; // 1. 空字符串不是数字 if(s.empty()) return false; if(s.size() == 1 &amp;&amp; s[0] == '-') return false; for(size_t i=0;i&lt;s.length();i++)&#123; // 2. 如果第二个字符及以后的不是0--9，不是数字，直接返回false if( (i&gt;0 &amp;&amp; (s[i]&lt;'0'||s[i]&gt;'9')) ) return false; // 3. 如果第一个字符不是0--9，也不是-，则不是数字，直接返回false. if(i==0&amp;&amp;(s[i]!='-')&amp;&amp;(s[i]&lt;'0'||s[i]&gt;'9') ) return false; &#125; return true;&#125;vector&lt;string&gt; convertToRPN(vector&lt;string&gt; &amp;expression) &#123; // write your code here vector&lt;string&gt; ans; if(expression.empty()) return ans; // 操作符 stack&lt;string&gt; s; // 操作符的优先级 map&lt;string,int&gt; kv; kv[\"+\"] = 3; kv[\"-\"] = 3; kv[\"*\"] = 4; kv[\"/\"] = 4; kv[\"(\"] = 2; kv[\")\"] = 6; for(size_t i=0;i&lt;expression.size();i++)&#123; // 1. 如果是数字，直接输出 if(isNumber(expression[i]))&#123; ans.push_back(expression[i]); &#125; // 2. 如果是符号+,-,*,/,(,),需要按照优先级顺序处理 else if(kv[expression[i]] &gt;= 2 &amp;&amp; kv[expression[i]] &lt;= 6)&#123; // 2.1 如果栈为空，或者是左括号，直接入栈 if(s.empty() || kv[expression[i]]==2 )&#123; s.push(expression[i]); &#125; // 2.2 如果遇到的是右括号，持续输出栈中的元素，直到遇到左括号为止 else if(kv[expression[i]] == 6)&#123; while(!s.empty() &amp;&amp; s.top() != \"(\")&#123; ans.push_back(s.top()); s.pop(); &#125; if(!s.empty()) s.pop(); // 弹出左括号 &#125; // 如果是+,-,*,/，就要比较和当前栈顶元素的优先级了，如果比栈顶运算符的优先级低，可以直接入栈， // 如果高，需要弹出栈顶元素，直到栈顶的运算符低于当前的运算符或者栈为空为止 else if(kv[expression[i]]==3 || kv[expression[i]]==4)&#123; // 2.3 如果当前的运算符优先级高于栈顶的，直接入栈 if(kv[expression[i]] &gt; kv[s.top()])&#123; s.push(expression[i]); &#125;else&#123; while(!s.empty() &amp;&amp; kv[expression[i]] &lt;= kv[s.top()])&#123; ans.push_back(s.top()); s.pop(); &#125; s.push(expression[i]); &#125; &#125; &#125; &#125; // 把栈中的操作符输出 while(!s.empty())&#123; ans.push_back(s.top()); s.pop(); &#125; return ans;&#125; 中缀表达式求值 先转换成后缀表达式，再求值。 表达式求值 123456int evaluateExpression(vector&lt;string&gt; expression) &#123; // write your code here vector&lt;string&gt; r = convert(expression); if(r.empty()) return 0; return evalRPN(r);&#125; 表达树构造 表达树是一个二叉树的结构，用于衡量特定的表达。所有表达树的叶子都有一个数字字符串值。而所有表达树的非叶子都有另一个操作字符串值。 给定一个表达数组，请构造该表达的表达树，并返回该表达树的根。 表达树构造 思路： 可以利用以前做过的题目，将本题分解成几个子问题。通过分析我们发现，中缀表达式是表达树的中序遍历，后缀表达式是表达树的后序遍历，通过中缀表达式我们可以得到后缀表达式，这个在之前已经做过。而通过二叉树的中序遍历序列和后序遍历序列也可以很容易的重建出该二叉树。所以该问题分解为这样几个子问题： 求后缀表达式 根据中序遍历和后序遍历序列重建二叉树 需要注意的是，本题中以数字和运算符作为节点的值，这并不能保证节点值的唯一，而重建二叉树的时候要求节点值唯一。这里我们采用定义新结构的方法使得每个节点都是唯一的。具体见代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123struct uniqueNode&#123; string description; int id; uniqueNode():description(\"\"), id(0)&#123;&#125; uniqueNode(string s, int i) : description(s), id(i)&#123;&#125;&#125;;//Definition of ExpressionTreeNode:class ExpressionTreeNode &#123;public: string symbol; ExpressionTreeNode *left, *right; ExpressionTreeNode(string symbol) &#123; this-&gt;symbol = symbol; this-&gt;left = this-&gt;right = NULL; &#125;&#125;;//后序遍历和中序遍历重建二叉树ExpressionTreeNode* buildTree(vector&lt;uniqueNode&gt;&amp; inorder, vector&lt;uniqueNode&gt;&amp; postorder) &#123; if (inorder.empty() || postorder.empty()) &#123; return nullptr; &#125; ExpressionTreeNode *node = new ExpressionTreeNode(postorder[postorder.size()-1].description);// 先建立根节点 int len = inorder.size(); for (size_t i = 0; i &lt; inorder.size(); ++i) &#123; if (inorder[i].id == postorder[postorder.size()-1].id) &#123; // 找到了中序遍历的根节点，则左面的全部是左子树，右面的全部是右子树。 vector&lt;uniqueNode&gt; left_post(i); vector&lt;uniqueNode&gt; left_vin(i); vector&lt;uniqueNode&gt; right_post(len - 1 - i); vector&lt;uniqueNode&gt; right_vin(len - 1 - i); copy(inorder.begin(), inorder.begin() + i, left_vin.begin()); copy(inorder.begin() + i + 1, inorder.end(), right_vin.begin()); copy(postorder.begin(), postorder.begin() + i, left_post.begin()); copy(postorder.begin() + i, postorder.end()-1, right_post.begin()); node-&gt;left = buildTree(left_vin,left_post); node-&gt;right = buildTree(right_vin,right_post); &#125; &#125; return node;&#125;inline bool isnumber(string &amp;s)&#123; for(auto a : s)&#123; if(a &gt; '9' || a &lt; '0')&#123; return false; &#125; &#125; return true;&#125;/** * 中缀表达式 -&gt; 后缀表达式 * @param expression * @return */vector&lt;uniqueNode&gt; convert(vector&lt;uniqueNode&gt; expression) &#123; vector&lt;uniqueNode&gt; re; stack&lt;uniqueNode&gt; cc; // 设置运算符的优先级 map&lt;string,int&gt; p; p[\"+\"] = 3; p[\"-\"] = 3; p[\"*\"] = 4; p[\"/\"] = 4; p[\"(\"] = 2; p[\")\"] = 1; for(int i=0; i&lt; expression.size();i++)&#123; // 遇到数字直接入栈 if(isnumber(expression[i].description))&#123; re.push_back(expression[i]); continue; &#125; // 遇到操作符 if(p[expression[i].description] &gt;= 1 &amp;&amp; p[expression[i].description] &lt;= 4)&#123; //栈为空或者遇到左括号，直接入栈 if(cc.empty() || p[expression[i].description] == 2 || p[expression[i].description] &gt; p[cc.top().description])&#123; cc.push(expression[i]); &#125; //遇到右括号，弹出栈中左括号之前的所有运算符号，输出，最后左括号弹出，不输出 else if(p[expression[i].description] == 1)&#123; while(cc.top().description != \"(\")&#123; auto tmp = cc.top(); re.push_back(tmp); cc.pop(); &#125; cc.pop(); // 弹出左括号 &#125; //当前运算符的优先级小于等于栈顶运算符的优先级，应该先计算栈顶的运算符，所以弹出栈顶的运算符，输出，把当前的运算符入栈 else if(p[expression[i].description] &lt;= p[cc.top().description])&#123; // 弹出栈中优先级高于当前运算符的运算符 while(!cc.empty() &amp;&amp; p[expression[i].description] &lt;= p[cc.top().description])&#123; re.push_back(cc.top()); cc.pop(); &#125; // 当栈为空 或者 遇到运算符的运算顺序低于当前运算符的时候，循环退出 cc.push(expression[i]); //当前运算符的优先级大于栈顶运算符的优先级，直接入栈 &#125; continue; &#125; cout&lt;&lt;\"error 1.\"&lt;&lt;endl; &#125; while(!cc.empty())&#123; re.push_back(cc.top()); cc.pop(); &#125; return re;&#125;ExpressionTreeNode* build(vector&lt;string&gt; &amp;expression) &#123; vector&lt;uniqueNode&gt; v; for (int i = 0; i &lt; expression.size(); ++i) &#123; v.push_back(uniqueNode(expression[i],i+1)); &#125; auto last = convert(v); for (int j = 0; j &lt; v.size(); ++j) &#123; if(v[j].description == \"(\" || v[j].description == \")\")&#123; v.erase(v.begin()+j); j--; &#125; &#125; auto head = buildTree(v,last); return head;&#125; 表达树的特殊结构决定了我们只根据后缀表达式也能构造出来一棵表达树(注意：只根据后序遍历序列是不能构造一棵二叉树的，因为答案不唯一。)，具体的做法是模拟后缀表达式的计算顺序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//Definition of ExpressionTreeNode:class ExpressionTreeNode &#123;public: string symbol; ExpressionTreeNode *left, *right; ExpressionTreeNode(string symbol) &#123; this-&gt;symbol = symbol; this-&gt;left = this-&gt;right = NULL; &#125;&#125;;bool isnumber(string &amp;s)&#123; for (int i = 0; i &lt; s.size(); ++i) &#123; if(s[i] &lt; '0' || s[i] &gt; '9') return false; &#125; return true;&#125;bool isoperator(string &amp;s)&#123; if(s == \"+\" || s == \"-\" || s == \"*\" || s == \"/\") return true; return false;&#125;vector&lt;string&gt; convert(vector&lt;string&gt; expression) &#123; vector&lt;string&gt; re; stack&lt;string&gt; cc; // 设置运算符的优先级 map&lt;string,int&gt; p; p[\"+\"] = 3; p[\"-\"] = 3; p[\"*\"] = 4; p[\"/\"] = 4; p[\"(\"] = 2; p[\")\"] = 1; for(int i=0; i&lt; expression.size();i++)&#123; // 遇到数字直接入栈 if(isnumber(expression[i]))&#123; re.push_back(expression[i]); continue; &#125; // 遇到操作符 if(p[expression[i]] &gt;= 1 &amp;&amp; p[expression[i]] &lt;= 4)&#123; //栈为空或者遇到左括号，直接入栈 if(cc.empty() || p[expression[i]] == 2 || p[expression[i]] &gt; p[cc.top()])&#123; cc.push(expression[i]); &#125; //遇到右括号，弹出栈中左括号之前的所有运算符号，输出，最后左括号弹出，不输出 else if(p[expression[i]] == 1)&#123; while(cc.top() != \"(\")&#123; string tmp = cc.top(); re.push_back(tmp); cc.pop(); &#125; cc.pop(); // 弹出左括号 &#125; //当前运算符的优先级小于等于栈顶运算符的优先级，应该先计算栈顶的运算符，所以弹出栈顶的运算符，输出，把当前的运算符入栈 else if(p[expression[i]] &lt;= p[cc.top()])&#123; // 弹出栈中优先级高于当前运算符的运算符 while(!cc.empty() &amp;&amp; p[expression[i]] &lt;= p[cc.top()])&#123; re.push_back(cc.top()); cc.pop(); &#125; // 当栈为空 或者 遇到运算符的运算顺序低于当前运算符的时候，循环退出 cc.push(expression[i]); //当前运算符的优先级大于栈顶运算符的优先级，直接入栈 &#125; continue; &#125; cout&lt;&lt;\"error 1.\"&lt;&lt;endl; &#125; while(!cc.empty())&#123; re.push_back(cc.top()); cc.pop(); &#125; return re;&#125;ExpressionTreeNode* build(vector&lt;string&gt; &amp;expression) &#123; expression = convert(expression); if(expression.empty()) return nullptr; stack&lt;ExpressionTreeNode*&gt; cc; for (int i = 0; i &lt; expression.size(); ++i) &#123; if(isnumber(expression[i]))&#123; ExpressionTreeNode *node = new ExpressionTreeNode(expression[i]); cc.push(node); &#125; if(isoperator(expression[i]))&#123; ExpressionTreeNode *node = new ExpressionTreeNode(expression[i]); ExpressionTreeNode *right = cc.top(); cc.pop(); ExpressionTreeNode *left = cc.top(); cc.pop(); node-&gt;left = left; node-&gt;right = right; cc.push(node); &#125; &#125; return cc.top();&#125; 简易的正则表达式解析 s = abc3[a], return abcaaa s = 3[abc], return abcabcabc s = 4[ac]dy, return acacacacdy s = 3[2[ad]3[pf]]xyz, return adadpfpfpfadadpfpfpfadadpfpfpfxyz Expression Expand 12345678910111213141516171819202122232425262728293031323334353637string expressionExpand(string&amp; s) &#123; bool finished = true; for(int i = 0; i &lt; s.length(); ++i)&#123; if(s[i] == '[' || s[i] == ']')&#123; finished = false; break; &#125; &#125; if(finished) return s; int left, right,pre_left; for(int i=0;i&lt;s.length();++i)&#123; if(s[i] == '[')&#123; left = i; &#125; if(s[i] == ']')&#123; for(int j = left-1; j &gt;= 0;--j)&#123; if(s[j]&gt;='0' &amp;&amp; s[j]&lt;='9')&#123; pre_left = j; &#125;else&#123; break; &#125; &#125; string num = s.substr(pre_left,left-pre_left); int count = stoi(num); string cycle = s.substr(left+1,i-left-1); string cycle_with_count = \"\"; while(count--)&#123; cycle_with_count += cycle; &#125; s.erase(pre_left,i-pre_left+1); s.insert(pre_left,cycle_with_count); return expressionExpand(s); &#125; &#125; return expressionExpand(s);&#125; 带有getMin()的栈 实现一个可以在O(1)时间内得到最小值的栈结构。支持pop(),push(),top(),getMin()四种操作。 带最小值操作的栈 思路 使用两个栈来模拟这个栈，一个栈用来保存实际的数据，一个栈用来保存对应数据的最小值。每次入栈和出栈操作的时候，判断最小值有没有发生变化，如果没有发生变化，直接弹出数据，如果发生了变化，更新存储最大值最小值的栈。 123456789101112131415161718192021222324252627282930313233343536class StackWithGetMin2&#123;public: stack&lt;int&gt; data; stack&lt;int&gt; min_data; void push(int val)&#123; data.push(val); if(!min_data.empty())&#123; if(min_data.top()&gt;=val)&#123; min_data.push(val); &#125; &#125; else&#123; min_data.push(val); &#125; &#125; int pop()&#123; auto v = data.top(); if(v &gt; min_data.top())&#123; data.pop(); return v; &#125;else&#123; data.pop(); min_data.pop(); return v; &#125; &#125; int getMin()&#123; if(min_data.empty)&#123;throw new exception;&#125; else&#123; return min_data.top(); &#125; &#125; int top()&#123; return data.top(); &#125;&#125;; 132序列 Given a sequence of n integers a1, a2, …, an, a 132 pattern is a subsequence ai, aj, ak such that i &lt; j &lt; k and ai &lt; ak &lt; aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list. n will be less than 20,000. pattern 123456789101112bool find132pattern(vector&lt;int&gt;&amp; nums) &#123; int third = INT32_MIN; stack&lt;int&gt; s; for (int i = nums.size() - 1; i &gt;= 0; --i) &#123; if (nums[i] &lt; third) return true; else while (!s.empty() &amp;&amp; nums[i] &gt; s.top()) &#123; third = s.top(); s.pop(); &#125; s.push(nums[i]); &#125; return false;&#125; 用栈实现队列 用栈实现队列 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class MyQueue &#123;public: stack&lt;int&gt; stack1; stack&lt;int&gt; stack2; MyQueue() &#123; // do intialization if necessary &#125; void push(int element) &#123; // write your code here stack1.push(element); &#125; int pop() &#123; // write your code here if(stack2.empty())&#123; if(stack1.empty())&#123; return -1; &#125; while(!stack1.empty())&#123; int a = stack1.top(); stack1.pop(); stack2.push(a); &#125; &#125; int a = stack2.top(); stack2.pop(); return a; &#125; int top() &#123; // write your code here if(stack2.empty())&#123; if(stack1.empty())&#123; return -1; &#125; while(!stack1.empty())&#123; int a = stack1.top(); stack1.pop(); stack2.push(a); &#125; &#125; int a = stack2.top(); return a; &#125;&#125;; 用一个栈排序另外一个栈 要求排序好的数据就在原来的栈里面。 思路 设存放数据的栈是s, 辅助排序的栈是help,一个临时变量v用来暂存从栈里面出来的数据。我们只要确保把s中的数有序的入栈help,然后在反向从help压入s就能得到需要的结果。如果要求从大到小排序，即s栈顶的元素是最大的，那么help中就应该是从小到大排序,栈顶的元素是最小的。每次从s向help移动数据的时候，都要和help的栈顶比较，如果小于栈顶的元素，直接入栈，如果大于栈顶的元素，把栈顶元素入栈到s,直到v中的数小于help的栈顶元素，才将v入栈到help,其实这有点向汉诺塔问题，循环利用两个栈做中转，只不过更加简单。 12345678910111213141516171819void sortStack(stack&lt;int&gt; s)&#123; stack&lt;int&gt; help; help.push( s.top() ); s.pop(); auto v = s.top(); if(help.top()&gt;v)&#123; help.push(v); s.pop(); &#125; else&#123; while(help.top()&lt;=v)&#123; auto temp = help.top(); help.pop(); s.push(temp); &#125; help.push(v); &#125;&#125; 栈的压入、弹出序列 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列,4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 思路 设压入序列是pushV,弹出序列是popV,从pushV中找到第一个和popV首元素相同的元素，假设是a,可以知道a必定是压入栈之后就被弹出来了。假设用一个临时的栈s1保a之前入栈的元素和a,那么此时popV和s1的栈顶元素应该是一致的。 接下来，遍历popV中的元素，与s1中的元素比较，如果相等，弹出该元素,popV的指针加1,继续下一次比较.如果不相等,就把pushV中a后面的元素继续入栈到s1,popV的指针不动，继续比较popV和当前s1的栈顶元素是不是相等。按照这样的规则处理，直到指针走到尽头，看s1中的元素是否非空，如果是空的，popV就是pushV的弹出序列。 1234567891011121314151617181920212223242526bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123; if(pushV.size() != popV.size()) return false; stack&lt;int&gt; s1; //找到第一个相同的元素 size_t i = 0; while(pushV[i] != popV[0] &amp;&amp; i&lt;pushV.size())&#123; s1.push(pushV[i]); i++; &#125; s1.push(pushV[i]); //此时是s1栈顶和popV的第一个元素相同； i++;//i指向下一元素； for(size_t j=0;j&lt;=popV.size();j++)&#123; if( j&lt;popV.size() &amp;&amp; popV[j] == s1.top() )&#123; s1.pop(); &#125;else if(i&lt;pushV.size())&#123; s1.push(pushV[i]); j--; i++; &#125;else if( j== popV.size() &amp;&amp; s1.empty())&#123; return true; &#125;else&#123; return false; &#125; &#125; return false; &#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"本地代码集锦","slug":"技术/数据结构和算法/本地代码集锦","date":"2017-04-11T03:11:14.000Z","updated":"2019-03-28T00:54:56.124Z","comments":true,"path":"2017/04/11/技术/数据结构和算法/本地代码集锦/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/04/11/技术/数据结构和算法/本地代码集锦/","excerpt":"未整理的本地代码","text":"未整理的本地代码 求数组的部分和的递归实现 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;/** * 部分和问题，给定的数组中有没有若干可以组成K * @param i * @param sum * @return */bool partSum(int i,int sum,int k,int n,vector&lt;int&gt; &amp;v)&#123; if(i == n) return sum == k; if(partSum(i+1,sum,k,n,v)) return true; if(partSum(i+1,sum+v[i],k,n,v)) return true; return false;&#125;int main()&#123; vector&lt;int&gt; v1 = &#123;1,5,8,1&#125;; if(partSum(0,0,11,4,v1)) cout&lt;&lt;\"true\"&lt;&lt;endl; else cout&lt;&lt;\"false\"&lt;&lt;endl; return 0;&#125; 背包问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;/** * 0--1 背包问题 * 从第start个物体开始，总重量为weight的背包，返回最大的价值 * @return */int rec(int start,int weight,vector&lt;int&gt; w,vector&lt;int&gt; v,vector&lt;int&gt; &amp;ob)&#123; cout&lt;&lt;\"rec(\"&lt;&lt;start&lt;&lt;\",\"&lt;&lt;weight&lt;&lt;\")\"&lt;&lt;endl; int result = 0; // 物体的最大个数是w.size()-1,如果超过这个，返回0，含义是从第n个 //物体开始，得到的价值是0，因为不能放入进去 if(start == w.size()) &#123;return result;&#125; //如果当前物体的重量已经大于总重量，那么一定不能放入背包， //一旦放入重量就超过了 if(w[start] &gt; weight)&#123; result = rec(start+1,weight,w,v,ob); &#125; //如果当前物体的重量小于等于最大的重量，那么这个物体可以放入背包， //尝试放入和不放入两种情况，选择较大的那个；// if(w[start] &lt;= weight)&#123;// result = max(rec(start+1,weight,w,v),rec(start+1,weight-w[start],w,v)+v[start]);// &#125; // 记录物品是否放入了背包 if(w[start] &lt;= weight)&#123; int noput = rec(start+1,weight,w,v,ob); int putted = rec(start+1,weight-w[start],w,v,ob)+v[start]; if(putted &gt; noput)&#123; result = putted; cout&lt;&lt;\"===\"&lt;&lt;\"rec(\"&lt;&lt;start&lt;&lt;\",\"&lt;&lt;weight&lt;&lt;\")\"&lt;&lt;\"===\"&lt;&lt;endl; ob.push_back(start); &#125;else&#123; result = noput; &#125; &#125; return result;&#125;void print(vector&lt;int&gt; v)&#123; for(auto a : v)&#123; cout&lt;&lt;a&lt;&lt;\" \"; &#125; cout&lt;&lt;endl;&#125;void print2(vector&lt;vector&lt;int&gt;&gt; v)&#123; for(auto i : v)&#123; for(auto j : i)&#123; cout&lt;&lt;j&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; &#125; cout&lt;&lt;endl;&#125;/** * 背包问题的动态规划解法 * dp[i][j] = dp[i+1][j] 当第i个物体的重量大于j的时候； * dp[i][i] = max( dp[i+1][j] , dp[i+1][j-w[i]]+v[i] ) 当第i个物体能够装进去的时候，分别尝试装入和不装入，取最大值。 * @param w * @param v * @param weight * @return */int dp(vector&lt;int&gt; w,vector&lt;int&gt; v,int weight)&#123; int n = w.size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(weight+1)); for(int i=n-1;i&gt;=0;i--)&#123; for(int j=0;j&lt;weight+1;j++)&#123; if(w[i] &gt; j)&#123; dp[i][j] = dp[i+1][j]; &#125;else&#123; dp[i][j] = max(dp[i+1][j],dp[i+1][j-w[i]] + v[i]); &#125; &#125; &#125; print2(dp); return dp[0][weight];&#125;/** * 从状态转移的观点来看 * dp[i][j] 表示挑选出从0到i物体，总重量不超过j的状态。dp[0][j]表示选择0个物品时的重大价值 * dp[1][j] 表示选择物体1时候，总重量不超过j的最大的价值 * 所以有dp[0][j] = 0; * dp[i][j] = dp[i-1][j] 当i-1物体不能放入背包时 * dp[i][j] = dp[i-1][j-w[i]] + v[i] 当i-1物体可以放入背包的时候 * dp[0][j] * @param w * @param v * @param weight * @return */int dp2(vector&lt;int&gt; w,vector&lt;int&gt; v,int weight)&#123; int n = w.size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(weight+1)); for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;weight+1;j++)&#123; if(w[i] &gt; j)&#123; dp[i+1][j] = dp[i][j]; &#125;else&#123; dp[i+1][j] = max(dp[i][j],dp[i][j-w[i]] + v[i]); &#125; &#125; &#125; print2(dp); return dp[n][weight];&#125;/** * 完全背包问题 * @param w * @param v * @param weight * @return */int dp3(vector&lt;int&gt; w,vector&lt;int&gt; v,int weight)&#123; int n = w.size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(weight+1)); for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;=weight;j++)&#123; if(j&lt;w[i])&#123; dp[i+1][j] = dp[i][j]; &#125;else&#123; dp[i+1][j] = max(dp[i][j],dp[i+1][j-w[i]]+v[i]); &#125; &#125; &#125; print2(dp); return dp[n][weight];&#125;/** * 0-1背包的变种 * @return */int dp4(vector&lt;int&gt; w,vector&lt;int&gt; v,int weight)&#123; int n = w.size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(weight+1)); dp[0][0] = 0; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;=weight;j++)&#123; if(j&lt;v[i])&#123; dp[i+1][j] = dp[i][j]; &#125;else&#123; dp[i+1][j] = min(dp[i][j],dp[i+1][j-v[i]]+w[i]); &#125; &#125; &#125; print2(dp); return dp[n][weight];&#125;int main() &#123; vector&lt;int&gt; w = &#123;2,1,3,2&#125;; vector&lt;int&gt; v = &#123;3,2,4,2&#125;; int weight = 7; vector&lt;int&gt; w2 = &#123;3,4,2&#125;; vector&lt;int&gt; v2 = &#123;4,5,3&#125;; cout&lt;&lt;dp3(w2,v2,weight)&lt;&lt;endl; return 0;&#125; dijkstra 算法实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;/** * 图的问题 * @return */void printV(vector&lt;int&gt; v)&#123; for(int i : v)&#123; cout&lt;&lt;i&lt;&lt;\"\\t\"; &#125; cout&lt;&lt;endl;&#125;/** * 单源最短路问题 * 从一个固定的点s到其他的所有的点的最短距离 * @return */struct edge&#123; // 从from到to的边的权值是cost int from; int to; int cost; edge(int f, int t, int c) : from(f),to(t),cost(c)&#123;&#125;;&#125;;vector&lt;edge&gt; createTu()&#123; vector&lt;edge&gt; s; s.push_back(edge(1,2,2)); // 每一行定义一条边 s.push_back(edge(1,3,5)); s.push_back(edge(2,3,4)); s.push_back(edge(2,4,6)); s.push_back(edge(2,5,10)); s.push_back(edge(3,4,2)); s.push_back((edge(4,6,1))); s.push_back(edge(5,6,3)); s.push_back((edge(5,7,5))); s.push_back((edge(6,7,9))); return s;&#125;void Bellman_Ford(int s)&#123; vector&lt;edge&gt; es = createTu(); //图的存储 int V = 7 ; // 顶点的数量 int E = 10 ; // 边的数量 vector&lt;int&gt; d; //结果的存储 for(int i=0;i&lt;=V;i++)&#123; d.push_back(100); &#125; d[s] = 0; //从顶点s出发，顶点的编号从1开始, ds[0] 舍弃不要了 while(true)&#123; bool update = false; for(int i=0;i&lt;E;i++)&#123; edge e = es[i]; if(d[e.from] != 100 &amp;&amp; d[e.to] &gt; d[e.from] + e.cost)&#123; d[e.to] = d[e.from] + e.cost; update = true; printV(d); &#125; &#125; if(!update)&#123; break; &#125; &#125;&#125;void dijkstra(int s)&#123; typedef pair&lt;int,int&gt; P ; // first 表示最短距离，second是顶点的编号 vector&lt;edge&gt; es = createTu(); //图的存储 priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt; que; int V = 7; int E = 10; vector&lt;int&gt; d; //结果的存储 for(int i=0;i&lt;=V;i++)&#123; d.push_back(100); &#125; d[s] = 0; //从顶点s出发，顶点的编号从1开始, ds[0] 舍弃不要了 que.push(P(0,s)); while(!que.empty())&#123; P p = que.top(); que.pop(); int v = p.second; if(d[v] &lt; p.first) continue; for(int i=0;i&lt;es)&#123; &#125; &#125;&#125;int main() &#123; Bellman_Ford(1); return 0;&#125; 寻找丑数 12345678910111213141516171819202122232425int getMaxN(vector&lt;long long&gt; uglies, int count, int n) &#123; /** * 这个用二分定位或许更快，也更稳定 */ for (int i = 0; i &lt; count; i ++) &#123; if (uglies[i] * n &gt; uglies[count-1]) return uglies[i] * n; &#125; return 0;&#125;int GetUglyNumber_Solution(int index) &#123; vector&lt;long long&gt; uglies(index,0); uglies[0] = 1; for (int i = 1; i &lt; index; i ++) &#123; int m2 = getMaxN(uglies, i, 2); int m3 = getMaxN(uglies, i, 3); int m5 = getMaxN(uglies, i, 5); uglies[i] = min(m5, min(m2, m3)); &#125; return uglies[index-1];&#125; 一个整数的数位之和 12345678int sumS(int a)&#123; int sum = 0; while(a)&#123; sum += a % 10; a = a / 10; &#125; return sum;&#125; 最后出现的数字 123456789101112131415161718192021222324252627282930int LastRemaining_Solution(int n, int m)&#123; vector&lt;bool&gt; v(n,true); int count = 0; // 记录数过的数字 int deleted = 0; //记录删除的数字 int i = 0; while(true)&#123; if(v[i])&#123; count++; &#125; if(count == m)&#123; v[i] = false; cout&lt;&lt;i&lt;&lt;endl; count = 0; deleted++; &#125; i++; if( i &gt;= n)&#123; i = i % n ; &#125; if(deleted == n-1)&#123; break; &#125; &#125; for(int i=0;i&lt;n;i++)&#123; if(v[i])&#123; return i; &#125; &#125;&#125; 寻找连续的整数序列和等于n 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123; vector&lt;vector&lt;int&gt;&gt; result; map&lt;int,vector&lt;int&gt;&gt; m; // 连续和等于sum，有两种情况，奇数个和偶数个 //如果奇数个连续的整数和等于sum, 那么位于中间的那个数一定可以被sum整除 //如果偶数个连续的整数和等于sum,那么必然有最中间的两个数的和可以被sum整除 for(int i=sqrt(2*sum);i&gt;=1;i--)&#123; vector&lt;int&gt; v; if(sum % i != 0) continue; // i表示有多少个连续的数字加和成sum,如果sum不能整除i，肯定不可能有解 if(i % 2 == 0 || i == 1)&#123; //有偶数个数字 int pair = sum / i ; if((pair - 1 ) % 2 == 0)&#123; cout&lt;&lt;i&lt;&lt;endl; int pair1 = (pair - 1) / 2; //找到了位于最中间位置的两个数字 int pair2 = pair1 + 1; int start = pair1 - i + 1; // 最开始的数字 int end = pair2 + i -1 ; //结尾的数字 if(start &gt; 0) &#123; for(int a = start;a&lt;=end;a++)&#123; v.push_back(a); &#125; &#125; &#125; &#125;else&#123; // 有奇数个数字 if(sum % i == 0)&#123; cout&lt;&lt;i&lt;&lt;endl; int mid = sum / i ; //最中间的数字 if(mid - (i-1)/2 &gt; 0)&#123; for(int a = mid - (i-1)/2;a&lt;=mid+(i-1)/2;a++)&#123; v.push_back(a); &#125; &#125; &#125; &#125; if(!v.empty())&#123; m[v[0]] = v; &#125; &#125; for(auto e = m.begin();e!=m.end();e++)&#123; result.push_back(e-&gt;second); &#125; return result;&#125; 多个数字一起构成最小的数字 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889// 解题思路： 构成最小的数字，其实质就是从最高位开始，每次都选择最小的数字作为最高位// 只需要对原来的数字按照下面的规则排序就可以做到// 把两个数字的最高位对齐，例如// 3332// 332// 从左向右比较，如果数字小的排在前面，如果数字相等，比较后面一位。如果其中一个数字没有了，// 那么比较另外一个剩下的数字与首数字的关系，如果大于首数字，则该数较大，如果小于该数字，则该数较小//如果相等，则指针后移，继续比较下一位，直到结束，如果直到结束都没有比较出大小，可以认为两个数一样大.//使用自定义的比较方法之后，直接使用multiset排序，然后拼接在一起就是结果struct NumBit&#123; int num; NumBit(int n) : num(n) &#123;&#125; bool operator&lt;(const struct NumBit &amp; right)const //重载&lt;运算符 &#123; vector&lt;int&gt; vtmp1; int n = this-&gt;num; int b = 0; while(n)&#123; b = n % 10; vtmp1.insert(vtmp1.begin(),b); n /= 10; &#125; vector&lt;int&gt; vtmp2; int n2 = right.num; int b2 = 0; while(n2)&#123; b2 = n2 % 10; vtmp2.insert(vtmp2.begin(),b2); n2 /= 10; &#125; int i = 0; int j = 0; int ilen = vtmp1.size(); int jlen = vtmp2.size(); while( i&lt;ilen || j&lt;jlen )&#123; if(i&lt;ilen &amp;&amp; j&lt;jlen &amp;&amp; vtmp1[i] &gt; vtmp2[j])&#123; return false; &#125;else if(i&lt;ilen &amp;&amp; j&lt;jlen &amp;&amp; vtmp1[i] &lt; vtmp2[j])&#123; return true; &#125;else if(i&lt;ilen &amp;&amp; j&lt;jlen &amp;&amp; vtmp1[i] == vtmp2[j])&#123; i++; j++; &#125;else if(i==ilen)&#123; if(vtmp2[j] &gt; vtmp2[0]) return true; else if(vtmp2[j] &lt; vtmp2[0]) return false; else if(j == jlen)&#123; return false; &#125;else&#123; j++; &#125; &#125;else if(j==jlen)&#123; if(vtmp1[i] &gt; vtmp1[0]) return false; else if(vtmp1[i] &lt; vtmp1[0]) return true; else if(i == ilen)&#123; return true; &#125;else&#123; i++; &#125; &#125;else&#123; break; &#125; &#125; return false; &#125;&#125;;string Int_to_String(int n)&#123; ostringstream stream; stream&lt;&lt;n; //n为int类型 return stream.str();&#125;string PrintMinNumber(vector&lt;int&gt; numbers) &#123; string re; multiset&lt;NumBit&gt; s; // 存放每个数字的各位数字 for(int i=0;i&lt;numbers.size();i++)&#123; NumBit *tmp = new NumBit(numbers[i]); s.insert(s.end(),*tmp); &#125; while(!s.empty())&#123; NumBit t = *s.begin(); re.append( Int_to_String(t.num)); s.erase(s.begin(),++s.begin()); &#125; // 每次选择最小的数字放在高位上 return re;&#125; 12345678910111213141516171819202122232425262728//找到出现次数大于一半的数字int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; if(numbers.size() == 0) return 0; if(numbers.size() == 1) return numbers[0]; int count = 1; int card = numbers[0]; for(size_t i=1;i&lt;numbers.size();i++)&#123; if(numbers[i] == card)&#123; count++; &#125;else&#123; count--; if(count == 0)&#123; card = numbers[i]; count = 1; &#125; &#125; &#125; int sum = 0; for(size_t i=0;i&lt;numbers.size();i++)&#123; if(numbers[i] == card)&#123; sum++; &#125; &#125; if(numbers.size()/2 &lt; sum)&#123; return card; &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930int getMinUnique(vector&lt;int&gt; v)&#123; int len = v.size(); //统计独立的数字的个数 set&lt;int&gt; se; for(int i=0;i&lt;v.size();i++)&#123; se.insert(v[i]); &#125; int ulen = se.size(); int s = 0; int t = 0; int num = 0; map&lt;int,int&gt; count; int res = len; // 存放结果，最坏的情况下是数组的长度，结果肯定不会大于这个值 while(true)&#123; while(t&lt;len &amp;&amp; num &lt;ulen)&#123; if(count[v[t++]]++ == 0)&#123; num ++; &#125; &#125; if(num &lt; ulen) break; res = min(res,t-s); if(--count[v[s++]] == 0)&#123; num--; &#125; &#125; return res;&#125; 12345678vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123; vector&lt;int&gt; result; sort(input.begin(),input.end()); for(size_t i=0;i&lt;k;i++)&#123; result.push_back(input[i]); &#125; return result;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109class Solution &#123;public: /** * @param A: An integer array * @return: Count the number of element before this element 'ai' is * smaller than it and return count number array */ vector&lt;int&gt; countOfSmallerNumberII(vector&lt;int&gt; &amp;A) &#123; // write your code here Node *root = build(0, 20000); vector&lt;int&gt; res; for (int i = 0; i &lt; A.size(); i++) &#123; int cnt = query(root, 0, A[i] - 1); res.push_back(cnt); // 更新计数下标是i的计数 modify(root, A[i]); &#125; return res; &#125; vector&lt;int&gt; countOfSmallerNumberBack(vector&lt;int&gt; &amp;A)&#123; vector&lt;int&gt; tmp(A); int len = A.size(); for(int i=0;i&lt;len;i++)&#123; tmp[i] = A[len-1-i]; &#125; vector&lt;int&gt; re = countOfSmallerNumberII(tmp); vector&lt;int&gt; result(re); for(int i=0;i&lt;len;i++)&#123; result[i] = re[len-1-i]; &#125; return result; &#125;private: Node *build(int start, int end) &#123; if (start &gt; end) &#123; return NULL; &#125; if (start == end) &#123; return new Node(start, end); &#125; int mid = start + ((end - start) &gt;&gt; 1); Node *root = new Node(start, end); root-&gt;left = build(start, mid); root-&gt;right = build(mid + 1, end); return root; &#125; void modify(Node *root, int idx)&#123; if (root == NULL) &#123; return; &#125; if (root-&gt;start == root-&gt;end &amp;&amp; root-&gt;start == idx) &#123; ++(root-&gt;cnt); return; &#125; int mid = root-&gt;start + ((root-&gt;end - root-&gt;start) &gt;&gt; 1); if (mid &gt;= idx) &#123; modify(root-&gt;left, idx); &#125; else &#123; modify(root-&gt;right, idx); &#125; root-&gt;cnt = root-&gt;left-&gt;cnt + (root-&gt;right ? root-&gt;right-&gt;cnt : 0); &#125; int query(Node *root, int start, int end) &#123; if (root-&gt;end &lt; start || root-&gt;start &gt; end) &#123; return 0; &#125; if (root-&gt;start &gt;= start &amp;&amp; root-&gt;end &lt;= end) &#123; return root-&gt;cnt; &#125; int mid = root-&gt;start + ((root-&gt;end - root-&gt;start) &gt;&gt; 1); if (mid &gt;= end) &#123; return query(root-&gt;left, start, end); &#125; if (mid &lt; start) &#123; return query(root-&gt;right, start, end); &#125; int leftRes = query(root-&gt;left, start, mid); int rightRes = query(root-&gt;right, mid + 1, end); return leftRes + rightRes; &#125;&#125;; 链表的操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct Node&#123; int value; Node *next; Node() : value(0),next(nullptr)&#123;&#125; Node(int v) : value(v),next(nullptr)&#123;&#125;&#125;;//双向链表struct BiNode&#123; int value; BiNode *pre; BiNode *next; BiNode() : value(0),pre(nullptr),next(nullptr)&#123;&#125; BiNode(int v) : value(v),pre(nullptr),next(nullptr)&#123;&#125;&#125;;Node* createLinks(vector&lt;int&gt; v)&#123; if(v.empty()) return nullptr; Node *head = new Node(v[0]); //头节点，最后需要返回创建的链表的头结点，所以头结点需要保存下来 Node *tmp = head; for(int i=1;i&lt;v.size();++i)&#123; Node *node = new Node(v[i]); tmp-&gt;next = node; tmp = tmp-&gt;next; &#125; return head;&#125;//创建循环单链表Node* createLinksCycle(vector&lt;int&gt; v)&#123; if(v.empty()) return nullptr; Node *head = new Node(v[0]); //头节点，最后需要返回创建的链表的头结点，所以头结点需要保存下来 Node *tmp = head; for(int i=1;i&lt;v.size();++i)&#123; Node *node = new Node(v[i]); tmp-&gt;next = node; tmp = tmp-&gt;next; &#125; tmp-&gt;next = head; // 让结尾指向开头的第一个元素 return head;&#125;pair&lt;BiNode*,BiNode*&gt; createBiNode(vector&lt;int&gt; v)&#123; if(v.empty()) return &#123;nullptr,nullptr&#125;; BiNode *head = new BiNode(v[0]); BiNode *tmp = head; for(int i=1;i&lt;v.size();i++)&#123; BiNode *node = new BiNode(v[i]); tmp-&gt;next = node; node-&gt;pre = tmp; tmp = tmp-&gt;next; &#125; BiNode *tail = tmp; return &#123;head,tail&#125;;&#125;//创建循环双链表pair&lt;BiNode*,BiNode*&gt; createBiNodeCycle(vector&lt;int&gt; v)&#123; if(v.empty()) return &#123;nullptr,nullptr&#125;; BiNode *head = new BiNode(v[0]); BiNode *tmp = head; for(int i=1;i&lt;v.size();i++)&#123; BiNode *node = new BiNode(v[i]); tmp-&gt;next = node; node-&gt;pre = tmp; tmp = tmp-&gt;next; &#125; BiNode *tail = tmp; tail-&gt;next = head; // 尾元素的后面是头元素 head-&gt;pre = tail; // 头元素的前面是尾元素 return &#123;head,tail&#125;;&#125;//反转单向链表Node* notLinks(Node* head)&#123; if(head == nullptr || head-&gt;next == nullptr) return head; Node *current = head; Node *pre=nullptr; Node *next= nullptr; while(current)&#123; next = current-&gt;next; // 首先记录current的下一个节点 current-&gt;next = pre; // curent的下一个节点设置为前一个节点 pre = current; // pre向前推进一个元素 current = next; //current像前推进一个元素 &#125; return pre; //返回指向新链表的头节点&#125;BiNode* notBiLinks(BiNode* head)&#123; if(head == nullptr || head-&gt;next == nullptr) return head; BiNode *current = head; BiNode *pre=nullptr; BiNode *next= nullptr; while(current)&#123; next = current-&gt;next; // 首先记录current的下一个节点 current-&gt;next = pre; // curent的下一个节点设置为前一个节点 current-&gt;pre = next; pre = current; // pre向前推进一个元素 current = next; //current像前推进一个元素 &#125; return pre; //返回指向新链表的头节点&#125;BiNode* notBiLinks2(BiNode* head)&#123; if(head == nullptr || head-&gt;next == nullptr) return head; BiNode *current = head; BiNode *newHead; while(current)&#123; BiNode *tmp = current-&gt;pre; current-&gt;pre = current-&gt;next; current-&gt;next = tmp; newHead = current; current = current-&gt;pre; &#125; return newHead; //返回指向新链表的头节点&#125;void printLinks(Node *head) &#123; if (head == nullptr) &#123; cout &lt;&lt; \"empty\" &lt;&lt; endl; return; &#125; Node *tmp = head; while (tmp-&gt;next != nullptr) &#123; cout &lt;&lt; tmp-&gt;value &lt;&lt; \"-&gt;\"; tmp = tmp-&gt;next; &#125; cout &lt;&lt; tmp-&gt;value &lt;&lt; endl;&#125;void printBiLinks(BiNode *head)&#123; if(head == nullptr)&#123;cout&lt;&lt;\"empty\"&lt;&lt;endl;return;&#125; BiNode *tmp = head; while(tmp-&gt;next != nullptr)&#123; cout&lt;&lt;\"[\"&lt;&lt;tmp-&gt;value&lt;&lt;\"]\"&lt;&lt;\"&lt;-&gt;\"; tmp = tmp-&gt;next; &#125; cout&lt;&lt;\"[\"&lt;&lt;tmp-&gt;value&lt;&lt;\"]\"&lt;&lt;endl; cout&lt;&lt;endl;&#125;class Links&#123;public: Node *head; // 头节点 Links() : head(nullptr)&#123;&#125; //创建链表 Links(vector&lt;int&gt; v) &#123; if(v.empty())&#123; head = nullptr; &#125;else &#123; Node *first = new Node(v[0]); head = first; Node *tmp = first; for (int i = 1; i &lt; v.size(); ++i) &#123; Node *node = new Node(v[i]); tmp-&gt;next = node; tmp = node; &#125; &#125; &#125; //打印链表 void printLinks() &#123; if (head == nullptr) &#123; cout &lt;&lt; \"empty\" &lt;&lt; endl; return; &#125; Node *tmp = head; while (tmp-&gt;next != nullptr) &#123; cout &lt;&lt; tmp-&gt;value &lt;&lt; \"-&gt;\"; tmp = tmp-&gt;next; &#125; cout &lt;&lt; tmp-&gt;value &lt;&lt; endl; &#125; //反转这个链表 void inverseLinks()&#123; Node *pre = nullptr; Node *next = nullptr; while(head!= nullptr)&#123; next = head-&gt;next; head-&gt;next = pre; pre = head; head = next; &#125; head = pre; &#125;&#125;;int main() &#123; vector&lt;int&gt; v=&#123;1,2,3,4,5,6&#125;; Node *head = createLinks(v);// Node *CHead = createLinksCycle(v);// Node *IHead = notLinks(head); auto Binode = createBiNode(v);// auto *IBiHead = notBiLinks2(Binode.first);// auto BinodeC = createBiNodeCycle(v); printLinks(head); printBiLinks(Binode.first); return 0;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"算法专题_排列组合","slug":"技术/数据结构和算法/算法专题_排列组合","date":"2017-04-10T12:12:48.000Z","updated":"2019-03-28T00:54:56.653Z","comments":true,"path":"2017/04/10/技术/数据结构和算法/算法专题_排列组合/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/04/10/技术/数据结构和算法/算法专题_排列组合/","excerpt":"排列组合的问题也是常常出现在算法题中。一种类型是纯数学问题，可以利用排列组合的数学知识求解。一种是需要枚举出所有的状态，经过适当的剪枝和过程的优化才可以得到正确的结果。","text":"排列组合的问题也是常常出现在算法题中。一种类型是纯数学问题，可以利用排列组合的数学知识求解。一种是需要枚举出所有的状态，经过适当的剪枝和过程的优化才可以得到正确的结果。 排列组合相关的试题中常见的操作就是枚举各种情况。下面介绍几种按照一定的顺序枚举所有情况的方法。 ## 生成n!种不同的排列po n个元素的全排列一共有n!种。如何按照顺序生成这n!种排列呢？C++中提供了next_permutation这一函数。 next_permutation能够按照顺序产生下一个排列，例如vector&lt;int&gt; v = {1,2,3}, 把v作为参数传递,next_permutation(v.begin(),v.end())返回的是true, v变成了1,2,3的下一个序列1,3,2;如果将3,2,1传入，返回的将是false,因为没有了下一个序列。 产生全排列的方法： 1234567891011121314#include &lt;algorithm&gt;#include &lt;vector&gt;vector&lt;vector&lt;int&gt;&gt; per(int n)&#123; vector&lt;int&gt; v; for(int i=0;i&lt;n;i++)&#123; v.push_back(i+1); &#125; vector&lt;vector&lt;int&gt;&gt; re; re.push_back(v); while(next_permutation(v.begin(),v.end()))&#123; re.push_back(v); &#125; return re;&#125; 集合的整数表示 如果一个集合有n个元素，那么这个集合的所有子集有2n个（包括空集和自身）。如果我们想要对所有的自己对应一个整数，容易想到的就是按照顺序从1到2n表示它。 例如：a = {1,2,3} a的所有的子集有： {};{1},{2},{3};{1,2},{1,3},{2,3};{1,2,3}; 0 1 2 3 4 5 6 7 如果像上面那样编码，集合间的操作规律不好找。我们使用下面的方式编码每个子集，目的是使得集合间的操作有规律而容易实现。 我们把所有子集都用B填充成和原来的集合一样的元素个数，保持原来集合中元素的相对位置不变，然后用二进制位1表示出现的元素，用0表示B，如下标所示： {B,B,B} {B,B,1} {B,2,B} {B,2,1} {3,B,B} {3,B,1} {3,2,B} {3,2,1} 000 001 010 011 100 101 110 111 0 1 2 3 4 5 6 7 集合{0,1,...,n-1}的子集为S，S的整数编码定义为： f(S) = 2^i (i属于子集S) 特别定义：空集用0表示。 所以有如下的对应： &gt;{} : 0 &gt;{1} : 2^(1-1) = 1 &gt;{2} : 2^(2-1) = 2 &gt;{3} : 2^(3-1) = 4 &gt;{1,2} :2(1-1)+2(2-1) = 3 &gt;{1,3} :2(1-1)+2(3-1) = 5 &gt;{2,3} :2(2-1)+2(3-1) = 6 &gt;{1,2,3}:2(1-1)+2(2-1)+2(3-1)=23-1=7 像这样表示后，一些集合的运算可以表示成: &gt; 空集： 0 &gt; 自身： 2^n-1 (1&lt;&lt;n)-1 &gt; 只含有第i个元素的集合：2^i (1&lt;&lt;i) &gt; 判断第i个元素是否属于集合S： if(S&gt;&gt;i&amp;1) 如果第i个元素属于集合S,根据上面的表示方法，该数字的二进制表示中第i为必定是1，所以右移i位之后末尾必定为1. &gt; 向集合中加入第i个元素: S|(1&lt;&lt;i) 就是把第i位置1 &gt; 从集合中去除第i个元素: S&amp;~(1&lt;&lt;i) 就是把第i位置0 &gt; 集合S和T的并集：S|T &gt; 集合S和T的交集：S&amp;T 枚举所有的子集的方法 1234for(int i=0;i&lt;2^n;i++)&#123; cout&lt;&lt;i&lt;&lt;endl; //对子集的处理&#125; 给出一个子集枚举这个集合的子集的方法 假设给出的子集的二进制码是： 00101100 （原来集合共八个元素），要枚举这个集合的子集，依然用八位二进制码表示，我们需要一种方法每次从该数字中去掉一个二进制位1，而忽略掉二进制位0.恰巧，以前讲位运算的时候讲过，n&amp;(n-1)的效果就是去除n的最末位的1. 12345int sub = sup;do&#123; cout&lt;&lt;sub&lt;&lt;endl; //sub就是所有的子集 sub = (sub-1)&amp;sub;&#125;while(sub!=sup) // -1&amp;sup = sup 枚举所有大小为k的子集的办法 所有大小为k的子集，就是二进制位中所有1的位数加起来的和为k的数字。枚举一个二进制码之后的1的个数相同的二进制码的方法有很多中，下面是其中的一种实现。 1234567int comb = (1&lt;&lt;k)-1;while(comb &lt; (1&lt;&lt;k))&#123; cout&lt;&lt;comb; // 对集合的处理 int x = comb &amp; -comb ; int y = comb + x; comb = ((comb&amp;~y)/(x&gt;&gt;1)) | y;&#125; 另外一种实现： 先来分析如何从得到一个数字n的下一个与n二进制1个数相同的数字。例如，n=001001110; 则下一个数字为n2=00101011; 得到下一个数字的操作规则应该是：从最低位开始，找到第一个1的位置。把与这个1相邻的所有1作为一组，这组的最高位1向左移动一位，原来的位置上补0，剩下的1移动到最右边。 使用位操作完成上述的步骤需要了解如何使用位操作完成以下的功能： 找到最低位的1的位置： x = n&amp;(-n) 与最低位1相邻的一组1中最高位的1左移一位，其余的位置置0：t = x+n, 将最低的一组1右移到最右边：(n^t)/(n&amp;(-n))). 具体的过程描述如下： x = n&amp;(-n),获得n的最后一个1. t = x + n, n中连续1的最左边的1左移一位，其余位置0. n^t, n中连续1的最左边的0置1. (n^t)/x), 将连续的1移动到最右侧。 ((n^t)/x)&gt;&gt;2, 去掉多余的两个1. ans = t | ((N^t)/x)&gt;&gt;2;, 拼接两部分，得到最后的结果。 12345678// 求大于N的下一个与N有相同个数1（二进制表示）的数字int NextN(int N)&#123; int x = N&amp;(-N); int t = N+x; int ans = t | ((N^t)/x)&gt;&gt;2; return ans;&#125; 位操作枚举所有组合情况 12345678910111213141516171819202122232425262728int NextN(int N)&#123; int x = N&amp;(-N); int t = N+x; int ans = t | ((N^t)/x)&gt;&gt;2; return ans;&#125;vector&lt;vector&lt;int&gt;&gt; Cnk(vector&lt;int&gt; &amp;v,int n,int k)&#123; // 输出所有的组合情况Cnk vector&lt;vector&lt;int&gt;&gt; re; int tmp = (1&lt;&lt;k) - 1; while(tmp &lt; pow(2.0,n)-1)&#123; int tt = tmp; vector&lt;int&gt; vtmp; int i=0; while(tt &amp;&amp; i&lt;n)&#123; if(tt&amp;1)&#123; vtmp.push_back(v[i]); &#125; i++; tt = tt&gt;&gt;1; &#125; re.push_back(vtmp); tmp = NextN(tmp); &#125; return re;&#125; 去除重复元素的cnk,例如 1，2，2，3，3，3，4 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;sstream&gt;using namespace std;int NextN(int N)&#123; int x = N&amp;(-N); int t = N+x; int ans = t | ((N^t)/x)&gt;&gt;2; return ans;&#125;string int2String(int n)&#123; ostringstream stream; stream&lt;&lt;n; //n为int类型 return stream.str();&#125;string toString(vector&lt;int&gt; &amp;v)&#123; string re; for(auto s : v)&#123; re += int2String(s); &#125; return re;&#125;map&lt;string,vector&lt;int&gt;&gt; Cnk(vector&lt;int&gt; &amp;v,int n,int k)&#123; // 输出所有的组合情况Cnk map&lt;string,vector&lt;int&gt;&gt; re; int tmp = (1&lt;&lt;k) - 1; while(tmp &lt; pow(2.0,n)-1)&#123; int tt = tmp; vector&lt;int&gt; vtmp; int i=0; while(tt &amp;&amp; i&lt;n)&#123; if(tt&amp;1)&#123; vtmp.push_back(v[i]); &#125; i++; tt = tt&gt;&gt;1; &#125; string key = toString(vtmp); re[key] = vtmp; tmp = NextN(tmp); &#125; return re;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"算法专题_大数据和空间限制","slug":"技术/数据结构和算法/算法专题_大数据和空间限制","date":"2017-04-10T09:00:36.000Z","updated":"2019-03-28T00:54:56.554Z","comments":true,"path":"2017/04/10/技术/数据结构和算法/算法专题_大数据和空间限制/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/04/10/技术/数据结构和算法/算法专题_大数据和空间限制/","excerpt":"主要介绍一些涉及大量数据的一些算法设计问题。","text":"主要介绍一些涉及大量数据的一些算法设计问题。 Bloom filter（布隆过滤器） 宁可错杀三千，绝不放过一个(属于这个集合的肯定不会误判，但是不属于这个集合的却有可能误以为属于这个集合) 布隆过滤器是一种用来处理大数据的查询的一种方式，该方法允许精确的判断一个元素是否属于一个集合。这里的精确是只可以在一定的精度范围内。例如可以以99.99%的概率确定一个元素属于还是不属于这个集合。 &gt; 布隆过滤器的优势： - 使用很少的空间就可以把精确度做的很高。 - 不需要存储元素本身，在某些对保密要求非常严格的场合有优势 - 不需要顾忌单个元素取值范围的大小，因为它与最终布隆过滤器的大小没有关系 （需要注意的是，单个元素的大小必须在散列函数可以表示的范围内） 布隆过滤器的缺点： - 精确度永远不可能达到1 - 从集合中删除某个元素非常困难 布隆过滤器的原理是，当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。 散列函数 在生成布隆过滤器的时候遇到的对象，判断是否属于这个集合的时候是一定不会出错的。只有生成布隆过滤器的时候没有用到的元素，才可能出错。 布隆过滤器的设计需要考虑两个因素，要表示的数据量n和允许的误差范围p,这里举个例子：n=1000000000, p=0.01。已知数据量和误差范围的时候可以使用如下的公式求解需要布隆数组的位数和需要使用的散列函数的个数。 布隆数组的位数m: m = -(n*lnp)/(ln2)^2 散列函数的个数k: k = ln2 * (m/n) = 0.7 * m/n; 公式的具体推导过程可以参考这里 参考例题： 2017-03-22_151134.png 大文件的处理 把一个大的集合通过哈希函数分配到多台机器中，或者分配到多个文件里，这种技巧是处理面试题中涉及到大数据的时候的最常用的技巧。 只用2GB内存在20亿个数中找出出现次数最多的数字 统计出现次数，可以使用哈希表，本题的难点是直接使用哈希表的话，内存是放不下的。 具体做法是： 使用哈希函数将原来包含20亿个整数的文件分割成16个小文件，使得一样的数字在相同的文件中，文件大小尽可能均匀。 分别统计16个小文件的整数出现次数，然后得出最后的结果。 这其实就是分治思想的应用。 关键是使用什么样的哈希函数分割文件，怎样的合并结果策略可以保证得到正确的结果。本题最简单的哈希策略可以是直接用原来的整数当作哈希值，对16取余。余数为0的输出到第一个文件，余数为1的输出到第二个文件，还要注意统计文件中整数的数量，当超过1.25亿的时候就转向下一个文件保存数据，保证16个文件大小的均衡。合并结果的时候，统计每个小文件中出现次数最多的那个，然后判断其他小文件中有没有包含这个数字，有的话，加上，输出最后的结果。 40亿个非负整数中没有出现的数字 32位无符号整数可以表示大约42亿个数字，一个文件中存储了40亿个数字，那么即使这40亿个数字都不相同，也存在没有出现过的数字，找出这些数字。 思路：找出没有出现的数字，我们就得有方法记录所有已经出现的数字，只有记住了哪些数字出现过，才可以知道哪些数字没有出现过。所以这个问题是非常费内存的。如何记录40亿个数字的出现呢？ 使用一个40亿长度的数组显然是不能满足内存要求的。 现在考虑如果只用一个比特位表示一个数字是否能满足要求，经过计算，只需要500M的内存基本上就可以了。所以方法是：开辟一个INT32_MAX*2的位数组，记录每个数字出现的情况。遍历完一遍之后，我们就知道了每个数字出现的情况，然后再遍历一遍，遇到0就输出。 现在考虑如何使用更小的内存处理这个问题，例如10M内存，只找出一个未出现的就可以了。 解决的思路是分割处理，例如分割成64个子段，第一次遍历，统计落在每个区间的上的数字的数量，必定有一个区间是不满的，找出这个区间，第二次遍历，只处理落在这个区间上的数字，在对应的位上标记1表示出现过。第三次遍历，遇到是0的就输出，就可以了。 一致性哈希算法","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"算法专题_二叉树","slug":"技术/数据结构和算法/算法专题_二叉树","date":"2017-04-09T09:33:46.000Z","updated":"2019-03-28T00:54:56.337Z","comments":true,"path":"2017/04/09/技术/数据结构和算法/算法专题_二叉树/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/04/09/技术/数据结构和算法/算法专题_二叉树/","excerpt":"树是没有环的图。树和链表、图都有关联。链表是树的一种特殊情况，而图都可以对应一棵生成树。学习完链表，学习树，然后学习图，是一个比较容易接受的过程。每个节点最多有两个子节点的树叫做二叉树。二叉树是递归定义的，这导致很多涉及二叉树的问题都可以用递归的方法求解。按照节点数目的不同，二叉树的类型有：完全二叉树，满二叉树和完美二叉树。","text":"树是没有环的图。树和链表、图都有关联。链表是树的一种特殊情况，而图都可以对应一棵生成树。学习完链表，学习树，然后学习图，是一个比较容易接受的过程。每个节点最多有两个子节点的树叫做二叉树。二叉树是递归定义的，这导致很多涉及二叉树的问题都可以用递归的方法求解。按照节点数目的不同，二叉树的类型有：完全二叉树，满二叉树和完美二叉树。 二叉树的通用性质 二叉树的第i层节点数目至多是2^(i-1); (i&gt;=1) 深度为K的二叉树至多有2^(K-1)个节点。 二叉树中出度为2的节点数目记作n2, 叶节点记作n0; 则有n0 = n2 + 1 深度为n的完美二叉树，其节点的数目是2^n -1, 叶节点数目是2^(n-1), 非叶节点的数目是2^(n-1)-1 节点数目为n的完美二叉树，深度是log2(n+1) 节点数目为n的完全二叉树，深度是[log2(n)] + 1 其中[]表示向下取整 二叉树的定义 二叉树的结构和双向链表比较相似，需要两个指针分别指向左孩子和右孩子。 12345678910// 定义二叉树的结构class TreeNode &#123;public: int val; TreeNode *left, *right; TreeNode(int val) &#123; this-&gt;val = val; this-&gt;left = this-&gt;right = nullptr; &#125;&#125; 二叉树的创建(生成) 创建一棵二叉树有多种方式，算法中指定二叉树通常使用“#”表示不存在的节点，这里我们采用两个遍历序列的方式来确定一棵二叉树的结构。前序遍历序列和中序遍历序列可以唯一的确定一颗二叉树的结构，后序遍历序列和中序遍历序列也可以唯一的确定一棵二叉树的结构。 根据前序遍历和中序遍历重建二叉树 根据二叉树的前序遍历和中序遍历的结果创建二叉树，根据前序遍历序列和中序遍历序列可以唯一的确定一棵二叉树。 假设前序遍历的序列是pre; 中序遍历的序列是vin;里面都不含有重复数字；首先确定根节点，肯定是pre[0], 然后在vin中寻找pre[0], 它前面的一定是左子树上的，后面的都是右子树上的。假设pre[0]出现在vin[3],可以知道左子树上有三个节点，分别是vin[0],vin[1],vin[2], 在pre中从pre[0]以后数3个数字这三个数字一定是位于左子树上的，剩下的属于右子树。分别按照上面的方法递归处理左右子树，直到只剩下一个元素，返回答案；举例来说，假设pre = [1,2,4,7,3,5,6,8] vin=[4,7,2,1,5,3,8,6]第一次： 可知1是根，2，4，7是1的左子树上的，3,5,6,8,是1的右子树上的。 分别处理序列[2,4,7] [4,7,2] 和[3,5,6,8] [5,3,6,8]第二次： 对于[2,4,7] [4,7,2] 可以得到2是根，而4，7都是左子树上的， 接着处理[4,7] [4,7] 此时4是根，而7位于右子树上，这边处理完毕；对于[3,5,6,8] [5,3,8,6] 可以得到3是根，5是左子树上的，[6,8]是右子树上的。接着处理[6,8][8,6] 此时6是根，而8位于左子树上。 综合上面的分析，可以得到这个二叉树的形状如下： 12345678910111213141516171819202122//根据前序遍历和中序遍历重建二叉树TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123; if(pre.empty() || vin.empty())&#123;return nullptr;&#125; TreeNode* node = new TreeNode(pre[0]);// 先建立根节点 int len = pre.size(); for(size_t i=0;i&lt;vin.size();++i)&#123; if(vin[i] == pre[0])&#123; // 找到了中序遍历的根节点，则左面的全部是左子树，右面的全部是右子树。 vector&lt;int&gt; left_pre(i,0); vector&lt;int&gt; left_vin(i,0); vector&lt;int&gt; right_pre(len-1-i,0); vector&lt;int&gt; right_vin(len-1-i,0); copy(vin.begin(),vin.begin()+i,left_vin.begin()); copy(vin.begin()+i+1,vin.end(),right_vin.begin()); copy(pre.begin()+1,pre.begin()+1+i,left_pre.begin()); copy(pre.begin()+i+1,pre.end(),right_pre.begin()); node-&gt;left = reConstructBinaryTree(left_pre,left_vin); node-&gt;right = reConstructBinaryTree(right_pre,right_vin); &#125; &#125; return node; leetcode gist 根据后序遍历和中序遍历重建二叉树 12345678910111213141516171819202122//后序遍历和中序遍历重建二叉树TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; if (inorder.empty() || postorder.empty()) &#123; return nullptr; &#125; TreeNode *node = new TreeNode(postorder[postorder.size()-1]);// 先建立根节点 int len = inorder.size(); for (size_t i = 0; i &lt; inorder.size(); ++i) &#123; if (inorder[i] == postorder[postorder.size()-1]) &#123; // 找到了中序遍历的根节点，则左面的全部是左子树，右面的全部是右子树。 vector&lt;int&gt; left_post(i, 0); vector&lt;int&gt; left_vin(i, 0); vector&lt;int&gt; right_post(len - 1 - i, 0); vector&lt;int&gt; right_vin(len - 1 - i, 0); copy(inorder.begin(), inorder.begin() + i, left_vin.begin()); copy(inorder.begin() + i + 1, inorder.end(), right_vin.begin()); copy(postorder.begin(), postorder.begin() + i, left_post.begin()); copy(postorder.begin() + i, postorder.end()-1, right_post.begin()); node-&gt;left = buildTree(left_vin,left_post); node-&gt;right = buildTree(right_vin,right_post); &#125; &#125; return node;&#125; leetcode gist 二叉树的深度 从根节点到叶节点经过的节点数量定义为二叉树的深度。 最大深度 12345678 // 二叉树的最大深度int maxDepth2(TreeNode *root, const int dep)&#123; if(!root) return dep; if(!root-&gt;left &amp;&amp; !root-&gt;right) return dep+1; if(root-&gt;left &amp;&amp; !root-&gt;right) return maxDepth2(root-&gt;left,dep+1); if(root-&gt;right &amp;&amp; !root-&gt;left) return maxDepth2(root-&gt;right,dep+1); return max(maxDepth2(root-&gt;left,dep+1),maxDepth2(root-&gt;right,dep+1)); &#125; 最小深度 12345678// 二叉树的最小深度int minDepth2(TreeNode* root,const int dep)&#123; if(!root) return dep; if(!root-&gt;left &amp;&amp; !root-&gt;right) return dep+1; if(root-&gt;left &amp;&amp; !root-&gt;right) return minDepth2(root-&gt;left,dep+1); if(!root-&gt;left &amp;&amp; root-&gt;right) return minDepth2(root-&gt;right,dep+1); return min(minDepth2(root-&gt;left,dep+1),minDepth2(root-&gt;right,dep+1));&#125; 二叉树的遍历 二叉树有三种常见的遍历方式：前序遍历、中序遍历、后序遍历。前中后指的都是根节点相对于左右孩子节点的顺序。所以前序遍历的顺序是 root-left-right, 中序遍历的顺序是 left-root-right, 后序遍历的顺序是 left-right-root. 前序遍历(递归) 前序遍历遍历的步骤： 输出当前节点 如果有左孩子，用左孩子做参数递归 如果有右孩子，用由孩子做参数递归 12345678910111213141516// 前序遍历 vector&lt;int&gt; preorderTraversal(TreeNode *root) &#123; // write your code here vector&lt;int&gt; re; if(root == nullptr) return re; re.push_back(root-&gt;val); if(root-&gt;left)&#123; vector&lt;int&gt; ll = preorderTraversal(root-&gt;left); re.insert(re.end(), ll.begin(), ll.end()); &#125; if(root-&gt;right)&#123; vector&lt;int&gt; rr = preorderTraversal(root-&gt;right); re.insert(re.end(), rr.begin(), rr.end()); &#125; return re; &#125; 前序遍历(非递归) 非递归的实现，递归函数的实现是使用堆栈的方式，所以把递归调用的函数改写成非递归的形式一般也是使用堆栈作为数据结构。 前序遍历的非递归遍历步骤 输出当前的节点值，并把当前的节点压入栈 current = current-&gt;left;循环以上步骤直到没有左孩子，执行下面的步骤 取栈顶元素的右孩子，弹出栈顶元素，然后回到步骤1. 123456789101112131415161718192021//前序遍历的非递归实现vector&lt;int&gt; preorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; re; if(root == nullptr) return re; stack&lt;TreeNode*&gt; s; TreeNode *tmp = root; while(tmp!=nullptr || !s.empty())&#123; // 逻辑或是短路的 while(tmp!=nullptr)&#123; re.push_back(tmp-&gt;val); s.push(tmp); tmp = tmp-&gt;left; &#125; // 循环退出说明没有了左孩子 if(!s.empty())&#123; tmp = s.top(); s.pop(); tmp = tmp-&gt;right; &#125; &#125; return re;&#125; 中序遍历(递归) 中序遍历遍历的步骤 如果当前的节点有左孩子，用左孩子作为参数递归 输出当前节点 如果当前节点有右孩子，用右孩子作为参数递归 12345678910111213141516// 中序遍历的递归实现vector&lt;int&gt; inorderTraversal(TreeNode *root) &#123; // write your code here vector&lt;int&gt; re; if(root == nullptr) return re; if(root-&gt;left)&#123; vector&lt;int&gt; ll = inorderTraversal(root-&gt;left); re.insert(re.end(),ll.begin(),ll.end()); &#125; re.push_back(root-&gt;val); if(root-&gt;right)&#123; vector&lt;int&gt; rr = inorderTraversal(root-&gt;right); re.insert(re.end(),rr.begin(),rr.end()); &#125; return re; &#125; 中序遍历(非递归) 中序遍历的非递归实现 对于当前的节点，放入堆栈，然后搜索有没有左孩子，一直向下搜索到没有左孩子为止。 从堆栈取出栈顶元素，输出，然后搜索右孩子 123456789101112131415161718192021222324//中序遍历的非递归实现 vector&lt;int&gt; inorderTraversal(TreeNode * root) &#123; // write your code here vector&lt;int&gt; re; if(root == nullptr) return re; TreeNode* iter = root; stack&lt;TreeNode*&gt; s; while(iter || !s.empty())&#123; while(iter)&#123; s.push(iter); iter = iter-&gt;left; &#125; if(!s.empty())&#123; iter = s.top(); s.pop(); re.push_back(iter-&gt;val); iter = iter-&gt;right; &#125; &#125; return re; &#125; 后序遍历(递归) 后序遍历遍历的步骤是 如果当前节点有左孩子，用左孩子作为参数递归 如果当前节点有右孩子，用右孩子作为参数递归 输出当前节点 12345678910111213141516// 后续遍历的递归实现 vector&lt;int&gt; postorderTraversal(TreeNode *root) &#123; // write your code here vector&lt;int&gt; re; if(root == nullptr) return re; if(root-&gt;left)&#123; vector&lt;int&gt; ll = postorderTraversal(root-&gt;left); re.insert(re.end(),ll.begin(),ll.end()); &#125; if(root-&gt;right)&#123; vector&lt;int&gt; rr = postorderTraversal(root-&gt;right); re.insert(re.end(),rr.begin(),rr.end()); &#125; re.push_back(root-&gt;val); return re; &#125; 后序遍历(非递归) 后序遍历的非递归实现 第一种思路：对于任一结点P，将其入栈，然后沿其左子树一直往下搜索，直到搜索到没有左孩子的结点，此时该结点出现在栈顶，但是此时不能将其出栈并访问，因此其右孩子还为被访问。所以接下来按照相同的规则对其右子树进行相同的处理，当访问完其右孩子时，该结点又出现在栈顶，此时可以将其出栈并访问。这样就保证了正确的访问顺序。可以看出，在这个过程中，每个结点都两次出现在栈顶，只有在第二次出现在栈顶时，才能访问它。因此需要多设置一个变量标识该结点是否是第一次出现在栈顶。 1//后序遍历的非递归实现 第二种思路：要保证根结点在左孩子和右孩子访问之后才能访问，因此对于任一结点P，先将其入栈。如果P不存在左孩子和右孩子，则可以直接访问它；或者P存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。若非上述两种情况，则将P的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根结点前面被访问。 1234567891011121314151617181920212223242526272829// 后序遍历的非递归实现vector&lt;int&gt; postOrder(TreeNode *root)&#123; vector&lt;int&gt; re; if(root == nullptr) return re; TreeNode *p = root; stack&lt;TreeNode *&gt; s; TreeNode *last = root; s.push(p); while (!s.empty()) &#123; p = s.top(); if( (p-&gt;left == nullptr &amp;&amp; p-&gt;right == nullptr) || (p-&gt;right == nullptr &amp;&amp; last == p-&gt;left) || (last == p-&gt;right) ) &#123; re.push_back(p-&gt;val); last = p; s.pop(); &#125; else &#123; if(p-&gt;right) s.push(p-&gt;right); if(p-&gt;left) s.push(p-&gt;left); &#125; &#125; return re;&#125; 层次遍历 二叉树的层次遍历类似与图的广度优先搜索，可以使用队列来实现。思路是： 使用两个队列保存相邻两层的节点，循环输出每层的节点 层次遍历遍历的步骤 初始化两个队列d1,d2;令d1保存root,d2为空 清空d2,遍历d1中的节点，把d1中节点的所有孩子节点按照顺序放入d2中 打印d1中的节点 交换d1和d2;转到2 循环直到d2中为空，结束。 123456789101112131415161718192021222324252627282930// 从底向上层次遍历二叉树 vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode *root) &#123; // write your code here vector&lt;vector&lt;int&gt;&gt; result; vector&lt;TreeNode*&gt; v1,v2; if(root == nullptr)&#123; return result; &#125; v1.push_back(root); while(!v1.empty())&#123; // 遍历v1中的所有节点，将下一层节点保存在v2中 for(int i=0;i&lt;v1.size();i++)&#123; if(v1[i]-&gt;left)&#123; v2.push_back(v1[i]-&gt;left); &#125; if(v1[i]-&gt;right)&#123; v2.push_back(v1[i]-&gt;right); &#125; &#125; vector&lt;int&gt; tmp; //打印v1 for(int i=0;i&lt;v1.size();i++)&#123; tmp.push_back(v1[i]-&gt;val); &#125; result.insert(result.begin(),tmp); swap(v1,v2); v2.clear(); &#125; return result; &#125; 123456789101112131415161718192021222324252627282930313233343536373839// 自顶向下遍历二叉树 vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode *root) &#123; // write your code here vector&lt;vector&lt;int&gt;&gt; result; if(!root) return result; vector&lt;TreeNode*&gt; v1,v2; v1.push_back(root); int level = 1; while(!v1.empty())&#123; //遍历v1中的节点，把v1中所有节点的下一级节点存储在v2中 for(int i=0;i&lt;v1.size();i++)&#123; if(v1[i]-&gt;left)&#123; v2.push_back(v1[i]-&gt;left); &#125; if(v1[i]-&gt;right)&#123; v2.push_back(v1[i]-&gt;right); &#125; &#125; // 打印v1中的节点,如果level 是奇数，则从左向又打印， // 如果level是偶数，则从右向左打印 vector&lt;int&gt; tmp; if(level % 2 == 0)&#123; for(int i=v1.size()-1;i&gt;=0;i--)&#123; tmp.push_back(v1[i]-&gt;val); &#125; &#125; if(level % 2 )&#123; for(int i=0;i&lt;v1.size();i++)&#123; tmp.push_back(v1[i]-&gt;val); &#125; &#125; result.push_back(tmp); // 更新该更新的数据 swap(v1,v2); v2.clear(); level++; &#125; return result; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 之字形遍历二叉树vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123; vector&lt;vector&lt;int&gt; &gt; output; vector&lt;int&gt; row; if(pRoot == nullptr) return output; vector&lt;TreeNode*&gt; first; vector&lt;TreeNode*&gt; second; bool odd = true; first.push_back(pRoot); while(!first.empty())&#123; if(odd)&#123; for (int i = 0; i &lt; first.size(); ++i) &#123; row.push_back(first[i]-&gt;val); if(first[i]-&gt;left)&#123; second.push_back(first[i]-&gt;left); &#125; if(first[i]-&gt;right)&#123; second.push_back(first[i]-&gt;right); &#125; &#125; output.push_back(row); row.clear(); swap(first,second); second.clear(); odd = !odd; &#125;else&#123; for (int i = first.size()-1; i &gt;= 0; --i) &#123; row.push_back(first[i]-&gt;val); &#125; output.push_back(row); row.clear(); for (int j = 0; j &lt; first.size(); ++j) &#123; if(first[j]-&gt;left)&#123; second.push_back(first[j]-&gt;left); &#125; if(first[j]-&gt;right)&#123; second.push_back(first[j]-&gt;right); &#125; &#125; swap(first,second); second.clear(); odd = !odd; &#125; &#125; return output;&#125; 平衡二叉树 平衡二叉树的定义是：要么是一棵空树，要么根节点左右两棵子树的高度相差不超过1，并且左右两个子树也是平衡二叉树。 平衡二叉树的判定 1234567891011121314151617181920212223242526272829303132333435363738// 求树的最大深度int maxDepth(TreeNode* root) &#123; if(root == nullptr) return 0; int left = 1; int right = 1; int depth = 1; if(root-&gt;left)&#123; left += maxDepth(root-&gt;left); &#125; if(root-&gt;right)&#123; right += maxDepth(root-&gt;right); &#125; depth = max(left,right); return depth;&#125;// 判断二叉树是否是平衡二叉树bool isBalanced(TreeNode* root) &#123; if(root == nullptr) return true; if(root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) return true; if(root-&gt;left &amp;&amp; root-&gt;right == nullptr)&#123; if(root-&gt;left-&gt;left== nullptr &amp;&amp; root-&gt;left-&gt;right == nullptr)&#123; return true; &#125; return false; &#125; if(root-&gt;left == nullptr &amp;&amp; root-&gt;right)&#123; if(root-&gt;right-&gt;left == nullptr &amp;&amp; root-&gt;right-&gt;right == nullptr)&#123; return true; &#125; return false; &#125; bool left = isBalanced(root-&gt;left); bool right = isBalanced(root-&gt;right); int ldepth = maxDepth(root-&gt;left); int rdepth = maxDepth(root-&gt;right); if(abs(ldepth-rdepth)&lt;=1 &amp;&amp; left &amp;&amp; right) return true; return false;&#125; 二叉搜索树(二叉查找树) 二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树： 若任意结点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若任意结点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 任意结点的左、右子树也分别为二叉查找树。 没有键值相等的结点（no duplicate nodes）。 因为，一棵由n个结点，随机构造的二叉查找树的高度为lgn，所以顺理成章，一般操作的执行时间为O（lgn）.（至于n个结点的二叉树高度为lgn的证明，可参考算法导论 第12章 二叉查找树 第12.4节）。 但二叉树若退化成了一棵具有n个结点的线性链后，则此些操作最坏情况运行时间为O（n）。后面我们会看到一种基于二叉查找树-红黑树，它通过一些性质使得树相对平衡，使得最终查找、插入、删除的时间复杂度最坏情况下依然为O（lgn）。 二叉搜索树的判定 12 二叉搜索树的遍历序列 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 1234567891011121314151617181920212223242526// 思路：如果是二叉搜索树的后序遍历序列，那么最后一个一定是根，并且一定可以存在这样的关系：根前面的元素分成两部分，前一部分都比根小，后一部分都比根大，注意，这里前一部分和后一部分都可能为空。判断给出的序列是否满足这样的规律，然后分别递归判断左右两个分支。bool bst(vector&lt;int&gt; &amp;a,int l,int r)&#123; // 1. 找到第一个比根(r)小的元素，这里作为左右子树的分界 if(l&gt;=r) return true; int i=r-1; while(i&gt;=l &amp;&amp; a[i]&gt;a[r])&#123; --i; &#125; // 此时i指向从后向前第一个小于a[r]的元素 // 2. 检查从i到l的所有元素是否都小于a[r] int mid = i; while(i&gt;=l)&#123; if(a[i] &gt;= a[r])&#123; return false; &#125; i--; &#125; // 此时 i应该等于l-1 // 3. 划分出左右子树并且确保符合二叉搜索树的要求，递归左右子树，看是否符合要求 return bst(a,l,mid) &amp;&amp; bst(a,mid+1,r-1); &#125; bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123; if(sequence.empty()) return false; return bst(sequence,0,sequence.size()-1); &#125; 红黑树 参考文章：http://blog.csdn.net/chenhuajie123/article/details/11951777 红黑树，本质上来说就是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n) 红黑树的性质： 每个结点要么是红的，要么是黑的。 根结点是黑的。 每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。 如果一个结点是红的，那么它的俩个儿子都是黑的。 对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。 红黑树的示例： 2017-04-11_094148.png","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"算法专题_通用树结构","slug":"技术/数据结构和算法/算法专题_通用树结构","date":"2017-04-09T09:33:46.000Z","updated":"2019-03-28T00:54:57.031Z","comments":true,"path":"2017/04/09/技术/数据结构和算法/算法专题_通用树结构/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/04/09/技术/数据结构和算法/算法专题_通用树结构/","excerpt":"学习树结构的时候，做了大量二叉树的题目，了解了二叉树的表示结构和各种操作。但是当遇到普通的树的时候，一时竟不知道如何表示。其实树就是没有环的图。所以用来表示图的两种方法都可以用来表示一般的树结构。","text":"学习树结构的时候，做了大量二叉树的题目，了解了二叉树的表示结构和各种操作。但是当遇到普通的树的时候，一时竟不知道如何表示。其实树就是没有环的图。所以用来表示图的两种方法都可以用来表示一般的树结构。 定义 邻接表 用一个二维的数组(或者链表)表示每个节点的相邻的节点有哪些。 邻接矩阵 用一个矩阵表示哪两个节点之间直接相连。 应用 无根树化为有根树 将一棵树转换成以其中某个节点为根的树。 hihocoder 1542 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1005;vector&lt;int&gt; v[maxn];int n,rt;int par[maxn];void dfs(int x,int p)&#123; par[x] = p; for(int i=0;i&lt;v[x].size();i++) &#123; int toit = v[x][i]; if(toit!=p) dfs(toit,x); &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; rt; int a, b; for(int i=1;i&lt;n;i++) &#123; cin &gt;&gt; a &gt;&gt; b; v[a].push_back(b); v[b].push_back(a); &#125; dfs(rt,0); for(int i=1;i&lt;=n;i++) cout &lt;&lt; par[i] &lt;&lt; (i==n?'\\n':' '); return 0;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"做过的算法题汇总表","slug":"技术/数据结构和算法/做过的算法题汇总表","date":"2017-04-08T13:52:05.000Z","updated":"2019-03-28T00:54:56.030Z","comments":true,"path":"2017/04/08/技术/数据结构和算法/做过的算法题汇总表/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/04/08/技术/数据结构和算法/做过的算法题汇总表/","excerpt":"在各个不同的平台上做过的算法题目。","text":"在各个不同的平台上做过的算法题目。 [lintcode] 二叉树的前序遍历 - C++ [lintcode] http://www.lintcode.com/zh-cn/problem/binary-tree-preorder-traversal/ 1234567891011121314151617181920212223242526272829303132333435/** * Definition of TreeNode: * class TreeNode &#123; * public: * int val; * TreeNode *left, *right; * TreeNode(int val) &#123; * this-&gt;val = val; * this-&gt;left = this-&gt;right = NULL; * &#125; * &#125; */class Solution &#123;public: /** * @param root: The root of binary tree. * @return: Preorder in vector which contains node values. */ vector&lt;int&gt; preorderTraversal(TreeNode *root) &#123; // write your code here vector&lt;int&gt; re; if(root == nullptr) return re; re.push_back(root-&gt;val); if(root-&gt;left)&#123; vector&lt;int&gt; ll = preorderTraversal(root-&gt;left); re.insert(re.end(), ll.begin(), ll.end()); &#125; if(root-&gt;right)&#123; vector&lt;int&gt; rr = preorderTraversal(root-&gt;right); re.insert(re.end(), rr.begin(), rr.end()); &#125; return re; &#125;&#125;; 二叉树的中序遍历 - C++ [lintcode] http://www.lintcode.com/zh-cn/problem/binary-tree-inorder-traversal/ 12345678910111213141516171819202122232425262728293031323334/** * Definition of TreeNode: * class TreeNode &#123; * public: * int val; * TreeNode *left, *right; * TreeNode(int val) &#123; * this-&gt;val = val; * this-&gt;left = this-&gt;right = NULL; * &#125; * &#125; */class Solution &#123; /** * @param root: The root of binary tree. * @return: Inorder in vector which contains node values. */public: vector&lt;int&gt; inorderTraversal(TreeNode *root) &#123; // write your code here vector&lt;int&gt; re; if(root == nullptr) return re; if(root-&gt;left)&#123; vector&lt;int&gt; ll = inorderTraversal(root-&gt;left); re.insert(re.end(),ll.begin(),ll.end()); &#125; re.push_back(root-&gt;val); if(root-&gt;right)&#123; vector&lt;int&gt; rr = inorderTraversal(root-&gt;right); re.insert(re.end(),rr.begin(),rr.end()); &#125; return re; &#125;&#125;; 二叉树的后序遍历 - C++ [lintcode] http://www.lintcode.com/zh-cn/problem/binary-tree-postorder-traversal/ 12345678910111213141516171819202122232425262728293031323334/** * Definition of TreeNode: * class TreeNode &#123; * public: * int val; * TreeNode *left, *right; * TreeNode(int val) &#123; * this-&gt;val = val; * this-&gt;left = this-&gt;right = NULL; * &#125; * &#125; */class Solution &#123; /** * @param root: The root of binary tree. * @return: Postorder in vector which contains node values. */public: vector&lt;int&gt; postorderTraversal(TreeNode *root) &#123; // write your code here vector&lt;int&gt; re; if(root == nullptr) return re; if(root-&gt;left)&#123; vector&lt;int&gt; ll = postorderTraversal(root-&gt;left); re.insert(re.end(),ll.begin(),ll.end()); &#125; if(root-&gt;right)&#123; vector&lt;int&gt; rr = postorderTraversal(root-&gt;right); re.insert(re.end(),rr.begin(),rr.end()); &#125; re.push_back(root-&gt;val); return re; &#125;&#125;; 二叉树的最大深度 - C++ [lintcode] http://www.lintcode.com/zh-cn/problem/maximum-depth-of-binary-tree/ 1234567891011121314151617181920212223242526272829303132/** * Definition of TreeNode: * class TreeNode &#123; * public: * int val; * TreeNode *left, *right; * TreeNode(int val) &#123; * this-&gt;val = val; * this-&gt;left = this-&gt;right = NULL; * &#125; * &#125; */class Solution &#123;public: /** * @param root: The root of binary tree. * @return: An integer */ int maxDepth(TreeNode *root) &#123; // write your code here if(root == nullptr) return 0; int maxDL = 1; int maxDR = 1; if(root-&gt;left)&#123; maxDL += maxDepth(root-&gt;left); &#125; if(root-&gt;right)&#123; maxDR += maxDepth(root-&gt;right); &#125; return max(maxDL,maxDR); &#125;&#125;; 二叉树的最小深度 - C++ [lintcode] http://www.lintcode.com/zh-cn/problem/minimum-depth-of-binary-tree/ 123456789101112131415161718192021222324252627282930313233/** * Definition of TreeNode: * class TreeNode &#123; * public: * int val; * TreeNode *left, *right; * TreeNode(int val) &#123; * this-&gt;val = val; * this-&gt;left = this-&gt;right = NULL; * &#125; * &#125; */class Solution &#123;public: /** * @param root: The root of binary tree. * @return: An integer */ int minDepth(TreeNode *root) &#123; // write your code here // write your code here if(root == nullptr) return 0; int maxDL = 1; int maxDR = 1; if(root-&gt;left)&#123; maxDL += maxDepth(root-&gt;left); &#125; if(root-&gt;right)&#123; maxDR += maxDepth(root-&gt;right); &#125; return min(maxDL,maxDR); &#125;&#125;; 二叉树的层次遍历 II - C++ [lintcode] http://www.lintcode.com/zh-cn/problem/binary-tree-level-order-traversal-ii/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Definition of TreeNode: * class TreeNode &#123; * public: * int val; * TreeNode *left, *right; * TreeNode(int val) &#123; * this-&gt;val = val; * this-&gt;left = this-&gt;right = NULL; * &#125; * &#125; */class Solution &#123; /** * @param root : The root of binary tree. * @return : buttom-up level order a list of lists of integer */public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode *root) &#123; // write your code here vector&lt;vector&lt;int&gt;&gt; result; vector&lt;TreeNode*&gt; v1,v2; if(root == nullptr)&#123; return result; &#125; v1.push_back(root); while(!v1.empty())&#123; // 遍历v1中的所有节点，将下一层节点保存在v2中 for(int i=0;i&lt;v1.size();i++)&#123; if(v1[i]-&gt;left)&#123; v2.push_back(v1[i]-&gt;left); &#125; if(v1[i]-&gt;right)&#123; v2.push_back(v1[i]-&gt;right); &#125; &#125; vector&lt;int&gt; tmp; //打印v1 for(int i=0;i&lt;v1.size();i++)&#123; tmp.push_back(v1[i]-&gt;val); &#125; result.insert(result.begin(),tmp); swap(v1,v2); v2.clear(); &#125; return result; &#125;&#125;; 二叉树的锯齿形层次遍历 - C++ [lintcode] http://www.lintcode.com/zh-cn/problem/binary-tree-zigzag-level-order-traversal/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * Definition of TreeNode: * class TreeNode &#123; * public: * int val; * TreeNode *left, *right; * TreeNode(int val) &#123; * this-&gt;val = val; * this-&gt;left = this-&gt;right = NULL; * &#125; * &#125; */class Solution &#123; /** * @param root: The root of binary tree. * @return: A list of lists of integer include * the zigzag level order traversal of its nodes' values */public: vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode *root) &#123; // write your code here vector&lt;vector&lt;int&gt;&gt; result; if(!root) return result; vector&lt;TreeNode*&gt; v1,v2; v1.push_back(root); int level = 1; while(!v1.empty())&#123; //遍历v1中的节点，把v1中所有节点的下一级节点存储在v2中 for(int i=0;i&lt;v1.size();i++)&#123; if(v1[i]-&gt;left)&#123; v2.push_back(v1[i]-&gt;left); &#125; if(v1[i]-&gt;right)&#123; v2.push_back(v1[i]-&gt;right); &#125; &#125; // 打印v1中的节点,如果level 是奇数，则从左向又打印， // 如果level是偶数，则从右向左打印 vector&lt;int&gt; tmp; if(level % 2 == 0)&#123; for(int i=v1.size()-1;i&gt;=0;i--)&#123; tmp.push_back(v1[i]-&gt;val); &#125; &#125; if(level % 2 )&#123; for(int i=0;i&lt;v1.size();i++)&#123; tmp.push_back(v1[i]-&gt;val); &#125; &#125; result.push_back(tmp); // 更新该更新的数据 swap(v1,v2); v2.clear(); level++; &#125; return result; &#125;&#125;; 用栈实现队列 - C++ [lintcode] http://www.lintcode.com/zh-cn/problem/implement-queue-by-two-stacks/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class MyQueue &#123;public: stack&lt;int&gt; stack1; stack&lt;int&gt; stack2; MyQueue() &#123; // do intialization if necessary &#125; void push(int element) &#123; // write your code here stack1.push(element); &#125; int pop() &#123; // write your code here if(stack2.empty())&#123; if(stack1.empty())&#123; return -1; &#125; while(!stack1.empty())&#123; int a = stack1.top(); stack1.pop(); stack2.push(a); &#125; &#125; int a = stack2.top(); stack2.pop(); return a; &#125; int top() &#123; // write your code here if(stack2.empty())&#123; if(stack1.empty())&#123; return -1; &#125; while(!stack1.empty())&#123; int a = stack1.top(); stack1.pop(); stack2.push(a); &#125; &#125; int a = stack2.top(); return a; &#125;&#125;; 线段树的构造 - C++ [lintcode] http://www.lintcode.com/zh-cn/problem/segment-tree-build/ 123456789101112131415161718192021222324252627282930/** * Definition of SegmentTreeNode: * class SegmentTreeNode &#123; * public: * int start, end; * SegmentTreeNode *left, *right; * SegmentTreeNode(int start, int end) &#123; * this-&gt;start = start, this-&gt;end = end; * this-&gt;left = this-&gt;right = NULL; * &#125; * &#125; */class Solution &#123;public: /** *@param start, end: Denote an segment / interval *@return: The root of Segment Tree */ SegmentTreeNode * build(int start, int end) &#123; // write your code here if(start &gt; end) return nullptr; SegmentTreeNode *node = new SegmentTreeNode(start,end); if( start &lt; end ) &#123; node-&gt;left = build(node-&gt;start,(node-&gt;start+node-&gt;end)/2); node-&gt;right = build((node-&gt;start+node-&gt;end)/2+1,node-&gt;end); &#125; return node; &#125;&#125;; 线段树的查询 - C++ [lintcode] http://www.lintcode.com/zh-cn/problem/segment-tree-query/ 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition of SegmentTreeNode: * class SegmentTreeNode &#123; * public: * int start, end, max; * SegmentTreeNode *left, *right; * SegmentTreeNode(int start, int end, int max) &#123; * this-&gt;start = start; * this-&gt;end = end; * this-&gt;max = max; * this-&gt;left = this-&gt;right = NULL; * &#125; * &#125; */class Solution &#123;public: /** *@param root, start, end: The root of segment tree and * an segment / interval *@return: The maximum number in the interval [start, end] */ int query(SegmentTreeNode *root, int start, int end) &#123; // write your code here // 区间比根区间还大的情况 if(start &lt;= root-&gt;start &amp;&amp; end &gt;= root-&gt;end)&#123; return root-&gt;max; &#125; //如果左边界已经大于等于又边界 或者 右边界已经大于等于左边界， 则不存在的这样的区域 //返回不影响计算最大值的数字 if(start&gt;root-&gt;end || end &lt; root-&gt;start)&#123; return 0; &#125; int ll = query(root-&gt;left,start,end); int rr = query(root-&gt;right,start,end); return max(ll,rr); &#125;&#125;; 线段树查询 II - C++ [lintcode] http://www.lintcode.com/zh-cn/problem/segment-tree-query-ii/ 12345678910111213141516171819202122232425262728293031323334353637/** * Definition of SegmentTreeNode: * class SegmentTreeNode &#123; * public: * int start, end, count; * SegmentTreeNode *left, *right; * SegmentTreeNode(int start, int end, int count) &#123; * this-&gt;start = start; * this-&gt;end = end; * this-&gt;count = count; * this-&gt;left = this-&gt;right = NULL; * &#125; * &#125; */class Solution &#123;public: /** *@param root, start, end: The root of segment tree and * an segment / interval *@return: The count number in the interval [start, end] */ int query(SegmentTreeNode *root, int start, int end) &#123; // write your code here if(!root||start&gt;end) return 0; // 如果数据非法就返回0，表示这个区间没有元素 if(start&lt;=root-&gt;start&amp;&amp;end&gt;=root-&gt;end) return root-&gt;count; //如果给出的区间比根的区间还大，不用查找，直接返回根区间的元素个数 int mid = (root-&gt;start + root-&gt;end)/2; if(start&gt;mid) return query(root-&gt;right,start,end); else if(end&lt;mid+1) return query(root-&gt;left,start,end); else // 如果跨越分支，应该把两个分支的数据加在一起 return query(root-&gt;left,start,mid)+query(root-&gt;right,mid+1,end); &#125;&#125;; 统计前面比自己小的数的个数 - C++ [lintcode] http://www.lintcode.com/zh-cn/problem/count-of-smaller-number-before-itself/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107class Node&#123;public: Node(int _start, int _end) : start(_start), end(_end), left(nullptr), right(nullptr), cnt(0) &#123;&#125; int start, end; Node *left, *right; int cnt;&#125;;class Solution &#123;public: /** * @param A: An integer array * @return: Count the number of element before this element 'ai' is * smaller than it and return count number array */ vector&lt;int&gt; countOfSmallerNumberII(vector&lt;int&gt; &amp;A) &#123; // write your code here Node *root = build(0, 20000); vector&lt;int&gt; res; for (int i = 0; i &lt; A.size(); i++) &#123; int cnt = query(root, 0, A[i] - 1); res.push_back(cnt); modify(root, A[i]); &#125; return res; &#125;private: Node *build(int start, int end) &#123; if (start &gt; end) &#123; return NULL; &#125; if (start == end) &#123; return new Node(start, end); &#125; int mid = start + ((end - start) &gt;&gt; 1); Node *root = new Node(start, end); root-&gt;left = build(start, mid); root-&gt;right = build(mid + 1, end); return root; &#125; void modify(Node *root, int idx)&#123; if (root == NULL) &#123; return; &#125; if (root-&gt;start == root-&gt;end &amp;&amp; root-&gt;start == idx) &#123; ++(root-&gt;cnt); return; &#125; int mid = root-&gt;start + ((root-&gt;end - root-&gt;start) &gt;&gt; 1); if (mid &gt;= idx) &#123; modify(root-&gt;left, idx); &#125; else &#123; modify(root-&gt;right, idx); &#125; root-&gt;cnt = root-&gt;left-&gt;cnt + (root-&gt;right ? root-&gt;right-&gt;cnt : 0); &#125; int query(Node *root, int start, int end) &#123; if (root-&gt;end &lt; start || root-&gt;start &gt; end) &#123; return 0; &#125; if (root-&gt;start &gt;= start &amp;&amp; root-&gt;end &lt;= end) &#123; return root-&gt;cnt; &#125; int mid = root-&gt;start + ((root-&gt;end - root-&gt;start) &gt;&gt; 1); if (mid &gt;= end) &#123; return query(root-&gt;left, start, end); &#125; if (mid &lt; start) &#123; return query(root-&gt;right, start, end); &#125; int leftRes = query(root-&gt;left, start, mid); int rightRes = query(root-&gt;right, mid + 1, end); return leftRes + rightRes; &#125;&#125;; [nowcoder] 最小的K个数 C++ [nowcoder] 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=11047976 123456789101112class Solution &#123;public: vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123; vector&lt;int&gt; result; if(k&gt;(int)input.size()) return result; sort(input.begin(),input.end()); for(size_t i=0;i&lt;k;i++)&#123; result.push_back(input[i]); &#125; return result; &#125;&#125;; 找出出现的次数超过数组长度的一半的数 C++ [nowcoder] 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=11047857 123456789101112131415161718192021222324252627282930class Solution &#123;public: int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; if(numbers.size() == 0) return 0; if(numbers.size() == 1) return numbers[0]; int count = 1; int card = numbers[0]; for(size_t i=1;i&lt;numbers.size();i++)&#123; if(numbers[i] == card)&#123; count++; &#125;else&#123; count--; if(count == 0)&#123; card = numbers[i]; count = 1; &#125; &#125; &#125; int sum = 0; for(size_t i=0;i&lt;numbers.size();i++)&#123; if(numbers[i] == card)&#123; sum++; &#125; &#125; if(numbers.size()/2 &lt; sum)&#123; return card; &#125; return 0;&#125;&#125;; 找到第一个只出现一次的字符 C++ [nowcoder] 在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置。如果字符串为空,返回-1 https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=11034739 12345678910111213141516171819class Solution &#123;public: int FirstNotRepeatingChar(string str) &#123; // 统计每个字母的个数，只出现一次的第一个字母的位置 if(str.empty()) return -1; vector&lt;int&gt; hash(256,0); for(size_t i=0;i&lt;str.size();i++)&#123; hash[str[i]]++; &#125; // 之所以这样顺序正确，是因为我们不是按照hash数组的顺序来遍历的 //而是按照str[i]作为hash数组的下标来遍历的，这一点十分重要 for(size_t i=0;i&lt;str.size();i++)&#123; if(1==hash[str[i]])&#123; return i; &#125; &#125; return -1; &#125;&#125;; 找到第1500个丑数 C++ [nowcoder] 把只包含素因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=11033314 12345678910111213141516171819class Solution &#123;public: int GetUglyNumber_Solution(int index) &#123; if (index &lt; 7)return index; vector&lt;int&gt; res(index); res[0] = 1; //开始的时候t2,t3,t5都指向开始的1，一旦出现被使用一次的情况，就加1，这样保证 //不会重复比较，也不会漏掉 int t2 = 0, t3 = 0, t5 = 0, i; for (i = 1; i &lt; index; ++i) &#123; res[i] = min(res[t2] * 2, min(res[t3] * 3, res[t5] * 5)); if (res[i] == res[t2] * 2)t2++; if (res[i] == res[t3] * 3)t3++; if (res[i] == res[t5] * 5)t5++; &#125; return res[index - 1]; &#125;&#125;; 打印所有数字中最小的一个 C++ [nowcoder] 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=11021544 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192class Solution &#123;public:struct NumBit&#123; int num; NumBit(int n) : num(n) &#123;&#125; bool operator&lt;(const struct NumBit &amp; right)const //重载&lt;运算符 &#123; vector&lt;int&gt; vtmp1; int n = this-&gt;num; int b = 0; while(n)&#123; b = n % 10; vtmp1.insert(vtmp1.begin(),b); n /= 10; &#125; vector&lt;int&gt; vtmp2; int n2 = right.num; int b2 = 0; while(n2)&#123; b2 = n2 % 10; vtmp2.insert(vtmp2.begin(),b2); n2 /= 10; &#125; int i = 0; int j = 0; int ilen = vtmp1.size(); int jlen = vtmp2.size(); while( i&lt;ilen || j&lt;jlen )&#123; if(i&lt;ilen &amp;&amp; j&lt;jlen &amp;&amp; vtmp1[i] &gt; vtmp2[j])&#123; return false; &#125;else if(i&lt;ilen &amp;&amp; j&lt;jlen &amp;&amp; vtmp1[i] &lt; vtmp2[j])&#123; return true; &#125;else if(i&lt;ilen &amp;&amp; j&lt;jlen &amp;&amp; vtmp1[i] == vtmp2[j])&#123; i++; j++; &#125;else if(i==ilen)&#123; if(vtmp2[j] &gt; vtmp2[0]) return true; else if(vtmp2[j] &lt; vtmp2[0]) return false; else if(j == jlen)&#123; return false; &#125;else&#123; j++; &#125; &#125;else if(j==jlen)&#123; if(vtmp1[i] &gt; vtmp1[0]) return false; else if(vtmp1[i] &lt; vtmp1[0]) return true; else if(i == ilen)&#123; return true; &#125;else&#123; i++; &#125; &#125;else&#123; break; &#125; &#125; return false; &#125;&#125;; string Int_to_String(int n) &#123; ostringstream stream; stream&lt;&lt;n; //n为int类型 return stream.str(); &#125; // 解题思路： 构成最小的数字，其实质就是从最高位开始，每次都选择最小的数字作为最高位 // 只需要对原来的数字按照下面的规则排序就可以做到 // 把两个数字的最高位对齐，例如 // 3332 // 332 // 从左向右比较，如果数字小的排在前面，如果数字相等，比较后面一位。如果其中一个数字没有了， // 那么比较另外一个剩下的数字与首数字的关系，如果大于首数字，则该数较大，如果小于该数字，则该数较小 //如果相等，则指针后移，继续比较下一位，直到结束，如果直到结束都没有比较出大小，可以认为两个数一样大. //使用自定义的比较方法之后，直接使用multiset排序，然后拼接在一起就是结果 string PrintMinNumber(vector&lt;int&gt; numbers) &#123; string re; multiset&lt;NumBit&gt; s; // 存放每个数字的各位数字 for(int i=0;i&lt;numbers.size();i++)&#123; NumBit *tmp = new NumBit(numbers[i]); s.insert(s.end(),*tmp); &#125; while(!s.empty())&#123; NumBit t = *s.begin(); re.append( Int_to_String(t.num)); s.erase(s.begin(),++s.begin()); &#125; // 每次选择最小的数字放在高位上 return re; &#125;&#125;; 整数中1出现的次数 C++ [nowcoder] 求出113的整数中1出现的次数,并算出1001300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。 https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=11014410 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int NumberOf1Between1AndN_Solution(int n) &#123; //整体思路是分别计算当各位，十位，百位..为1的时候其他的位有多少中可能的情况 //其实就是一个有限制条件的排列组合问题 float sum = 0; int i=0; int b = 0; int tb = 0; float tail = 0; // 结尾的数字 while(n)&#123; b = n % 10; n /= 10; if(i&gt;0)&#123; tail = tb * pow(10.0,i-1) + tail; cout&lt;&lt;\"==\"&lt;&lt;tail&lt;&lt;endl; &#125; if(b == 0)&#123; sum += (n)*pow(10.0,i); &#125; else if( b == 1)&#123; sum += (n)*pow(10.0,i) + tail + 1; &#125;else&#123; sum += (n+1)*pow(10.0,i); &#125; i++; tb = b; &#125; return sum; &#125;&#125;; 所有和为S的连续正数序列 C++ [nowcoder] 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=11007141 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123; vector&lt;vector&lt;int&gt;&gt; result; map&lt;int,vector&lt;int&gt;&gt; m; // 连续和等于sum，有两种情况，奇数个和偶数个 //如果奇数个连续的整数和等于sum, 那么位于中间的那个数一定可以被sum整除 //如果偶数个连续的整数和等于sum,那么必然有最中间的两个数的和可以被sum整除 for(int i=sqrt(2*sum);i&gt;=1;i--)&#123; vector&lt;int&gt; v; if(sum % i != 0) continue; // i表示有多少个连续的数字加和成sum,如果sum不能整除i，肯定不可能有解 if(i % 2 == 0 || i == 1)&#123; //有偶数个数字 int pair = sum / i ; if((pair - 1 ) % 2 == 0)&#123; cout&lt;&lt;i&lt;&lt;endl; int pair1 = (pair - 1) / 2; //找到了位于最中间位置的两个数字 int pair2 = pair1 + 1; int start = pair1 - i + 1; // 最开始的数字 int end = pair2 + i -1 ; //结尾的数字 if(start &gt; 0) &#123; for(int a = start;a&lt;=end;a++)&#123; v.push_back(a); &#125; &#125; &#125; &#125;else&#123; // 有奇数个数字 if(sum % i == 0)&#123; cout&lt;&lt;i&lt;&lt;endl; int mid = sum / i ; //最中间的数字 if(mid - (i-1)/2 &gt; 0)&#123; for(int a = mid - (i-1)/2;a&lt;=mid+(i-1)/2;a++)&#123; v.push_back(a); &#125; &#125; &#125; &#125; if(!v.empty())&#123; m[v[0]] = v; &#125; &#125; for(auto e = m.begin();e!=m.end();e++)&#123; result.push_back(e-&gt;second); &#125; return result;&#125;&#125;; 循环删除整数数列问题 C++ [nowcoder] 每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10998340 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int LastRemaining_Solution(int n, int m) &#123; if(n == 0) return -1; vector&lt;bool&gt; v(n,true); int count = 0; // 记录数过的数字 int deleted = 0; //记录删除的数字 int i = 0; while(true)&#123; if(v[i])&#123; count++; &#125; if(count == m)&#123; v[i] = false; cout&lt;&lt;i&lt;&lt;endl; count = 0; deleted++; &#125; i++; if( i &gt;= n)&#123; i = i % n ; &#125; if(deleted == n-1)&#123; break; &#125; &#125; for(int i=0;i&lt;n;i++)&#123; if(v[i])&#123; return i; &#125; &#125; return -1; &#125;&#125;; 图中是否包含某条路径 C++ [nowcoder] 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如[a b c e s f c s a d e e]是3*4矩阵，其包含字符串“bcced”的路径，但是矩阵中不包含“abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10995271 12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool dfs(char* matrix,char* path,int rows,int cols,int i,int j,char* str,int k)&#123; int t=i*cols+j; if(i&lt;0||i&gt;=rows||j&lt;0||j&gt;=cols||path[t]) return false; if(matrix[t]==str[k])&#123; path[t]=1; if(str[k+1]==0) return true; if(dfs(matrix,path,rows,cols,i+1,j,str,k+1)==true) return true; if(dfs(matrix,path,rows,cols,i-1,j,str,k+1)==true) return true; if(dfs(matrix,path,rows,cols,i,j+1,str,k+1)==true) return true; if(dfs(matrix,path,rows,cols,i,j-1,str,k+1)==true) return true; path[t]=0; &#125; return false; &#125; bool hasPath(char* matrix, int rows, int cols, char* str) &#123; if(matrix==NULL||str==NULL||str[0]==0||rows&lt;=0||cols&lt;=0) return false; int i,j; char* path=new char[100000](); for(i=0;i&lt;rows;i++)&#123; for(j=0;j&lt;cols;j++)&#123; if(dfs(matrix,path,rows,cols,i,j,str,0)==true) &#123;delete[] path;return true;&#125; &#125; &#125; delete[] path; return false; &#125;&#125;; 机器人能够达到多少个格子 C++ [nowcoder] 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10992716 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: //求数位之和 int sumS(int a)&#123; int sum = 0; while(a)&#123; sum += a % 10; a = a / 10; &#125; return sum; &#125; // 暴力解法时间复杂度太高 int movingCount(int threshold, int rows, int cols) &#123; int count = 0; if(rows == 1)&#123; for(int j=0;j&lt;cols;j++)&#123; if(sumS(j)&lt;=threshold)&#123; count++; &#125;else&#123; break; &#125; &#125; return count; &#125;else if(cols == 1)&#123; for(int i=0;i&lt;rows;i++)&#123; if(sumS(i)&lt;=threshold)&#123; count++; &#125;else&#123; break; &#125; &#125; return count; &#125;else&#123; for(int i=0;i&lt;rows;i++)&#123; for(int j=0;j&lt;cols;j++)&#123; if(sumS(i) + sumS(j) &lt;= threshold)&#123; count++; &#125; &#125; &#125; return count; &#125; &#125;&#125;; 找到只出现一次的数字 C++ [nowcoder] Given an array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10769216 12345678910class Solution &#123;public: int singleNumber(int A[], int n) &#123; int result = A[0]; for(size_t i=1;i&lt;n;i++)&#123; result ^= A[i]; &#125; return result; &#125;&#125;; 查找数组中未出现的最小正整数 C++ [nowcoder] 请设计一个高效算法，查找数组中未出现的最小正整数。 给定一个整数数组A和数组的大小n，请返回数组中未出现的最小正整数。保证数组大小小于等于500。 测试样例： [-1,2,3,4],4 返回：1 https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10735711 123456789101112131415161718192021class ArrayMex &#123;public: int findArrayMex(vector&lt;int&gt; A, int n) &#123; // write code here int minValue; int intV = 1; while(true)&#123; minValue = intV+1; for(int i=0;i&lt;n;i++)&#123; if(A[i]&gt;=intV)&#123; minValue = min(minValue,A[i]); &#125; &#125; if(minValue != intV) return intV; else&#123; intV++; &#125; &#125; &#125;&#125;; 数组的单调和 C++ [nowcoder] 现定义数组单调和为所有元素i的f(i)值之和。这里的f(i)函数定义为元素i左边(不包括其自身)小于等于它的数字之和。请设计一个高效算法，计算数组的单调和。 给定一个数组A同时给定数组的大小n，请返回数组的单调和。保证数组大小小于等于500，同时保证单调和不会超过int范围。 测试样例： [1,3,5,2,4,6],6 返回：27 https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10733959 123456789101112131415161718class MonoSum &#123;public: int calcMonoSum(vector&lt;int&gt; A, int n) &#123; // write code here //暴力方法 int total = 0; for(int i=1;i&lt;n;i++)&#123; int sum = 0; for(int j=i-1;j&gt;=0;j--)&#123; if(A[j]&lt;=A[i])&#123; sum+=A[j]; &#125; &#125; total += sum; &#125; return total; &#125;&#125;; C是否是A和B的混编 C++ [nowcoder] A、B和C。如果C包含且仅包含来自A和B的所有字符，而且在C中属于A的字符之间保持原来在A中的顺序，属于B的字符之间保持原来在B中的顺序，那么称C是A和B的混编。实现一个函数，判断C是否是A和B的混编。 给定三个字符串A,B和C，及他们的长度。请返回一个bool值，代表C是否是A和B的混编。保证三个串的长度均小于等于100。 测试样例： “ABC”,3,“12C”,3,“A12BCC”,6 返回：true https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10731304 12345678910111213141516171819202122232425262728293031323334353637class Mixture &#123;public: bool chkMixture(string A, int n, string B, int m, string C, int v) &#123; // 如果A+B的长度！= C的长度，肯定不能交错组成 if(n+m!=v) return false; //用动态规划的方法做，开一个dp[n+1][m+1]的数组， //dp[i][j] 表示A[1...i-1] 和B[1...j-1] 能否交错组成C[i+j-1] //这里第一行和第一列都表示空串，下标是-1时表示是空串。 vector&lt;vector&lt;bool&gt;&gt; dp(n+1,vector&lt;bool&gt;(m+1,false)); // 定义空串可以由空串交错组成 dp[0][0] = true; //初始化第一列，就是B为空串的时候，C能否由A交错组成。注意题目要求相对顺序不能改变 //所以如果A == C 就是true,否则后面的全部为false; for(size_t i=1;i&lt;=n;i++)&#123; if(A[i-1] == C[i-1]) dp[i][0] = true; else break; &#125; //初始化第一行。就是A为空串的时候，C能否由B交错组成 for(size_t j=1;j&lt;=m;j++)&#123; if(B[j-1] == C[j-1]) dp[0][j] = true; else break; &#125; // dp[i][j] 有以下两种情况 // 1. A[i-1] == C[i+j-1] &amp;&amp; dp[i-1][j] // 2. B[j-1] == C[i+j-1] &amp;&amp; dp[i][j-1] //以上任何一个条件成立，就可以交错组成，否则就不能 for(size_t i=1;i&lt;=n;i++)&#123; for(size_t j=1;j&lt;=m;j++)&#123; if(A[i-1] == C[i+j-1] &amp;&amp; dp[i-1][j] || B[j-1] == C[i+j-1] &amp;&amp; dp[i][j-1])&#123; dp[i][j] = true; &#125; &#125; &#125; return dp[n][m]; &#125;&#125;; 字符串交错组成 C++ [nowcoder] 对于三个字符串A，B，C。我们称C由A和B交错组成当且仅当C包含且仅包含A，B中所有字符，且对应的顺序不改变。请编写一个高效算法，判断C串是否由A和B交错组成。 给定三个字符串A,B和C，及他们的长度。请返回一个bool值，代表C是否由A和B交错组成。保证三个串的长度均小于等于100。 测试样例： “ABC”,3,“12C”,3,“A12BCC”,6 返回：true https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10730897 12345678910111213141516171819202122232425262728293031323334353637class Mixture &#123;public: bool chkMixture(string A, int n, string B, int m, string C, int v) &#123; // 如果A+B的长度！= C的长度，肯定不能交错组成 if(n+m!=v) return false; //用动态规划的方法做，开一个dp[n+1][m+1]的数组， //dp[i][j] 表示A[1...i-1] 和B[1...j-1] 能否交错组成C[i+j-1] //这里第一行和第一列都表示空串，下标是-1时表示是空串。 vector&lt;vector&lt;bool&gt;&gt; dp(n+1,vector&lt;bool&gt;(m+1,false)); // 定义空串可以由空串交错组成 dp[0][0] = true; //初始化第一列，就是B为空串的时候，C能否由A交错组成。注意题目要求相对顺序不能改变 //所以如果A == C 就是true,否则后面的全部为false; for(size_t i=1;i&lt;=n;i++)&#123; if(A[i-1] == C[i-1]) dp[i][0] = true; else break; &#125; //初始化第一行。就是A为空串的时候，C能否由B交错组成 for(size_t j=1;j&lt;=m;j++)&#123; if(B[j-1] == C[j-1]) dp[0][j] = true; else break; &#125; // dp[i][j] 有以下两种情况 // 1. A[i-1] == C[i+j-1] &amp;&amp; dp[i-1][j] // 2. B[j-1] == C[i+j-1] &amp;&amp; dp[i][j-1] //以上任何一个条件成立，就可以交错组成，否则就不能 for(size_t i=1;i&lt;=n;i++)&#123; for(size_t j=1;j&lt;=m;j++)&#123; if(A[i-1] == C[i+j-1] &amp;&amp; dp[i-1][j] || B[j-1] == C[i+j-1] &amp;&amp; dp[i][j-1])&#123; dp[i][j] = true; &#125; &#125; &#125; return dp[n][m]; &#125;&#125;; 最小编辑代价 C++ [nowcoder] 对于两个字符串A和B，我们需要进行插入、删除和修改操作将A串变为B串，定义c0，c1，c2分别为三种操作的代价，请设计一个高效算法，求出将A串变为B串所需要的最少代价。 给定两个字符串A和B，及它们的长度和三种操作代价，请返回将A串变为B串所需要的最小代价。保证两串长度均小于等于300，且三种代价值均小于等于100。 测试样例： “abc”,3,“adc”,3,5,3,100 返回：8 https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10728936 123456789101112131415161718192021222324252627282930313233class MinCost &#123;public: int findMinCost(string A, int n, string B, int m, int c0, int c1, int c2) &#123; // write code here if(c2 &gt;= c0 + c1) c2 = c0 + c1 ; //动态规划，开一个dp[n+1][m+1]的数组，dp[i][j] 表示把A[i-1]编辑成B[j-1]的最小编辑代价； vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(m+1,0)); //初始化第一列，即编辑成空串的代价，想要编辑成空串，代价就是把字符都删除。 for(size_t i=0;i&lt;=n;i++)&#123; dp[i][0] = i * c1 ; &#125; //初始化第一行，将空串编辑成对应字符串的方法就是插入字符 for(size_t j=0;j&lt;=m;j++)&#123; dp[0][j] = j * c0 ; &#125; //求解dp[i][j] //dp[i][j]有三种情况； A[i-1]编辑成B[j-1]然后替换最后一个字符，需要注意的是，如果最后一个字符相同，则不用替换，所以为dp[i-1][j-1]+c2 或者 dp[i-1][j-1] //将A[i]编辑成B[i-1]然后插入B[i] dp[i][j-1]+c0 //将A[i]删除一个字符得到A[i-1] 然后将A[i-1]编辑成B[j] dp[i-1][j] + c1 for(size_t i=1;i&lt;=n;i++)&#123; for(size_t j=1;j&lt;=m;j++)&#123; dp[i][j] = min(dp[i-1][j] + c1,dp[i][j-1] + c0); if(A[i-1] == B[j-1])&#123; dp[i][j] = min(dp[i-1][j-1],dp[i][j]); &#125;else&#123; dp[i][j] = min(dp[i][j],dp[i-1][j-1]+c2); &#125; &#125; &#125; //返回结果 return dp[n][m]; &#125;&#125;; 最大间隔 C++ [nowcoder] 给定一个递增序列，a1 &lt;a2 &lt;...&lt;an 。定义这个序列的最大间隔为d=max{ai+1 - ai }(1≤i&lt;n),现在要从a2 ,a3 ..an-1中删除一个元素。问剩余序列的最大间隔最小是多少？ https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10725149 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int n; while(cin&gt;&gt;n)&#123; if(n&lt;=2) cout&lt;&lt;-1&lt;&lt;endl; else&#123; vector&lt;int&gt; v(n,0); for(size_t i=0;i&lt;n;i++)&#123; cin&gt;&gt;v[i]; &#125; int maxV = v[1] - v[0]; //统计原来的最大间隔 for(size_t i=0;i&lt;n-1;i++)&#123; maxV = max(maxV,v[i+1]-v[i]); &#125; //计算删除一个元素之后的最大间隔 int minV = v[2] - v[0]; for(size_t i=1;i&lt;n-1;i++)&#123; minV = min(minV,v[i+1]-v[i-1]) ; &#125; if(minV &lt;= maxV)&#123; cout&lt;&lt;maxV&lt;&lt;endl; &#125; if(minV &gt; maxV)&#123; cout&lt;&lt;minV&lt;&lt;endl; &#125; &#125; &#125; return 0;&#125; 搬圆桌 c++ [nowcoder] 现在有一张半径为r的圆桌，其中心位于(x,y)，现在他想把圆桌的中心移到(x1,y1)。每次移动一步，都必须在圆桌边缘固定一个点然后将圆桌绕这个点旋转。问最少需要移动几步。 https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10724077 1234567891011121314#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;int main()&#123; int r, x, y, x1, y1; while (cin&gt;&gt;r&gt;&gt;x&gt;&gt;y&gt;&gt;x1&gt;&gt;y1)&#123; double distance = sqrt((double)(x-x1) * (x-x1) + (double)(y-y1) * (y-y1)); // 上取整 int step = (int)ceil(distance / (2*r)); cout &lt;&lt; step &lt;&lt; endl; &#125; return 0;&#125; 裁减网格纸 C++ [nowcoder] 度度熊有一张网格纸，但是纸上有一些点过的点，每个点都在网格点上，若把网格看成一个坐标轴平行于网格线的坐标系的话，每个点可以用一对整数x，y来表示。度度熊必须沿着网格线画一个正方形，使所有点在正方形的内部或者边界。然后把这个正方形剪下来。问剪掉正方形的最小面积是多少。 https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10721856 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int n; while(cin&gt;&gt;n)&#123; vector&lt;vector&lt;int&gt;&gt; v(n,vector&lt;int&gt;(2,0)); for(size_t i=0;i&lt;n;i++)&#123; cin&gt;&gt;v[i][0]; cin&gt;&gt;v[i][1]; &#125; int x_min=v[0][0]; int x_max=v[0][0]; int y_min=v[0][1]; int y_max=v[0][1]; for(size_t i=0;i&lt;n;i++)&#123; x_min = min(x_min,v[i][0]); x_max = max(x_max,v[i][0]); y_min = min(y_min,v[i][1]); y_max = max(y_max,v[i][1]); &#125; int x = x_max - x_min; int y = y_max - y_min; if(x&gt;y)&#123;cout&lt;&lt;x*x&lt;&lt;endl;&#125; if(x&lt;=y)&#123;cout&lt;&lt;y*y&lt;&lt;endl;&#125; &#125; return 0;&#125; 罪犯转移 C++ [nowcoder] C市现在要转移一批罪犯到D市，C市有n名罪犯，按照入狱时间有顺序，另外每个罪犯有一个罪行值，值越大罪越重。现在为了方便管理，市长决定转移入狱时间连续的c名犯人，同时要求转移犯人的罪行值之和不超过t，问有多少种选择的方式？ https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10720643 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; int n; int t; int c; while(cin&gt;&gt;n&gt;&gt;t&gt;&gt;c)&#123; vector&lt;int&gt; z(n,0); for(size_t i=0;i&lt;n;i++)&#123; cin&gt;&gt;z[i]; &#125; int sum = 0; for(size_t i=0;i&lt;c;i++)&#123; sum += z[i]; &#125; int count = 0; for(size_t i=0;i&lt;n-c+1;i++)&#123; if(sum&lt;=t)&#123;count++;&#125; sum = sum - z[i] + z[i+c]; &#125; cout&lt;&lt;count&lt;&lt;endl; &#125; return 0; &#125; 首个重复字符 C++ [nowcoder] 对于一个字符串，请设计一个高效算法，找到第一次重复出现的字符。 给定一个字符串(不一定全为字母)A及它的长度n。请返回第一个重复出现的字符。保证字符串中有重复字符，字符串的长度小于等于500。 测试样例： “qywyer23tdd”,11 返回：y https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10689361 123456789101112class FirstRepeat &#123;public: char findFirstRepeat(string A, int n) &#123; // write code here map&lt;char,int&gt; m; for(int i=0;i&lt;A.size();i++)&#123; if(m[A[i]]!=0) return A[i]; else m[A[i]]++; &#125; return A[0]; &#125;&#125;; 棋子翻转 在4x4的棋盘上摆满了黑白棋子，黑白两色的位置和数目随机其中左上角坐标为(1,1),右下角坐标为(4,4),现在依次有一些翻转操作，要对一些给定支点坐标为中心的上下左右四个棋子的颜色进行翻转，请计算出翻转后的棋盘颜色。 给定两个数组A和f,分别为初始棋盘和翻转位置。其中翻转位置共有3个。请返回翻转后的棋盘。 测试样例： [[0,0,1,1],[1,0,1,0],[0,1,1,0],[0,0,1,0]],[[2,2],[3,3],[4,4]] 返回：[[0,1,1,1],[0,0,1,0],[0,1,1,0],[0,0,1,0]] https://www.nowcoder.com/profile/6879987/codeBookDetail?submissionId=10681526 123456789101112131415161718class Flip &#123;public: vector&lt;vector&lt;int&gt; &gt; flipChess(vector&lt;vector&lt;int&gt; &gt; A, vector&lt;vector&lt;int&gt; &gt; f) &#123; // write code here // f.size() == 3 auto cow = A.size(); auto col = A.size(); for(int i=0;i&lt;f.size();i++)&#123; int x = f[i][0]-1; //转换成程序中常用的以0开始的坐标 int y = f[i][1]-1; if(x+1&lt;=cow-1)&#123; A[x+1][y] = 1-A[x+1][y];&#125; if(x-1&gt;=0)&#123;A[x-1][y] = 1- A[x-1][y];&#125; if(y-1&gt;=0)&#123;A[x][y-1] = 1-A[x][y-1];&#125; if(y+1&lt;=col-1)&#123;A[x][y+1] = 1-A[x][y+1];&#125; &#125; return A; &#125;&#125;; 最大差值 C++ [nowcoder] 有一个长为n的数组A，求满足0≤a≤b","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"C++语言技巧","slug":"技术/编程语言/C++/C++语言技巧","date":"2017-04-07T03:29:34.000Z","updated":"2019-03-28T00:08:58.642Z","comments":true,"path":"2017/04/07/技术/编程语言/C++/C++语言技巧/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/04/07/技术/编程语言/C++/C++语言技巧/","excerpt":"C++有关的概念和常用的代码。主要包括内存模型(堆内存，栈内存)，虚函数，虚表，const 的用法，include，sizeof, 构造函数等内容。","text":"C++有关的概念和常用的代码。主要包括内存模型(堆内存，栈内存)，虚函数，虚表，const 的用法，include，sizeof, 构造函数等内容。 基础概念 include (文件包含) include &lt;&gt; 和 include &quot;&quot; 有什么区别？ &lt;&gt;和&quot;&quot;的区别是系统在搜索头文件的时候顺序不同，&lt;&gt;在搜索的时候首先从系统目录开始搜索，然后搜索path环境变量下面，不搜索当前的目录； &quot;&quot;首先搜索当前目录，然后搜索系统和path目录，所以自己写的文件用双引号，系统自带的库用&lt;&gt;,主要是为了搜索快。 如何避免头文件被重复包含 按照如下的格式书写头文件： 123456#ifndef _HEADERNAME_H#define _HEADERNAME_H...//(头文件内容)#endif 这样头文件在第一次被包含的时候，_HEADERNAME_H 没有被定义，执行定义_HEADERNAME_H的动作并包含头文件的内容， 第二次包含的时候，_HEADERNAME_H 已经被定义，就不会包含后面的内容；_HEADERNAME_H是自定义的名称，需要为每一个头文件起一个不一样的名称，这样才能达到效果。 常量(const) 常量的定义方式和异同？ 有两种定义方式： define PI 3.14 和 const double PI = 3.14. define 定义的常量是在编译之前的预处理阶段执行的简单的字符串替换，就是把代码中所有出现PI的地方替换成3.14,不执行语法和类型的检查。 const定义的常量是在编译阶段处理的，有类型的检查和语法的检查，更安全。 如果使用define定义复杂的常量表达式，需要特别注意括号的使用。 顶层const和底层const const既可以修饰普通的变量(整形，字符串等)也可以修饰指针，假设一个指针p指向一个变量a, 如果指针是常量(p中存储的地址不能改变) 叫做顶层const, 如果a是常量(a中存储的数值不能改变)，叫做底层const. 顶层const的定义： int *const p = &amp;a; p 的值不能改变，但是可以通过p改变它指向的a的值； 底层const的定义： const int *p = &amp;a; p 的值可以改变，但是不能通过p改变它指向的a的值。 既是顶层也是底层：const int *const p = &amp;a; p的值不能改变，也不能通过p改变a的值； 常量表达式 值不会改变并且在编译的时候可以确定值的表达式就是常量表达式，可以使用constexpr声明常量表达式，这样编译器会自己判断表达式是否是常量表达式，如果不是，就会报错。constexpr int m = 20 + 90; constexpr 还可以用来修饰函数的返回值，这是一种常量函数，要保证在编译的时候就能得到结果。constexpr int getIntSize(){return 4;}这样一个函数在编译的时候就可以确定其返回值，所以该函数可以用来初始化常量。 需要注意的是，并不一定加了constexpr的函数就一定返回常量，也可以返回非常量，如果用返回非常量的constexpr函数初始化常量，编译器会报错。 虚函数 对于非 虚函数的调用，在编译的时候确定调用哪一个，例如函数的重载，通过函数参数的类型，个数就可以确定调用哪一个； 对于虚函数的调用，直到运行的时候才能确定应该调用哪一个函数。 当使用基类的引用调用基类的虚函数的时候，编译器是无法确定到底调用哪一个函数的，需要等到运行时，了解基类的指针或者引用具体绑定到了哪一个子类上，才能确定下来（调用该子类自己实现的函数版本). 虚函数 不代表 不被实现， 纯虚函数才是不被实现的函数； 虚函数的目的是允许用基类的指针调用子类的这个函数；（在基类中声明为虚函数就可以，子类中不用带virtual） 纯虚函数的目的是定义一个接口，规定所有继承该类的的子类必须实现这个函数； 包含纯虚函数的类是抽象类，不能实例化，不能创建类的实例。 虚析构函数的作用是在销毁对象的时候首先销毁基类指针指向的子类对象的实例，再执行基类对象的析构函数，如果子类不定义程虚析构函数，则不会执行子类的析构函数，容易造成内存泄漏。 堆内存和栈内存 http://www.cnblogs.com/yyxt/archive/2015/02/02/4268304.html char a[] = &quot;1234&quot;; 是存储在栈上的； char *a = &quot;1234&quot;; 是存储在堆上的； 栈内存访问的速度快于堆内存，因为堆内存的指针也是存放在栈上的，需要先访问栈，然后去堆上访问，对的地址也是不连续的，这导致访问的速度下降。 new malloc new 和 malloc 开辟的内存是存储在堆上的，需要自己去释放内存，否则只有在程序结束之后才有可能被操作系统回收。 delete 和 free 是用来释放内存的，delete 或调用被释放对象的析构函数，安全的释放内存，free 直接释放。 静态链接和动态连接 源文件–&gt;预编译–&gt;编译–&gt;汇编–&gt; 链接 –&gt;可执行程序 如果在链接的时候，将源文件中用到的库函数与汇编生成的文件合并生成一个可执行文件，之后的程序仅需要这个可执行文件即可运行，这样的方式叫做静态链接； 缺点是文件可能太大，毕竟一个简单的程序也会包含很多的头文件。 如果在链接的时候，不把源文件中用到的库合并在一起，而是单独编译，在运行的时候，用到的地方在去寻找该库，这种方式叫做动态链接，动态连接可以有效的避免重复，但是可移植性就受到限制，经常遇到的运行某个程序的时候XX找不到的错误就是动态链接库需要的文件丢失后者没有在正确的路径上导致的。 参考文章：http://www.cnblogs.com/52php/p/5681711.html 基本操作 字符串基本操作 12345678910111213#include &lt;string&gt;// 末尾添加一个字符s.push_back('a');// 末尾追加一个字符串s.append(\"aaa\");// 任意位置插入字符//任意位置插入字符串//任意位置删除字符//任意位置删除字符串 判断x是否是素数 12345678// 判断x是否是素数bool isPrime(int x)&#123; int xx = (int)sqrt((double)x); for(int i=2;i&lt;=xx;i++)&#123; if( x % i == 0) return false; &#125; return true;&#125; 找出n以内，2，3，5整除的所有数字 123456789101112131415161718192021222324252627282930// 返回三个数字中的最小值和最小值的索引int minThree(vector&lt;int&gt; v, int &amp;index)&#123; if(v.size()!=3) return -1; int minValue = v[0]; index = 0; if(minValue &gt; v[1])&#123; minValue = v[1]; index = 1; &#125; if(minValue &gt; v[2])&#123; minValue = v[2]; index = 2; &#125; return minValue;&#125;// 找出n以内所有能被2，3，5其中一个或者多个整除的数字vector&lt;int&gt; getNumbers(int x)&#123; vector&lt;int&gt; results=&#123;1&#125;; vector&lt;int&gt; index235 = &#123;1,1,1&#125;; int index = 0; int minValue = minThree(&#123;2*index235[0],3*index235[1],5*index235[2]&#125;,index); while(minValue&lt;=x)&#123; if(minValue != results[results.size()-1])&#123; results.push_back(minValue); &#125; index235[index]++; minValue = minThree(&#123;2*index235[0],3*index235[1],5*index235[2]&#125;,index); &#125; return results;&#125; 找出第1500个只包含2或3或5为因子的数字(从1开始) 123456789101112131415161718192021222324252627282930313233// 返回三个数字中的最小值和最小值的索引int minThree(vector&lt;int&gt; v, int &amp;index)&#123; if(v.size()!=3) return -1; int minValue = v[0]; index = 0; if(minValue &gt; v[1])&#123; minValue = v[1]; index = 1; &#125; if(minValue &gt; v[2])&#123; minValue = v[2]; index = 2; &#125; return minValue;&#125;// 找到第K个数字（从1开始）int getNumbers(int k)&#123; vector&lt;int&gt; index235 = &#123;1,1,1&#125;; int index = 0; int tmp = 1; int count = 1; int minValue = 1; while(count &lt; k)&#123; minValue = minThree(&#123;2*index235[0],3*index235[1],5*index235[2]&#125;,index); if(minValue != tmp)&#123; count++; tmp = minValue; &#125; index235[index]++; &#125; return minValue;&#125; 小于等于n的所有素数 123456789101112131415161718// 找出x以内的所有素数vector&lt;int&gt; getPrimes(int x)&#123; vector&lt;int&gt; Primes; // 初始化 0 - x 都是素数 vector&lt;bool&gt; isPrime(x+1,true); isPrime[0] = false; // 0 不是素数 isPrime[1] = false; // 1 不是素数 for(int i=2;i&lt;=x;i++)&#123; // 如果i是素数，把所有i的倍数设置成不是素数 if(isPrime[i])&#123; Primes.push_back(i); for(int j=i*2;j&lt;=x;j=j+i)&#123; isPrime[j] = false; &#125; &#125; &#125; return Primes;&#125; 最大公约数 1234567891011// 最大公约数int getY(int x,int y)&#123; int tmp = 0; while(y)&#123; tmp = y; y = x % y; x = tmp; &#125; return x;&#125; 自定义set的比较函数 存入set的元素默认是有序的，但是默认的比较可能不能满足我们的要求，这个时候 就需要自定义比较的函数。 set的排序是使用红黑树的结构，插入删除和取出最小的 元素都比较高效。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556struct NumBit&#123; int num; NumBit(int n) : num(n) &#123;&#125; bool operator&lt;(const struct NumBit &amp; right)const //重载&lt;运算符 &#123; vector&lt;int&gt; vtmp1; int n = this-&gt;num; int b = 0; while(n)&#123; b = n % 10; vtmp1.insert(vtmp1.begin(),b); n /= 10; &#125; vector&lt;int&gt; vtmp2; int n2 = right.num; int b2 = 0; while(n2)&#123; b2 = n2 % 10; vtmp2.insert(vtmp2.begin(),b2); n2 /= 10; &#125; int i = 0; int j = 0; int ilen = vtmp1.size(); int jlen = vtmp2.size(); while( i&lt;ilen || j&lt;jlen )&#123; if(i&lt;ilen &amp;&amp; j&lt;jlen &amp;&amp; vtmp1[i] &gt; vtmp2[j])&#123; return false; &#125;else if(i&lt;ilen &amp;&amp; j&lt;jlen &amp;&amp; vtmp1[i] &lt; vtmp2[j])&#123; return true; &#125;else if(i&lt;ilen &amp;&amp; j&lt;jlen &amp;&amp; vtmp1[i] == vtmp2[j])&#123; i++; j++; &#125;else if(i==ilen)&#123; if(vtmp2[j] &gt; vtmp2[0]) return true; else if(vtmp2[j] &lt; vtmp2[0]) return false; else if(j == jlen)&#123; return false; &#125;else&#123; j++; &#125; &#125;else if(j==jlen)&#123; if(vtmp1[i] &gt; vtmp1[0]) return false; else if(vtmp1[i] &lt; vtmp1[0]) return true; else if(i == ilen)&#123; return true; &#125;else&#123; i++; &#125; &#125;else&#123; break; &#125; &#125; return false; &#125;&#125;; 使用的时候直接使用上面定义的结构体作为set的类型 1multiset&lt;NumBit&gt; s; // 整数转换成字符串 12345678#include &lt;sstream&gt;#include &lt;string&gt;string Int_to_String(int n)&#123; ostringstream stream; stream&lt;&lt;n; //n为int类型 return stream.str();&#125; 十进制数字转换成K进制之后数位之和 123456789// 10进制数字 转换成K进制之后各个数位的数字之和int getSum(int n,int k)&#123; int sum = 0; while(n)&#123; sum += n % k; n = n / k; &#125; return sum;&#125; 十进制数字转换成K进制 123456789deque&lt;int&gt; Kin(int n,int k)&#123; deque&lt;int&gt; result; while(n/k != 0)&#123; result.push_front(n%k); n = n / k; &#125; result.push_front(n); return result;&#125; K进制数字转换成十进制 1234567891011121314/** * 将K进制的deque转换成10进制 * @param v * @return */int Kinverse(deque&lt;int&gt; v,int k)&#123; int s = 0; int i = 0; while(!v.empty())&#123; s += v.back() * std::pow(float(k),i); ++i; &#125; return s;&#125; 输入输出重定向 有的算法题是从接收的是从控制台的输入，而且输入还很多，这个时候如果每次调试都从控制台一次一次的输入测试数据，就会很麻烦。我们可以把要输入的数据保存在一个文本文件中，然后使用输入重定向freopen把标准输入重定向到该文件。以输入一个m行n列的矩阵来说，首先把输入数据存储在文本文件d:/A.in中。 123454 41 2 3 45 6 7 89 10 11 1213 14 15 16 然后执行下面的代码： 1234567891011121314151617freopen(\"d:\\\\A.in\",\"r\",stdin);// 输入重定向int m,n;cin&gt;&gt;m&gt;&gt;n;vector&lt;vector&lt;int&gt;&gt; v(m,vector&lt;int&gt;(n));//读取数据for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; cin&gt;&gt;v[i][j]; &#125;&#125;//输出读取的数据门这里输出到控制台for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; cout&lt;&lt;v[i][j]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl;&#125; 同样，输出也可以重定向到文件，当有大量的输出或者需要保存输出结果的时候，重定向到文件是一个不错的方法。只需要在输出之前加上下面这段代码，输出就会重定向到文件，这个时候运行程序，控制台就看不到输出了。 1freopen(\"d:\\\\A.out\",\"w\",stdout); 格式化输入输出 C++定义了一些操纵符来控制输出流的状态，endl就是一个常用的操纵符。 控制布尔值的格式 boolalpha使得布尔值输出true or false; noboolalpha使得输出变回默认的0 or 1. 12cout&lt;&lt;\"default: \"&lt;&lt;true&lt;&lt;\" \"&lt;&lt;false&lt;&lt;endl;cout&lt;&lt;boolalpha&lt;&lt;\"boolalpha: \"&lt;&lt;true&lt;&lt;\" \"&lt;&lt;false&lt;&lt;noboolalpha&lt;&lt;endl; 控制整数的输出进制 八进制： oct 十六进制： hex 十进制： dec 控制固定小数点位数 1234#include &lt;iomanip&gt;cout.precision(6);cout.setf(ios::fixed); 数据的表示范围 以下内容来源于C++ Premier 第五版 整型 包括整数，字符型，和布尔类型；这类数据在计算机的内部都是以二进制位0和1直接保存的。 123456789101112// 获得整形类型的表示范围， climits cout&lt;&lt;\"char: \"&lt;&lt;CHAR_MIN&lt;&lt;\" to \"&lt;&lt;CHAR_MAX&lt;&lt;endl; cout&lt;&lt;\"unsinged char: \"&lt;&lt;0&lt;&lt;\" to \"&lt;&lt;UCHAR_MAX&lt;&lt;endl; cout&lt;&lt;\"int8: \"&lt;&lt;INT8_MIN&lt;&lt;\" to \"&lt;&lt;INT8_MAX&lt;&lt;endl; cout&lt;&lt;\"unsinged int8: \"&lt;&lt;0&lt;&lt;\" to \"&lt;&lt;UINT8_MAX&lt;&lt;endl; cout&lt;&lt;\"int16: \"&lt;&lt;INT16_MIN&lt;&lt;\" to \"&lt;&lt;INT16_MAX&lt;&lt;endl; cout&lt;&lt;\"unsigned int16: \"&lt;&lt;0&lt;&lt;\" to \"&lt;&lt;UINT16_MAX&lt;&lt;endl; cout&lt;&lt;\"int32: \"&lt;&lt;INT32_MIN&lt;&lt;\" to \"&lt;&lt;INT32_MAX&lt;&lt;endl; cout&lt;&lt;\"unsigned int32: \"&lt;&lt;0&lt;&lt;\" to \"&lt;&lt;UINT32_MAX&lt;&lt;endl; cout&lt;&lt;\"int64: \"&lt;&lt;INT64_MIN&lt;&lt;\" to \"&lt;&lt;INT64_MAX&lt;&lt;endl; cout&lt;&lt;\"unsigned int64: \"&lt;&lt;0&lt;&lt;\" to \"&lt;&lt;UINT64_MAX&lt;&lt;endl; cout&lt;&lt;endl; 浮点型 在计算机内部，这种类型是把保存数据的空间分成两部分，一部分存储小数部分，一部分存储指数部分，数的实际大小是通过计算得出来的。 浮点类型由四部分组成： - sign : 符号，正 或 负 - base(radix) : 基数(2,8,10,16) - significand : 尾数 - exponent ： 指数 浮点类型的大小可以通过包含cfloat查看。 123456789101112131415//获得浮点类型的表示范围 cfloat cout&lt;&lt;\"float range: \"&lt;&lt;FLT_MIN&lt;&lt;\" to \"&lt;&lt;FLT_MAX&lt;&lt;endl; cout&lt;&lt;\"float significand: \"&lt;&lt;FLT_MANT_DIG&lt;&lt;endl; cout&lt;&lt;\"float exponent: \"&lt;&lt;FLT_MIN_EXP &lt;&lt;\" to \"&lt;&lt;FLT_MAX_EXP&lt;&lt;endl; cout&lt;&lt;\"double range: \"&lt;&lt;DBL_MIN&lt;&lt;\" to \"&lt;&lt;DBL_MAX&lt;&lt;endl; cout&lt;&lt;\"double significant: \"&lt;&lt;DBL_MANT_DIG &lt;&lt;endl; cout&lt;&lt;\"double exponent: \"&lt;&lt;DBL_MIN_EXP &lt;&lt;\" to \"&lt;&lt;DBL_MAX_EXP&lt;&lt;endl; cout&lt;&lt;\"long double range: \"&lt;&lt;LDBL_MIN&lt;&lt;\" to \"&lt;&lt;LDBL_MAX&lt;&lt;endl; cout&lt;&lt;\"long double significant: \"&lt;&lt;LDBL_MANT_DIG&lt;&lt;endl; cout&lt;&lt;\"long double exponent\"&lt;&lt;LDBL_MIN_EXP&lt;&lt;\" to \"&lt;&lt;LDBL_MAX_EXP&lt;&lt;endl; cout&lt;&lt;\"base: \"&lt;&lt;FLT_RADIX&lt;&lt;endl; cout&lt;&lt;endl; 获得类型所占用的字节数目 12345678910// 获得类型在内存中占的字节数 cout&lt;&lt;\"bool: \"&lt;&lt;sizeof(bool)&lt;&lt;endl; cout&lt;&lt;\"char: \"&lt;&lt;sizeof(char)&lt;&lt;endl; cout&lt;&lt;\"short: \"&lt;&lt;sizeof(short)&lt;&lt;endl; cout&lt;&lt;\"int: \"&lt;&lt;sizeof(int)&lt;&lt;endl; cout&lt;&lt;\"long: \"&lt;&lt;sizeof(long)&lt;&lt;endl; cout&lt;&lt;\"long long : \"&lt;&lt;sizeof(long long)&lt;&lt;endl; cout&lt;&lt;\"float: \"&lt;&lt;sizeof(float)&lt;&lt;endl; cout&lt;&lt;\"long double: \"&lt;&lt;sizeof(long double)&lt;&lt;endl; cout&lt;&lt;endl; 类型的使用准则 明确知道不可能为负，使用无符号数。 整数运算一般使用int, 需要大数的时候考虑long long.需要小整数的时候考虑signed char or unsigned char 浮点运算用double 快速幂和矩阵快速幂 整数的快速幂 求\\(a^b\\)一般的做法是用一个循环，将a累乘b次，这样需要做b次乘法。快速幂的思想是利用了 \\(a^(b1+b2) = a^b1 + a^b2\\) 的思想，把b表示成二进制，然后拆分开，分别求幂，再求和。举例来说： 假设要求\\(5^{12}\\),传统的方法是12个5相乘，要做12次乘法运算。快速幂的思想是把12表示成二进制，1100 = \\(2^2+2^3\\), \\[ 5^{12} = 5^{(2^2+2^3)} = 5^{2^2} * 5^{2^3} \\] 2的幂的计算可以由十分迅速的移位计算得到，所有原来需要12个乘法运算才能解决的计算问题，现在编程了只需要三次计算节能解决。 12345678910int quickPow(int a,int b)&#123; int ans=1,base=a; while(b!=0)&#123; if(b&amp;1!=0) ans*=base; base*=base; b&gt;&gt;=1; &#125; return ans;&#125; 按照上面的代码计算出来的实际上是\\(5^{2^2} * 5^{2^3}\\), 因为我们用的是右移，每次都只判断末尾的一个二进制位，如果是1，就乘入当前的结果。每次循环（不管是不是1），base都要翻倍，因为是二进制，每移动一位就意味着乘以2. 另外一个需要注意的问题是，实际使用时需要注意数据的范围，如果int的范围不够，可以使用long long类型。 矩阵的快速幂 矩阵乘法 一个\\(m*n\\)的矩阵 乘以 一个\\(n*p\\)的矩阵，会得到一个\\(m*p\\)的矩阵。矩阵相乘的规则是：第一个矩阵的每一行乘以第二个矩阵的每一列，对应的元素相乘再相加，作为新矩阵对应位置上的元素。朴素的矩阵乘法的代码如下： 12345678910111213141516171819202122232425typedef vector&lt;vector&lt;int&gt;&gt; matrix;matrix MatricMul(matrix A,matrix B)&#123; int m = A.size(); int n1 = A[0].size(); int n2 = B.size(); int p = B[0].size(); if(n1 != n2) &#123;cout&lt;&lt;\"no cheng of the two matrix.\"&lt;&lt;endl;return matrix();&#125; int n = n1 = n2; matrix C(m,vector&lt;int&gt;(p,0)); for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;p;j++)&#123; for(int k=0;k&lt;n;k++)&#123; C[i][j] += A[i][k] * B[k][j]; &#125; &#125; &#125; return C;&#125;int main()&#123; matrix A = &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;; matrix B = &#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6&#125;&#125;; matrix C = MatricMul(A,B); return 0;&#125; \\(A^n\\) 快速求矩阵的n次幂，注意这里A只能是方阵 矩阵的快速幂和整数的快速幂是一样的，就是重载一下*这个运算符，使得两侧是矩阵的时候，计算的是矩阵乘法。这里我们就不重载运算符了，直接使用上面定义的矩阵乘法函数MatricMul: 12345678910111213141516matrix quickPowMatrix(matrix A,int n)&#123; matrix base = A; // 初始化成单位矩阵 int len = A.size(); matrix ans(len,vector&lt;int&gt;(len,0)); for(int i=0;i&lt;A.size();i++)&#123; ans[i][i] = 1; &#125; while(n!=0)&#123; if(n&amp;1!=0) ans = MatricMul(ans,base); base = MatricMul(base,base); n&gt;&gt;=1; &#125; return ans;&#125; 快速幂通常用来求很大的数，这个时候虽然就算速度在可以接受的范围内，但是数据的范围早已经超过了能够表示范围，通常的方法就是mod每个大数，得到一个较小的结果。 为了减少计算的开销（计算小数的乘法要比计算大数的乘法开销小），通常利用模运算的法则： \\[ (a+b) mod c = (a mod c + b mod c) mod c ; \\] \\[ (a*b) mod c = (a mod c * b mod c) mod c ; \\] 上面的代码每一次计算之后就取模，就可以保证数据的范围不溢出，还能保证比较快的计算速度。 使用C++的模版技术编写通用的快速幂模版 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template&lt;class T, int MAXN, T MOD=-1&gt;class Matrix &#123;public: T m[MAXN][MAXN]; Matrix()&#123;&#125; // 如果MOD不是-1，把num取模 void init(T num[MAXN][MAXN])&#123; for(int i = 0 ; i &lt; MAXN ; i++) &#123; for(int j = 0 ; j &lt; MAXN ; j++) &#123; m[i][j] = num[i][j]; if (MOD!=-1) m[i][j] %= MOD; &#125; &#125; &#125; //矩阵乘法的实现 friend Matrix operator*(const Matrix &amp;m1 ,const Matrix &amp;m2) &#123; int i, j, k; Matrix ret; memset(ret.m, 0, sizeof(ret.m)); for (i = 0; i &lt; MAXN; i++) &#123; for (j = 0; j &lt; MAXN; j++) if ( m1.m[i][j] ) &#123; for(k = 0 ; k &lt; MAXN ; k++)&#123; ret.m[i][k] += m1.m[i][j] * m2.m[j][k]; if (MOD!=-1) ret.m[i][k] %= MOD; &#125; &#125; &#125; return ret; &#125; // 矩阵加法的实现 friend Matrix operator+(const Matrix &amp;m1 ,const Matrix &amp;m2) &#123; int i, j; Matrix ret; for (i = 0; i &lt; MAXN; i++) &#123; for (j = 0; j &lt; MAXN; j++) &#123; ret.m[i][j] = 0; ret.m[i][j] = m1.m[i][j]+m2.m[i][j]; if (MOD!=-1) ret.m[i][j] %= MOD; &#125; &#125; return ret; &#125; //矩阵快速幂的实现 friend Matrix operator^(const Matrix &amp;_M , LL nx)&#123; Matrix ret,M(_M); //ret 初始化成单位矩阵 for(int i = 0 ; i &lt; MAXN ; i++)&#123; for(int j = 0 ; j &lt; MAXN ; j++)&#123; if(i == j) ret.m[i][j] = 1; else ret.m[i][j] = 0; &#125; &#125; while(nx)&#123; if(nx &amp; 1) ret = ret * M; nx = nx &gt;&gt; 1; M = M * M; &#125; return ret; &#125;&#125;;int main()&#123; int C[2][2] = &#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;; Matrix&lt;int,2,1000&gt; mm; mm.init(C); auto add = mm + mm; auto cheng = mm * mm; auto mi = mm ^ 2 ; return 0;&#125; 包含一切的头文件 1#include &lt;bits/stdc++.h&gt; 一个文件包含了所有常用的头文件，你所有使用的函数不再需要引入相应的头文件。该头文件在ACM竞赛中经常被使用，可以减少你包含需要的头文件需要的时间。 需要注意的是，这个头文件并不是标准的，这意味着可能有的编译器不支持它。 暂停和计时 暂停 如果想要让程序暂停几秒继续执行，可以这样使用： 12# include &lt;windows.h&gt;Sleep(2000); // 暂停2s, 参数的单位是毫秒 计算程序运行的时间 有的时候可能要看某段程序运行需要多少时间，可以这样使用： - 秒级计时 1234567#include &lt;ctime&gt;auto start_time = time(nullptr);//Sleep(3000);// ... 代码块auto end_time = time(nullptr);cout&lt;&lt;end_time - start_time&lt;&lt;endl;// 输出的是程序运行的秒数。 毫秒级计时 12345// 获取毫秒级别的时间差auto start_time = clock();//Sleep(3000);auto end_time = clock();cout&lt;&lt;end_time - start_time&lt;&lt;endl; 返回一个无序数组排序之后的下标，不动原来的数组 例如 a = [3,5,2,4,1] , 从小到大排序之后应该是[1,2,3,4,5], 原来在a中的下标是[4,2,0,3,1],我们的目标就是输入a，返回[4,2,0,3,1] 12345678910111213#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; getOrderIndex(vector&lt;int&gt; &amp;a)&#123; vector&lt;int&gt; order(a.size(),0); for(int i=0;i&lt;a.size();i++)&#123; order[i] = i; &#125; sort(order.begin(), order.begin() + a.size(), [a](const int&amp; x, const int&amp; y)-&gt;bool &#123; return a[x] &lt; a[y];&#125;); return order;&#125; order中就是我们想要的结果。 读取数量不定的若干个整数 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;sstream&gt;using namespace std;/** * 读取一行整数，返回数组 * @param s * @return */vector&lt;int&gt; getInt(string &amp;s)&#123; getline(cin,s); istringstream iss(s); vector&lt;int&gt; v; int num; while(iss &gt;&gt; num)&#123; v.push_back(num); &#125; return v;&#125; 字符串转换成整数 1234567891011121314/** * 用空格分割的字符串转换成整数 * @param s * @return */vector&lt;int&gt; string2int(string &amp;s)&#123; istringstream in(s); vector&lt;int&gt; v; int num; while(in &gt;&gt; num)&#123; v.push_back(num); &#125; return v;&#125; 输入挂 当纯数字的输入规模超过\\(10^6\\)时，可以考虑使用输入挂，比系统自带的cin快很多。 12345678910111213141516inline void q_read(int &amp;num)&#123; char ch; int f = 1; while(true) &#123; ch = getchar(); if(ch == '-') f = -1; if(isdigit(ch)) &#123; num = ch - '0'; break; &#125; &#125; while(ch = getchar(), isdigit(ch)) num = num*10+ch-'0'; num *= f;&#125; 还可以在开始的时候加入 ios::sync_with_stdio(false);, 它的作用是去掉cin额外的检查开销，达到和scanf相似的输入效率；","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"编程语言","slug":"技术/编程语言","permalink":"http://ff120.github.io/hexoblog/categories/技术/编程语言/"},{"name":"C++","slug":"技术/编程语言/C","permalink":"http://ff120.github.io/hexoblog/categories/技术/编程语言/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://ff120.github.io/hexoblog/tags/C/"}]},{"title":"算法专题_图问题","slug":"技术/数据结构和算法/算法专题_图","date":"2017-04-06T07:02:35.000Z","updated":"2019-03-28T00:54:56.462Z","comments":true,"path":"2017/04/06/技术/数据结构和算法/算法专题_图/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/04/06/技术/数据结构和算法/算法专题_图/","excerpt":"图由顶点(vertex), 边(edge)组成，所以常用(V,E)来表示图。 图分为两种：有向图和无向图。","text":"图由顶点(vertex), 边(edge)组成，所以常用(V,E)来表示图。 图分为两种：有向图和无向图。 图的表示方法 QQ截图20170406150818.png 邻接矩阵表示法 邻接矩阵表示就是一个二维的矩阵V[i][j] V[i][j] = 1 表示有一条边从节点i连接节点j 邻接表表示法 邻接表就是把每个节点直接连接的节点都列举出来。 图的遍历方法 深度优先遍历 深度优先遍历用递归实现，借助栈的结构。 深度优先搜索的C++语言的实现，图的存储使用邻接矩阵的方式。 12 广度优先遍历 广度优先遍历一般使用队列结构，适用于解决最短路径问题。一般遍历解的状态都是使用 深度优先遍历，因为深度优先遍历可以使用递归函数实现，比较方便。 广度优先搜索的C++语言的实现，图的存储使用邻接矩阵的方式。 12 图相关的经典问题 二分图的判定 给一个图的顶点着色，相邻的顶点着不同颜色，需要的最少的颜色数，叫做最小着色数。 最小着色数是2的图叫做二分图。 简单来说，如果图中点可以被分为两组，并且使得所有边都跨越组的边界，则这就是一个二分图。准确地说：把一个图的顶点划分为两个不相交集 U 和V ，使得每一条边都分别连接U、V中的顶点。如果存在这样的划分，则此图为一个二分图。二分图的一个等价定义是：不含有「含奇数条边的环」的图。图 1 是一个二分图。为了清晰，我们以后都把它画成图 2 的形式。 判断一个图是否是二分图，只需要从任意一个节点开始，遍历这个图，给当前节点和相邻节点然不同的色，然后判断有没有相邻的节点同色即可。 12 二分图的最大匹配和完美匹配 http://www.renfei.org/blog/bipartite-matching.html 最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。图 4 是一个最大匹配，它包含 4 条匹配边。 完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。图 4 是一个完美匹配。显然，完美匹配一定是最大匹配（完美匹配的任何一个点都已经匹配，添加一条新的匹配边一定会与已有的匹配边冲突）。但并非每个图都存在完美匹配。 举例来说：如下图所示，如果在某一对男孩和女孩之间存在相连的边，就意味着他们彼此喜欢。是否可能让所有男孩和女孩两两配对，使得每对儿都互相喜欢呢？图论中，这就是完美匹配问题。如果换一个说法：最多有多少互相喜欢的男孩/女孩可以配对儿？这就是最大匹配问题。 基本概念讲完了。求解最大匹配问题的一个算法是匈牙利算法，下面讲的概念都为这个算法服务。 交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。 增广路：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路（agumenting path）。例如，图 5 中的一条增广路如图 6 所示（图中的匹配点均用红色标出）： 增广路有一个重要特点：非匹配边比匹配边多一条。因此，研究增广路的意义是改进匹配。只要把增广路中的匹配边和非匹配边的身份交换即可。由于中间的匹配节点不存在其他相连的匹配边，所以这样做不会破坏匹配的性质。交换后，图中的匹配边数目比原来多了 1 条。 我们可以通过不停地找增广路来增加匹配中的匹配边和匹配点。找不到增广路时，达到最大匹配（这是增广路定理）。匈牙利算法正是这么做的。在给出匈牙利算法 DFS 和 BFS 版本的代码之前，先讲一下匈牙利树。 匈牙利树一般由 BFS 构造（类似于 BFS 树）。从一个未匹配点出发运行 BFS（唯一的限制是，必须走交替路），直到不能再扩展为止。例如，由图 7，可以得到如图 8 的一棵 BFS 树：","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"算法专题_动态规划","slug":"技术/数据结构和算法/算法专题_动态规划","date":"2017-04-05T06:58:57.000Z","updated":"2019-03-28T00:54:56.439Z","comments":true,"path":"2017/04/05/技术/数据结构和算法/算法专题_动态规划/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/04/05/技术/数据结构和算法/算法专题_动态规划/","excerpt":"动态规划方法就是有规律的记忆化搜索方法。一般可以从穷竭搜索中总结出来。 动态规划还可以解决许多排列组合问题。","text":"动态规划方法就是有规律的记忆化搜索方法。一般可以从穷竭搜索中总结出来。 动态规划还可以解决许多排列组合问题。 0-1背包问题 QQ截图20170406094558.png 使用穷竭搜索 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;/** * 0--1 背包问题 * 从第start个物体开始，总重量为weight的背包，返回最大的价值 * @return */int rec(int start,int weight,vector&lt;int&gt; w,vector&lt;int&gt; v,vector&lt;int&gt; &amp;ob)&#123; cout&lt;&lt;\"rec(\"&lt;&lt;start&lt;&lt;\",\"&lt;&lt;weight&lt;&lt;\")\"&lt;&lt;endl; int result = 0; // 物体的最大个数是w.size()-1,如果超过这个，返回0，含义是从第n个 //物体开始，得到的价值是0，因为不能放入进去 if(start == w.size()) &#123;return result;&#125; //如果当前物体的重量已经大于总重量，那么一定不能放入背包， //一旦放入重量就超过了 if(w[start] &gt; weight)&#123; result = rec(start+1,weight,w,v,ob); &#125; //如果当前物体的重量小于等于最大的重量，那么这个物体可以放入背包， //尝试放入和不放入两种情况，选择较大的那个；// if(w[start] &lt;= weight)&#123;// result = max(rec(start+1,weight,w,v),rec(start+1,weight-w[start],w,v)+v[start]);// &#125; // 记录物品是否放入了背包 if(w[start] &lt;= weight)&#123; int noput = rec(start+1,weight,w,v,ob); int putted = rec(start+1,weight-w[start],w,v,ob)+v[start]; if(putted &gt; noput)&#123; result = putted; cout&lt;&lt;\"===\"&lt;&lt;\"rec(\"&lt;&lt;start&lt;&lt;\",\"&lt;&lt;weight&lt;&lt;\")\"&lt;&lt;\"===\"&lt;&lt;endl; ob.push_back(start); &#125;else&#123; result = noput; &#125; &#125; return result;&#125;void print(vector&lt;int&gt; v)&#123; for(auto a : v)&#123; cout&lt;&lt;a&lt;&lt;\" \"; &#125; cout&lt;&lt;endl;&#125;int main() &#123; vector&lt;int&gt; w = &#123;2,1,3,2&#125;; vector&lt;int&gt; v = &#123;3,2,4,2&#125;; int weight = 5; vector&lt;int&gt; ob; cout&lt;&lt;rec(0,weight,w,v,ob)&lt;&lt;endl; print(ob); return 0;&#125; 使用动态规划 动态规划的递推公式实际上可以从上面的穷竭搜索中得到。 rec(i,j) 表示从第i个物体开始，在不超过j的重量的情况下，最大的价值是多少 设置dp[i][j] = rec(i,j); 则可以知道dp[n][j] = 0; 因为最多只有n-1个物体； dp[i][j] = dp[i+1][j] 当第i个物体的重量大于j的时候； dp[i][i] = max( dp[i+1][j] , dp[i+1][j-w[i]]+v[i] ) 当第i个物体能够装进去的时候，分别尝试装入和不装入，取最大值。 12345678910111213141516171819202122/** * 背包问题的动态规划解法 * @param w * @param v * @param weight * @return */int dp(vector&lt;int&gt; w,vector&lt;int&gt; v,int weight)&#123; int n = w.size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(weight+1)); for(int i=n;i&gt;=0;i--)&#123; for(int j=0;j&lt;weight+1;j++)&#123; if(w[i] &gt; j)&#123; dp[i][j] = dp[i+1][j]; &#125;else&#123; dp[i][j] = max(dp[i+1][j],dp[i+1][j-w[i]] + v[i]); &#125; &#125; &#125; print2(dp); return dp[0][weight];&#125; 使用状态转移的观点 12345678910111213141516171819202122232425262728/** * 从状态转移的观点来看 * dp[i][j] 表示挑选出从0到i物体，总重量不超过j的状态。dp[0][j]表示选择0个物品时的重大价值 * dp[1][j] 表示选择物体1时候，总重量不超过j的最大的价值 * 所以有dp[0][j] = 0; * dp[i][j] = dp[i-1][j] 当i-1物体不能放入背包时 * dp[i][j] = dp[i-1][j-w[i]] + v[i] 当i-1物体可以放入背包的时候 * dp[0][j] * @param w * @param v * @param weight * @return */int dp2(vector&lt;int&gt; w,vector&lt;int&gt; v,int weight)&#123; int n = w.size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(weight+1)); for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;weight+1;j++)&#123; if(w[i] &gt; j)&#123; dp[i+1][j] = dp[i][j]; &#125;else&#123; dp[i+1][j] = max(dp[i][j],dp[i][j-w[i]] + v[i]); &#125; &#125; &#125; print2(dp); return dp[n][weight];&#125; 完全背包问题 完全背包问题可以这样建立递推关系； dp[i][j] 表示前i-1个物体放入背包，总重量不超过j的情况下的最大价值。i=0时表示没有物体。 w[i] 和 v[i] 表示第i个物体的重量和价值。注意这里dp中的i和w,v中的i相差1.也就是dp[i+1]对应的物体的重量和价值分别是w[i],v[i]; 1234dp[i+1][j] := dp[i][j] 第i个物体不放入背包 := dp[i][j-1*w[i]] + v[i] 第i个物体放入1次的时候 := dp[i][j-2*w[i]] + 2*v[i] 第i个物体放入2次的时候 ... 上面的递推关系虽然容易理解，却存在这循环，有重复计算的地方。递推关系还可以定义如下： dp[i+1][j] = dp[i][j] ; 第i个物体无法放入背包的情况 dp[i+1][j] = d[i+1][j-w[i]] + v[i] ; 如果第i个物体可以放入背包，那么最大价值等于 在dp[i+1][j-w[i]]的基础上再放入一个i物品，这时的价值是dp[i+1][j-w[i]] + v[i]; 所以最后的递推关系可以写成： dp[0][j] = 0; dp[i+1][j] = max(dp[i][j],dp[i+1][j-w[i]] + v[i]) 完全背包问题 1234567891011121314151617181920212223/** * 完全背包问题 * @param w * @param v * @param weight * @return */int dp3(vector&lt;int&gt; w,vector&lt;int&gt; v,int weight)&#123; int n = w.size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(weight+1)); for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;=weight;j++)&#123; if(j&lt;w[i])&#123; dp[i+1][j] = dp[i][j]; &#125;else&#123; dp[i+1][j] = max(dp[i][j],dp[i+1][j-w[i]]+v[i]); &#125; &#125; &#125; print2(dp); return dp[n][weight];&#125; 以上背包的问题的时间复杂度都可以优化到O（nW）也就是物品数量 * 背包容量，空间复杂度可以优化到O（n）. 一般情况下，这样的时间复杂度足够了。但是针对下面这道题，时间复杂度就不够用了，需要另外寻找解题的方法。 &gt; 有n个重量和价值分别为w[i],v[i]的物品，装入容量为W的背包，求最大价值。 &gt; 限制条件： &gt; n : 1–100 ; w[i] : 1–10000000 ; v[i] : 1–100; W : 1–1000000000 原来背包问题的时间复杂度是O(nW),但是本题’故意’把W设置的很大，使得不能使用原来的方法求解。 仔细分析数据的取值范围发现，v[i]的范围比较小，我们可以转换思路，求解总重量不超过W的情况下价值的最大值， 就是求解相同价值下的总重量的最小值。 dp[i][j] 表示前i-1个物体在价值不超过j的时候的总重量的最小值。 dp[0][j] = INF; 把不存在最小值的情况设置为最大值，这样是方便用min(); dp[0][0] = 0 ; dp[i+1][j] = min(dp[i][j],dp[i][j-v[i]]+w[i]) 123456789101112131415161718192021/** * 0-1背包的变种 * @return */int dp4(vector&lt;int&gt; w,vector&lt;int&gt; v,int weight)&#123; int n = w.size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(weight+1)); dp[0][0] = 0; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;=weight;j++)&#123; if(j&lt;v[i])&#123; dp[i+1][j] = dp[i][j]; &#125;else&#123; dp[i+1][j] = min(dp[i][j],dp[i+1][j-v[i]]+w[i]); &#125; &#125; &#125; print2(dp); return dp[n][weight];&#125; 单词切分 给出一个字符串s和一个词典，判断字符串s是否可以被空格切分成一个或多个出现在字典中的单词。 样例 给出 s = “lintcode” dict = [“lint”,“code”] 返回 true 因为“lintcode”可以被空格切分成“lint code” 单词切分 思路一：开一个dp[n+1]表示前i个字母能否用空格分割开(按照字典里面给出的单词)。dp[0]=true表示空字符串能够分割开，dp[1]=true当s[0]在字典中存在时。对于dp[j]来说，逐个向前搜索，看是否有s[i,j]存在与dict中的同时dp[i-1]为真。如果有，dp[j]=true,如果搜索到头还没有，dp[j]=false.这种方法最容易想到，但是时间复杂度高。(不能通过lintcode的所有测试用例) 12345678910111213141516171819202122//[单词切分](http://lintcode.com/zh-cn/problem/word-break/)bool wordBreak(string s, unordered_set&lt;string&gt; &amp;dict) &#123; // write your code here if(s.empty()) return false; vector&lt;bool&gt; dp(s.size()+1,false); dp[0] = true; for (int i = 1; i &lt;= s.size(); ++i) &#123; if(dict.find(s.substr(i-1,1))!=dict.end() &amp;&amp; dp[i-1])&#123; dp[i] = true; &#125; int clen = 2; for (int j = i - 1; j &gt;= 1 ; --j) &#123; string ss = s.substr(j-1,clen); if(dict.find(ss) != dict.end() &amp;&amp; dp[j-1])&#123; dp[i] = true; break; &#125; clen ++; &#125; &#125; return dp[s.size()];&#125; 思路二：上面的算法每次都会回溯到第一个字符，如果字典的最大的字符的长度远远小于字符串的长度(很常见的情况)，会造成大量的浪费，所以可以改进一下，每次只回溯到字典中最大的字符串长度处，这样就能通过lintcode的大规模的数据了。getMaxLen用来获取字典中最长的字符串的长度。但是该方法当dict中最大字符串的长度很长时，时间复杂度并没有降低。 1234567891011121314151617181920212223242526272829303132int getMaxLen( unordered_set&lt;string&gt; &amp;dict)&#123; int maxlen = 0; for(auto a : dict)&#123; maxlen = max(maxlen,(int)a.size()); &#125; return maxlen;&#125;//[单词切分](http://lintcode.com/zh-cn/problem/word-break/)bool wordBreak(string s, unordered_set&lt;string&gt; &amp;dict) &#123; // write your code here if(s.empty() &amp;&amp; dict.empty()) return true; if(s.empty()) return false; vector&lt;bool&gt; dp(s.size()+1,false); int maxlen = getMaxLen(dict); dp[0] = true; for (int i = 1; i &lt;= s.size(); ++i) &#123; if(dict.find(s.substr(i-1,1))!=dict.end() &amp;&amp; dp[i-1])&#123; dp[i] = true; &#125; int clen = 2; int end = max(1,i-1-maxlen); for (int j = i - 1; j &gt;= end ; --j) &#123; string ss = s.substr(j-1,clen); if(dict.find(ss) != dict.end() &amp;&amp; dp[j-1])&#123; dp[i] = true; break; &#125; clen ++; &#125; &#125; return dp[s.size()];&#125; 换钱的方法数 思路： 动态规划。dp[i][j]表示用前i种面值的钱组成j总共有多少中方案。设钱币的面值一共有N中，组成的面值为M，则需要N*(M+1)的数组。第一行表示使用第一种面值的货币组成目标值的方法数量，当j能够被整除时，方法数量为1，否则为0. 第一列表示组成目标值0有多少种情况，无论有几种面值的货币，只有一种方法，就是一个都不用。 递推公式： dp[i][j] = dp[i-1][j] if j &lt; v[i], (当面值为v[i]的货币比目标值还要大的时候，肯定一张v[i]都不能使用，这个时候方法数量等于dp[-1][j]). dp[i][j] = dp[i-1][j] + dp[i][j-v[i]] if j &gt;= v[i], (如果目标值比面值为v[i]的钱大，则意味着可以使用v[i]若干次，一直到超过目标值； 在这种情况下，组成目标值的总方法数量为以下几种情况的和： 不使用第i中货币组成j, 方法数量是dp[i-1][j]; 使用第i种货币组成j的数量，dp[i][j-v[i]], 这个式子可以这样理解： 首先使用一张v[i],然后用前i中货币组成剩下的j-v[i]目标值，这个值之前计算过，可以直接写出来，就是dp[i][j-v[i]]; 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int getNum(vector&lt;int&gt; v,int aim)&#123; vector&lt;vector&lt;int&gt; &gt; dp(v.size(),vector&lt;int&gt;(aim+1)); //初始化第一列 for(int i=0;i&lt;v.size();++i)&#123; dp[i][0] = 1; &#125; //初始化第一行 for(int j=1;j&lt;=aim;j++)&#123; dp[0][j] = j%v[0]==0 ? 1 : 0; &#125; for(int i=1;i&lt;v.size();++i)&#123; for(int j=1;j&lt;=aim;++j)&#123; dp[i][j] = j-v[i]&gt;=0 ? dp[i-1][j]+dp[i][j-v[i]] : dp[i-1][j]; &#125; &#125; //打印动态规划表格 for(int i=0;i&lt;dp.size();++i)&#123; for(int j=0;j&lt;dp[0].size();++j)&#123; cout&lt;&lt;dp[i][j]&lt;&lt;\"\\t\"; &#125; cout&lt;&lt;endl; &#125; return dp[v.size()-1][aim];&#125;int main() &#123; vector&lt;int&gt; v = &#123;5,2,3,7&#125;; int aim = 7; std::cout &lt;&lt; getNum(v,aim) &lt;&lt; std::endl; return 0;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"算法专题_链表","slug":"技术/数据结构和算法/算法专题_链表","date":"2017-03-23T02:10:03.000Z","updated":"2019-03-28T00:54:57.075Z","comments":true,"path":"2017/03/23/技术/数据结构和算法/算法专题_链表/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/03/23/技术/数据结构和算法/算法专题_链表/","excerpt":"链表是一种比较基础的数据结构，主要类型有单链表，双链表，循环链表等。 链表的实现可以使用数组；也可以使用结构体和指针实现。","text":"链表是一种比较基础的数据结构，主要类型有单链表，双链表，循环链表等。 链表的实现可以使用数组；也可以使用结构体和指针实现。 链表的基础知识 链表的基本操作 C++11的标准中，结构体和类并没有本质的不同。所有可以用结构体和类来定义节点的数据结构。 单链表通常包含一个val和一个指向下一个节点的指针*next,双向链表通常包含一个val和两个指针*pre,*next,分别指向前面的节点和后面的节点。 链表节点结构的定义 单链表 1234567//单链表节点的定义-使用结构体struct Node&#123; int value; Node *next; Node() : value(0),next(nullptr)&#123;&#125; Node(int v) : value(v),next(nullptr)&#123;&#125;&#125;; 12345678910//使用类class ListNode &#123;public: int val; ListNode *next; ListNode(int val) &#123; this-&gt;val = val; this-&gt;next = NULL; &#125; &#125; 双向链表 12345678//双向链表struct BiNode&#123; int value; BiNode *pre; BiNode *next; BiNode() : value(0),pre(nullptr),next(nullptr)&#123;&#125; BiNode(int v) : value(v),pre(nullptr),next(nullptr)&#123;&#125;&#125;; 链表的创建 单链表 首先判断是不是空，如果是空，返回空链表 如果不是空，创建第一个元素的节点，并用头指针指向它，日后返回这个头指针； 然后从第二个元素开始，创建新的节点，把这个节点赋值个前一个节点的next指针，然后更新tmp指向当前新创建的节点。 核心的语句： 123Node *node = new Node(v[i]);tmp-&gt;next = node;tmp = tmp-&gt;next; 1234567891011Node* createLinks(vector&lt;int&gt; v)&#123; if(v.empty()) return nullptr; Node *head = new Node(v[0]); //头节点，最后需要返回创建的链表的头结点，所以头结点需要保存下来 Node *tmp = head; for(int i=1;i&lt;v.size();++i)&#123; Node *node = new Node(v[i]); tmp-&gt;next = node; tmp = tmp-&gt;next; &#125; return head;&#125; 双链表 双向链表的创建需要返回两个指针，一个指向头部，便于正向遍历链表；另外一个指向尾部，便于逆向遍历链表 首先判断是不是空，如果是空，返回空链表 用第一个元素创建节点，并用头节点指向它 创建临时变量指向第一个节点，此临时变量一直指向当前创建的节点 从数组的第二个元素开始创建新的节点，创建的节点的pre设置为tmp, 然后把tmp的next赋值成node,即让tmp所指向的节点连接到当前创建的节点上 更新tmp使它指向当前新创建的节点。 循环体结束后，tmp正好指向最会一个创建的节点，所以把tmp赋值给tail 返回head和tail; 关键语句： 1234BiNode *node = new BiNode(v[i]);node-&gt;pre = tmp;tmp-&gt;next = node;tmp = tmp-&gt;next; 12345678910111213pair&lt;BiNode*,BiNode*&gt; createBiNode(vector&lt;int&gt; v)&#123; if(v.empty()) return &#123;nullptr,nullptr&#125;; BiNode *head = new BiNode(v[0]); BiNode *tmp = head; for(int i=1;i&lt;v.size();i++)&#123; BiNode *node = new BiNode(v[i]); node-&gt;pre = tmp; tmp-&gt;next = node; tmp = tmp-&gt;next; &#125; BiNode *tail = tmp; return &#123;head,tail&#125;;&#125; 循环链表 循环链表就是结尾的元素又指向了开头的元素。所以创建过程基本上是一样的，指示在结尾的处理稍有不同。 循环单链表只需要在结尾添加tmp-&gt;next = head; 循环双向链表只需要在结尾添加tail-&gt;next = head; // 尾元素的后面是头元素 head-&gt;pre = tail; // 头元素的前面是尾元素 . 12345678910111213//创建循环单链表Node* createLinksCycle(vector&lt;int&gt; v)&#123; if(v.empty()) return nullptr; Node *head = new Node(v[0]); //头节点，最后需要返回创建的链表的头结点，所以头结点需要保存下来 Node *tmp = head; for(int i=1;i&lt;v.size();++i)&#123; Node *node = new Node(v[i]); tmp-&gt;next = node; tmp = tmp-&gt;next; &#125; tmp-&gt;next = head; // 让结尾指向开头的第一个元素 return head;&#125; 12345678910111213141516//创建循环双链表pair&lt;BiNode*,BiNode*&gt; createBiNodeCycle(vector&lt;int&gt; v)&#123; if(v.empty()) return &#123;nullptr,nullptr&#125;; BiNode *head = new BiNode(v[0]); BiNode *tmp = head; for(int i=1;i&lt;v.size();i++)&#123; BiNode *node = new BiNode(v[i]); tmp-&gt;next = node; node-&gt;pre = tmp; tmp = tmp-&gt;next; &#125; BiNode *tail = tmp; tail-&gt;next = head; // 尾元素的后面是头元素 head-&gt;pre = tail; // 头元素的前面是尾元素 return &#123;head,tail&#125;;&#125; 链表的插入和删除 单链表 要在单链表中插入一个节点，只需要知道插入位置的前一个节点就可以了。假设c指向了插入位置的前一个节点，n是新创建的节点 那么插入的方法是： 12n-&gt;next = c-&gt;next ; //新节点n的后一个节点设置成c的后一个节点c-&gt;next = n; //c节点指向新插入的节点 注意如果插入的位置是链表的头部，需要单独处理。 12n-&gt;next = head; //新插入的节点的下一个节点连接到头节点head = n; //头结点编程新插入的节点 双链表 双链表既可以向前访问，也可以向后访问。所以插入一个节点，只需要知道要插入的位置的前一个节点，或者要插入位置的后一个节点就可以了。 假设c代表要插入位置的前一个节点；n代表新插入的节点，b代表插入位置的后一个节点。 利用c的插入方法是： 1234n-&gt;next = c-&gt;next;c-&gt;next-&gt;pre = n; // 这两句将新的节点和后面的节点连接起来n-&gt;pre = c;c-&gt;next = n; //这两句将c和n连接起来 如果要在头节点之前插入，会发现头结点之前没有节点了，所以不能使用上面的语句，需要另外处理： 123n-&gt;next = head;head-&gt;pre = n;head = n; 利用b的插入方法是： 1234n-&gt;pre = b-&gt;pre;b-&gt;pre-&gt;next = n; // 把新的节点和b前面的节点连接起来n-&gt;next = b;b-&gt;pre = n; // 把新的节点和b连接起来 如果在最后一个节点后面插入节点，会发现没有b,这个时候需要另外处理： 123n-&gt;pre = tail;tail-&gt;next = n;tail = n; 循环链表 循环链表的插入和删除没有了像上面不循环的链表那样需要另外处理头部和尾部的情况。所以插入操作更加简单。 如果插入的是头节点的话，注意head的更新情况即可。 ### 链表的删除 单链表 删除单链表的某一个节点，只需要知道该节点的前一个节点。假设要删除的节点的前一个节点是c. 删除操作：c-&gt;next = c-&gt;next-&gt;next; 如果删除的是第一个节点，则直接head = head-&gt;next; 如果删除的是最后一个节点，则直接c-&gt;next=nullptr. 双链表 同插入类似，双链表的删除只需要知道要删除的节点的前一个节点或者后一个节点就可以了。假设c是前一个节点，b是后一个节点。 删除操作1： 12c-&gt;next = c-&gt;next-&gt;next;c-&gt;next-&gt;next-&gt;pre = c; 删除操作2： 12b-&gt;pre = b-&gt;pre-&gt;pre;b-&gt;pre-&gt;pre-&gt;next = b; 删除首节点和尾节点同样需要特殊考虑； 删除首节点：b-&gt;pre = nullptr;head = b; 删除尾节点：c-&gt;next=nullptr;tail=c; 需要的注意的是，这样做只是从head和tail开始访问的话，再也访问不到被删除的节点，但是实际上，从删除的节点还有指针指向这个链表的某个节点。 如果想要删除干净，就是彻底断开连接，可以使用下面的语句： 删除首节点：b-&gt;pre-&gt;next=nullptr; b-&gt;pre=nullptr;head=b; 删除尾节点：c-&gt;next-&gt;pre=nullptr;c-&gt;next=nullptr;tail=c; 循环链表 循环链表的插入和删除同样不需要考虑特殊的情况，如果插入的是头节点的话，注意head的更新情况即可。 链表的替换 想要更新链表中的某个值，只需要查找到该节点c，然后执行c-&gt;val = new_value;即可。 链表的反向 单链表 基本思路是设置三个指针pre,current,next;分别代表相邻的三个节点。 每次循环执行下面的操作： 1234next = current-&gt;next; // 首先记录current的下一个节点current-&gt;next = pre; // curent的下一个节点设置为前一个节点pre = current; // pre向前推进一个元素current = next; //current像前推进一个元素 12345678910111213Node* notLinks(Node* head)&#123; if(head == nullptr || head-&gt;next == nullptr) return head; Node *current = head; Node *pre=nullptr; Node *next= nullptr; while(current)&#123; next = current-&gt;next; // 首先记录current的下一个节点 current-&gt;next = pre; // curent的下一个节点设置为前一个节点 pre = current; // pre向前推进一个元素 current = next; //current像前推进一个元素 &#125; return pre; //返回指向新链表的头节点&#125; 双链表 双向链表的反转与单向链表的思路一致，设置三个指针pre,current,next分别指向相邻的三个节点； 每次循环这样操作： 12345next = current-&gt;next; // 首先记录current的下一个节点current-&gt;next = pre; // curent的下一个节点设置为前一个节点current-&gt;pre = next;pre = current; // pre向前推进一个元素current = next; //current像前推进一个元素 1234567891011121314BiNode* notBiLinks(BiNode* head)&#123; if(head == nullptr || head-&gt;next == nullptr) return head; BiNode *current = head; BiNode *pre=nullptr; BiNode *next= nullptr; while(current)&#123; next = current-&gt;next; // 首先记录current的下一个节点 current-&gt;next = pre; // curent的下一个节点设置为前一个节点 current-&gt;pre = next; pre = current; // pre向前推进一个元素 current = next; //current像前推进一个元素 &#125; return pre; //返回指向新链表的头节点&#125; 当然，在逻辑上双向链表是没有正反的，以上所说的反向是在相同的输出函数下，输出的顺序正好相反。 也可以利用这一点反转双向链表，只需要把链表节点的指针pre,next交换一下即可。具体代码如下： 12345BiNode *tmp = current-&gt;pre;current-&gt;pre = current-&gt;next;current-&gt;next = tmp; // 以上三行交换两个变量的值newHead = current; //存储下来当前节点，日后返回该节点current = current-&gt;pre; //处理下一个节点 12345678910111213BiNode* notBiLinks2(BiNode* head)&#123; if(head == nullptr || head-&gt;next == nullptr) return head; BiNode *current = head; BiNode *newHead; while(current)&#123; BiNode *tmp = current-&gt;pre; current-&gt;pre = current-&gt;next; current-&gt;next = tmp; newHead = current; current = current-&gt;pre; &#125; return newHead; //返回指向新链表的头节点&#125; 循环链表 循环链表的反转没有什么实际的意义，只是用来练习链表的处理。具体的步骤和上面的基本相同。 链表的可视化 打印单链表 123456789101112void printLinks(Node *head) &#123; if (head == nullptr) &#123; cout &lt;&lt; \"empty\" &lt;&lt; endl; return; &#125; Node *tmp = head; while (tmp-&gt;next != nullptr) &#123; cout &lt;&lt; tmp-&gt;value &lt;&lt; \"-&gt;\"; tmp = tmp-&gt;next; &#125; cout &lt;&lt; tmp-&gt;value &lt;&lt; endl;&#125; 打印出来的样式 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 打印双向链表 12345678910void printBiLinks(BiNode *head)&#123; if(head == nullptr)&#123;cout&lt;&lt;\"empty\"&lt;&lt;endl;return;&#125; BiNode *tmp = head; while(tmp-&gt;next != nullptr)&#123; cout&lt;&lt;\"[\"&lt;&lt;tmp-&gt;value&lt;&lt;\"]\"&lt;&lt;\"&lt;-&gt;\"; tmp = tmp-&gt;next; &#125; cout&lt;&lt;\"[\"&lt;&lt;tmp-&gt;value&lt;&lt;\"]\"&lt;&lt;endl; cout&lt;&lt;endl;&#125; 打印出来的样式 1&gt; [1]&lt;-&gt;[2]&lt;-&gt;[3]&lt;-&gt;[4]&lt;-&gt;[5]&lt;-&gt;[6] 单链表类的定义 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Links&#123;public: Node *head; // 头节点 Links() : head(nullptr)&#123;&#125; //创建链表 Links(vector&lt;int&gt; v) &#123; if(v.empty())&#123; head = nullptr; &#125;else &#123; Node *first = new Node(v[0]); head = first; Node *tmp = first; for (int i = 1; i &lt; v.size(); ++i) &#123; Node *node = new Node(v[i]); tmp-&gt;next = node; tmp = node; &#125; &#125; &#125; //打印链表 void printLinks() &#123; if (head == nullptr) &#123; cout &lt;&lt; \"empty\" &lt;&lt; endl; return; &#125; Node *tmp = head; while (tmp-&gt;next != nullptr) &#123; cout &lt;&lt; tmp-&gt;value &lt;&lt; \"-&gt;\"; tmp = tmp-&gt;next; &#125; cout &lt;&lt; tmp-&gt;value &lt;&lt; endl; &#125; //反转这个链表 void inverseLinks()&#123; Node *pre = nullptr; Node *next = nullptr; while(head!= nullptr)&#123; next = head-&gt;next; head-&gt;next = pre; pre = head; head = next; &#125; head = pre; &#125;&#125;; 双向链表类的定义 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//双向链表的实现class BiLinks&#123;public: BiNode *head; BiNode *tail; BiLinks() : head(nullptr),tail(nullptr)&#123;&#125; BiLinks(vector&lt;int&gt; v)&#123; BiNode *first = new BiNode(v[0]); head = first; BiNode *tmp = head; for(int i=1;i&lt;v.size();i++)&#123; BiNode *node = new BiNode(v[i]); tmp-&gt;next = node; node-&gt;pre = tmp; tmp = tmp-&gt;next; &#125; tail = tmp; &#125; void printBiLinks()&#123; if(head == nullptr || tail == nullptr)&#123;cout&lt;&lt;\"empty!\"&lt;&lt;endl;return;&#125; BiNode *tmp = head; while(tmp-&gt;next != nullptr)&#123; cout&lt;&lt;\"[\"&lt;&lt;tmp-&gt;value&lt;&lt;\"]\"&lt;&lt;\"-&gt;\"; tmp = tmp-&gt;next; &#125; cout&lt;&lt;\"[\"&lt;&lt;tmp-&gt;value&lt;&lt;\"]\"&lt;&lt;endl; tmp = tail; while(tmp-&gt;pre!= nullptr)&#123; tmp = tmp-&gt;pre; &#125; while(tmp-&gt;next!= nullptr)&#123; cout&lt;&lt;tmp-&gt;value&lt;&lt;\"&lt;-&gt;\"; tmp = tmp-&gt;next; &#125; cout&lt;&lt; tmp-&gt;value &lt;&lt;endl; cout&lt;&lt;endl; &#125; void inverseBiLinks()&#123; BiNode *pre = nullptr; BiNode *next = nullptr; while(head!= nullptr)&#123; next = head-&gt;next; head-&gt;next= pre; head-&gt;pre = next; pre = head; head = next; &#125; head = pre; &#125;&#125;; 链表操作的完整示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct Node&#123; int value; Node *next; Node() : value(0),next(nullptr)&#123;&#125; Node(int v) : value(v),next(nullptr)&#123;&#125;&#125;;//双向链表struct BiNode&#123; int value; BiNode *pre; BiNode *next; BiNode() : value(0),pre(nullptr),next(nullptr)&#123;&#125; BiNode(int v) : value(v),pre(nullptr),next(nullptr)&#123;&#125;&#125;;Node* createLinks(vector&lt;int&gt; v)&#123; if(v.empty()) return nullptr; Node *head = new Node(v[0]); //头节点，最后需要返回创建的链表的头结点，所以头结点需要保存下来 Node *tmp = head; for(int i=1;i&lt;v.size();++i)&#123; Node *node = new Node(v[i]); tmp-&gt;next = node; tmp = tmp-&gt;next; &#125; return head;&#125;//创建循环单链表Node* createLinksCycle(vector&lt;int&gt; v)&#123; if(v.empty()) return nullptr; Node *head = new Node(v[0]); //头节点，最后需要返回创建的链表的头结点，所以头结点需要保存下来 Node *tmp = head; for(int i=1;i&lt;v.size();++i)&#123; Node *node = new Node(v[i]); tmp-&gt;next = node; tmp = tmp-&gt;next; &#125; tmp-&gt;next = head; // 让结尾指向开头的第一个元素 return head;&#125;pair&lt;BiNode*,BiNode*&gt; createBiNode(vector&lt;int&gt; v)&#123; if(v.empty()) return &#123;nullptr,nullptr&#125;; BiNode *head = new BiNode(v[0]); BiNode *tmp = head; for(int i=1;i&lt;v.size();i++)&#123; BiNode *node = new BiNode(v[i]); tmp-&gt;next = node; node-&gt;pre = tmp; tmp = tmp-&gt;next; &#125; BiNode *tail = tmp; return &#123;head,tail&#125;;&#125;//创建循环双链表pair&lt;BiNode*,BiNode*&gt; createBiNodeCycle(vector&lt;int&gt; v)&#123; if(v.empty()) return &#123;nullptr,nullptr&#125;; BiNode *head = new BiNode(v[0]); BiNode *tmp = head; for(int i=1;i&lt;v.size();i++)&#123; BiNode *node = new BiNode(v[i]); tmp-&gt;next = node; node-&gt;pre = tmp; tmp = tmp-&gt;next; &#125; BiNode *tail = tmp; tail-&gt;next = head; // 尾元素的后面是头元素 head-&gt;pre = tail; // 头元素的前面是尾元素 return &#123;head,tail&#125;;&#125;//反转单向链表Node* notLinks(Node* head)&#123; if(head == nullptr || head-&gt;next == nullptr) return head; Node *current = head; Node *pre=nullptr; Node *next= nullptr; while(current)&#123; next = current-&gt;next; // 首先记录current的下一个节点 current-&gt;next = pre; // curent的下一个节点设置为前一个节点 pre = current; // pre向前推进一个元素 current = next; //current像前推进一个元素 &#125; return pre; //返回指向新链表的头节点&#125;BiNode* notBiLinks(BiNode* head)&#123; if(head == nullptr || head-&gt;next == nullptr) return head; BiNode *current = head; BiNode *pre=nullptr; BiNode *next= nullptr; while(current)&#123; next = current-&gt;next; // 首先记录current的下一个节点 current-&gt;next = pre; // curent的下一个节点设置为前一个节点 current-&gt;pre = next; pre = current; // pre向前推进一个元素 current = next; //current像前推进一个元素 &#125; return pre; //返回指向新链表的头节点&#125;BiNode* notBiLinks2(BiNode* head)&#123; if(head == nullptr || head-&gt;next == nullptr) return head; BiNode *current = head; BiNode *newHead; while(current)&#123; BiNode *tmp = current-&gt;pre; current-&gt;pre = current-&gt;next; current-&gt;next = tmp; newHead = current; current = current-&gt;pre; &#125; return newHead; //返回指向新链表的头节点&#125;void printLinks(Node *head) &#123; if (head == nullptr) &#123; cout &lt;&lt; \"empty\" &lt;&lt; endl; return; &#125; Node *tmp = head; while (tmp-&gt;next != nullptr) &#123; cout &lt;&lt; tmp-&gt;value &lt;&lt; \"-&gt;\"; tmp = tmp-&gt;next; &#125; cout &lt;&lt; tmp-&gt;value &lt;&lt; endl;&#125;void printBiLinks(BiNode *head)&#123; if(head == nullptr)&#123;cout&lt;&lt;\"empty\"&lt;&lt;endl;return;&#125; BiNode *tmp = head; while(tmp-&gt;next != nullptr)&#123; cout&lt;&lt;\"[\"&lt;&lt;tmp-&gt;value&lt;&lt;\"]\"&lt;&lt;\"&lt;-&gt;\"; tmp = tmp-&gt;next; &#125; cout&lt;&lt;\"[\"&lt;&lt;tmp-&gt;value&lt;&lt;\"]\"&lt;&lt;endl; cout&lt;&lt;endl;&#125;class Links&#123;public: Node *head; // 头节点 Links() : head(nullptr)&#123;&#125; //创建链表 Links(vector&lt;int&gt; v) &#123; if(v.empty())&#123; head = nullptr; &#125;else &#123; Node *first = new Node(v[0]); head = first; Node *tmp = first; for (int i = 1; i &lt; v.size(); ++i) &#123; Node *node = new Node(v[i]); tmp-&gt;next = node; tmp = node; &#125; &#125; &#125; //打印链表 void printLinks() &#123; if (head == nullptr) &#123; cout &lt;&lt; \"empty\" &lt;&lt; endl; return; &#125; Node *tmp = head; while (tmp-&gt;next != nullptr) &#123; cout &lt;&lt; tmp-&gt;value &lt;&lt; \"-&gt;\"; tmp = tmp-&gt;next; &#125; cout &lt;&lt; tmp-&gt;value &lt;&lt; endl; &#125; //反转这个链表 void inverseLinks()&#123; Node *pre = nullptr; Node *next = nullptr; while(head!= nullptr)&#123; next = head-&gt;next; head-&gt;next = pre; pre = head; head = next; &#125; head = pre; &#125;&#125;;int main() &#123; vector&lt;int&gt; v=&#123;1,2,3,4,5,6&#125;; Node *head = createLinks(v);// Node *CHead = createLinksCycle(v);// Node *IHead = notLinks(head); auto Binode = createBiNode(v);// auto *IBiHead = notBiLinks2(Binode.first);// auto BinodeC = createBiNodeCycle(v); printLinks(head); printBiLinks(Binode.first); return 0;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"深度学习_Theano使用技巧","slug":"技术/机器学习/深度学习/深度学习_Theano使用技巧","date":"2017-03-22T08:19:50.000Z","updated":"2019-03-28T00:54:58.320Z","comments":true,"path":"2017/03/22/技术/机器学习/深度学习/深度学习_Theano使用技巧/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/03/22/技术/机器学习/深度学习/深度学习_Theano使用技巧/","excerpt":"theano 介绍 Theano is a Python library that allows you to define, optimize, and evaluate mathematical expressions involving multi-dimensional arrays efficiently. (http://deeplearning.net/software/theano/)","text":"theano 介绍 Theano is a Python library that allows you to define, optimize, and evaluate mathematical expressions involving multi-dimensional arrays efficiently. (http://deeplearning.net/software/theano/) theano 安装 （http://deeplearning.net/software/theano/install_windows.html#install-windows） Windows平台成功的安装方式，先安装anaconda, 然后执行 $ conda install mingw libpython 错误信息 . collect2.exe: error: ld returned 1 exit status theano 基本操作 引入常用的包 1234from theano import *import theano.tensor as T## 计算卷积的函数from theano.tensor.nnet import conv 函数的定义和计算 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# 标量x = T.dscalar('a')y = T.dscalar('b')z = x * y ** 2f = function([x,y],z)# 向量x = T.vector('a')z = x + xf = function([x],z)f([1,2,3])# 矩阵x = T.dmatrix('x')y = T.dmatrix('y')z = x + yf = function([x,y],z)f(np.array([[1,2,3],[4,5,6]]),np.array([[3,4,5],[6,7,8]]))# 逻辑回归函数# 验证 1 / (1 + T.exp(-x)) == (1 + T.tanh(x/2)) / 2x = T.dmatrix('x')s = 1 / (1 + T.exp(-x))f = function([x],s)f(np.array([[4,-1],[2,3]]))s2 = (1 + T.tanh(x/2)) / 2f2 = function([x],s2)f2(np.array([[4,-1],[2,3]]))## 一次计算多个函数a,b = T.dmatrices('a','b')f1 = a + bf2 = a - bf3 = a*bf4 = a**bf = function([a,b],[f1,f2,f3,f4])ss = f(np.array([[1,2],[3,5]]),np.array([[1,2],[3,5]]))# 为输入参数设置默认值from theano import Inx,y = T.dscalars('x','y')z = x + yf = function([x,In(y,value=1)],z)# 只传入x， y的默认值就是1f(10)## 截止到目前为止，变量都只是在函数内部使用，没有共享# 下面看看如何实现值的累加from theano import sharedcount = shared(0) # 计数值初始化为0inc = T.iscalar('inc')f = function([inc],count,updates=[(count,count+inc)])f(10)f(2)count.get_value()count.set_value(-1)count.get_value()## 随机数from theano.tensor.shared_randomstreams import RandomStreamssrng = RandomStreams(seed=234)rv_u = srng.uniform((2,2)) # 均匀分布的随机数rv_n = srng.normal((2,2)) # 正太分布的随机数f = function([],rv_u)g = function([],rv_n,no_default_updates = True)nearly_zeros = function([],rv_u + rv_u-2 * rv_u)f()g()nearly_zeros()# 设置随机数发生器的种子rng_val = rv_u.rng.get_value(borrow=True)rng_val.seed(100)rv_u.rng.set_value(rng_val,borrow=True) 求函数的导数 1234567891011import numpy as npimport theanoimport theano.tensor as Tfrom theano import ppx = T.dscalar('x')y = x ** 2gy = T.grad(y,x)pp(gy)f = theano.function([x], gy)f(4) # x的平方的导数 卷积操作 2D卷积 theano计算卷积的函数： 1234from theano.tensor.nnet import conv2doutput = conv2d( input, filters, input_shape=(1, 1, 5, 5), filter_shape=(1, 1, 3, 3), border_mode=(1, 1), subsample=(2, 2)) 上式计算的是类似下面这样的卷积： 其中各个参数的含义是： input(batch size, input channels, input rows, input columns) batch size : 一次处理的样本数量 input channels : input feature map 的数量 input rows: input feature map 的行 input columns: input feature map 的列 filters(output channels, input channels, filter rows, filter columns). output channels ： output feature map 的数量 input channels : input feature map 的数量 filter rows ：卷积核的行 filter columns : 卷积核的列 input_shape(batch size (b), input channels (c), input rows (i1), input columns (i2)) batch size : 一次处理的样本数量 input channels : input feature map 的个数 input rows: input feature map 的行 input columns : input feature map 的列 filter_shape(output channels (c1), input channels (c2), filter rows (k1), filter columns (k2)) output channels ： output feature map 的个数 input channels : input feature map 的个数 filter rows &amp; filter columns ： 卷积核的大小 border_mode: ‘valid’, ‘half’, ‘full’ or (p_1, p_2) 边缘补0的模式。 subsample: (s1, s2) 定义卷积核的步长。","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"},{"name":"深度学习","slug":"技术/机器学习/深度学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/深度学习/"}],"tags":[{"name":"ML","slug":"ML","permalink":"http://ff120.github.io/hexoblog/tags/ML/"},{"name":"theano","slug":"theano","permalink":"http://ff120.github.io/hexoblog/tags/theano/"}]},{"title":"机器学习_人脸识别","slug":"技术/机器学习/机器学习_人脸识别","date":"2017-03-22T07:34:04.000Z","updated":"2019-03-28T00:54:57.946Z","comments":true,"path":"2017/03/22/技术/机器学习/机器学习_人脸识别/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/03/22/技术/机器学习/机器学习_人脸识别/","excerpt":"","text":"现有平台 Face++ 旷世 （https://www.faceplusplus.com.cn/） 商汤科技 （http://www.sensetime.com/index/） 云从科技 （http://www.cloudwalk.cn/index.html） 腾讯优图 百度人脸团队","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"}],"tags":[{"name":"ML","slug":"ML","permalink":"http://ff120.github.io/hexoblog/tags/ML/"}]},{"title":"博客收藏","slug":"收藏夹/博客集锦","date":"2017-03-22T05:54:40.000Z","updated":"2019-03-28T00:54:55.814Z","comments":true,"path":"2017/03/22/收藏夹/博客集锦/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/03/22/收藏夹/博客集锦/","excerpt":"","text":"Bloom Filter概念和原理 http://blog.csdn.net/jiaomeng/article/details/1495500","categories":[{"name":"收藏夹","slug":"收藏夹","permalink":"http://ff120.github.io/hexoblog/categories/收藏夹/"}],"tags":[{"name":"收藏","slug":"收藏","permalink":"http://ff120.github.io/hexoblog/tags/收藏/"}]},{"title":"算法专题_位运算","slug":"技术/数据结构和算法/算法专题_位运算","date":"2017-03-21T03:12:12.000Z","updated":"2019-03-28T00:54:56.412Z","comments":true,"path":"2017/03/21/技术/数据结构和算法/算法专题_位运算/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/03/21/技术/数据结构和算法/算法专题_位运算/","excerpt":"每种编程语言中都会有相关的位运算操作符，实现二进制的按位运算。 位运算有四种：与(&amp;)，或(|)，非(~),异或(^) 熟悉每种位运算的特点，是做与位运算有关的题目的基础。","text":"每种编程语言中都会有相关的位运算操作符，实现二进制的按位运算。 位运算有四种：与(&amp;)，或(|)，非(~),异或(^) 熟悉每种位运算的特点，是做与位运算有关的题目的基础。 与(&amp;) 0&amp;0=0; 0&amp;1=0; 1&amp;0=0; 1&amp;1=1; 仔细观察上面的操作，发现与操作的结果与二进制加法的进位规则非常一致。 0+0=0 ; 0+1=0; 1+0=0; 1+1 = 1; (此处等号后面的数字表示应该的进位) n = n&amp;(n-1) 该操作的效果是把n的最后一个二进制1变为0. 此操作在涉及统计二进制数中1的个数的时候比较有用。 n = n&amp;(~n+1) 该操作的效果是把n的最右边的二进制1留下，其余的1全部置0. n = n&amp;(-n) 该操作的效果是得到n的最后一个1 或(|) 0|0=0; 0|1=1; 1|0=1; 1|1=1; `` 非(~) ~0=1; ~1=0 异或(^) 0^0=0;1^1=0; 0^1=1;1^0=1; 仔细观察上面的操作，发现异或操作的结果与二进制加法(忽略进位的情况下)规则一致。 0+0=0;0+1=1;1+0=1;1+1=0;(此处等号后面的数字是无进位加法的结果) a^0=a; a^a=0; a^a^a=a 偶数个a异或的结果是0，奇数个a异或的结果是a. a^(a^b)=b;b^(a^b)=a; 此规则可以用来交换两个数字，无需额外的空间 除法 (a)/(a &amp; (-a));, 去除末尾的若干个0. 例如 1011000 -&gt; 1011 相关的应用 交换两个整数(不适用额外的空间) 此题是典型的利用异或运算的性质求解的题。 - a^a = 0; a^0 = a; - a^(a^b) = b ; b^(a^b) = a ; 具体的交换代码如下： 123a = a^b;b = a^b;a = a^b; 分析一下这三行代码，我们把原来的a,b 记作a1,b1;把交换之后的记作a2,b2;最后要达到的结果是a2=b1;b2=a1; 第一行，a=a^b, 此时a的值已经改变，变成了a^b的值； 第二行变成b = (a^b)^b = a, 此时b的值已经改变，变成了a的值。 第三行，此时的a=a^b,而b=a,所以 a=a^b=(a^b)^a=b,a变成了b的值。 通过分析可以发现，其实充当暂存中间结果的变量是a, a先存储了a^b的值，然后去跟b异或得到a,再跟得到的a异或得到b. 而一般的需要第三个变量做中介的交换思路是首先把b存起来，因为在b=a时，b的值丢失了。之所以利用异或不怕b的值丢失， 是因为可以利用得到的a再次得到b. 不用比较找出两个数中较大的数 不用比较运算符比较两个数字的大小，可以使用减法运算符。 如果也不能使用减法运算符，可以考虑只使用位运算实现减法运算。 a-b = c 如果c&gt;0,a&gt;b; 如果c&lt;0;c&lt;b;但是不幸的是，还是用到的&lt;或者&gt; C++中有函数signbit(x)可以返回x的符号，使用的时候需要注意包含头文件#include &lt;cmath&gt; 另外需要注意的问题就是整数的溢出，a-b如果a是正数，b是负数，就会变成两个整数相加，这时候如果二者都接近 INT类型表示的边界，就会超出能够表示的最大的数的范围，产生正溢出。 同理，如果a是负数,b是正数，同样可能超出 能够表示的最小的负数的范围，产生负溢出。 幸运的是，如果知道二者异号，很容易判断谁大谁小。所以先判断是否是异号比较好，可以防止数据溢出产生错误。 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;//找出两个数中较大的数字，不使用任何比较运算// 不比较两个元素，只能做差//两个数做差或涉及到溢出的问题// a - b 如果a 接近最大的整数，b接近最大的负数， 就会溢出// a- b 如果a 接近最大的负数，b接近最大的正数，也会溢出//所以先判断正负，再做差int getMax(int a,int b)&#123; if(signbit(a) &amp;&amp; !signbit(b))&#123;return b;&#125; if(signbit(b) &amp;&amp; !signbit(a))&#123;return a;&#125; if(signbit(a-b))&#123;return b;&#125; return a;&#125;int main() &#123; cout&lt;&lt;getMax(5435651,-2393)&lt;&lt;endl; return 0;&#125; 不使用任何算术运算只使用位运算实现加减乘除 加法运算的思路 不考虑进位的情况下， a^b 就是a+b的结果 只考虑进位的情况下， (a&amp;b)&lt;&lt;1 就是a+b的结果 所以综合二者，就能得到加法的正确答案。 减法的思路 a-b = a+(-b); 而-b = ~b+1 每个二进制位取反再加1. 乘法运算的思路 a*b 把b看成二进制位，每次把a左移（相当于乘以2），看b对应的位置上是否是1， 是1就将结果加到最终的结果上，是0就不加，返回最后的结果。 除法运算的思路 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;using namespace std;/** * 用位运算实现加法运算 * 按照二进制位加法 0 + 0 = 0 | 0 + 1 = 1 | 1 + 1 = 0 * 如果不考虑进位，该规则正好与异或相同 * * 考虑什么时候会产生进位 0 + 0 = 0 0 + 1 = 0 1+ 1 = 1 * 该规则正好与 &amp; 运算一致 * * 所以分别考虑无进位相加和只考虑进位的结果 加在一起就好了。 * @return */int add(int a,int b)&#123; int sum =a ; while(b!=0)&#123; sum = a ^ b; b = (a &amp; b) &lt;&lt; 1; a = sum; &#125; return a;&#125;/** * 用位实现减法运算， 不能用-运算符 * @param a * @param b * @return */int minus2(int a,int b)&#123; // a - b == a + (-b) // -b == ~b + 1 add(a,add(~b,1));&#125;/** * 用位运算实现乘法 * * @return */int cheng(int a,int b)&#123; int sum = 0; while(b!=0)&#123; if(b&amp;1!=0)&#123; sum = add(sum,a); &#125; a&lt;&lt;=1; b&gt;&gt;=1; &#125;&#125;int main() &#123; std::cout &lt;&lt; cheng(-20,500) &lt;&lt; std::endl; return 0;&#125; 整数的二进制表达中有多少个1 题目： 给定一个32位的整数，可0，可正，可负，返回该整数的二进制表达中有多少个1. 第一种方法是每次右移，然后统计1的个数，这种方法需要统计32次。 第二种方法只有原来数字中有多少个1有关，1越少速度越快。 n = n&amp;(n-1) 该操作可以抹掉n最右边的1 n = n&amp;(~n+1) 该操作可以得到n最右侧的1 使用上面的任意一种操作，可以设计算法实现只与1的个数有关的算法。 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;/** * 统计整数的二进制表达中有多少个1 * @return */int getSum(int a)&#123; int sum = 0; while(a!=0)&#123; if(a&amp;1 == 1)&#123; sum++; &#125; a = a&gt;&gt;1; &#125; return sum;&#125;/** * n&amp;(n-1)的作用就是消除n最右边的1 * @param a * @return */int getSumA(int a)&#123; int sum = 0; while(a!=0)&#123; a = a&amp;(a-1); ++sum; &#125; return sum;&#125;int main() &#123; std::cout &lt;&lt; getSumA(8)&lt;&lt; std::endl; return 0;&#125; 找出一个只出现一次的数字 题目： 一个整数数组中，只有一个数字只出现了一次，其他所有数字都出现的两次，找出这个出现一次的数字。 变种： 一个整数数组中，只有一个数字出现了奇数次，其他所有的数字都出现了偶数次，找出这个出现奇数次的数字。 了解异或运算特点，a^a = 0; a^0 = a; a^a^a = a; 出现偶数次的数在异或运算下都是0，出现奇数次的数异或之后就是它本身。 12345678910111213/** * 只有一个数字出现了奇数次，其余的数字都出现了偶数次，找出这个数字 * 找出这个数字 * @param v * @return */int research(vector&lt;int&gt; v)&#123; int re = 0; for(auto a:v)&#123; re = re ^ a; &#125; return re;&#125; 这个题目还可以从另外一个角度去理解，K个K进制的数字如果忽略进位相加的话，结果一定是0.那么nK个K进制的数字相加的话，结果 也一定是0. 而异或恰好是二进制无进位相加的实现。 了解了这一点，如果我们能够像异或这样，实现任意的K进制数无进位相加的结果，就可以解决下面这样的问题： 在其他数字都出现K次的数组中找出只出现一次的数字。 找出两个只出现一次的数字 题目：一个整数数组中，只有两个数字只出现了一次，其他所有数字都出现的两次，找出这两个数字。 思路：异或一遍之后得到的结果是a^b， a,b必然有一位是不同的(如果结果是0，那么a=b，说明并没有两个只出现一次的数字)。 根据这个二进制位将原来的数据分成两组，分别异或一遍即可得到这两个数字。 12345678910111213141516171819202122/** * 只有两个数出现了奇数次，找出这两个数 * @param v * @return */vector&lt;int&gt; research2(vector&lt;int&gt; v)&#123; vector&lt;int&gt; result; int r1 = 0; for(auto i : v)&#123; r1 = r1 ^ i; &#125; int bit1 = r1 &amp; (~r1 +1); int ab = 0; // 现在r1保存的是两个出现奇数次的数的异或 for(auto j : v)&#123; if((j&amp;bit1) != 0)&#123; ab = ab ^ j; &#125; &#125; result.push_back(ab); result.push_back(ab^r1); return result;&#125; 找出三个只出现一次的数字 题目：一个整数数组中，只有三个数字只出现了一次，其他所有数字都出现的两次，找出这三个数字。 思路：整体异或一遍，得到x=a^b^c. 设f(x)表示获取x的最后一位二进制1，例如f(10100)=00100. n = f(x^a)^f(x^b)^f(x^c), 设n的最后一个二进制位1在第m位上。则有x^a,x^b,x^c只有一个数字在第m位上是1，其余的两个数字在第m位上都是0. (具体的推导过程参考这里). 算法步骤： abc = 0; 循环一遍：abc^=v[i] , 得到x=a^b^c; g1 = 0; 循环一遍：g1^=getLastOne(abc^v[i]);, 得到上面提到的n. g1 = getLastOne(g1), 得到分界数字，上面提到的第m位置1的数字。 把所有满足getLastOne( v[i] ^ abc ) == g1条件的分成一组，该组中只包含a,b,c三个数字中的一个数字，异或一遍，得到a. 剩下的就是找到两个数字了。 12345678910111213141516171819202122232425262728293031int getLastOne(int n)&#123; return n &amp; -(n-1);&#125;void solve(vector&lt;int&gt; v,int &amp;a,int &amp;b,int &amp;c)&#123; if(v.size() == 0) return; int abc = 0; for(int i=0;i&lt;v.size();i++)&#123; abc = abc ^ v[i]; &#125; int g1 = 0; for(int i=0;i&lt;v.size();i++)&#123; g1 = g1 ^ getLastOne(abc^v[i]); &#125; // g1 只有1位是1，a,b,c中只有一个数字的这一位是1 g1 = getLastOne(g1); a = 0; for(int i=0;i&lt;v.size();i++)&#123; if(getLastOne( v[i] ^ abc ) == g1)&#123; a = a ^ v[i]; &#125; &#125; int bc = abc ^ a; int g2 = getLastOne(bc); b = 0; for(int i=0;i&lt;v.size();i++)&#123; if(v[i]&amp;g2 &amp;&amp; v[i]!=a)&#123; b = b ^ v[i]; &#125; &#125; c = bc ^ b;&#125; 在其他数字都出现K次的数组中找到只出现一次的数 这里要明白一个规律，K个相同的K进制的数无进位相加的话，结果必然是0，因为所有是0的位还是0，所有不是0的位都加到了需要进位，除去进位，就是0. 明白了上面的一点，这个问题就容易解决了。首先把所有的数字转换成K进制，然后实现无进位相加的函数,再把结果转换回十进制输出即可。 另外一种解法： 可以统计所有数字每个二进制位上1的个数。然后每个二进制位对K取余，哪些出现K次的数字累加到对应位上的和肯定是K的倍数，取余之后就是0.剩下来的就是那个只出现一次的数字。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * 将一个十进制的数转换成K进制 * @param n * @return */deque&lt;int&gt; Kin(int n,int k)&#123; deque&lt;int&gt; result; while(n/k != 0)&#123; result.push_front(n%k); n = n / k; &#125; result.push_front(n); return result;&#125;/** * 将K进制的deque转换成10进制 * @param v * @return */int Kinverse(deque&lt;int&gt; v,int k)&#123; int s = 0; int i = 0; while(!v.empty())&#123; s += v.back() * std::pow(float(k),i); ++i; &#125; return s;&#125;/** * 实现两个vector按照K进制相加，忽略进位 * @param v1 * @param v2 * @return */deque&lt;int&gt; addV(deque&lt;int&gt; v1,deque&lt;int&gt; v2,int k)&#123; deque&lt;int&gt; result; if(v1.size() &lt; v2.size())&#123; auto tmp = v1; v1 = v2; v2 = tmp; &#125; while(!v2.empty())&#123; result.push_front( (v1.back() + v2.back() ) % k ); v1.pop_back(); v2.pop_back(); &#125; while(!v1.empty())&#123; result.push_front( v1.back() ); v1.pop_back(); &#125; return result;&#125;/** * 实现v中的十进制数按照K进制相加，忽略进位，返回和 * @param v * @param k * @return */int Kplus(vector&lt;int&gt; v,int k)&#123; deque&lt;int&gt; result; for(auto i : v)&#123; result = addV(result,Kin(i,k),k); &#125; return Kinverse(result,k);&#125;int main() &#123;// vector&lt;int&gt; v = &#123;1,2,2,3,3,4,4,5,5,70&#125;;// auto reuslt = research2(v);// std::cout &lt;&lt; reuslt[0] &lt;&lt;\" \"&lt;&lt;reuslt[1] &lt;&lt; std::endl; vector&lt;int&gt; v = &#123;3,4,5,6&#125;; cout&lt;&lt;Kplus(v,10); return 0;&#125; 123456789101112131415161718192021222324int solve(vector&lt;int&gt; &amp;v,int k)&#123; vector&lt;int&gt; counts(64,0); for(int i=0;i&lt;v.size();i++)&#123; int index = 0; int tmp = v[i]; while(tmp)&#123; if(tmp&amp;1)&#123; counts[index]++; &#125; tmp = tmp&gt;&gt;1; index++; &#125; &#125; for(int i=0;i&lt;v.size();i++)&#123; counts[i] = counts[i] % k; &#125; int number = 0; int base = 1; for(int i=0;i&lt;counts.size();i++)&#123; number += counts[i] * base; base = base *2; &#125; return number;&#125; 快速的求一个整数的N次方 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;bitset&gt;using namespace std;/** * f(n) = f(n-1) + f(n-2) * 1 1 2 3 5 8 ... * 要求实现O(logn)的算法 * @return */int getNum(int n)&#123; vector&lt;int&gt; v; for(int i=0;i&lt;n;i++)&#123; if(i==0)&#123; v.insert(v.end(),1); &#125; else if(i==1)&#123; v.insert(v.end(),1); &#125; else&#123; v.insert(v.end(),v[i-2]+v[i-1]); &#125; &#125; for(auto i:v)&#123; cout&lt;&lt;i&lt;&lt;endl; &#125; return v.back();&#125;/** * * @param n * @return */int getNum2(int a,int n)&#123; int i = 0; double sum = 0; while(n!=0)&#123; int s = n&amp;1; if(s==1)&#123; double t = powf(2,i); sum += powf(a,t); &#125; n&gt;&gt;1; ++i; &#125; cout&lt;&lt;sum&lt;&lt;endl;&#125;int main() &#123; int a = 3; int n = 5; while(n!=0)&#123; &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"矩阵和用矩阵表示的图的相关问题","slug":"技术/数据结构和算法/算法专题_矩阵和图","date":"2017-03-21T03:11:20.000Z","updated":"2019-03-28T00:54:56.883Z","comments":true,"path":"2017/03/21/技术/数据结构和算法/算法专题_矩阵和图/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/03/21/技术/数据结构和算法/算法专题_矩阵和图/","excerpt":"图，路径，矩阵操作的相关问题。","text":"图，路径，矩阵操作的相关问题。 旋转打印矩阵 设计一个函数，打印矩阵的最外层，然后循环调用这个函数， 可以实现旋转打印矩阵。同样，矩阵整体旋转多少度的问题也可以这样 解决，设计一个旋转最外层的函数，每次调用这个函数，就可以实现整个 矩阵的旋转。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;/** * 顺时针打印矩阵最外层 * @return */void printEdge(vector&lt;vector&lt;int&gt;&gt; m,int li,int lj,int ri,int rj)&#123; if(li == ri) &#123; for (int j = lj; j &lt;= rj; ++j) &#123; cout &lt;&lt; m[li][j] &lt;&lt; \" \"; &#125; return; &#125; if(lj == rj)&#123; for(int i=li;i&lt;=ri;++i)&#123; cout&lt;&lt;m[i][lj]&lt;&lt;\" \"; &#125; return; &#125; int i = li; int j = lj; while(i == li &amp;&amp; j &lt;= rj)&#123; cout&lt;&lt;m[i][j]&lt;&lt;\" \"; ++j; &#125; --j; ++i; while(i&lt;=ri&amp;&amp;j==rj)&#123; cout&lt;&lt;m[i][j]&lt;&lt;\" \"; ++i; &#125; --i; --j; while(i == ri &amp;&amp; j&gt;=lj)&#123; cout&lt;&lt;m[i][j]&lt;&lt;\" \"; --j; &#125; ++j; --i; while(i&gt;li &amp;&amp; j==lj)&#123; cout&lt;&lt;m[i][j]&lt;&lt;\" \"; --i; &#125;&#125;/** * 逆时针打印矩阵的最外层 * @param v * @param li * @param lj * @param ri * @param rj */void printEdge2(vector&lt;vector&lt;int&gt;&gt; v,int li,int lj,int ri,int rj)&#123; int i=li; int j=lj; while(i &lt;= ri &amp;&amp; j == lj)&#123; cout&lt;&lt;v[i][j]&lt;&lt;\" \"; ++i; &#125; --i; ++j; while(i == ri &amp;&amp; j &lt;= rj)&#123; cout&lt;&lt;v[i][j]&lt;&lt;\" \"; ++j; &#125; --j; --i; while(i&gt;=li &amp;&amp; j==rj)&#123; cout&lt;&lt;v[i][j]&lt;&lt;\" \"; --i; &#125; ++i; --j; while(i == li &amp;&amp; j&gt;lj)&#123; cout&lt;&lt;v[i][j]&lt;&lt;\" \"; --j; &#125;&#125;/** * 顺时针旋转矩阵最外圈90度 * @param v * @param li * @param lj * @param ri * @param rj */void rotateEdge(vector&lt;vector&lt;int&gt;&gt; &amp;v,int li,int lj,int ri,int rj)&#123; int times = ri - li; int tmp = 0; for(int c = 0;c&lt;times;++c)&#123; tmp = v[li][lj+c]; v[li][lj+c] = v[ri-c][lj]; v[ri-c][lj] = v[ri][rj-c]; v[ri][rj-c] = v[li+c][rj]; v[li+c][rj] = tmp; &#125;&#125;/** * 逆时针旋转最外圈90度 * @param v * @param li * @param lj * @param ri * @param rj */void rotateEdge2(vector&lt;vector&lt;int&gt;&gt; &amp;v,int li,int lj,int ri,int rj)&#123; int times = ri-li; for(int c=0;c&lt;times;++c)&#123; int tmp = v[li+c][lj]; v[li+c][lj] = v[li][rj-c]; v[li][rj-c] = v[ri-c][rj]; v[ri-c][rj] = v[ri][li+c]; v[ri][lj+c] = tmp; &#125;&#125;/** * 旋转最外圈180 度 */void rotateEdge3(vector&lt;vector&lt;int&gt;&gt; &amp;v,int li,int lj,int ri,int rj)&#123; int times = ri - li; int tmp = 0; for(int c = 0;c&lt;times;++c)&#123; tmp = v[li][lj+c]; v[li][lj+c] = v[ri][rj-c]; v[ri][rj-c] = tmp; tmp = v[li+c][rj]; v[li+c][rj] = v[ri-c][lj]; v[ri-c][lj] = tmp; &#125;&#125;/** * 顺时针打印矩阵 * @param v */void printM1(vector&lt;vector&lt;int&gt;&gt; v)&#123; int m = v.size()-1; int n = v[0].size()-1; int a = 0; int b = 0; while(a&lt;=m &amp;&amp; b &lt;= n)&#123; printEdge(v,a,b,m,n); ++a; ++b; --m; --n; &#125;&#125;/** * 逆时针打印数组 * * @param v */void printM2(vector&lt;vector&lt;int&gt;&gt; v)&#123; int m = v.size()-1; int n = v[0].size()-1; int a = 0; int b = 0; while(a&lt;=m &amp;&amp; b &lt;= n)&#123; printEdge2(v,a,b,m,n); ++a; ++b; --m; --n; &#125;&#125;void rotateM(vector&lt;vector&lt;int&gt;&gt; &amp;v)&#123; int m = v.size()-1; int n = v[0].size()-1; int a = 0; int b = 0; while(a&lt;=m &amp;&amp; b &lt;= n)&#123; rotateEdge(v,a,b,m,n); ++a; ++b; --m; --n; &#125;&#125;void rotateM2(vector&lt;vector&lt;int&gt;&gt; &amp;v)&#123; int m = v.size()-1; int n = v[0].size()-1; int a = 0; int b = 0; while(a&lt;=m &amp;&amp; b &lt;= n)&#123; rotateEdge2(v,a,b,m,n); ++a; ++b; --m; --n; &#125;&#125;/** * 矩阵打印输出 * @param v */void print(vector&lt;vector&lt;int&gt;&gt; v)&#123; cout&lt;&lt;endl; for(auto i:v)&#123; for(auto j:i)&#123; cout&lt;&lt;j&lt;&lt;\"\\t\"; &#125; cout&lt;&lt;endl; &#125;&#125;int main() &#123; vector&lt;vector&lt;int&gt;&gt; v = &#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;,&#123;13,14,15,16&#125;&#125;; print(v); cout&lt;&lt;\"---------------\"&lt;&lt;endl; rotateEdge3(v,0,0,3,3); print(v); return 0;&#125; 之字型打印矩阵 2017-03-22_143007.png 在行和列都排序好的矩阵中寻找数 - 提示： 从矩阵的右上角开始寻找。 子矩阵的最大累加和问题 - 提示： 利用子数组的最大累加和的解法 - 必须含有两行的矩阵的累加和就是先把对应的列相加，形成一个向量，在求这个向量的最大累加和 打印N个数组整体最大的top K 边界都是1的最大正方形的大小 2017-03-22_145906.png 打印最短通路值 时间复杂度O（NM），使用宽度优先搜索。 ## 矩阵的最小路径和 用动态规划的方法，dp[i][j]表示从左上角走到i,j的最小路径和。 时间复杂度O（MN），空间复杂度经过优化之后可以达到O(min{M,N}) 龙与地下城游戏问题 dp[i][j] 表示骑士在位置i,j的时候，如果要能走到最后，最少应该具有的血量。 12 N皇后问题 2017-03-22_110620.png","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"算法专题_二维数组","slug":"技术/数据结构和算法/算法专题_二维数组","date":"2017-03-21T01:31:12.000Z","updated":"2019-03-28T00:54:56.388Z","comments":true,"path":"2017/03/21/技术/数据结构和算法/算法专题_二维数组/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/03/21/技术/数据结构和算法/算法专题_二维数组/","excerpt":"主要是关于两个数组，两个字符串的相关问题。","text":"主要是关于两个数组，两个字符串的相关问题。 最长公共子序列 解法: 动态规划。设str1长度是m, str2长度是n, 开一个大小是dp[m+1][n+1]的二维数组，dp[0][j]和dp[i][0]分别表示第一行和第一列，全部初始化为0. dp[i][j]表示str1前i个字符和str2前j个字符组成的最长公共子序列的长度。dp[0][0]表示两个字符串都是空串的情况下最长公共子序列的长度为0. 递推公式： dp[i][j] = max(dp[i-1][j],dp[i][j-1]), dp[i][j] = max(dp[i][j],dp[i-1][j-1]+1) if(str1[i] == str2[j]) 含义是： str1[i]和 str2[j] 的最长公共子序列 首先应该是 str1[i-1]与str2[j] str[i]与str2[j-1] 中较长的那个， 然后比较 str1[i]与str2[j]是否相等，如果相等，还可能是str1[i-1]str2[j-1]的长度 + 1 与当前的dp[i][j]中较大的那个。 输出找到的最长公共子序列的方法： 如果格子dp[i][j]对应的str1[i-1] == str2[j-1]，则把这个字符放入 LCS 中，并跳入dp[i-1][j-1]中继续进行判断； 如果格子dp[i][j]对应的 str1[i-1] ≠str2[j-1]，则比较dp[i-1][j]和dp[i][j-1]的值，跳入值较大的格子继续进行判断；(如果相等，说明存在多个最长的子序列) 直到i或j 小于等于零为止，倒序输出 LCS 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;int getMaxlength(const string &amp;s1,const string &amp;s2)&#123; int ans; size_t m = s1.size(); size_t n = s2.size(); vector&lt;vector&lt;int&gt; &gt; dp(m+1,vector&lt;int&gt;(n+1,0)); // 第一行，第一列初始化为0 //动态规划的递推公式 for(int i=1;i&lt;=m;++i)&#123; for(int j=1;j&lt;=n;++j)&#123; dp[i][j] = max(dp[i-1][j],dp[i][j-1]); if(s1[i-1] == s2[j-1])&#123; dp[i][j] = max(dp[i][j],dp[i-1][j-1]+1); &#125; &#125; &#125; // 输出最长的子序列 int i = m; int j = n; string cstr ; while(i &gt; 0 &amp;&amp; j &gt; 0)&#123; if(s1[i-1] == s2[j-1])&#123; cstr.insert(cstr.begin(),s1[i-1]); i--; j--; &#125;else if(dp[i-1][j] &gt;= dp[i][j-1])&#123; i--; &#125;else if(dp[i-1][j] &lt; dp[i][j-1])&#123; j--; &#125; &#125; cout &lt;&lt; cstr &lt;&lt; endl; return dp[m][n];&#125;int main() &#123; string s1 = \"2bcd\"; string s2 = \"a2ed\"; std::cout &lt;&lt;getMaxlength(s1,s2) &lt;&lt; std::endl; return 0;&#125; 最长公共子串问题 2017-03-21_093641.png 解法：动态规划。 dp[i][j]表示以i,j结尾的str1,str2的最长子串是多少； 如果str1[i]!=str2[j],则为0，否则，str1[i] == str[2][j],dp[i][j] = dp[i-1][j-1]+1; 找到dp表中最大的值输出。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;/** * 两个字符串的最长公共子串 * @param s1 * @param s2 * @return */int longestCommonSubstring(string &amp;A, string &amp;B)&#123; int ans = 0; if(A.empty() || B.empty()) return ans; size_t m = A.size(); size_t n = B.size(); vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1,0)); for(int i=1;i&lt;=m;++i)&#123; for(int j=1;j&lt;=n;++j)&#123; if(A[i-1] == B[j-1])&#123; dp[i][j] = dp[i-1][j-1]+1; ans = max(ans,dp[i][j]); &#125; else dp[i][j] = 0; &#125; &#125; // 输出最长公共子串 int tmp = 0; int ii = 0; for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(dp[i][j] &gt; tmp)&#123; tmp = dp[i][j]; ii = i; &#125; &#125; &#125; cout &lt;&lt; A.substr(ii-ans,ans) &lt;&lt; endl; return ans;&#125;int main() &#123; string s1 = \"1ab2345cd\"; string s2 = \"12345ef\"; getMaxC(s1,s2); return 0;&#125; 最小的编辑代价 解法：动态规划，dp[i][j]的值代表把str1[0…i-1]编辑成[str2[0..j-1] 的最小的代价。注意这里生成的是M+1，N+1的dp矩阵，第一行和第一列都是空字符， 用来表示全部添加或者全部删除。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;/** * 最小编辑代价 * @param a * @param b * @param ic * @param dc * @param rc * @return */int getMin(string a,string b,int ic,int dc,int rc)&#123; //如果先删除在插入的代价小于直接替换的代价，那么就永远不使用直接替换 if(dc+ic&lt;=rc)&#123;rc = dc+ic;&#125; int result = 0; vector&lt;vector&lt;int&gt;&gt; dp(a.size()+1,vector&lt;int&gt;(b.size()+1)); //初始化第一列，把a[i]编辑成空串的代价 //要把a[i]编辑成空串只有一种方法，就是把所有的字符都删除 for(int i=0;i&lt;=a.size();++i)&#123; dp[i][0] = dc*i; &#125; //初始化第一行，把空串编辑成b[j]的方法也只有一种，就是插入相应的字符 for(int j=1;j&lt;=b.size();++j)&#123; dp[0][j] = ic*j; &#125; //动态规划的递推公式 for(int i=1;i&lt;=a.size();++i)&#123; for(int j=1;j&lt;=b.size();++j)&#123; dp[i][j] = min(dp[i-1][j]+dc,dp[i][j-1]+ic); if(a[i-1] == b[j-1])&#123; dp[i][j] = min(dp[i][j],dp[i-1][j-1]); &#125; else&#123; dp[i][j] = min(dp[i][j],dp[i-1][j-1]+rc); &#125; &#125; &#125; //输出动态规划表 for(auto row : dp)&#123; for(auto cow : row)&#123; cout&lt;&lt;cow&lt;&lt;\"\\t\"; &#125; cout&lt;&lt;endl; &#125; return dp[a.size()][b.size()];&#125;int main() &#123; string a = \"ab12cd3\"; string b = \"abcdf\"; int ic = 5; int dc = 3; int rc = 2; std::cout &lt;&lt; getMin(a,b,ic,dc,rc) &lt;&lt; std::endl; return 0;&#125; 字符串的交错组成 解法： 动态规划，生成M+1，N+1的dp矩阵，dp[i][j]表示aim[0,i+j-1] 能否被str1[0…i-1]和str2[0…j-1]交错组成。注意第一行和第一列都是空串。 aim[-1]表示aim为空串的时候。str1[-1],str2[-1]都表示是空串的时候。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;/** * 字符串的交错组成 * 判断aim能够由str1 and str2 交错组成 * @param s1 * @param s2 * @param aim * @return */bool isCom(string s1,string s2,string aim)&#123; //先从长度判断 if(s1.size() + s2.size() != aim.size())&#123;return false;&#125; vector&lt;vector&lt;bool&gt;&gt; dp(s1.size()+1,vector&lt;bool&gt;(s2.size()+1)); //空串可以被空串交错组成 dp[0][0] = true; //初始化第一列 for(int i=1;i&lt;=s1.size();++i)&#123; if(s1[i-1] != aim[i-1])&#123;break;&#125; dp[i][0] = true; &#125; //初始化第一行 for(int j=1;j&lt;s2.size();++j)&#123; if(s2[j-1] != aim[j-1])&#123;break;&#125; dp[0][j] = true; &#125; for(int i=1;i&lt;=s1.size();++i)&#123; for(int j=1;j&lt;=s2.size();++j)&#123; if(s1[i-1] == aim[i+j-1] &amp;&amp; dp[i-1][j] || s2[j-1] == aim[i+j-1] &amp;&amp; dp[i][j-1])&#123; dp[i][j] = true; &#125; &#125; &#125; //输出dp数组 for(auto i:dp)&#123; for(auto j:i)&#123; cout&lt;&lt;j&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; &#125; return dp[s1.size()][s2.size()];&#125;int main() &#123; string s1 = \"ABC\"; string s2 = \"123\"; string aim = \"12AA3C\"; auto result = isCom(s1,s2,aim); cout&lt;&lt;result; return 0;&#125; 判断两个字符串是否互为旋转词 思路： 将其中一个字符串复制一份，拼接在后面，然后在这个长字符串中查找另外一个短的有没有出现。 例如判断a,b字符串，只需要find(a,b+b)!=(b+b).end() 就是旋转词，否则就不是。 12","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据结构和算法","slug":"技术/数据结构和算法","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据结构和算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://ff120.github.io/hexoblog/tags/ACM/"}]},{"title":"动态因果模型(DCM)的批量定义和估计","slug":"技术/认知神经科学/动态因果模型(DCM)的批量定义和估计","date":"2017-03-20T13:19:23.000Z","updated":"2019-03-28T00:54:59.836Z","comments":true,"path":"2017/03/20/技术/认知神经科学/动态因果模型(DCM)的批量定义和估计/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/03/20/技术/认知神经科学/动态因果模型(DCM)的批量定义和估计/","excerpt":"借助SPM中的DCM，实现批量定义模型和批量估计。附带一些批量查看和保存结果的函数。 重写了SPM中的一些函数，带extend的为重写的函数。","text":"借助SPM中的DCM，实现批量定义模型和批量估计。附带一些批量查看和保存结果的函数。 重写了SPM中的一些函数，带extend的为重写的函数。 spm_dcm_specify_extend.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376function DCM = spm_dcm_specify_extend(spmmatfile,name,VOIs,condition_mask,TE,Input_a,Input_b,Input_c)% Specify inputs of a DCM% FORMAT [DCM] = spm_dcm_specify%% DCM - the DCM structure (see spm_dcm_ui)%__________________________________________________________________________% Copyright (C) 2008 Wellcome Trust Centre for Neuroimaging% Karl Friston% $Id: spm_dcm_specify.m 4185 2011-02-01 18:46:18Z guillaume $%-Interactive window%--------------------------------------------------------------------------Finter = spm_figure('GetWin','Interactive');bcolor = get(Finter,'color');WS = spm('WinScale');dx = 20;spm_input('Specify DCM:... ',1,'d');%==========================================================================% Get design and directory%==========================================================================%[spmmatfile, sts] = spm_select(1,'^SPM\\.mat$','Select SPM.mat');%spmmatfile = 'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\first_level_dcm_w_whole\\20160716002\\SPM.mat';sts = 1;if ~sts, DCM = []; return; endswd = spm_str_manip(spmmatfile,'H');try load(fullfile(swd,'SPM.mat'))catch error(['Cannot read ' fullfile(swd,'SPM.mat')]);end%==========================================================================% Name%==========================================================================%name = spm_input('name for DCM_???.mat','+1','s');%name = 'HG_DCM';%==========================================================================% Outputs%==========================================================================%-Get cell array of region structures%--------------------------------------------------------------------------% VOI1_path = 'd:\\fmri_root\\yantai\\aNALYSIS\\first_level_dcm_w_whole\\20160716002\\VOI_HG_DW_1.mat';% VOI2_path = 'd:\\fmri_root\\yantai\\aNALYSIS\\first_level_dcm_w_whole\\20160716002\\VOI_MFG_DW_1.mat';% VOI3_path = 'd:\\fmri_root\\yantai\\aNALYSIS\\first_level_dcm_w_whole\\20160716002\\VOI_STG_DW_1.mat';% VOIs = &#123;VOI1_path;VOI2_path;VOI3_path&#125;;%P = cellstr(spm_select([1 8],'^VOI.*\\.mat$',&#123;'select VOIs'&#125;,'',swd));P = VOIs;m = numel(P);for i = 1:m p = load(P&#123;i&#125;,'xY'); xY(i) = p.xY;end%==========================================================================% Inputs%==========================================================================%-Get (nc) 'causes' or inputs U%--------------------------------------------------------------------------spm_input('Input specification:... ',1,'d');Sess = SPM.Sess(xY(1).Sess);%condition_mask = [1,0,0,0]; % 配置包含哪个条件，不包含哪个条件＿if isempty(Sess.U) % spontaneous activity, i.e. no stimuli nc = 0; U = [];else % with stimuli U.dt = Sess.U(1).dt; u = length(Sess.U); U.name = &#123;&#125;; U.u = []; for i = 1:u %i 是条件的编号 1＿JX＿ 2＿DW 3＿RL 4＿ZR for j = 1:length(Sess.U(i).name) str = ['include ' Sess.U(i).name&#123;j&#125; '?']; % include JX if condition_mask(i)%spm_input(str,'+1','y/n',[1 0],1) include JX20 ,yes 1 ; no 0; U.u = [U.u Sess.U(i).u(33:end,j)]; U.name&#123;end + 1&#125; = Sess.U(i).name&#123;j&#125;; end end end nc = size(U.u,2);end%==========================================================================% Timings%==========================================================================spm_input('Timing information:... ',-1,'d');%-Slice timings%--------------------------------------------------------------------------RT = SPM.xY.RT;%delays = spm_input('Slice timings [s]','+1','r', repmat(RT,1,m),m,[0 RT]);delays = repmat(RT,1,m)';%-Echo time (TE) of data acquisition%--------------------------------------------------------------------------%TE = 0.04; %==================================================================自己输入TE的忽===================TE_ok = 0;while ~TE_ok %TE = spm_input('Echo time, TE [s]', '+1', 'r', TE); if ~TE || (TE &lt; 0) || (TE &gt; 0.1) str = &#123; 'Extreme value for TE or TE undefined.',... 'Please re-enter TE (in seconds!)'&#125;; spm_input(str,'+1','bd','OK',[1],1); else TE_ok = 1; endend%==========================================================================% Model options%==========================================================================if nc % there are inputs spm_input('Model options:... ',-1,'d'); %options.nonlinear = spm_input('modulatory effects','+1','b',&#123;'bilinear','nonlinear'&#125;,[0 1],1); options.nonlinear = 0; %modulatory effects : 0: bilinear , 1: nonlinear %options.two_state = spm_input('states per region', '+1','b',&#123;'one','two'&#125;,[0 1],1); options.two_state = 0 ; % states per region ; 0: one ; 1 : two %options.stochastic = spm_input('stochastic effects','+1','b',&#123;'no','yes'&#125;,[0 1],1); options.stochastic = 0 ; %stochastic effects; 0 : no ; 1 : yes, %options.centre = spm_input('centre input', '+1','b',&#123;'no','yes'&#125;,[0 1],1); options.centre = 0 ; % centre input ; 0 : no 1: yes; options.endogenous = 0;else options.nonlinear = 0; options.two_state = 0; options.stochastic = 1; options.centre = 1; options.endogenous = 1;end%==========================================================================% Graph connections%==========================================================================a = zeros(m,m);if options.endogenous b = zeros(m,m,1); c = zeros(m,1);else b = zeros(m,m,nc); c = zeros(m,nc);endd = zeros(m,m,0);%-Intrinsic connections (A matrix)%==========================================================================%-Buttons and labels%--------------------------------------------------------------------------spm_input('Specify intrinsic connections from',1,'d')spm_input('to',3,'d')for i = 1:m str = sprintf('%s %i',xY(i).name,i); h1(i) = uicontrol(Finter,'String',str,... 'Style','text',... 'FontSize',10,... 'BackgroundColor',bcolor,... 'HorizontalAlignment','right',... 'Position',[080 350-dx*i 080 020].*WS); h2(i) = uicontrol(Finter,'String',sprintf('%i',i),... 'Style','text',... 'FontSize',10,... 'BackgroundColor',bcolor,... 'Position',[180+dx*i 350 010 020].*WS);endfor i = 1:m for j = 1:m h3(i,j) = uicontrol(Finter,... 'Position',[180+dx*j 350-dx*i 020 020].*WS,... 'BackgroundColor',bcolor,... 'Style','radiobutton'); if i == j set(h3(i,j),'Value',1,... 'enable','off'); else set(h3(i,j),'enable','on','TooltipString', ... sprintf('from %s to %s',xY(j).name,xY(i).name)); end if nc &amp;&amp; i~=j set(h3(i,j),'Value',0); else set(h3(i,j),'Value',1); end endenduicontrol(Finter,'String','done','Position', [300 100 060 020].*WS,... 'Callback', 'uiresume(gcbf)');%uiwait(Finter);%-Get a a 就是DCM模型的连接矩阿%--------------------------------------------------------------------------%for i = 1:m% for j = 1:m% a(i,j) = get(h3(i,j),'Value');% end%end%a = [1,1,1;1,1,1;1,1,1]; %=========================================================定义的DCM模型，此处有三个节点，所以是3*3的矩阵；a = Input_a;delete(findobj(get(Finter,'Children'),'flat'));%-Effects of causes (B and C matrices)%==========================================================================uicontrol(Finter,'String','done','Position', [300 100 060 020].*WS,... 'Callback', 'uiresume(gcbf)');for k = 1:nc %-Buttons and labels %---------------------------------------------------------------------- str = sprintf(... 'Effects of %-12s on regions... and connections',... U.name&#123;k&#125;); spm_input(str,1,'d'); % Effects of JX on regions... and connections for i = 1:m h1(i) = uicontrol(Finter,'String',xY(i).name,... 'Style','text',... 'BackgroundColor',bcolor,... 'FontSize',10,... 'Position',[080 350-dx*i 080 020].*WS); h2(i) = uicontrol(Finter,... 'Position',[160 360-dx*i 020 020].*WS,... 'BackgroundColor',bcolor,... 'Style','radiobutton'); end for i = 1:m for j = 1:m if a(i,j) == 1 % Allow modulation of intrinsic connections %---------------------------------------------------------- h3(i,j) = uicontrol(Finter,... 'Position',[220+dx*j 360-dx*i 020 020].*WS,... 'BackgroundColor',bcolor,... 'Style','radiobutton'); set(h3(i,j),'TooltipString', ... sprintf('from %s to %s',xY(j).name,xY(i).name)); end end end %uiwait(Finter); %-Get c 就是左边的第丿?，代表输入加在那个脑区上＿ * 1 %---------------------------------------------------------------------- %for i = 1:m %c(i,k) = get(h2(i),'Value'); %end %c = [1,0,0]; c = Input_c; %-Get b allowing any 2nd order effects 3*3 的矩阵，代表调节变量在哪条线上??里有三个区域，承?昿*3 %---------------------------------------------------------------------- % for i = 1:m % for j = 1:m % if a(i,j)==1 % b(i,j,k) = get(h3(i,j),'Value'); % end % end % end %b = [0,0,0;0,0,0;0,0,0]; b = Input_b; delete([h1(:); h2(:); h3(a==1)])enddelete(findobj(get(Finter,'Children'),'flat'));%-Effects of nonlinear modulations (D matrices)%==========================================================================if options.nonlinear uicontrol(Finter,'String','done','Position', [300 100 060 020].*WS,... 'Callback', 'uiresume(gcbf)'); for k = 1:m %-Buttons and labels %------------------------------------------------------------------ str = sprintf('Effects of %-12s activity on connections',xY(k).name); spm_input(str,1,'d'); for i = 1:m for j = 1:m if a(i,j)==1 % Allow modulation of intrinsic connections %------------------------------------------------------ h4(i,j) = uicontrol(Finter,... 'Position',[220+dx*j 360-dx*i 020 020].*WS,... 'BackgroundColor',bcolor,... 'Style','radiobutton'); end end end uiwait(Finter); %-Get d allowing any 2nd order effects %------------------------------------------------------------------ for i = 1:m for j = 1:m if a(i,j)==1 d(i,j,k) = get(h4(i,j),'Value'); end end end delete(h4(a==1)) endenddelete(findobj(get(Finter,'Children'),'flat'));spm_input('Thank you',1,'d')%==========================================================================% Response%==========================================================================%-Response variables &amp; confounds (NB: the data have been whitened)%--------------------------------------------------------------------------n = length(xY); % number of regionsv = length(xY(1).u); % number of time pointsY.dt = SPM.xY.RT;Y.X0 = xY(1).X0;for i = 1:n Y.y(:,i) = xY(i).u; Y.name&#123;i&#125; = xY(i).name;end%-Error precision components (one for each region) - i.i.d. (because of W)%--------------------------------------------------------------------------Y.Q = spm_Ce(ones(1,n)*v);%==========================================================================% DCM structure%==========================================================================% Endogenous input specificationif isempty(U) U.u = zeros(v,1); U.name = &#123;'null'&#125;;end%-Store all variables in DCM structure%--------------------------------------------------------------------------DCM.a = a;DCM.b = b;DCM.c = c;DCM.d = d;DCM.U = U;DCM.Y = Y;DCM.xY = xY;DCM.v = v;DCM.n = n;DCM.TE = TE;DCM.delays = delays;DCM.options = options;%-Save%--------------------------------------------------------------------------if spm_check_version('matlab','7') &gt;= 0 save(fullfile(swd,['DCM_' name '.mat']),'-V6','DCM');else save(fullfile(swd,['DCM_' name '.mat']),'DCM');end spm_getSPM_extend.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702function [SPM,xSPM] = spm_getSPM_extend(varargin)% Compute a specified and thresholded SPM/PPM following estimation% FORMAT [SPM,xSPM] = spm_getSPM;% Query SPM in interactive mode.%% FORMAT [SPM,xSPM] = spm_getSPM(xSPM);% Query SPM in batch mode. See below for a description of fields that may% be present in xSPM input. Values for missing fields will be queried% interactively.%FORMAT [SPM,xSPM] = spm_getSPM(spm_mat_path,InputIC,InputMask，InputthresDesc，Input_u);% spm_mat_path : SPM.mat path% InputIC : 选择设置的第几个Contrast,整数＿% InputMask; % 0 none 1 contrast 2 image ============% InputthresDesc ; %===p value adjustment to control: 'FWE' or 'none'==% Input_u; %threshold 默认0.001====%-GUI setup%--------------------------------------------------------------------------spm_help('!ContextHelp',mfilename)spm('Pointer','Arrow')%-Select SPM.mat &amp; note SPM results directory%--------------------------------------------------------------------------if nargin == 1 xSPM = varargin&#123;1&#125;;endif nargin &gt; 1 spm_mat_path = varargin&#123;1&#125;; InputIC = varargin&#123;2&#125;; InputMask = varargin&#123;3&#125;; InputthresDesc = varargin&#123;4&#125;; Input_u = varargin&#123;5&#125;; Input_k = varargin&#123;6&#125;;endtry swd = xSPM.swd; sts = 1;catch sts = 1; spmmatfile = spm_mat_path; swd = spm_str_manip(spmmatfile,'H');endif ~sts, SPM = []; xSPM = []; return; end%-Preliminaries...%==========================================================================%-Load SPM.mat%--------------------------------------------------------------------------try load(fullfile(swd,'SPM.mat'));catch error(['Cannot read ' fullfile(swd,'SPM.mat')]);endSPM.swd = swd;%-Change directory so that relative filenames are valid%--------------------------------------------------------------------------cd(SPM.swd);%-Check the model has been estimated%--------------------------------------------------------------------------try SPM.xVol.S;catch %-Check the model has been estimated %---------------------------------------------------------------------- str = &#123; 'This model has not been estimated.';... 'Would you like to estimate it now?'&#125;; if spm_input(str,1,'bd','yes|no',[1,0],1) SPM = spm_spm(SPM); else SPM = []; xSPM = []; return endendxX = SPM.xX; %-Design definition structureXYZ = SPM.xVol.XYZ; %-XYZ coordinatesS = SPM.xVol.S; %-search Volume &#123;voxels&#125;R = SPM.xVol.R; %-search Volume &#123;resels&#125;M = SPM.xVol.M(1:3,1:3); %-voxels to mm matrixVOX = sqrt(diag(M'*M))'; %-voxel dimensions%==========================================================================% - C O N T R A S T S , S P M C O M P U T A T I O N , M A S K I N G%==========================================================================%-Get contrasts%--------------------------------------------------------------------------try, xCon = SPM.xCon; catch, xCon = &#123;&#125;; endtry Ic = xSPM.Ic;catch Ic = InputIC;endif isempty(xCon) % figure out whether new contrasts were defined, but not selected % do this by comparing length of SPM.xCon to xCon, remember added % indices to run spm_contrasts on them as well try noxCon = numel(SPM.xCon); catch noxCon = 0; end IcAdd = (noxCon+1):numel(xCon);else IcAdd = [];endnc = length(Ic); % Number of contrasts%-Allow user to extend the null hypothesis for conjunctions%% n: conjunction number% u: Null hyp is k&lt;=u effects real; Alt hyp is k&gt;u effects real% (NB Here u is from Friston et al 2004 paper, not statistic thresh).% u n% Conjunction Null nc-1 1 | u = nc-n% Intermediate 1..nc-2 nc-u | #effects under null &lt;= u% Global Null 0 nc | #effects under alt &gt; u, &gt;= u+1%----------------------------------+---------------------------------------if nc &gt; 1 try n = xSPM.n; catch if nc==2 But = 'Conjunction|Global'; Val=[1 nc]; else But = 'Conj''n|Intermed|Global'; Val=[1 NaN nc]; end n = spm_input('Null hyp. to assess?','+1','b',But,Val,1); if isnan(n) if nc == 3, n = nc - 1; else n = nc - spm_input('Effects under null ','0','n1','1',nc-1); end end endelse n = 1;end%-Enforce orthogonality of multiple contrasts for conjunction% (Orthogonality within subspace spanned by contrasts)%--------------------------------------------------------------------------if nc &gt; 1 &amp;&amp; n &gt; 1 &amp;&amp; ~spm_FcUtil('|_?',xCon(Ic), xX.xKXs) OrthWarn = 0; %-Successively orthogonalise %-NB: This loop is peculiarly controlled to account for the % possibility that Ic may shrink if some contrasts disappear % on orthogonalisation (i.e. if there are colinearities) %---------------------------------------------------------------------- i = 1; while(i &lt; nc), i = i + 1; %-Orthogonalise (subspace spanned by) contrast i w.r.t. previous %------------------------------------------------------------------ oxCon = spm_FcUtil('|_',xCon(Ic(i)), xX.xKXs, xCon(Ic(1:i-1))); %-See if this orthogonalised contrast has already been entered % or is colinear with a previous one. Define a new contrast if % neither is the case. %------------------------------------------------------------------ d = spm_FcUtil('In',oxCon,xX.xKXs,xCon); if spm_FcUtil('0|[]',oxCon,xX.xKXs) %-Contrast was colinear with a previous one - drop it %-------------------------------------------------------------- Ic(i) = []; i = i - 1; elseif any(d) %-Contrast unchanged or already defined - note index %-------------------------------------------------------------- Ic(i) = min(d); else %-Define orthogonalised contrast as new contrast %-------------------------------------------------------------- OrthWarn = OrthWarn + 1; conlst = sprintf('%d,',Ic(1:i-1)); oxCon.name = sprintf('%s (orth. w.r.t &#123;%s&#125;)', xCon(Ic(i)).name,... conlst(1:end-1)); xCon = [xCon, oxCon]; Ic(i) = length(xCon); end end % while... if OrthWarn warning('SPM:ConChange','%d contrasts orthogonalized',OrthWarn) end SPM.xCon = xCon;end % if nc&gt;1...SPM.xCon = xCon;%-Apply masking%--------------------------------------------------------------------------try Mask = ~isempty(xSPM.Im) * (isnumeric(xSPM.Im) + 2*iscellstr(xSPM.Im));catch % Mask = spm_input('mask with other contrast(s)','+1','y/n',[1,0],2); Mask = InputMask; % 0 none 1 contrast 2 image =================================================endif Mask == 1 %-Get contrasts for masking %---------------------------------------------------------------------- try Im = xSPM.Im; catch [Im,xCon] = spm_conman(SPM,'T&amp;F',-Inf,... 'Select contrasts for masking...',' for masking',1); end %-Threshold for mask (uncorrected p-value) %---------------------------------------------------------------------- try pm = xSPM.pm; catch pm = spm_input('uncorrected mask p-value','+1','r',0.05,1,[0,1]); end %-Inclusive or exclusive masking %---------------------------------------------------------------------- try Ex = xSPM.Ex; catch Ex = spm_input('nature of mask','+1','b','inclusive|exclusive',[0,1],1); end elseif Mask == 2 %-Get mask images %---------------------------------------------------------------------- try Im = xSPM.Im; catch Im = cellstr(spm_select([1 Inf],'image','Select mask image(s)')); end %-Inclusive or exclusive masking %---------------------------------------------------------------------- try Ex = xSPM.Ex; catch Ex = spm_input('nature of mask','+1','b','inclusive|exclusive',[0,1],1); end pm = []; else Im = []; pm = []; Ex = [];end%-Create/Get title string for comparison%--------------------------------------------------------------------------if nc == 1 str = xCon(Ic).name;else str = [sprintf('contrasts &#123;%d',Ic(1)),sprintf(',%d',Ic(2:end)),'&#125;']; if n == nc str = [str ' (global null)']; elseif n == 1 str = [str ' (conj. null)']; else str = [str sprintf(' (Ha: k&gt;=%d)',(nc-n)+1)]; endendif Ex mstr = 'masked [excl.] by';else mstr = 'masked [incl.] by';endif isnumeric(Im) if length(Im) == 1 str = sprintf('%s (%s %s at p=%g)',str,mstr,xCon(Im).name,pm); elseif ~isempty(Im) str = [sprintf('%s (%s &#123;%d',str,mstr,Im(1)),... sprintf(',%d',Im(2:end)),... sprintf('&#125; at p=%g)',pm)]; endelseif iscellstr(Im) &amp;&amp; numel(Im) &gt; 0 [pf,nf,ef] = spm_fileparts(Im&#123;1&#125;); str = sprintf('%s (%s %s',str,mstr,[nf ef]); for i=2:numel(Im) [pf,nf,ef] = spm_fileparts(Im&#123;i&#125;); str =[str sprintf(', %s',[nf ef])]; end str = [str ')'];endtry titlestr = xSPM.title; if isempty(titlestr) titlestr = str; endcatch titlestr = str;% 名称，可以自定义========================================================================end%-Bayesian or classical Inference?%==========================================================================if isfield(SPM,'PPM') % Make sure SPM.PPM.xCon field exists %---------------------------------------------------------------------- if ~isfield(SPM.PPM,'xCon') SPM.PPM.xCon = []; end % Set Bayesian con type %---------------------------------------------------------------------- SPM.PPM.xCon(Ic).PSTAT = xCon(Ic).STAT; % Make all new contrasts Bayesian contrasts %---------------------------------------------------------------------- [xCon(Ic).STAT] = deal('P'); if all(strcmp([SPM.PPM.xCon(Ic).PSTAT],'T')) % Simple contrast %------------------------------------------------------------------ str = 'Effect size threshold for PPM'; if isfield(SPM.PPM,'VB') % 1st level Bayes % For VB - set default effect size to zero %-------------------------------------------------------------- Gamma = 0; xCon(Ic).eidf = spm_input(str,'+1','e',sprintf('%0.2f',Gamma)); elseif nc == 1 &amp;&amp; isempty(xCon(Ic).Vcon) % 2nd level Bayes % con image not yet written %-------------------------------------------------------------- if spm_input('Inference',1,'b',&#123;'Bayesian','classical'&#125;,[1 0]); %-Get Bayesian threshold (Gamma) stored in xCon(Ic).eidf % The default is one conditional s.d. of the contrast %---------------------------------------------------------- Gamma = sqrt(xCon(Ic).c'*SPM.PPM.Cb*xCon(Ic).c); xCon(Ic).eidf = spm_input(str,'+1','e',sprintf('%0.2f',Gamma)); xCon(Ic).STAT = 'P'; end end else % Compound contrast using Chi^2 statistic %------------------------------------------------------------------ if ~isfield(xCon(Ic),'eidf') || isempty(xCon(Ic).eidf) xCon(Ic).eidf = 0; % temporarily end endend%-Compute &amp; store contrast parameters, contrast/ESS images, &amp; SPM images%==========================================================================SPM.xCon = xCon;if isnumeric(Im) SPM = spm_contrasts(SPM, unique([Ic, Im, IcAdd]));else SPM = spm_contrasts(SPM, unique([Ic, IcAdd]));endxCon = SPM.xCon;STAT = xCon(Ic(1)).STAT;VspmSv = cat(1,xCon(Ic).Vspm);%-Check conjunctions - Must be same STAT w/ same df%--------------------------------------------------------------------------if (nc &gt; 1) &amp;&amp; (any(diff(double(cat(1,xCon(Ic).STAT)))) || ... any(abs(diff(cat(1,xCon(Ic).eidf))) &gt; 1)) error('illegal conjunction: can only conjoin SPMs of same STAT &amp; df');end%-Degrees of Freedom and STAT string describing marginal distribution%--------------------------------------------------------------------------df = [xCon(Ic(1)).eidf xX.erdf];if nc &gt; 1 if n &gt; 1 str = sprintf('^&#123;%d \\\\&#123;Ha:k\\\\geq%d\\\\&#125;&#125;',nc,(nc-n)+1); else str = sprintf('^&#123;%d \\\\&#123;Ha:k=%d\\\\&#125;&#125;',nc,(nc-n)+1); endelse str = '';endswitch STAT case 'T' STATstr = sprintf('%c%s_&#123;%.0f&#125;','T',str,df(2)); case 'F' STATstr = sprintf('%c%s_&#123;%.0f,%.0f&#125;','F',str,df(1),df(2)); case 'P' STATstr = sprintf('%s^&#123;%0.2f&#125;','PPM',df(1));end%-Compute (unfiltered) SPM pointlist for masked conjunction requested%==========================================================================fprintf('\\t%-32s: %30s','SPM computation','...initialising') %-#%-Compute conjunction as minimum of SPMs%--------------------------------------------------------------------------Z = Inf;for i = Ic Z = min(Z,spm_get_data(xCon(i).Vspm,XYZ));end%-Copy of Z and XYZ before masking, for later use with FDR%--------------------------------------------------------------------------XYZum = XYZ;Zum = Z;%-Compute mask and eliminate masked voxels%--------------------------------------------------------------------------for i = 1:numel(Im) fprintf('%s%30s',repmat(sprintf('\\b'),1,30),'...masking') %-# if isnumeric(Im) Mask = spm_get_data(xCon(Im(i)).Vspm,XYZ); um = spm_u(pm,[xCon(Im(i)).eidf,xX.erdf],xCon(Im(i)).STAT); if Ex Q = Mask &lt;= um; else Q = Mask &gt; um; end else v = spm_vol(Im&#123;i&#125;); Mask = spm_get_data(v,v.mat\\SPM.xVol.M*[XYZ; ones(1,size(XYZ,2))]); Q = Mask ~= 0 &amp; ~isnan(Mask); if Ex, Q = ~Q; end end XYZ = XYZ(:,Q); Z = Z(Q); if isempty(Q) fprintf('\\n') %-# warning('SPM:NoVoxels','No voxels survive masking at p=%4.2f',pm); break endend%==========================================================================% - H E I G H T &amp; E X T E N T T H R E S H O L D S%==========================================================================u = -Inf; % height thresholdk = 0; % extent threshold &#123;voxels&#125;%-Get FDR mode%--------------------------------------------------------------------------try topoFDR = spm_get_defaults('stats.topoFDR');catch topoFDR = true;end%-Height threshold - classical inference%--------------------------------------------------------------------------if STAT ~= 'P' %-Get height threshold %---------------------------------------------------------------------- fprintf('%s%30s',repmat(sprintf('\\b'),1,30),'...height threshold') %-# try thresDesc = xSPM.thresDesc; catch if topoFDR str = 'FWE|none'; else str = 'FWE|FDR|none'; end thresDesc = InputthresDesc;%===p value adjustment to control: 'FWE' or 'none'==================================================================== end switch thresDesc case 'FWE' % Family-wise false positive rate %-------------------------------------------------------------- try u = xSPM.u; catch u = spm_input('p value (FWE)','+0','r',0.05,1,[0,1]); end thresDescDes = ['p&lt;' num2str(u) ' (' thresDesc ')']; u = spm_uc(u,df,STAT,R,n,S); case 'FDR' % False discovery rate %-------------------------------------------------------------- if topoFDR, fprintf('\\n'); %-# error('Change defaults.stats.topoFDR to use voxel FDR'); end try u = xSPM.u; catch u = spm_input('p value (FDR)','+0','r',0.05,1,[0,1]); end thresDescDes = ['p&lt;' num2str(u) ' (' thresDesc ')']; u = spm_uc_FDR(u,df,STAT,n,VspmSv,0); case 'none' % No adjustment: p for conjunctions is p of the conjunction SPM %-------------------------------------------------------------- try u = xSPM.u; catch u = Input_u; %threshold 默认0.001======================================================================== end if u &lt;= 1 thresDescDes = ['p&lt;' num2str(u) ' (unc.)']; u = spm_u(u^(1/n),df,STAT); else thresDescDes = [STAT '=' num2str(u) ]; end otherwise %-------------------------------------------------------------- fprintf('\\n'); %-# error('Unknown control method \"%s\".',thresDesc); end % switch thresDesc %-Compute p-values for topological and voxel-wise FDR (all search voxels) %---------------------------------------------------------------------- if ~topoFDR fprintf('%s%30s',repmat(sprintf('\\b'),1,30),'...for voxelFDR') %-# switch STAT case 'Z' Ps = (1-spm_Ncdf(Zum)).^n; case 'T' Ps = (1 - spm_Tcdf(Zum,df(2))).^n; case 'X' Ps = (1-spm_Xcdf(Zum,df(2))).^n; case 'F' Ps = (1 - spm_Fcdf(Zum,df)).^n; end Ps = sort(Ps); end %-Peak FDR %---------------------------------------------------------------------- [up,Pp] = spm_uc_peakFDR(0.05,df,STAT,R,n,Zum,XYZum,u); %-Cluster FDR %---------------------------------------------------------------------- if STAT == 'T' &amp;&amp; n == 1 V2R = 1/prod(SPM.xVol.FWHM(SPM.xVol.DIM &gt; 1)); [uc,Pc,ue] = spm_uc_clusterFDR(0.05,df,STAT,R,n,Zum,XYZum,V2R,u); else uc = NaN; ue = NaN; Pc = []; end %-Peak FWE %---------------------------------------------------------------------- uu = spm_uc(0.05,df,STAT,R,n,S); %-Height threshold - Bayesian inference%--------------------------------------------------------------------------elseif STAT == 'P' u_default = 1 - 1/SPM.xVol.S; str = 'Posterior probability threshold for PPM'; u = spm_input(str,'+0','r',u_default,1); thresDescDes = ['P&gt;' num2str(u) ' (PPM)']; end % (if STAT)%-Calculate height threshold filtering%--------------------------------------------------------------------------Q = find(Z &gt; u);%-Apply height threshold%--------------------------------------------------------------------------Z = Z(:,Q);XYZ = XYZ(:,Q);if isempty(Q) fprintf('\\n'); %-# warning('SPM:NoVoxels','No voxels survive height threshold at u=%0.2g',u);end%-Extent threshold%--------------------------------------------------------------------------if ~isempty(XYZ) fprintf('%s%30s',repmat(sprintf('\\b'),1,30),'...extent threshold'); %-# %-Get extent threshold [default = 0] %---------------------------------------------------------------------- try k = xSPM.k; catch k = Input_k; end %-Calculate extent threshold filtering %---------------------------------------------------------------------- A = spm_clusters(XYZ); Q = []; for i = 1:max(A) j = find(A == i); if length(j) &gt;= k, Q = [Q j]; end end % ...eliminate voxels %---------------------------------------------------------------------- Z = Z(:,Q); XYZ = XYZ(:,Q); if isempty(Q) fprintf('\\n'); %-# warning('SPM:NoVoxels','No voxels survive extent threshold at k=%0.2g',k); end else k = 0; end % (if ~isempty(XYZ))%-For Bayesian inference provide (default) option to display contrast values%--------------------------------------------------------------------------if STAT == 'P' if spm_input('Plot effect-size/statistic',1,'b',&#123;'Yes','No'&#125;,[1 0]) Z = spm_get_data(xCon(Ic).Vcon,XYZ); endend%==========================================================================% - E N D%==========================================================================fprintf('%s%30s\\n',repmat(sprintf('\\b'),1,30),'...done') %-#spm('Pointer','Arrow')%-Assemble output structures of unfiltered data%==========================================================================xSPM = struct( ... 'swd', swd,... 'title', titlestr,... 'Z', Z,... 'n', n,... 'STAT', STAT,... 'df', df,... 'STATstr', STATstr,... 'Ic', Ic,... 'Im', &#123;Im&#125;,... 'pm', pm,... 'Ex', Ex,... 'u', u,... 'k', k,... 'XYZ', XYZ,... 'XYZmm', SPM.xVol.M(1:3,:)*[XYZ; ones(1,size(XYZ,2))],... 'S', SPM.xVol.S,... 'R', SPM.xVol.R,... 'FWHM', SPM.xVol.FWHM,... 'M', SPM.xVol.M,... 'iM', SPM.xVol.iM,... 'DIM', SPM.xVol.DIM,... 'VOX', VOX,... 'Vspm', VspmSv,... 'thresDesc',thresDesc);%-RESELS per voxel (density) if it exists%--------------------------------------------------------------------------try, xSPM.VRpv = SPM.xVol.VRpv; endtry xSPM.units = SPM.xVol.units;catch try, xSPM.units = varargin&#123;1&#125;.units; endend%-p-values for topological and voxel-wise FDR%--------------------------------------------------------------------------try, xSPM.Ps = Ps; end % voxel FDRtry, xSPM.Pp = Pp; end % peak FDRtry, xSPM.Pc = Pc; end % cluster FDR%-0.05 critical thresholds for FWEp, FDRp, FWEc, FDRc%--------------------------------------------------------------------------try, xSPM.uc = [uu up ue uc]; end spm_regions_extend.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229function [Y,xY] = spm_regions_extend(xSPM,SPM,hReg,xY,Input_VOINames,Input_is,Input_VOI_path)% VOI time-series extraction of adjusted data (&amp; local eigenimage analysis)% FORMAT [Y xY] = spm_regions(xSPM,SPM,hReg,[xY]);% FORMAT [Y xY] = spm_regions(xSPM,SPM,hReg,[xY],Input_VOIName,Input_i)% Input_VOIName : 抽取的VOI的名称% Input_i : adjust_contrst 这里选择那个F-All的,整数，1 是dont adjust, 2 是F-All.% Input_VOI_path : 抽取VOI所使用的Mask的路径;if nargin &lt; 4, xY = []; endif nargin &gt; 5 Input_VOIName = Input_VOINames; Input_i =Input_is; xY = []; end%-Get figure handles%--------------------------------------------------------------------------Finter = spm_figure('FindWin','Interactive');if isempty(Finter), noGraph = 1; else noGraph = 0; endheader = get(Finter,'Name');set(Finter,'Name','VOI time-series extraction');if ~noGraph, Fgraph = spm_figure('GetWin','Graphics'); end%-Find nearest voxel [Euclidean distance] in point list%--------------------------------------------------------------------------if isempty(xSPM.XYZmm) spm('alert!','No suprathreshold voxels!',mfilename,0); Y = []; xY = []; returnendtry xyz = xY.xyz;catch xyz = spm_XYZreg('NearestXYZ',... spm_XYZreg('GetCoords',hReg),xSPM.XYZmm); xY.xyz = xyz;end% and update GUI location%--------------------------------------------------------------------------spm_XYZreg('SetCoords',xyz,hReg);%-Get adjustment options and VOI name%--------------------------------------------------------------------------if ~noGraph if ~isempty(xY.xyz) posstr = sprintf('at [%3.0f %3.0f %3.0f]',xY.xyz); else posstr = ''; end spm_input(posstr,1,'d','VOI time-series extraction');endif ~isfield(xY,'name') xY.name = Input_VOIName; %name of region char字符串类型 ========================================================================endif ~isfield(xY,'Ic') q = 0; Con = &#123;'&lt;don''t adjust&gt;'&#125;; for i = 1:length(SPM.xCon) if strcmp(SPM.xCon(i).STAT,'F') q(end + 1) = i; Con&#123;end + 1&#125; = SPM.xCon(i).name; end end i = Input_i; % adjust_contrst 这里选择那个F-All的,整数，1 是dont adjust, 2 是F-All. ===================================================================== xY.Ic = q(i);end%-If fMRI data then ask user to select session%--------------------------------------------------------------------------if isfield(SPM,'Sess') &amp;&amp; ~isfield(xY,'Sess') s = length(SPM.Sess); if s &gt; 1 s = spm_input('which session','!+1','n1',s,s); end xY.Sess = s;end%-Specify VOI%--------------------------------------------------------------------------xY.M = xSPM.M;[xY, xY.XYZmm, Q] = spm_ROI_extend(xY, xSPM.XYZmm,Input_VOI_path);%--------------------------------------------------------------------try, xY = rmfield(xY,'M'); endtry, xY = rmfield(xY,'rej'); endif isempty(xY.XYZmm) warning('Empty region.'); Y = []; return;end%-Extract required data from results files%==========================================================================spm('Pointer','Watch')%-Get raw data, whiten and filter %--------------------------------------------------------------------------y = spm_get_data(SPM.xY.VY,xSPM.XYZ(:,Q));y = spm_filter(SPM.xX.K,SPM.xX.W*y);%-Computation%==========================================================================%-Remove null space of contrast%--------------------------------------------------------------------------if xY.Ic %-Parameter estimates: beta = xX.pKX*xX.K*y %---------------------------------------------------------------------- beta = spm_get_data(SPM.Vbeta,xSPM.XYZ(:,Q)); %-subtract Y0 = XO*beta, Y = Yc + Y0 + e %---------------------------------------------------------------------- y = y - spm_FcUtil('Y0',SPM.xCon(xY.Ic),SPM.xX.xKXs,beta);end%-Confounds%--------------------------------------------------------------------------xY.X0 = SPM.xX.xKXs.X(:,[SPM.xX.iB SPM.xX.iG]);%-Extract session-specific rows from data and confounds%--------------------------------------------------------------------------try i = SPM.Sess(xY.Sess).row; y = y(i,:); xY.X0 = xY.X0(i,:);end% and add session-specific filter confounds%--------------------------------------------------------------------------try xY.X0 = [xY.X0 SPM.xX.K(xY.Sess).X0];endtry xY.X0 = [xY.X0 SPM.xX.K(xY.Sess).KH]; % Compatibility checkend%-Remove null space of X0%--------------------------------------------------------------------------xY.X0 = xY.X0(:,any(xY.X0));%-Compute regional response in terms of first eigenvariate%--------------------------------------------------------------------------[m n] = size(y);if m &gt; n [v s v] = svd(y'*y); s = diag(s); v = v(:,1); u = y*v/sqrt(s(1));else [u s u] = svd(y*y'); s = diag(s); u = u(:,1); v = y'*u/sqrt(s(1));endd = sign(sum(v));u = u*d;v = v*d;Y = u*sqrt(s(1)/n);%-Set in structure%--------------------------------------------------------------------------xY.y = y;xY.u = Y;xY.v = v;xY.s = s;%-Display VOI weighting and eigenvariate%==========================================================================if ~noGraph % show position %---------------------------------------------------------------------- spm_results_ui('Clear',Fgraph); figure(Fgraph); subplot(2,2,3) spm_dcm_display(xY) % show dynamics %---------------------------------------------------------------------- subplot(2,2,4) try plot(SPM.xY.RT*[1:length(xY.u)],Y) str = 'time (seconds&#125;'; catch plot(Y) str = 'scan'; end title(['1st eigenvariate: ' xY.name],'FontSize',10) if strcmpi(xY.def,'mask') [p,n,e] = fileparts(xY.spec.fname); posstr = sprintf('from mask %s', [n e]); else posstr = sprintf('at [%3.0f %3.0f %3.0f]',xY.xyz); end str = &#123; str;' ';... sprintf('%d voxels in VOI %s',length(Q),posstr);... sprintf('Variance: %0.2f%%',s(1)*100/sum(s))&#125;; xlabel(str) axis tight squareend%-Save%==========================================================================str = ['VOI_' xY.name '.mat'];if isfield(xY,'Sess') &amp;&amp; isfield(SPM,'Sess') str = sprintf('VOI_%s_%i.mat',xY.name,xY.Sess);endif spm_check_version('matlab','7') &gt;= 0 save(fullfile(SPM.swd,str),'-V6','Y','xY')else save(fullfile(SPM.swd,str),'Y','xY')endfprintf(' VOI saved as %s\\n',spm_str_manip(fullfile(SPM.swd,str),'k55'));%-Reset title%--------------------------------------------------------------------------set(Finter,'Name',header);spm('Pointer','Arrow') spm_result_ui_extend.m 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073function varargout = spm_result_ui_extend(varargin)% FORMAT [hreg,xSPM,SPM] = spm_results_ui('Setup')% Query SPM and setup GUI. %% FORMAT [hreg,xSPM,SPM] = spm_results_ui('Setup',xSPM)% Query SPM and setup GUI using a xSPM input structure. This allows to run% results setup without user interaction. See spm_getSPM for details of% allowed fields.%% FORMAT hReg = spm_results_ui('SetupGUI',M,DIM,xSPM,Finter)% Setup results GUI in Interactive window% M - 4x4 transformation matrix relating voxel to \"real\" co-ordinates% DIM - 3 vector of image X, Y &amp; Z dimensions% xSPM - structure containing xSPM. Required fields are:% .Z - minimum of n Statistics &#123;filtered on u and k&#125;% .XYZmm - location of voxels &#123;mm&#125;% Finter - handle (or 'Tag') of Interactive window (default 'Interactive')% hReg - handle of XYZ registry object%% FORMAT spm_results_ui('DrawButts',hReg,DIM,Finter,WS,FS)% Draw GUI buttons% hReg - handle of XYZ registry object% DIM - 3 vector of image X, Y &amp; Z dimensions% Finter - handle of Interactive window% WS - WinScale [Default spm('WinScale') ]% FS - FontSizes [Default spm('FontSizes')]%% FORMAT hFxyz = spm_results_ui('DrawXYZgui',M,DIM,xSPM,xyz,Finter)% Setup editable XYZ control widgets at foot of Interactive window% M - 4x4 transformation matrix relating voxel to \"real\" co-ordinates% DIM - 3 vector of image X, Y &amp; Z dimensions% xSPM - structure containing SPM; Required fields are:% .Z - minimum of n Statistics &#123;filtered on u and k&#125;% .XYZmm - location of voxels &#123;mm&#125;% xyz - Initial xyz location &#123;mm&#125;% Finter - handle of Interactive window% hFxyz - handle of XYZ control - the frame containing the edit widgets%% FORMAT spm_results_ui('EdWidCB')% Callback for editable XYZ control widgets%% FORMAT spm_results_ui('UpdateSPMval',hFxyz)% FORMAT spm_results_ui('UpdateSPMval',UD)% Updates SPM value string in Results GUI (using data from UserData of hFxyz)% hFxyz - handle of frame enclosing widgets - the Tag object for this control% UD - XYZ data structure (UserData of hFxyz).%% FORMAT xyz = spm_results_ui('GetCoords',hFxyz)% Get current co-ordinates from editable XYZ control% hFxyz - handle of frame enclosing widgets - the Tag object for this control% xyz - current co-ordinates &#123;mm&#125;% NB: When using the results section, should use XYZregistry to get/set location%% FORMAT [xyz,d] = spm_results_ui('SetCoords',xyz,hFxyz,hC)% Set co-ordinates to XYZ widget% xyz - (Input) desired co-ordinates &#123;mm&#125;% hFxyz - handle of XYZ control - the frame containing the edit widgets% hC - handle of calling object, if used as a callback. [Default 0]% xyz - (Output) Desired co-ordinates are rounded to nearest voxel if hC% is not specified, or is zero. Otherwise, caller is assumed to% have checked verity of desired xyz co-ordinates. Output xyz returns% co-ordinates actually set &#123;mm&#125;.% d - Euclidean distance between desired and set co-ordinates.% NB: When using the results section, should use XYZregistry to get/set location%% FORMAT hFxyz = spm_results_ui('FindXYZframe',h)% Find/check XYZ edit widgets frame handle, 'Tag'ged 'hFxyz'% h - handle of frame enclosing widgets, or containing figure [default gcf]% If ischar(h), then uses spm_figure('FindWin',h) to locate named figures% hFxyz - handle of confirmed XYZ editable widgets control% Errors if hFxyz is not an XYZ widget control, or a figure containing% a unique such control%% FORMAT spm_results_ui('PlotUi',hAx)% GUI for adjusting plot attributes - Sets up controls just above results GUI% hAx - handle of axes to work with%% FORMAT spm_results_ui('PlotUiCB')% CallBack handler for Plot attribute GUI%% FORMAT Fgraph = spm_results_ui('Clear',F,mode)% Clears results subpane of Graphics window, deleting all but semi-permanent% results section stuff% F - handle of Graphics window [Default spm_figure('FindWin','Graphics')]% mode - 1 [default] - clear results subpane% - 0 - clear results subpane and hide results stuff% - 2 - clear, but respect 'NextPlot' 'add' axes% (which is set by `hold on`)% Fgraph - handle of Graphics window%% FORMAT hMP = spm_results_ui('LaunchMP',M,DIM,hReg,hBmp)% Prototype callback handler for integrating MultiPlanar toolbox%% FORMAT spm_results_ui('Delete',h)% deletes HandleGraphics objects, but only if they're valid, thus avoiding% warning statements from MATLAB.%__________________________________________________________________________ SVNid = '$Rev: 4209 $'; %-Condition arguments%--------------------------------------------------------------------------if nargin == 0, Action='SetUp'; else Action=varargin&#123;1&#125;; end %==========================================================================switch lower(Action), case 'setup' %-Set up results%========================================================================== %-Initialise %---------------------------------------------------------------------- SPMid = spm('FnBanner',mfilename,SVNid); [Finter,Fgraph,CmdLine] = spm('FnUIsetup','Stats: Results'); spm_clf('Satellite') FS = spm('FontSizes'); %-Get thresholded xSPM data and parameters of design %====================================================================== if nargin &gt; 1 [SPM,xSPM] = spm_getSPM_extend(varargin&#123;2&#125;); else [SPM,xSPM] = spm_getSPM; end if isempty(xSPM) varargout = &#123;[],[],[]&#125;; return; end %-Ensure pwd = swd so that relative filenames are valid %---------------------------------------------------------------------- cd(SPM.swd) %-Get space information %====================================================================== M = SPM.xVol.M; DIM = SPM.xVol.DIM; %-Space units %---------------------------------------------------------------------- try try units = SPM.xVol.units; catch units = xSPM.units; end catch try if strcmp(spm('CheckModality'),'EEG') datatype = &#123;... 'Volumetric (2D/3D)',... 'Scalp-Time',... 'Scalp-Frequency',... 'Time-Frequency',... 'Frequency-Frequency'&#125;; selected = spm_input('Data Type: ','+1','m',datatype); datatype = datatype&#123;selected&#125;; else datatype = 'Volumetric (2D/3D)'; end catch datatype = 'Volumetric (2D/3D)'; end switch datatype case 'Volumetric (2D/3D)' units = &#123;'mm' 'mm' 'mm'&#125;; case 'Scalp-Time' units = &#123;'mm' 'mm' 'ms'&#125;; case 'Scalp-Frequency' units = &#123;'mm' 'mm' 'Hz'&#125;; case 'Time-Frequency' units = &#123;'Hz' 'ms' ''&#125;; case 'Frequency-Frequency' units = &#123;'Hz' 'Hz' ''&#125;; otherwise error('Unknown data type.'); end end if DIM(3) == 1, units&#123;3&#125; = ''; end xSPM.units = units; SPM.xVol.units = units; %-Setup Results User Interface; Display MIP, design matrix &amp; parameters %====================================================================== %-Setup results GUI %---------------------------------------------------------------------- spm_clf(Finter); spm('FigName',['SPM&#123;',xSPM.STAT,'&#125;: Results'],Finter,CmdLine); hReg = spm_results_ui('SetupGUI',M,DIM,xSPM,Finter); %-Setup design interrogation menu %---------------------------------------------------------------------- hDesRepUI = spm_DesRep('DesRepUI',SPM); figure(Finter) %-Setup contrast menu %---------------------------------------------------------------------- hC = uimenu(Finter,'Label','Contrasts', 'Tag','ContrastsUI'); hC1 = uimenu(hC,'Label','New Contrast...',... 'UserData',struct('Ic',0),... 'Callback',&#123;@mychgcon,xSPM&#125;); hC1 = uimenu(hC,'Label','Change Contrast'); for i=1:numel(SPM.xCon) hC2 = uimenu(hC1,'Label',[SPM.xCon(i).STAT, ': ', SPM.xCon(i).name], ... 'UserData',struct('Ic',i),... 'Callback',&#123;@mychgcon,xSPM&#125;); if any(xSPM.Ic == i) set(hC2,'ForegroundColor',[0 0 1],'Checked','on'); end end hC1 = uimenu(hC,'Label','Previous Contrast',... 'Accelerator','P',... 'UserData',struct('Ic',xSPM.Ic-1),... 'Callback',&#123;@mychgcon,xSPM&#125;); if xSPM.Ic-1&lt;1, set(hC1,'Enable','off'); end hC1 = uimenu(hC,'Label','Next Contrast',... 'Accelerator','N',... 'UserData',struct('Ic',xSPM.Ic+1),... 'Callback',&#123;@mychgcon,xSPM&#125;); if xSPM.Ic+1&gt;numel(SPM.xCon), set(hC1,'Enable','off'); end hC1 = uimenu(hC,'Label','Significance level','Separator','on'); xSPMtmp = xSPM; xSPMtmp.thresDesc = ''; uimenu(hC1,'Label','Change...','UserData',struct('Ic',xSPM.Ic),... 'Callback',&#123;@mychgcon,xSPMtmp&#125;); xSPMtmp = xSPM; xSPMtmp.thresDesc = 'p&lt;0.05 (FWE)'; uimenu(hC1,'Label','Set to 0.05 (FWE)','UserData',struct('Ic',xSPM.Ic),... 'Callback',&#123;@mychgcon,xSPMtmp&#125;); xSPMtmp = xSPM; xSPMtmp.thresDesc = 'p&lt;0.001 (unc.)'; uimenu(hC1,'Label','Set to 0.001 (unc.)','UserData',struct('Ic',xSPM.Ic),... 'Callback',&#123;@mychgcon,xSPMtmp&#125;); uimenu(hC1,'Label',[xSPM.thresDesc ', k=' num2str(xSPM.k)],... 'Enable','off','Separator','on'); %-Setup Maximum intensity projection (MIP) &amp; register %---------------------------------------------------------------------- hMIPax = axes('Parent',Fgraph,'Position',[0.05 0.60 0.55 0.36],'Visible','off'); hMIPax = spm_mip_ui(xSPM.Z,xSPM.XYZmm,M,DIM,hMIPax,units); spm_XYZreg('XReg',hReg,hMIPax,'spm_mip_ui'); if xSPM.STAT == 'P' str = xSPM.STATstr; else str = ['SPM\\&#123;',xSPM.STATstr,'\\&#125;']; end text(240,260,str,... 'Interpreter','TeX',... 'FontSize',FS(14),'Fontweight','Bold',... 'Parent',hMIPax) %-Print comparison title %---------------------------------------------------------------------- hTitAx = axes('Parent',Fgraph,... 'Position',[0.02 0.95 0.96 0.02],... 'Visible','off'); text(0.5,0,xSPM.title,'Parent',hTitAx,... 'HorizontalAlignment','center',... 'VerticalAlignment','baseline',... 'FontWeight','Bold','FontSize',FS(14)) %-Print SPMresults: Results directory &amp; thresholding info %---------------------------------------------------------------------- hResAx = axes('Parent',Fgraph,... 'Position',[0.05 0.55 0.45 0.05],... 'DefaultTextVerticalAlignment','baseline',... 'DefaultTextFontSize',FS(9),... 'DefaultTextColor',[1,1,1]*.7,... 'Units','points',... 'Visible','off'); AxPos = get(hResAx,'Position'); set(hResAx,'YLim',[0,AxPos(4)]) h = text(0,24,'SPMresults:','Parent',hResAx,... 'FontWeight','Bold','FontSize',FS(14)); text(get(h,'Extent')*[0;0;1;0],24,spm_str_manip(SPM.swd,'a30'),'Parent',hResAx) try thresDesc = xSPM.thresDesc; text(0,12,sprintf('Height threshold %c = %0.6f &#123;%s&#125;',xSPM.STAT,xSPM.u,thresDesc),'Parent',hResAx) catch text(0,12,sprintf('Height threshold %c = %0.6f',xSPM.STAT,xSPM.u),'Parent',hResAx) end text(0,00,sprintf('Extent threshold k = %0.0f voxels',xSPM.k), 'Parent',hResAx) %-Plot design matrix %---------------------------------------------------------------------- hDesMtx = axes('Parent',Fgraph,'Position',[0.65 0.55 0.25 0.25]); hDesMtxIm = image((SPM.xX.nKX + 1)*32); xlabel('Design matrix') set(hDesMtxIm,'ButtonDownFcn','spm_DesRep(''SurfDesMtx_CB'')',... 'UserData',struct(... 'X', SPM.xX.xKXs.X,... 'fnames', &#123;reshape(&#123;SPM.xY.VY.fname&#125;,size(SPM.xY.VY))&#125;,... 'Xnames', &#123;SPM.xX.name&#125;)) %-Plot contrasts %---------------------------------------------------------------------- nPar = size(SPM.xX.X,2); xx = [repmat([0:nPar-1],2,1);repmat([1:nPar],2,1)]; nCon = length(xSPM.Ic); xCon = SPM.xCon; if nCon dy = 0.15/max(nCon,2); hConAx = axes('Position',[0.65 (0.80 + dy*.1) 0.25 dy*(nCon-.1)],... 'Tag','ConGrphAx','Visible','off'); title('contrast(s)') htxt = get(hConAx,'title'); set(htxt,'Visible','on','HandleVisibility','on') end for ii = nCon:-1:1 axes('Position',[0.65 (0.80 + dy*(nCon - ii +.1)) 0.25 dy*.9]) if xCon(xSPM.Ic(ii)).STAT == 'T' &amp;&amp; size(xCon(xSPM.Ic(ii)).c,2) == 1 %-Single vector contrast for SPM&#123;t&#125; - bar %-------------------------------------------------------------- yy = [zeros(1,nPar);repmat(xCon(xSPM.Ic(ii)).c',2,1);zeros(1,nPar)]; h = patch(xx,yy,[1,1,1]*.5); set(gca,'Tag','ConGrphAx',... 'Box','off','TickDir','out',... 'XTick',spm_DesRep('ScanTick',nPar,10) - 0.5,'XTickLabel','',... 'XLim', [0,nPar],... 'YTick',[-1,0,+1],'YTickLabel','',... 'YLim',[min(xCon(xSPM.Ic(ii)).c),max(xCon(xSPM.Ic(ii)).c)] +... [-1 +1] * max(abs(xCon(xSPM.Ic(ii)).c))/10 ) else %-F-contrast - image %-------------------------------------------------------------- h = image((xCon(xSPM.Ic(ii)).c'/max(abs(xCon(xSPM.Ic(ii)).c(:)))+1)*32); set(gca,'Tag','ConGrphAx',... 'Box','on','TickDir','out',... 'XTick',spm_DesRep('ScanTick',nPar,10),'XTickLabel','',... 'XLim', [0,nPar]+0.5,... 'YTick',[0:size(SPM.xCon(xSPM.Ic(ii)).c,2)]+0.5,... 'YTickLabel','',... 'YLim', [0,size(xCon(xSPM.Ic(ii)).c,2)]+0.5 ) end ylabel(num2str(xSPM.Ic(ii))) set(h,'ButtonDownFcn','spm_DesRep(''SurfCon_CB'')',... 'UserData', struct( 'i', xSPM.Ic(ii),... 'h', htxt,... 'xCon', xCon(xSPM.Ic(ii)))) end %-Store handles of results section Graphics window objects %---------------------------------------------------------------------- H = get(Fgraph,'Children'); H = findobj(H,'flat','HandleVisibility','on'); H = findobj(H); Hv = get(H,'Visible'); set(hResAx,'Tag','PermRes','UserData',struct('H',H,'Hv',&#123;Hv&#125;)) %-Finished results setup %---------------------------------------------------------------------- varargout = &#123;hReg,xSPM,SPM&#125;; spm('Pointer','Arrow') %====================================================================== case 'setupgui' %-Set up results section GUI %====================================================================== % hReg = spm_results_ui('SetupGUI',M,DIM,xSPM,Finter) if nargin &lt; 5, Finter='Interactive'; else Finter = varargin&#123;5&#125;; end if nargin &lt; 4, error('Insufficient arguments'), end M = varargin&#123;2&#125;; DIM = varargin&#123;3&#125;; Finter = spm_figure('GetWin',Finter); WS = spm('WinScale'); FS = spm('FontSizes'); %-Create frame for Results GUI objects %------------------------------------------------------------------ hReg = uicontrol(Finter,'Style','Frame','Position',[001 001 400 190].*WS,... 'BackgroundColor',spm('Colour')); hFResUi = uicontrol(Finter,... 'Style','Pushbutton',... 'enable','off',... 'Position',[008 007 387 178].*WS); %-Initialise registry in hReg frame object %------------------------------------------------------------------ [hReg,xyz] = spm_XYZreg('InitReg',hReg,M,DIM,[0;0;0]); %-Setup editable XYZ widgets &amp; cross register with registry %------------------------------------------------------------------ hFxyz = spm_results_ui('DrawXYZgui',M,DIM,varargin&#123;4&#125;,xyz,Finter); spm_XYZreg('XReg',hReg,hFxyz,'spm_results_ui'); %-Set up buttons for results functions %------------------------------------------------------------------ spm_results_ui('DrawButts',hReg,DIM,Finter,WS,FS); varargout = &#123;hReg&#125;; %====================================================================== case 'drawbutts' %-Draw results section buttons in Interactive window %====================================================================== % spm_results_ui('DrawButts',hReg,DIM,Finter,WS,FS) % if nargin&lt;3, error('Insufficient arguments'), end hReg = varargin&#123;2&#125;; DIM = varargin&#123;3&#125;; if nargin&lt;4, Finter = spm_figure('FindWin','Interactive'); else Finter = varargin&#123;4&#125;; end if nargin &lt; 5, WS = spm('WinScale'); else WS = varargin&#123;5&#125;; end if nargin &lt; 6, FS = spm('FontSizes'); else FS = varargin&#123;6&#125;; end %-p-values %------------------------------------------------------------------ uicontrol(Finter,'Style','Text','String','p-values',... 'Position',[020 168 080 015].*WS,... 'FontAngle','Italic',... 'FontSize',FS(10),... 'HorizontalAlignment','Left',... 'ForegroundColor','w') uicontrol(Finter,'Style','PushButton','String','whole brain','FontSize',FS(10),... 'ToolTipString',... 'tabulate summary of local maxima, p-values &amp; statistics',... 'Callback','spm_list(''List'',xSPM,hReg);',... 'Interruptible','on','Enable','on',... 'Position',[015 145 100 020].*WS) uicontrol(Finter,'Style','PushButton','String','current cluster','FontSize',FS(10),... 'ToolTipString',... 'tabulate p-values &amp; statistics for local maxima of nearest cluster',... 'Callback','spm_list(''ListCluster'',xSPM,hReg);',... 'Interruptible','on','Enable','on',... 'Position',[015 120 100 020].*WS) uicontrol(Finter,'Style','PushButton','String','small volume','FontSize',FS(10),... 'ToolTipString',['Small Volume Correction - corrected p-values ',... 'for a small search region'],... 'Callback','spm_VOI(SPM,xSPM,hReg);',... 'Interruptible','on','Enable','on',... 'Position',[015 095 100 020].*WS) %-SPM area - used for Volume of Interest analyses %------------------------------------------------------------------ uicontrol(Finter,'Style','Text','String','Multivariate',... 'Position',[135 168 80 015].*WS,... 'FontAngle','Italic',... 'FontSize',FS(10),... 'HorizontalAlignment','Left',... 'ForegroundColor','w') uicontrol(Finter,'Style','PushButton','String','eigenvariate',... 'Position',[130 145 70 020].*WS,... 'ToolTipString',... 'Responses (principal eigenvariate) in volume of interest',... 'Callback','[Y,xY] = spm_regions(xSPM,SPM,hReg)',... 'Interruptible','on','Enable','on',... 'FontSize',FS(10),'ForegroundColor',[1 1 1]/3) uicontrol(Finter,'Style','PushButton','String','CVA',... 'Position',[205 145 65 020].*WS,... 'ToolTipString',... 'Canonical variates analysis for the current contrast and VOI',... 'Callback','CVA = spm_cva(xSPM,SPM,hReg)',... 'Interruptible','on','Enable','on',... 'FontSize',FS(10),'ForegroundColor',[1 1 1]/3) uicontrol(Finter,'Style','PushButton','String','multivariate Bayes',... 'Position',[130 120 140 020].*WS,... 'ToolTipString',... 'Multivariate Bayes',... 'Callback','[MVB] = spm_mvb_ui(xSPM,SPM,hReg)',... 'Interruptible','on','Enable','on',... 'FontSize',FS(10),'ForegroundColor',[1 1 1]/3) uicontrol(Finter,'Style','PushButton','String','BMS',... 'Position',[130 95 68 020].*WS,... 'ToolTipString',... 'Compare or review a multivariate Bayesian model',... 'Callback','[F,P] = spm_mvb_bmc',... 'Interruptible','on','Enable','on',... 'FontSize',FS(8),'ForegroundColor',[1 1 1]/3) uicontrol(Finter,'Style','PushButton','String','p-value',... 'Position',[202 95 68 020].*WS,... 'ToolTipString',... 'Randomisation testing of a multivariate Bayesian model',... 'Callback','spm_mvb_p',... 'Interruptible','on','Enable','on',... 'FontSize',FS(8),'ForegroundColor',[1 1 1]/3) %-Hemodynamic modelling %------------------------------------------------------------------ if strcmp(spm('CheckModality'),'FMRI') uicontrol(Finter,'Style','PushButton','String','Hemodynamics',... 'FontSize',FS(10),... 'ToolTipString','Hemodynamic modelling of regional response',... 'Callback','[Ep,Cp,K1,K2] = spm_hdm_ui(xSPM,SPM,hReg);',... 'Interruptible','on','Enable','on',... 'Position',[130 055 140 020].*WS,... 'ForegroundColor',[1 1 1]/3); end %-Not currently used %------------------------------------------------------------------ %uicontrol(Finter,'Style','PushButton','String','','FontSize',FS(10),... % 'ToolTipString','',... % 'Callback','',... % 'Interruptible','on','Enable','on',... % 'Position',[015 055 100 020].*WS) %-Visualisation %------------------------------------------------------------------ uicontrol(Finter,'Style','Text','String','Display',... 'Position',[290 168 065 015].*WS,... 'FontAngle','Italic',... 'FontSize',FS(10),... 'HorizontalAlignment','Left',... 'ForegroundColor','w') uicontrol(Finter,'Style','PushButton','String','plot','FontSize',FS(10),... 'ToolTipString','plot data &amp; contrasts at current voxel',... 'Callback','[Y,y,beta,Bcov] = spm_graph(xSPM,SPM,hReg);',... 'Interruptible','on','Enable','on',... 'Position',[285 145 100 020].*WS,... 'Tag','plotButton') str = &#123; 'overlays...','slices','sections','render','previous sections','previous render'&#125;; tstr = &#123; 'overlay filtered SPM on another image: ',... '3 slices / ','ortho sections / ','render /','previous ortho sections /','previous surface rendering'&#125;; tmp = &#123; 'spm_transverse(''set'',xSPM,hReg)',... 'spm_sections(xSPM,hReg)',... ['spm_render( struct( ''XYZ'', xSPM.XYZ,',... '''t'', xSPM.Z'',',... '''mat'', xSPM.M,',... '''dim'', xSPM.DIM))'],... ['global prevsect;','spm_sections(xSPM,hReg,prevsect)'],... ['global prevrend;','if ~isstruct(prevrend)',... 'prevrend = struct(''rendfile'','''',''brt'',[],''col'',[]); end;',... 'spm_render( struct( ''XYZ'', xSPM.XYZ,',... '''t'', xSPM.Z'',',... '''mat'', xSPM.M,',... '''dim'', xSPM.DIM),prevrend.brt,prevrend.rendfile)']&#125;; uicontrol(Finter,'Style','PopUp','String',str,'FontSize',FS(10),... 'ToolTipString',cat(2,tstr&#123;:&#125;),... 'Callback','spm(''PopUpCB'',gcbo)',... 'UserData',tmp,... 'Interruptible','on','Enable','on',... 'Position',[285 120 100 020].*WS) uicontrol(Finter,'Style','PushButton','String','save','FontSize',FS(10),... 'ToolTipString','save thresholded SPM as image',... 'Callback',['spm_write_filtered(xSPM.Z,xSPM.XYZ,xSPM.DIM,xSPM.M,',... 'sprintf(''SPM&#123;%c&#125;-filtered: u = %5.3f, k = %d'',',... 'xSPM.STAT,xSPM.u,xSPM.k));'],... 'Interruptible','on','Enable','on',... 'Position',[285 095 100 020].*WS) %-ResultsUI controls %------------------------------------------------------------------ hClear = uicontrol(Finter,'Style','PushButton','String','clear',... 'ToolTipString','clears results subpane',... 'FontSize',FS(9),'ForegroundColor','b',... 'Callback',['spm_results_ui(''Clear''); ',... 'spm_input(''!DeleteInputObj''),',... 'spm_clf(''Satellite'')'],... 'Interruptible','on','Enable','on',... 'DeleteFcn','spm_clf(''Graphics'')',... 'Position',[285 055 035 018].*WS); hExit = uicontrol(Finter,'Style','PushButton','String','exit',... 'ToolTipString','exit the results section',... 'FontSize',FS(9),'ForegroundColor','r',... 'Callback','spm_results_ui(''close'')',... 'Interruptible','on','Enable','on',... 'Position',[325 055 035 018].*WS); hHelp = uicontrol(Finter,'Style','PushButton','String','?',... 'ToolTipString','results section help',... 'FontSize',FS(9),'ForegroundColor','g',... 'Callback','spm_help(''spm_results_ui'')',... 'Interruptible','on','Enable','on',... 'Position',[365 055 020 018].*WS); %====================================================================== case 'drawxyzgui' %-Draw XYZ GUI area %====================================================================== % hFxyz = spm_results_ui('DrawXYZgui',M,DIM,xSPM,xyz,Finter) if nargin&lt;6, Finter=spm_figure('FindWin','Interactive'); else Finter=varargin&#123;6&#125;; end if nargin &lt; 5, xyz=[0;0;0]; else xyz=varargin&#123;5&#125;; end if nargin &lt; 4, error('Insufficient arguments'), end DIM = varargin&#123;3&#125;; M = varargin&#123;2&#125;; xyz = spm_XYZreg('RoundCoords',xyz,M,DIM); %-Font details %------------------------------------------------------------------ WS = spm('WinScale'); FS = spm('FontSizes'); PF = spm_platform('fonts'); %-Create XYZ control objects %------------------------------------------------------------------ hFxyz = uicontrol(Finter,'Style','Pushbutton',... 'visible','off','enable','off','Position',[010 010 265 030].*WS); uicontrol(Finter,'Style','Text','String','co-ordinates',... 'Position',[020 035 090 016].*WS,... 'FontAngle','Italic',... 'FontSize',FS(10),... 'HorizontalAlignment','Left',... 'ForegroundColor','w') uicontrol(Finter,'Style','Text','String','x =',... 'Position',[020 015 024 018].*WS,... 'FontName',PF.times,'FontSize',FS(10),'FontAngle','Italic',... 'HorizontalAlignment','Center'); hX = uicontrol(Finter,'Style','Edit','String',sprintf('%.2f',xyz(1)),... 'ToolTipString','enter x-coordinate',... 'Position',[044 015 056 020].*WS,... 'FontSize',FS(10),'BackGroundColor',[.8,.8,1],... 'HorizontalAlignment','Right',... 'Tag','hX',... 'Callback','spm_results_ui(''EdWidCB'')'); uicontrol(Finter,'Style','Text','String','y =',... 'Position',[105 015 024 018].*WS,... 'FontName',PF.times,'FontSize',FS(10),'FontAngle','Italic',... 'HorizontalAlignment','Center') hY = uicontrol(Finter,'Style','Edit','String',sprintf('%.2f',xyz(2)),... 'ToolTipString','enter y-coordinate',... 'Position',[129 015 056 020].*WS,... 'FontSize',FS(10),'BackGroundColor',[.8,.8,1],... 'HorizontalAlignment','Right',... 'Tag','hY',... 'Callback','spm_results_ui(''EdWidCB'')'); if DIM(3) ~= 1 uicontrol(Finter,'Style','Text','String','z =',... 'Position',[190 015 024 018].*WS,... 'FontName',PF.times,'FontSize',FS(10),'FontAngle','Italic',... 'HorizontalAlignment','Center') hZ = uicontrol(Finter,'Style','Edit','String',sprintf('%.2f',xyz(3)),... 'ToolTipString','enter z-coordinate',... 'Position',[214 015 056 020].*WS,... 'FontSize',FS(10),'BackGroundColor',[.8,.8,1],... 'HorizontalAlignment','Right',... 'Tag','hZ',... 'Callback','spm_results_ui(''EdWidCB'')'); else hZ = []; end %-Statistic value reporting pane %------------------------------------------------------------------ uicontrol(Finter,'Style','Text','String','statistic',... 'Position',[285 035 090 016].*WS,... 'FontAngle','Italic',... 'FontSize',FS(10),... 'HorizontalAlignment','Left',... 'ForegroundColor','w') hSPM = uicontrol(Finter,'Style','Text','String','',... 'Position',[285 012 100 020].*WS,... 'FontSize',FS(10),... 'HorizontalAlignment','Center'); %-Store data %------------------------------------------------------------------ set(hFxyz,'Tag','hFxyz','UserData',struct(... 'hReg', [],... 'M', M,... 'DIM', DIM,... 'XYZ', varargin&#123;4&#125;.XYZmm,... 'Z', varargin&#123;4&#125;.Z,... 'hX', hX,... 'hY', hY,... 'hZ', hZ,... 'hSPM', hSPM,... 'xyz', xyz )); set([hX,hY,hZ],'UserData',hFxyz) varargout = &#123;hFxyz&#125;; %====================================================================== case 'edwidcb' %-Callback for editable widgets %====================================================================== % spm_results_ui('EdWidCB') hC = gcbo; d = find(strcmp(get(hC,'Tag'),&#123;'hX','hY','hZ'&#125;)); hFxyz = get(hC,'UserData'); UD = get(hFxyz,'UserData'); xyz = UD.xyz; nxyz = xyz; o = evalin('base',['[',get(hC,'String'),']'],'sprintf(''error'')'); if ischar(o) || length(o)&gt;1 warning(sprintf('%s: Error evaluating ordinate:\\n\\t%s',... mfilename,lasterr)) else nxyz(d) = o; nxyz = spm_XYZreg('RoundCoords',nxyz,UD.M,UD.DIM); end if abs(xyz(d)-nxyz(d))&gt;0 UD.xyz = nxyz; set(hFxyz,'UserData',UD) if ~isempty(UD.hReg), spm_XYZreg('SetCoords',nxyz,UD.hReg,hFxyz); end set(hC,'String',sprintf('%.3f',nxyz(d))) spm_results_ui('UpdateSPMval',UD) end %====================================================================== case 'updatespmval' %-Update SPM value in GUI %====================================================================== % spm_results_ui('UpdateSPMval',hFxyz) % spm_results_ui('UpdateSPMval',UD) if nargin&lt;2, error('insufficient arguments'), end if isstruct(varargin&#123;2&#125;), UD=varargin&#123;2&#125;; else UD = get(varargin&#123;2&#125;,'UserData'); end i = spm_XYZreg('FindXYZ',UD.xyz,UD.XYZ); if isempty(i), str = ''; else str = sprintf('%6.2f',UD.Z(i)); end set(UD.hSPM,'String',str); %====================================================================== case 'getcoords' % Get current co-ordinates from XYZ widget %====================================================================== % xyz = spm_results_ui('GetCoords',hFxyz) if nargin&lt;2, hFxyz='Interactive'; else hFxyz=varargin&#123;2&#125;; end hFxyz = spm_results_ui('FindXYZframe',hFxyz); varargout = &#123;getfield(get(hFxyz,'UserData'),'xyz')&#125;; %====================================================================== case 'setcoords' % Set co-ordinates to XYZ widget %====================================================================== % [xyz,d] = spm_results_ui('SetCoords',xyz,hFxyz,hC) if nargin&lt;4, hC=0; else hC=varargin&#123;4&#125;; end if nargin&lt;3, hFxyz=spm_results_ui('FindXYZframe'); else hFxyz=varargin&#123;3&#125;; end if nargin&lt;2, error('Set co-ords to what!'); else xyz=varargin&#123;2&#125;; end %-If this is an internal call, then don't do anything if hFxyz==hC, return, end UD = get(hFxyz,'UserData'); %-Check validity of coords only when called without a caller handle %------------------------------------------------------------------ if hC &lt;= 0 [xyz,d] = spm_XYZreg('RoundCoords',xyz,UD.M,UD.DIM); if d&gt;0 &amp;&amp; nargout&lt;2, warning(sprintf(... '%s: Co-ords rounded to nearest voxel centre: Discrepancy %.2f',... mfilename,d)) end else d = []; end %-Update xyz information &amp; widget strings %------------------------------------------------------------------ UD.xyz = xyz; set(hFxyz,'UserData',UD) set(UD.hX,'String',sprintf('%.2f',xyz(1))) set(UD.hY,'String',sprintf('%.2f',xyz(2))) set(UD.hZ,'String',sprintf('%.2f',xyz(3))) spm_results_ui('UpdateSPMval',UD) %-Tell the registry, if we've not been called by the registry... %------------------------------------------------------------------ if (~isempty(UD.hReg) &amp;&amp; UD.hReg~=hC) spm_XYZreg('SetCoords',xyz,UD.hReg,hFxyz); end %-Return arguments %------------------------------------------------------------------ varargout = &#123;xyz,d&#125;; %====================================================================== case 'findxyzframe' % Find hFxyz frame %====================================================================== % hFxyz = spm_results_ui('FindXYZframe',h) % Sorts out hFxyz handles if nargin&lt;2, h='Interactive'; else, h=varargin&#123;2&#125;; end if ischar(h), h=spm_figure('FindWin',h); end if ~ishandle(h), error('invalid handle'), end if ~strcmp(get(h,'Tag'),'hFxyz'), h=findobj(h,'Tag','hFxyz'); end if isempty(h), error('XYZ frame not found'), end if length(h)&gt;1, error('Multiple XYZ frames found'), end varargout = &#123;h&#125;; %====================================================================== case 'plotui' %-GUI for plot manipulation %====================================================================== % spm_results_ui('PlotUi',hAx) if nargin&lt;2, hAx=gca; else hAx=varargin&#123;2&#125;; end WS = spm('WinScale'); FS = spm('FontSizes'); Finter=spm_figure('FindWin','Interactive'); figure(Finter) %-Check there aren't already controls! %------------------------------------------------------------------ hGraphUI = findobj(Finter,'Tag','hGraphUI'); if ~isempty(hGraphUI) %-Controls exist hBs = get(hGraphUI,'UserData'); if hAx==get(hBs(1),'UserData') %-Controls linked to these axes return else %-Old controls remain delete(findobj(Finter,'Tag','hGraphUIbg')) end end %-Frames &amp; text %------------------------------------------------------------------ hGraphUIbg = uicontrol(Finter,'Style','Frame','Tag','hGraphUIbg',... 'BackgroundColor',spm('Colour'),... 'Position',[001 196 400 055].*WS); hGraphUI = uicontrol(Finter,'Style','Frame','Tag','hGraphUI',... 'Position',[008 202 387 043].*WS); hGraphUIButtsF = uicontrol(Finter,'Style','Frame',... 'Position',[010 205 380 030].*WS); hText = uicontrol(Finter,'Style','Text','String','plot controls',... 'Position',[020 227 080 016].*WS,... 'FontWeight','Normal',... 'FontAngle','Italic','FontSize',FS(10),... 'HorizontalAlignment','Left',... 'ForegroundColor','w'); %-Controls %------------------------------------------------------------------ h1 = uicontrol(Finter,'Style','CheckBox','String','hold',... 'ToolTipString','toggle hold to overlay plots',... 'FontSize',FS(10),... 'Value',strcmp(get(hAx,'NextPlot'),'add'),... 'Callback',[... 'if get(gcbo,''Value''), ',... 'set(get(gcbo,''UserData''),''NextPlot'',''add''), ',... 'else, ',... 'set(get(gcbo,''UserData''),''NextPlot'',''replace''), ',... 'end'],... 'Interruptible','on','Enable','on',... 'Tag','holdButton',... 'Position',[015 210 070 020].*WS); set(findobj('Tag','plotButton'),'UserData',h1); h2 = uicontrol(Finter,'Style','CheckBox','String','grid',... 'ToolTipString','toggle axes grid',... 'FontSize',FS(10),... 'Value',strcmp(get(hAx,'XGrid'),'on'),... 'Callback',[... 'if get(gcbo,''Value''), ',... 'set(get(gcbo,''UserData''),''XGrid'',''on'','... '''YGrid'',''on'',''ZGrid'',''on''), ',... 'else, ',... 'set(get(gcbo,''UserData''),''XGrid'',''off'','... '''YGrid'',''off'',''ZGrid'',''off''), ',... 'end'],... 'Interruptible','on','Enable','on',... 'Position',[090 210 070 020].*WS); h3 = uicontrol(Finter,'Style','CheckBox','String','Box',... 'ToolTipString','toggle axes box',... 'FontSize',FS(10),... 'Value',strcmp(get(hAx,'Box'),'on'),... 'Callback',[... 'if get(gcbo,''Value''), ',... 'set(get(gcbo,''UserData''),''Box'',''on''), ',... 'else, ',... 'set(get(gcbo,''UserData''),''Box'',''off''), ',... 'end'],... 'Interruptible','on','Enable','on',... 'Position',[165 210 070 020].*WS); h4 = uicontrol(Finter,'Style','PopUp',... 'ToolTipString','edit axis text annotations',... 'FontSize',FS(10),... 'String','text|Title|Xlabel|Ylabel',... 'Callback','spm_results_ui(''PlotUiCB'')',... 'Interruptible','on','Enable','on',... 'Position',[240 210 070 020].*WS); h5 = uicontrol(Finter,'Style','PopUp',... 'ToolTipString','change various axes attributes',... 'FontSize',FS(10),... 'String','attrib|LineWidth|XLim|YLim|handle',... 'Callback','spm_results_ui(''PlotUiCB'')',... 'Interruptible','off','Enable','on',... 'Position',[315 210 070 020].*WS); %-Handle storage for linking, and DeleteFcns for linked deletion %------------------------------------------------------------------ set(hGraphUI,'UserData',[h1,h2,h3,h4,h5]) set([h1,h2,h3,h4,h5],'UserData',hAx) set(hGraphUIbg,'UserData',... [hGraphUI,hGraphUIButtsF,hText,h1,h2,h3,h4,h5],... 'DeleteFcn','spm_results_ui(''Delete'',get(gcbo,''UserData''))') set(hAx,'UserData',hGraphUIbg,... 'DeleteFcn','spm_results_ui(''Delete'',get(gcbo,''UserData''))') %====================================================================== case 'plotuicb' %====================================================================== % spm_results_ui('PlotUiCB') hPM = gcbo; v = get(hPM,'Value'); if v==1, return, end str = cellstr(get(hPM,'String')); str = str&#123;v&#125;; hAx = get(hPM,'UserData'); switch str case 'Title' h = get(hAx,'Title'); set(h,'String',spm_input('Enter title:',-1,'s+',get(h,'String'))) case 'Xlabel' h = get(hAx,'Xlabel'); set(h,'String',spm_input('Enter X axis label:',-1,'s+',get(h,'String'))) case 'Ylabel' h = get(hAx,'Ylabel'); set(h,'String',spm_input('Enter Y axis label:',-1,'s+',get(h,'String'))) case 'LineWidth' lw = spm_input('Enter LineWidth',-1,'e',get(hAx,'LineWidth'),1); set(hAx,'LineWidth',lw) case 'XLim' XLim = spm_input('Enter XLim',-1,'e',get(hAx,'XLim'),[1,2]); set(hAx,'XLim',XLim) case 'YLim' YLim = spm_input('Enter YLim',-1,'e',get(hAx,'YLim'),[1,2]); set(hAx,'YLim',YLim) case 'handle' varargout=&#123;hAx&#125;; otherwise warning(['Unknown action: ',str]) end set(hPM,'Value',1) %====================================================================== case 'clear' %-Clear results subpane %====================================================================== % Fgraph = spm_results_ui('Clear',F,mode) % mode 1 [default] usual, mode 0 - clear &amp; hide Res stuff, 2 - RNP if nargin&lt;3, mode=1; else, mode=varargin&#123;3&#125;; end if nargin&lt;2, F='Graphics'; else, F=varargin&#123;2&#125;; end F = spm_figure('FindWin',F); %-Clear input objects from 'Interactive' window %------------------------------------------------------------------ %spm_input('!DeleteInputObj') %-Get handles of objects in Graphics window &amp; note permanent results objects %------------------------------------------------------------------ H = get(F,'Children'); %-Get contents of window H = findobj(H,'flat','HandleVisibility','on'); %-Drop GUI components h = findobj(H,'flat','Tag','PermRes'); %-Look for 'PermRes' object if ~isempty(h) %-Found 'PermRes' object % This has handles of permanent results objects in it's UserData tmp = get(h,'UserData'); HR = tmp.H; HRv = tmp.Hv; else %-No trace of permanent results objects HR = []; HRv = &#123;&#125;; end H = setdiff(H,HR); %-Drop permanent results obj %-Delete stuff as appropriate %------------------------------------------------------------------ if mode==2 %-Don't delete axes with NextPlot 'add' H = setdiff(H,findobj(H,'flat','Type','axes','NextPlot','add')); end delete(H) if mode==0 %-Hide the permanent results section stuff set(HR,'Visible','off') else set(HR,&#123;'Visible'&#125;,HRv) end %====================================================================== case 'close' %-Close Results %====================================================================== spm_clf('Interactive'); spm_clf('Graphics'); close(spm_figure('FindWin','Satellite')); evalin('base','clear'); %====================================================================== case 'launchmp' %-Launch multiplanar toolbox %====================================================================== % hMP = spm_results_ui('LaunchMP',M,DIM,hReg,hBmp) if nargin&lt;5, hBmp = gcbo; else hBmp = varargin&#123;5&#125;; end hReg = varargin&#123;4&#125;; DIM = varargin&#123;3&#125;; M = varargin&#123;2&#125;; %-Check for existing MultiPlanar toolbox hMP = get(hBmp,'UserData'); if ishandle(hMP) figure(ancestor(hMP,'figure')); varargout = &#123;hMP&#125;; return end %-Initialise and cross-register MultiPlanar toolbox hMP = spm_XYZreg_Ex2('Create',M,DIM); spm_XYZreg('Xreg',hReg,hMP,'spm_XYZreg_Ex2'); %-Setup automatic deletion of MultiPlanar on deletion of results controls set(hBmp,'Enable','on','UserData',hMP) set(hBmp,'DeleteFcn','spm_results_ui(''delete'',get(gcbo,''UserData''))') varargout = &#123;hMP&#125;; %====================================================================== case 'delete' %-Delete HandleGraphics objects %====================================================================== % spm_results_ui('Delete',h) h = varargin&#123;2&#125;; delete(h(ishandle(h))); %====================================================================== otherwise %====================================================================== error('Unknown action string') end%==========================================================================function mychgcon(obj,evt,xSPM)%==========================================================================xSPM2.swd = xSPM.swd;try, xSPM2.units = xSPM.units; endxSPM2.Ic = getfield(get(obj,'UserData'),'Ic');if isempty(xSPM2.Ic) || all(xSPM2.Ic == 0), xSPM2 = rmfield(xSPM2,'Ic'); endxSPM2.Im = xSPM.Im;xSPM2.pm = xSPM.pm;xSPM2.Ex = xSPM.Ex;xSPM2.title = '';if ~isempty(xSPM.thresDesc) td = regexp(xSPM.thresDesc,'p\\D?(?&lt;u&gt;[\\.\\d]+) \\((?&lt;thresDesc&gt;\\S+)\\)','names'); if isempty(td) td = regexp(xSPM.thresDesc,'\\w=(?&lt;u&gt;[\\.\\d]+)','names'); td.thresDesc = 'none'; end if strcmp(td.thresDesc,'unc.'), td.thresDesc = 'none'; end xSPM2.thresDesc = td.thresDesc; xSPM2.u = str2double(td.u); xSPM2.k = xSPM.k;endhReg = spm_XYZreg('FindReg',spm_figure('GetWin','Interactive'));xyz = spm_XYZreg('GetCoords',hReg);[hReg,xSPM,SPM] = spm_results_ui('setup',xSPM2);spm_XYZreg('SetCoords',xyz,hReg);assignin('base','hReg',hReg);assignin('base','xSPM',xSPM);assignin('base','SPM',SPM);figure(spm_figure('GetWin','Interactive')); spm_ROI_extend.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176function [xY, XYZmm, j] = spm_ROI_extend(xY, XYZmm,Input_VOI_path)% Region of Interest specification% FORMAT xY = spm_ROI(xY)% xY - VOI structure% xY.def - VOI definition [sphere, box, mask, cluster, all]% xY.rej - cell array of disabled VOI definition options% xY.xyz - centre of VOI &#123;mm&#125;% xY.spec - VOI definition parameters% xY.str - description of the VOI%% FORMAT [xY, XYZmm, j] = spm_ROI(xY, XYZmm)% XYZmm - [3xm] locations of voxels &#123;mm&#125;% If an image filename, an spm_vol structure or a NIfTI object is% given instead, XYZmm will be initialised to all voxels within% the field of view of that image.%% XYZmm - [3xn] filtered locations of voxels &#123;mm&#125; (m&gt;=n) within VOI xY% j - [1xn] indices of input locations XYZmm within VOI xY%__________________________________________________________________________% Copyright (C) 2008 Wellcome Trust Centre for Neuroimaging % Karl Friston, Guillaume Flandin% $Id: spm_ROI.m 3960 2010-06-30 17:41:24Z ged $if nargin &lt; 2 &amp;&amp; nargout &gt; 1 error('Too many output arguments.');end%Input_VOI_path = 'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\first_level_dcm_w_whole\\MASK\\HG\\HG_Resliced_NiftiPairs\\NiftiPairs_Resliced_HG.img';try, xY; catch, xY = []; end%-Specify ROI%==========================================================================if ~isfield(xY,'def') def = &#123;'sphere','box','cluster','mask'&#125;; if isfield(xY,'rej') if ~isfield(xY,'M') xY.rej = &#123;xY.rej&#123;:&#125; 'cluster'&#125;; end else if isfield(xY,'M') xY.rej = &#123;&#125;; else xY.rej = &#123;'cluster'&#125;; end end [q, i] = setdiff(def,xY.rej); def = def(sort(i)); xY.def = 'mask'; %======'sphere','box','cluster','mask'======================================================end%-ROI parameters%--------------------------------------------------------------------------switch lower(xY.def) case 'sphere' %---------------------------------------------------------------------- if ~isfield(xY,'xyz') || isempty(xY.xyz) xY.xyz = spm_input('sphere centre [x y z] &#123;mm&#125;',... '!+0','r','0 0 0',3); end if ~isfield(xY,'spec') xY.spec = spm_input('sphere radius (mm)','!+0','r',0,1,[0,Inf]); end xY.str = sprintf('%0.1fmm sphere',xY.spec); case 'box' %---------------------------------------------------------------------- if ~isfield(xY,'xyz') || isempty(xY.xyz) xY.xyz = spm_input('box centre [x y z] &#123;mm&#125;',... '!+0','r','0 0 0',3); end if ~isfield(xY,'spec') xY.spec = spm_input('box dimensions [x y z] &#123;mm&#125;',... '!+0','r','0 0 0',3); end if length(xY.spec) &lt; 3 xY.spec = xY.spec(1)*[1 1 1]; end xY.str = sprintf('%0.1f x %0.1f x %0.1f mm box',xY.spec); case 'mask' %---------------------------------------------------------------------- if ~isfield(xY,'spec') xY.spec = spm_vol([Input_VOI_path,',1']);%=========================================================== else if ~isstruct(xY.spec) xY.spec = spm_vol(xY.spec); end end str = spm_str_manip(xY.spec.fname,'a30x'); xY.str = sprintf('image mask: %s',str); case 'cluster' %---------------------------------------------------------------------- if ~isfield(xY,'xyz') || isempty(xY.xyz) xY.xyz = spm_input('seed voxel [x y z] &#123;mm&#125;',... '!+0','r','0 0 0',3); end if ~isfield(xY,'M') xY.M = spm_input('affine transformation matrix',... '!+0','r','0 0 0',[4 4]); end xY.spec = []; xY.str = sprintf('cluster (seed voxel: %0.1f %0.1f %0.1f)',xY.xyz); case 'all' %---------------------------------------------------------------------- xY.str = 'all'; otherwise %---------------------------------------------------------------------- error('Unknown VOI type.'); endif nargin &lt; 2, return; end%-'Estimate' ROI%==========================================================================%-Argument check%--------------------------------------------------------------------------if ischar(XYZmm) &amp;&amp; isempty(XYZmm) XYZmm = spm_select(1,'image','Specify Image');endif ischar(XYZmm), XYZmm = spm_vol(XYZmm); endif isa(XYZmm,'nifti') XYZmm = struct('dim',size(XYZmm.dat), 'mat',XYZmm.mat);endif isstruct(XYZmm) % spm_vol [R,C,P] = ndgrid(1:XYZmm.dim(1),1:XYZmm.dim(2),1:XYZmm.dim(3)); RCP = [R(:)';C(:)';P(:)']; clear R C P RCP(4,:) = 1; XYZmm = XYZmm.mat(1:3,:)*RCP; endif isempty(XYZmm), XYZmm = zeros(3,0); end%-Filter location of voxels%--------------------------------------------------------------------------Q = ones(1,size(XYZmm,2));switch lower(xY.def) case 'sphere' %---------------------------------------------------------------------- j = find(sum((XYZmm - xY.xyz*Q).^2) &lt;= xY.spec^2); case 'box' %---------------------------------------------------------------------- j = find(all(abs(XYZmm - xY.xyz*Q) &lt;= xY.spec(:)*Q/2)); case 'mask' %---------------------------------------------------------------------- XYZ = xY.spec.mat \\ [XYZmm; Q]; j = find(spm_sample_vol(xY.spec, XYZ(1,:), XYZ(2,:), XYZ(3,:),0) &gt; 0); case 'cluster' %---------------------------------------------------------------------- [x i] = spm_XYZreg('NearestXYZ',xY.xyz,XYZmm); XYZ = round(xY.M \\ [XYZmm; Q]); A = spm_clusters(XYZ); j = find(A == A(i)); case 'all' %---------------------------------------------------------------------- j = 1:size(XYZmm,2); otherwise %---------------------------------------------------------------------- error('Unknown VOI type.'); endXYZmm = XYZmm(:,j);if strcmpi(xY.def,'mask') &amp;&amp; ~isempty(XYZmm), xY.xyz = mean(XYZmm,2); end createVOI 123456789101112131415161718192021222324252627282930313233343536function createVOI(spm_mat_path,Input_u)% 功能： 使用特定的Mask抽取VOI。% spm_mat_path : SPM.mat的完整路径，需要是做完FirstLevel之后的SPM.mat;% Input_u : 抽取时间序列时使用的P值，一般默认是0.001，当抽取失败的时候，，适当调大可以确保成功；% -----------------------------------------------------------------------------------------% 配置信息：% contrast_name ： First_Level时候设置的contrast,这里的顺序很重要，因为程序中使用数字表示每个contrast的；% InputMask ： appying mask : 0 none ; 1 contrast ; 2 image ;默认是整数 0 % InputthresDesc : p value adjustment to control: 'FWE' or 'none'% Input_k : extend threshold &#123;voxel&#125; 0 ; 默认是0% xx_mask_path : 抽取的VOI使用的mask的绝对路径% VOI_Mask ：抽取的VOI使用的mask的绝对路径% Input_is ： adjust_contrst 这里选择那个F-All的,整数，1 是dont adjust, 2 是F-All，3个数字分别对应三个Mask的adjust_contrst。contrast_name = &#123;'F-All','JX','DW','RL','ZR'&#125;;InputMask = 0; %appying mask : 0 none ; 1 contrast ; 2 image ============================================================================InputthresDesc = 'none'; %p value adjustment to control: 'FWE' or 'none'=================================================================Input_k = 0; % extend threshold &#123;voxel&#125; 0 ===============================================================================================HG_mask_path = 'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\first_level_dcm_w_whole\\MASK\\HG\\HG_Resliced_NiftiPairs\\NiftiPairs_Resliced_HG.img';MFG_mask_path = 'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\first_level_dcm_w_whole\\MASK\\MFG\\MFG_Resliced_NiftiPairs\\NiftiPairs_Resliced_MFG.img';STG_mask_path = 'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\first_level_dcm_w_whole\\MASK\\STG\\STG_Resliced_NiftiPairs\\NiftiPairs_Resliced_STG.img';VOI_Mask = &#123;HG_mask_path,MFG_mask_path,STG_mask_path&#125;;Input_is = &#123;2,2,2&#125;; %adjust_contrst 这里选择那个F-All的,整数，1 是dont adjust, 2 是F-All.empty_bit = []; % 占位符，没有用处% 配置结束% ----------------------------------------------------------------------------------------------------------------------------------------for j = 2:size(contrast_name,2) Ic = j; % 要使用的Contrast的编号，这里1 : F-All 2: JX 3: DW 4:RL 5:ZR VOI_Names = &#123;[contrast_name&#123;Ic&#125;,'_HG'],[contrast_name&#123;Ic&#125;,'_MFG'],[contrast_name&#123;Ic&#125;,'_STG',]&#125;; %Input_VOIName : 抽取的VOI的名称 [SPM,xSPM] = spm_getSPM_extend(spm_mat_path,Ic,InputMask,InputthresDesc,Input_u,Input_k); [hReg,xSPM,SPM] = spm_result_ui_extend('Setup',xSPM); for i = 1:size(VOI_Mask,2) [Y xY] = spm_regions_extend(xSPM,SPM,hReg,empty_bit,VOI_Names&#123;i&#125;,Input_is&#123;i&#125;,VOI_Mask&#123;i&#125;); end clear SPM; clear xSPM;end createVOIs, 创建多个被试的ROI 12345678910% 创建多个被试的VOI；% first_level_path = 'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\first_level_dcm_w_whole\\';cd(first_level_path);dir_str = dir('2016*');Input_u = 0.001; % P值；抽取不成功时，调大P值可以成功for i = 1:size(dir_str,1) spm_mat_path = [first_level_path,dir_str(i).name,'\\SPM.mat']; createVOI(spm_mat_path);end create_dcm 123456789101112131415161718192021222324252627282930313233343536function DCM = create_dcm(subject_path)%功能： 定义DCM模型，需要先做完抽取VOI，在FirstLevel文件夹下面VOI_开头的文件；%subject_path : First_Level 被试目录， eg.D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\first_level_dcm_w_whole\\20160716002\\%condition_name : SPM.mat 设计矩阵中定义的条件，这里用来给生成的DCM命名。%---------------------------------------------------------------%-配置----------------------------------------------------------condition_name = &#123;'JX','DW','RL','ZR'&#125;;%Input_a : DCM模型矩阵，需要更改模型的时候，修改这个矩阵%Input_b : 调节输入%Input_c : 外界输入%-配置结束------------------------------------------------------cd(subject_path);spmmatfile = [subject_path,'SPM.mat'];for i = 1:size(condition_name,2) %每次循环创建一个condition条件下的DCM模型 name = condition_name&#123;i&#125;; % 生成的DCM模型的名称； condition_mask = [0,0,0,0]; condition_mask(i) = 1; % 使用哪个condition作为 TE = 0.04; % TE Input_a = [1,1,1;1,1,1;1,1,1]; % 定义DCM模型的连接矩阵 Input_b = [0,0,0;0,0,0;0,0,0]; % 定义调节参数 Input_c = [1;0;0]; % 定义输入参数 % 获得VOI %------------------------------------------------ filter = ['VOI_',condition_name&#123;i&#125;,'_*']; VOIs_path = dir(filter); VOIs = cell(size(VOIs_path,1),1); for j = 1: size(VOIs_path,1) VOIs&#123;j&#125; = [subject_path,VOIs_path(j).name]; end %------------------------------------------------- DCM = spm_dcm_specify_extend(spmmatfile,name,VOIs,condition_mask,TE,Input_a,Input_b,Input_c); clear name; clear VOIs; clear condition_mask;end create_dcms, 定义多个被试的DCM模型 123456789%配置：first_level_path = 'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\first_level_dcm_w_whole\\';cd(first_level_path);dir_str = dir('2016*');for i = 1:size(dir_str,1) subject_path = [first_level_path,dir_str(i).name,'\\']; create_dcm(subject_path);end 批量估计DCM模型 12345678910111213% 估计DCM模型first_level_path = 'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\first_level_dcm_w_whole\\';cd(first_level_path);dir_path = dir('2016*');for i = 1: size(dir_path,1) subject_path = [first_level_path,dir_path(i).name]; cd(subject_path); dcm_models_path = dir('DCM*'); for j = 1:size(dcm_models_path,1) dcm_model_path = [subject_path,'\\',dcm_models_path(j).name]; spm_dcm_estimate(dcm_model_path); endend","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"认知神经科学","slug":"技术/认知神经科学","permalink":"http://ff120.github.io/hexoblog/categories/技术/认知神经科学/"}],"tags":[{"name":"fMRI","slug":"fMRI","permalink":"http://ff120.github.io/hexoblog/tags/fMRI/"}]},{"title":"SPM预处理中的常用操作","slug":"技术/认知神经科学/SPM预处理中的常用操作","date":"2017-03-20T12:59:07.000Z","updated":"2019-03-28T00:54:59.610Z","comments":true,"path":"2017/03/20/技术/认知神经科学/SPM预处理中的常用操作/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/03/20/技术/认知神经科学/SPM预处理中的常用操作/","excerpt":"一些数据处理当中用的到的功能函数。","text":"一些数据处理当中用的到的功能函数。 比较多幅图像是否配准 1234567891011121314151617function check_img(imgs)% -------------------------------------------------------------------------% 功能：比较多幅图像% 调用：check_img(imgs)% 参数：% imgs: cell类型的图像% 示例：% c1_img = 'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\pre_processing\\20160713001\\t1_mprage_sag_p2_0026\\run1\\c1s20160713001-193508-00001-00176-1.img';% c2_img = 'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\pre_processing\\20160713001\\t1_mprage_sag_p2_0026\\run1\\c2s20160713001-193508-00001-00176-1.img';% c3_img = 'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\pre_processing\\20160713001\\t1_mprage_sag_p2_0026\\run1\\c3s20160713001-193508-00001-00176-1.img';% func_img = 'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\pre_processing\\20160713001\\ep2d_bold_moco_p2_rest_0006\\f20160713001-190315-00238-00238-1.img';% imgs = &#123;c1_img,c2_img,c3_img,func_img&#125;;% check_img(imgs);% -------------------------------------------------------------------------spm_jobman('initcfg')matlabbatch&#123;1&#125;.spm.util.checkreg.data = imgs;spm_jobman('run',matlabbatch); 批量复制文件夹结构 12345678910111213141516171819202122232425262728293031323334353637383940414243function copy_structure(origin_path,destination_path,fileFilter,varargin)% -------------------------------------------------------------------------% 功能： 复制目录结构 或者 复制文件% 调用1：copy_structure(origin_path,destination_path,filter)% 调用2：copy_structure(origin_path,destination_path,fileFilter,subExpIDFilter)% 调用3：copy_structure(origin_path,destination_path,fileFilter,subExpIDFilter，runExpIDFilter)% 参数：% origin_path : 要复制的目录结构的绝对路径% destination_path : 新文件夹绝对路径% subExpIDFilter ：子一级目录通配符% runExpIDFilter : 子二级目录通配符% fileFilter: 过滤器，决定拷贝哪些文件% 示例：% copy_structure(origin_path,destination_path,'s4w*')% copy_structure(origin_path,destination_path,'s4w*','20160916001*')% copy_structure(origin_path,destination_path,'s4w*','20160916001*','ep2d_bold_moco_p2_rest_0006*')% 说明： subExpIDFilter默认值为'2016*';runExpIDFilter 默认值为 'ep2d*'% --------------------------------------------------------------------------if nargin &lt; 4 subExpIDFilter = '2016*';% 被试文件夹通配符 else subExpIDFilter = varargin&#123;1&#125;;endif nargin &lt; 5 runExpIDFilter = 'ep2d*';% RUN文件夹通配符else runExpIDFilter = varargin&#123;2&#125;;end%fileFilter = 'w*';cd(origin_path);subExpID=dir(subExpIDFilter); for i=1:size(subExpID,1) mkdir([destination_path,subExpID(i).name]); cd([origin_path,subExpID(i).name]); runExpID=dir(runExpIDFilter); for j=1:size(runExpID,1) mkdir([destination_path,subExpID(i).name,'\\',runExpID(j).name]); cd([origin_path,subExpID(i).name,'\\',runExpID(j).name]); if nargin &gt; 2 copyfile(fileFilter,[destination_path,subExpID(i).name,'\\',runExpID(j).name],'f'); end endend 从多标签mask生成单标签mask 注意本函数依赖marsbar, 需要将marsbar工具包setpath之后才能使用。 12345678910111213141516171819202122232425262728293031323334function create_masks_from_multiple_labels_img()% -------------------------------------------------------------------------% 功能： 从多标签图像创建多个Mask% 参数：% multiple_label_img_path ：多标签图像路径% multiple_label_path : 标签路径，名称为ROI，包含ID，Nom_C,Nom_L,ID是标签，整数，剩下的是名称% save_path ： 生成Mask的保存路径% P ： 提供重新采样的参数，需要随便一张被试的图像，Mask会按照该图像的规格重新采样aal = 'C:\\mazcx\\matlabtoolbox\\spm8\\toolbox\\wfu_pickatlas\\MNI_atlas_templates\\TD_label_extended_modified.img';aal_label = 'C:\\mazcx\\matlabtoolbox\\spm8\\toolbox\\wfu_pickatlas\\MNI_atlas_templates\\TD_label_extended_modified_List.mat';multiple_label_img_path = aal;multiple_label_path = aal_label;save_path = 'D:\\FMRI_ROOT\\YANTAI\\DESIGN\\MASK\\TDLabels\\';P = 'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\pre_processing\\20160911002\\ep2d_bold_moco_p2_rest_0006\\wraf20160911002-182754-00008-00008-1.img';roi_space = spm_vol(P);% ROI namesload(multiple_label_path);marsbar('on');% Make ROIsvol = spm_vol(multiple_label_img_path);for r = 1:length(ROI) nom = ROI(r).Nom_L; func = sprintf('img == %d', ROI(r).ID); o = maroi_image(struct('vol', vol, 'binarize',1,... 'func', func, 'descrip', nom, ... 'label', nom)); cd(save_path); %saveroi(maroi_matrix(o), fullfile(roi_path,['MNI_' nom '_roi.mat'])); mars_rois2img(maroi_matrix(o),['MNI_' nom '.img'],roi_space);end mask乘以激活之后再做成mask,就是每个被试不同的mask 12345678910111213141516function create_mask_use_T(input_img,output_img,f)% 制作的mask乘以相应的激活之后再做成Mask% STG_mask_path = 'D:\\FMRI_ROOT\\YANTAI\\DESIGN\\MASK\\NiftiPairs_Resliced_STG.mn.img';% spmT_path = 'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\first_level\\20160911002\\spmT_0017.img';% input_img = &#123;STG_mask_path; spmT_path&#125;; % 一个mask , 一个spmT图像% output_img = 'd:\\aaa.img';%------------P = input_img;Q = output_img;%f = 'i1.*(i2&gt;3.0987)';dmtx = 0;mask = 0;type = 4;hold = 0;flags = &#123;dmtx,mask,type,hold&#125;;[Q,Vo] = spm_imcalc_extend(P,Q,f,flags); 将同一个被试不同RUN的头动文件合并在一起 123456789101112131415161718% 将多个rp*头动文件，合成一个头动文件pre_processing = 'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\pre_processing\\';cd(pre_processing);subjects = dir('2016*');for i = 1: size(subjects,1) cd([pre_processing,subjects(i).name]); SubRunID = dir('ep2d*'); rps = ones(272*4,6); for j = 1:size(SubRunID,1) cd([pre_processing,subjects(i).name,'\\',SubRunID(j).name]); file = dir('rp*'); filename = file(1).name; a = load(filename); rps(272*(j-1)+1:272*j,1:6) = a; end cd([pre_processing,subjects(i).name]); save('rp_all.txt','rps','-ascii');end 提取图像某个点的值并绘制时间序列曲线 1234567891011121314function Y = extract_time_series(V,XYZ)% -------------------------------------------------------------------------% 功能：提取图像某个点的值并绘制时间序列曲线% 调用：Y = plot_time_series(V,XYZ)% 参数： % XYZ ：三维坐标，图像中的点% V : 存放图像路径的cell% 示例：% XYZ = [13;48;2];% V = &#123;'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\pre_processing\\20160911002\\ep2d_bold_moco_p2_rest_0006\\af20160911002-182750-00006-00006-1.img',% 'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\pre_processing\\20160911002\\ep2d_bold_moco_p2_rest_0006\\af20160911002-182750-00006-00006-1.img'&#125;;% Y = plot_time_series(V,XYZ)% -------------------------------------------------------------------------Y = spm_get_data(V,XYZ); 使用xjview批量找到激活的峰值并保存 123456789101112spmT_filepath = 'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\first_level\\20160911002\\spmT_0020.hdr';xjview(spmT_filepath);%显示出激活图像% 找到峰值h = spm_mip_ui('FindMIPax');% loc - String defining jump: 'dntmv' - don't move% 'nrvox' - nearest suprathreshold voxel% 'nrmax' - nearest local maxima% 'glmax' - global maximaloc = 'glmax';xyz = spm_mip_ui('Jump',h,loc); 求若干个图像的平均图像 123456789101112131415161718192021222324252627282930313233function mean_img(input_img,output_img)% -------------------------------------------------------------------------% 功能：求若干个图像的平均图像% 调用：mean_img(input_img,output_img)% 参数：% input_img : cell类型的输入图像，绝对路径% output_img : 输出图像的绝对路径% 示例：% input_img = &#123; 'd:\\fmri_root\\YANTAI\\ANALYSIS\\mean_smooth4\\DW10\\s4wraf20161104002-181316-00074-00074-1.img,1'% 'd:\\fmri_root\\YANTAI\\ANALYSIS\\mean_smooth4\\DW11\\s4wraf20161104002-181208-00040-00040-1.img,1'% 'd:\\fmri_root\\YANTAI\\ANALYSIS\\mean_smooth4\\DW20\\s4wraf20161104002-181822-00227-00227-1.img,1'% 'd:\\fmri_root\\YANTAI\\ANALYSIS\\mean_smooth4\\DW21\\s4wraf20161104002-181640-00176-00176-1.img,1'&#125;;% output_img = 'd:\\out.img';% mean_img(input_img,output_img)% 说明：修改matlabbatch&#123;1&#125;.spm.util.imcalc.expression可以完成不同的计算任务% -------------------------------------------------------------------------[path,name,exit] = fileparts(output_img) ;spm_jobman('initcfg')%-----------------------------------------------------------------------% Job configuration created by cfg_util (rev $Rev: 4252 $)%-----------------------------------------------------------------------matlabbatch&#123;1&#125;.spm.util.imcalc.input = input_img;matlabbatch&#123;1&#125;.spm.util.imcalc.output = [name,exit];matlabbatch&#123;1&#125;.spm.util.imcalc.outdir = &#123;path&#125;;matlabbatch&#123;1&#125;.spm.util.imcalc.expression = '(i1+i2+i3+i4)/4';matlabbatch&#123;1&#125;.spm.util.imcalc.options.dmtx = 0;matlabbatch&#123;1&#125;.spm.util.imcalc.options.mask = 0;matlabbatch&#123;1&#125;.spm.util.imcalc.options.interp = 1;matlabbatch&#123;1&#125;.spm.util.imcalc.options.dtype = 4;%--------------------------------------------------------------------------spm_jobman('run',matlabbatch);disp('mean_img successful !');clear matlabbatch; 求若干个图像的平均图像(一种速度更快的实现方式) 12345678910111213141516171819202122232425function Q = mean_img2(input_img,output_img)% -------------------------------------------------------------------------% 功能：计算四个图像的平均值% 调用：Q = mean_img2(input_img,output_img)% 参数：% input_img: cell类型的输入图像的绝对路径% output_img: 输出图像的绝对路径% 示例：% input_img = &#123;'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\pre_processing\\20160911002\\ep2d_bold_moco_p2_rest_0006\\s4wraf20160911002-182750-00006-00006-1.img'% 'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\pre_processing\\20160911002\\ep2d_bold_moco_p2_rest_0006\\s4wraf20160911002-182752-00007-00007-1.img'% 'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\pre_processing\\20160911002\\ep2d_bold_moco_p2_rest_0006\\s4wraf20160911002-182754-00008-00008-1.img'% 'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\pre_processing\\20160911002\\ep2d_bold_moco_p2_rest_0006\\s4wraf20160911002-182756-00009-00009-1.img'&#125;;% output_img = 'd:\\out.img';% Q = mean_img2(input_img,output_img)% -------------------------------------------------------------------------P = input_img;Q = output_img;f = '(i1+i2+i3+i4)/4';dmtx = 0;mask = 0;type = 4;hold = 0;flags = &#123;dmtx,mask,type,hold&#125;;[Q,Vo] = spm_imcalc_extend(P,Q,f,flags); 绘制一个RUN的时间序列 123456789101112131415161718function Y = plot_time_series_run(XYZ,run_dir,file_filter)% -------------------------------------------------------------------------% 功能 ： 绘制一个RUN的时间序列% 调用：Y = plot_time_series_run(run_dir,file_filter)% 参数：% XYZ : 图像中的某个点% run_dir : run文件夹路径% file_filter : 文件过滤器，e.g.w*.img% Y：提取的数据% -------------------------------------------------------------------------V = cell(272,1);cd(run_dir);files = dir(file_filter);for k = 1:size(files,1) V&#123;k&#125; = [run_dir,'\\',files(k).name];endY = spm_get_data(V,XYZ);plot(Y); 绘制被试的头动图像 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function plothm(file_path,save_name)% -------------------------------------------------------------------------% 功能：根据头动文件画头动图% 调用：plothm(file_path,save_name)% 参数：% file_path : rp*头动文件绝对路径% save_name : 生成图像的名称% 示例：% file_path = 'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\pre_processing\\20160716002\\ep2d_bold_moco_p2_rest_0016\\rp_af20160716002-183602-00006-00006-1.txt';% save_name = 'd:\\realign_run1.png'% plothm(file_path,save_name)% 说明：需要事先打开SPM的Graph窗口；save_name如果只有名称，则保存在Matlab当前工作目录下，如果提供了绝对路径，则保存为绝对路径指定的地方。% -------------------------------------------------------------------------Params = load(file_path);fg=spm_figure('FindWin','Graphics');if ~isempty(fg), % display results % translation and rotation over time series %------------------------------------------------------------------- spm_figure('Clear','Graphics'); ax=axes('Position',[0.1 0.65 0.8 0.2],'Parent',fg,'Visible','off'); set(get(ax,'Title'),'String','Image realignment','FontSize',16,'FontWeight','Bold','Visible','on'); ax=axes('Position',[0.1 0.35 0.8 0.2],'Parent',fg,'XGrid','on','YGrid','on'); plot(Params(:,1:3),'Parent',ax) s = ['x translation';'y translation';'z translation']; %text([2 2 2], Params(2, 1:3), s, 'Fontsize',10,'Parent',ax) legend(ax, s, 0) set(get(ax,'Title'),'String','translation','FontSize',16,'FontWeight','Bold'); set(get(ax,'Xlabel'),'String','image'); set(get(ax,'Ylabel'),'String','mm'); ax=axes('Position',[0.1 0.05 0.8 0.2],'Parent',fg,'XGrid','on','YGrid','on'); plot(Params(:,4:6)*180/pi,'Parent',ax) s = ['pitch';'roll ';'yaw ']; %text([2 2 2], Params(2, 4:6)*180/pi, s, 'Fontsize',10,'Parent',ax) legend(ax, s, 0) set(get(ax,'Title'),'String','rotation','FontSize',16,'FontWeight','Bold'); set(get(ax,'Xlabel'),'String','image'); set(get(ax,'Ylabel'),'String','degrees'); % print realigment parameters spm_print(save_name); print(fg,save_name,'-dpng');% 打印出PNG图片，还可以输出其他的格式，参考Matlab的print函数。endreturn; 批量保存xjview中的slice_view图像 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126function save_slice_view(file_path,save_path)%--------------------------------------------------------------------------% 功能：保存激活图像的slice_view图像% 调用：save_slice_view(file_path,save_path)% 参数：% file_path : spmT图像% save_path : 保存的绝对路径，包含文件名% 示例：% file_path = 'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\first_level\\20160911002\\spmT_0020.hdr';% save_path = 'd:\\aaa.png';% save_slice_view(file_path,save_path)% -------------------------------------------------------------------------%file_path = 'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\first_level\\20160911002\\spmT_0020.hdr';my_xjview(file_path);hObject = spm_mip_ui('FindMIPax');eventdata = [];handles = guidata(hObject);global sliceviewif(~isfield(sliceview, 'fig') || ~ishandle(sliceview.fig)) sliceview.viewtype = 't'; sliceview.row = 6; sliceview.col = 8; sliceview.spacing = 4; sliceview.page = 1; sliceview.data = &#123;&#123;&#125;,&#123;&#125;,&#123;&#125;&#125;; % t,s,c sliceview.slices = &#123;[],[],[]&#125;;% t,s,c sliceview.colormap = ''; sliceview.fig = figure('color','k', 'unit','normalized','position',[0.1 0.1 .6 .8],'toolbar','none', 'name', 'xjView slice view', 'NumberTitle','off'); sliceview.ax = axes('Visible','on','DrawMode','fast','Parent',sliceview.fig,... 'YDir','normal','Ydir','normal','XTick',[],'YTick',[], 'position', [0.15 0.05 .8 .9]); %handles.sliceview.d = image([],'Tag','Transverse','Parent',handles.sliceview.ax); set(sliceview.ax,'XTick',[],'YTick',[]); axis equal set(sliceview.ax,'color','k'); %setcolormap(colormp) width = 0.05; height = 0.025; step = 0.025; labeloffset = step/2;endslicegraph = figure(sliceview.fig);viewtype = sliceview.viewtype; row = sliceview.row;col = sliceview.col;spacing = sliceview.spacing;page = sliceview.page;slice_fig = sliceview.fig;ax = sliceview.ax;%d = handles.sliceview.d;[slicedata, colormp, slices] = cuixu_getSliceViewData(viewtype,row,col, spacing, page);if isempty(slices) return;endfor ii=1:length(slices) if(viewtype == 's') postmp = find(slices(ii) - sliceview.slices&#123;2&#125; == 0); if(isempty(postmp)) sliceview.data&#123;2&#125;&#123;end+1&#125; = slicedata&#123;ii&#125;; sliceview.slices&#123;2&#125;(end+1) = slices(ii); end elseif(viewtype == 't') postmp = find(slices(ii) - sliceview.slices&#123;1&#125; == 0); if(isempty(postmp)) sliceview.data&#123;1&#125;&#123;end+1&#125; = slicedata&#123;ii&#125;; sliceview.slices&#123;1&#125;(end+1) = slices(ii); end elseif(viewtype == 'c') postmp = find(slices(ii) - sliceview.slices&#123;3&#125; == 0); if(isempty(postmp)) sliceview.data&#123;3&#125;&#123;end+1&#125; = slicedata&#123;ii&#125;; sliceview.slices&#123;3&#125;(end+1) = slices(ii); end end end%slice_fig = figure('color','k', 'unit','normalized','position',[0.1 0.1 .6 .8],'toolbar','none');if(length(size(slicedata&#123;1&#125;)) == 3) [nx, ny, nz] = size(slicedata&#123;1&#125;); slicedatafinal = zeros(nx*row, ny*col, nz ); for ii=1:length(slicedata) slicedatafinal(nx*(floor((ii-1)/col))+1:nx*(1+floor((ii-1)/col)), ny*(mod(ii-1,col))+1:ny*(mod(ii-1,col)+1), :) = slicedata&#123;ii&#125;; endelse [nx, ny] = size(slicedata&#123;1&#125;); slicedatafinal = zeros(nx*row, ny*col ); for ii=1:length(slicedata) slicedatafinal(nx*(floor((ii-1)/col))+1:nx*(1+floor((ii-1)/col)), ny*(mod(ii-1,col))+1:ny*(mod(ii-1,col)+1)) = slicedata&#123;ii&#125;; endendtry delete(handles.sliceview.d)catch [];endhandles.sliceview.d = image(slicedatafinal,'Tag','Transverse','Parent',sliceview.ax);% put slice positionsfor ii=1:length(slicedata) %text(nx*(floor((ii-1)/col))+1:nx*(1+floor((ii-1)/col)), ny*(mod(ii-1,col))+1:ny*(mod(ii-1,col)+1), num2str(slices(ii)), 'color', 'w'); text(ny*(mod(ii-1,col))+1, nx*(floor((ii-1)/col))+1+20, num2str(slices(ii)), 'color', 'w');endset(sliceview.ax,'XTick',[],'YTick',[]);axis(sliceview.ax, 'equal');set(sliceview.ax,'color','k');guidata(hObject, handles);%print(handles.figure,'bbb','-dpng'); % 保存主窗口图像print(slicegraph,save_path,'-dpng'); % 保存slice_view图像close(slicegraph);close(handles.figure);clc; 获得图像的头信息 123P = &#123;'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\pre_processing\\20160911002\\ep2d_bold_moco_p2_rest_0006\\af20160911002-182750-00006-00006-1.img', 'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\pre_processing\\20160911002\\ep2d_bold_moco_p2_rest_0006\\af20160911002-182750-00006-00006-1.img'&#125;;header = spm_vol(P); 获得图像某个坐标的值 1234% 获得图像某个坐标的值V = &#123;'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\first_level\\20160911002\\beta_0001.img'&#125;;XYZ = [13;48;2];Y = spm_get_data(V,XYZ); 批量做图像的平滑处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172function smooth(filter,pres)% -------------------------------------------------------------------------% 功能： 平滑图像% 调用：smooth(filter,pres)% 参数：% filter : 控制处理的被试数量，例如'20161001*';% pres : 生成的平滑之后的图像的前缀，例如's';% 示例：% filter = '20161003*';% pres = 's';% smooth(filter,pres);% 说明：平滑之后的图像与输入图像在同一文件夹，前缀不同% -------------------------------------------------------------------------clc;warning('off');%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%需要修改的变量，修改此处可以处理多个被试的数据%filter = '2016*';% 输入： wraf*开头的图像文件% 输出： 平滑之后的文件(与输入文件在同一文件夹中，前缀不一样)%-------------------------------% 配置参数：% filter : 控制处理的被试数量% pres : 输出图像的前缀% pre_processing_path ： wraf*开头的图像文件的绝对路径% run_num ： 每个RUN的文件数量(删除TR之后的数量)% runExpID : RUN文件夹名称，这里是'ep2d*'% filenames = dir('wraf*.img'); 输入图像以wraf开头% matlabbatch&#123;1&#125;.spm.spatial.smooth.fwhm = [4 4 4]; 控制平滑核大小% matlabbatch&#123;1&#125;.spm.spatial.smooth.prefix = 's4';输出文件的前缀%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%预处理文件夹，整个预处理过程保存在这里pre_processing_path = &#123;'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\pre_processing\\'&#125;;%删除空TR后每个run文件的数量run_num = 272;%开始处理 cd(pre_processing_path&#123;1&#125;);subExpID = dir(filter); %====================================for i=1:size(subExpID,1) cd([pre_processing_path&#123;1&#125;,subExpID(i).name]); diary smooth_output.txt; % 重定向控制台输出到文件 tic; %开始计时 %2.获得run的功能像文件 cd([pre_processing_path&#123;1&#125;,subExpID(i).name]); runExpID=dir('ep2d*'); for j=1:size(runExpID,1) cd ([pre_processing_path&#123;1&#125;,subExpID(i).name,'\\',runExpID(j).name]); filenames = dir('wraf*.img'); funcFilenames = cell(run_num,1);%每个run的文件集合 for k=1:size(filenames,1) funcFilenames&#123;k&#125; = [pre_processing_path&#123;1&#125;,subExpID(i).name,'\\',runExpID(j).name,'\\',filenames(k).name,',1']; end funcFilenames = &#123;funcFilenames&#125;; %%================================batch-begin===================================================%% spm_jobman('initcfg') matlabbatch&#123;1&#125;.spm.spatial.smooth.data = funcFilenames&#123;1&#125;; matlabbatch&#123;1&#125;.spm.spatial.smooth.fwhm = [4 4 4]; matlabbatch&#123;1&#125;.spm.spatial.smooth.dtype = 0; matlabbatch&#123;1&#125;.spm.spatial.smooth.im = 0; matlabbatch&#123;1&#125;.spm.spatial.smooth.prefix = pres; %%================================batch-end===================================================%% spm_jobman('run',matlabbatch); disp('smooth successful !'); clear matlabbatch end toc diary off ;end 图像计算函数的拓展(针对fMRI图像) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163function [Q,Vo] = spm_imcalc_extend(P,Q,f,flags,varargin)% Perform algebraic functions on images% FORMAT Q = spm_imcalc_ui(P,Q,f,flags)% P - matrix of input image filenames% [user prompted to select files if arg missing or empty]% Q - name of output image% [user prompted to enter filename if arg missing or empty]% f - expression to be evaluated% [user prompted to enter expression if arg missing or empty]% flags - cell vector of flags: &#123;dmtx,mask,type,hold&#125;% dmtx - Read images into data matrix?% [defaults (missing or empty) to 0 - no]% mask - implicit zero mask?% [defaults (missing or empty) to 0]% type - data type for output image (see spm_type)% [defaults (missing or empty) to 4 - 16 bit signed shorts]% hold - interpolation hold (see spm_slice_vol)% [defaults (missing or empty) to 0 - nearest neighbour]% Q (output) - full pathname of image written% Vo - structure containing information on output image (see spm_vol)%%_______________________________________________________________________%% spm_imcalc_ui uses spm_imcalc as an engine to perform user-specified% algebraic manipulations on a set of images, with the result being% written out as an image. The user is prompted to supply images to% work on, a filename for the output image, and the expression to% evaluate. The expression should be a standard matlab expression,% within which the images should be referred to as i1, i2, i3,... etc.%% If the dmtx flag is set, then images are read into a data matrix X% (rather than into seperate variables i1, i2, i3,...). The data matrix% should be referred to as X, and contains images in rows.%% Computation is plane by plane, so in data-matrix mode, X is a NxK% matrix, where N is the number of input images [prod(size(Vi))], and K% is the number of voxels per plane [prod(Vi(1).dim(1:2))].%% For data types without a representation of NaN, implicit zero masking% assummes that all zero voxels are to be treated as missing, and% treats them as NaN. NaN's are written as zero (by spm_write_plane),% for data types without a representation of NaN.%% With images of different sizes and orientations, the size and% orientation of the first is used for the output image. A warning is% given in this situation. Images are sampled into this orientation% using the interpolation specified by the hold parameter. [default -% nearest neighbour]%% The image Q is written to current working directory unless a valid% full pathname is given.%% Example expressions (f):%% i) Mean of six images (select six images)% f = '(i1+i2+i3+i4+i5+i6)/6'% ii) Make a binary mask image at threshold of 100% f = 'i1&gt;100'% iii) Make a mask from one image and apply to another% f = 'i2.*(i1&gt;100)'% - here the first image is used to make the mask, which is% applied to the second image% iv) Sum of n images% f = 'i1 + i2 + i3 + i4 + i5 + ...'% v) Sum of n images (when reading data into a data-matrix - use dmtx arg)% f = 'sum(X)'% % Parameters can be passed as arguments to override internal defaults% (for hold, mask &amp; type), or to pre-specify images (P), output% filename (Q), or expression (f). Pass empty matrices for arguments% not to be set.% E.g. Q = spm_imcalc_ui(&#123;&#125;,'test','',&#123;[],[],[],1&#125;)% ... pre-specifies the output filename as 'test.img' in the current% working directory, and sets the interpolation hold to tri-linear.%% Further, if calling spm_imcalc directly, additional variables for use in% the computation can be passed at the end of the argument list. These% should be referred to by the names of the arguments passed in the% expression to be evaluated. E.g. if c is a 1xn vector of weights, then% for n images, using the (dmtx) data-matrix version, the weighted sum can% be computed using:% Vi= spm_vol(spm_select(inf,'image'));% Vo= Vi(1);% Vo.fname = 'output.img';% Vo.pinfo(1:2) = Inf;% Q = spm_imcalc(Vi,Vo,'c*X',&#123;1&#125;,c)% Here we've pre-specified the expression and passed the vector c as an% additional variable (you'll be prompted to select the n images).%__________________________________________________________________________% Copyright (C) 2008 Wellcome Trust Centre for Neuroimaging% John Ashburner &amp; Andrew Holmes% $Id: spm_imcalc_ui.m 3691 2010-01-20 17:08:30Z guillaume $%-GUI setup%--------------------------------------------------------------------------SVNid = '$Rev: 3691 $';%[Finter,Fgraph,CmdLine] = spm('FnUIsetup','ImCalc',0);spm('FnBanner',mfilename,SVNid);%-Condition arguments%--------------------------------------------------------------------------if nargin&lt;4, flags=&#123;&#125;; endif nargin&lt;3, f=''; endif nargin&lt;2, Q=''; endif nargin&lt;1, P=&#123;&#125;; end%if isempty(P), P = %spm_select(Inf,'image','Select images to work on'); endif isempty(P), error('no input images specified'), end%if isempty(Q), Q = %spm_input('Output filename',1,'s'); endif isempty(f), f = spm_input('Evaluated Function',2,'s'); endif length(flags)&lt;4, hold=[]; else hold=flags&#123;4&#125;; endif isempty(hold), hold=0; endif length(flags)&lt;3, type=[]; else type=flags&#123;3&#125;; endif isempty(type), type=4; end, if ischar(type), type=spm_type(type); endif length(flags)&lt;2, mask=[]; else mask=flags&#123;2&#125;; endif isempty(mask), mask=0; endif length(flags)&lt;1, dmtx=[]; else dmtx=flags&#123;1&#125;; endif isempty(dmtx), dmtx=0; end%spm('FigName','ImCalc: working',Finter,CmdLine);%spm('Pointer','Watch')%-Map input files%--------------------------------------------------------------------------Vi = spm_vol(char(P));if isempty(Vi), error('no input images specified'), end%-Check for consistency of image dimensions and orientation / voxel size%--------------------------------------------------------------------------if length(Vi)&gt;1 &amp;&amp; any(any(diff(cat(1,Vi.dim),1,1),1)) warning(['images don''t all have same dimensions',... ' - using those of 1st image']);endif any(any(any(diff(cat(3,Vi.mat),1,3),3))) warning(['images don''t all have same orientation &amp; voxel size',... ' - using 1st image']);end%-Work out filename for output image%--------------------------------------------------------------------------[p n e] = spm_fileparts(Q);if isempty(p), p = pwd; endif ~exist(p,'dir') warning('Invalid directory: writing to current directory') p = pwd;endVo = struct('fname', fullfile(p, [n, e]),... 'dim', Vi(1).dim(1:3),... 'dt', [type spm_platform('bigend')],... 'mat', Vi(1).mat,... 'descrip', 'spm - algebra');%-Call spm_imcalc to handle computations%--------------------------------------------------------------------------args = &#123;dmtx,mask,hold&#125;;Vo = spm_imcalc(Vi,Vo,f,args);%-End%--------------------------------------------------------------------------%spm('Pointer');%spm('FigName','ImCalc: done',Finter,CmdLine);","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"认知神经科学","slug":"技术/认知神经科学","permalink":"http://ff120.github.io/hexoblog/categories/技术/认知神经科学/"}],"tags":[{"name":"fMRI","slug":"fMRI","permalink":"http://ff120.github.io/hexoblog/tags/fMRI/"}]},{"title":"多被试多RUN批量预处理(SPM)","slug":"技术/认知神经科学/多被试多RUN批量预处理(SPM)","date":"2017-03-20T12:50:00.000Z","updated":"2019-03-28T00:55:00.012Z","comments":true,"path":"2017/03/20/技术/认知神经科学/多被试多RUN批量预处理(SPM)/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/03/20/技术/认知神经科学/多被试多RUN批量预处理(SPM)/","excerpt":"使用SPM处理多个被试多个RUN的数据。代码涉及到的文件夹结构如下：","text":"使用SPM处理多个被试多个RUN的数据。代码涉及到的文件夹结构如下： ├─20160911002 被试文件夹 │ ├─ep2d_bold_moco_p2_rest_0006 第一个RUN │ ├─ep2d_bold_moco_p2_rest_0011 第二个RUN │ ├─ep2d_bold_moco_p2_rest_0016 第三个RUN │ ├─ep2d_bold_moco_p2_rest_0021 第四个RUN │ └─t1_mprage_sag_p2_0026 被试的结构像 │ ├─run1 │ ├─run2 │ ├─run3 │ └─run4 ├─20160916001 │ ├─ep2d_bold_moco_p2_rest_0006 │ ├─ep2d_bold_moco_p2_rest_0011 │ ├─ep2d_bold_moco_p2_rest_0016 │ ├─ep2d_bold_moco_p2_rest_0021 │ └─t1_mprage_sag_p2_0026 │ ├─run1 │ ├─run2 │ ├─run3 │ └─run4 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233function pre_processing(filter)% -------------------------------------------------------------------------% 功能： 数据预处理，包括 1.slice timing; 2. realign； 3.配准；4.分割；5.标准化；6.平滑% 调用： pre_processing(filter)% 参数：% filter:控制处理的被试，例如'20161001*' % 示例：% filter = ‘20161001*’;% pre_processing(filter);% 说明：输入图像需要满足预定的文件夹结构，该结构为使用SPM8 Batch进行格式转换默认生成的结构%--------------------------------------------------------------------------clc;warning('off');%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%需要修改的变量，修改此处可以处理多个被试的数据%filter = '20161024002*';% 输入： 经过格式转换之后的img,hdr图像% 输出： 预处理之后的图像和预处理的结果文件% 配置参数：% filter : 控制处理的被试数量% img_hdr_path ：img,hdr文件存放的绝对路径% pre_processing_path ： wraf*开头的图像文件的绝对路径% delete_filenameID ：预处理开始之前需要删除的TR。% run_num ： 每个RUN的文件数量(删除TR之后的数量)% innerMatlab_path ： SPM8工具箱中灰质，白质，脑脊液文件的路径，这个在分割的时候会用到，在不同电脑间移植的时候需要修改。% runExpID : RUN文件夹名称，这里是'ep2d*'% filenames = dir('wraf*.img'); 输入图像以wraf开头% matlabbatch&#123;1&#125;.spm.spatial.smooth.fwhm = [4 4 4]; 控制平滑核大小% matlabbatch&#123;1&#125;.spm.spatial.smooth.prefix = 's4';输出文件的前缀%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%转换完格式的文件存放的文件夹img_hdr_path = &#123;'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\img_hdr\\'&#125;;%预处理文件夹，整个预处理过程保存在这里pre_processing_path = &#123;'D:\\FMRI_ROOT\\YANTAI\\ANALYSIS\\pre_processing\\'&#125;;%要删除掉的TRdelete_filenameID = &#123;'*-00001-00001-*','*-00002-00002-*','*-00003-00003-*','*-00004-00004-*','*-00005-00005-*'&#125;;%删除空TR后每个run文件的数量run_num = 272;%内部路径，根据SPM8安装路径修改innerMatlab_path = &#123; 'C:\\mazcx\\matlabtoolbox\\spm8\\tpm\\csf.nii,1' 'C:\\mazcx\\matlabtoolbox\\spm8\\tpm\\grey.nii,1' 'C:\\mazcx\\matlabtoolbox\\spm8\\tpm\\white.nii,1' &#125;;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%预处理部分，主要内容：%1. 将格式转换后的文件复制一份到预处理文件夹%2. 删除掉多余的TR，只剩下需要的TR%3. 在结构像文件中新建4个run，把结构像复制到每个run下,配准的时候每个run都是用自己对应run的结构像%4. 以每个run为单位，运行预处理的batch文件%5. 控制处理的文件夹主要需要修改的变量：% 把代码中带=============注释的改成被试文件夹名称%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%将数据拷贝到预处理文件夹cd(img_hdr_path&#123;1&#125;);copyfile(filter,pre_processing_path&#123;1&#125;); %====================%删除多余的TRcd(pre_processing_path&#123;1&#125;);subExpID=dir (filter); %被试文件夹==================for i=1:size(subExpID,1) cd ([pre_processing_path&#123;1&#125;,subExpID(i).name]); runExpID = dir('ep2d*'); %run 文件夹++++++++++++++++++++++++ for j=1:size(runExpID,1) cd ([pre_processing_path&#123;1&#125;,subExpID(i).name,'\\',runExpID(j).name]); for k = 1:size(delete_filenameID,2) delete(cell2mat(delete_filenameID(k))); end endend%复制4个run的结构像cd(pre_processing_path&#123;1&#125;);subExpID = dir(filter); %=========================for i=1:size(subExpID,1) cd([pre_processing_path&#123;1&#125;,subExpID(i).name]); t1ExpID = dir('t1*'); cd(t1ExpID.name); mkdir('run1'); copyfile('s*',[pre_processing_path&#123;1&#125;,subExpID(i).name,'\\',t1ExpID.name,'\\run1\\']); mkdir('run2'); copyfile('s*',[pre_processing_path&#123;1&#125;,subExpID(i).name,'\\',t1ExpID.name,'\\run2\\']); mkdir('run3'); copyfile('s*',[pre_processing_path&#123;1&#125;,subExpID(i).name,'\\',t1ExpID.name,'\\run3\\']); mkdir('run4'); copyfile('s*',[pre_processing_path&#123;1&#125;,subExpID(i).name,'\\',t1ExpID.name,'\\run4\\']);end%开始预处理 cd(pre_processing_path&#123;1&#125;);subExpID = dir(filter); %====================================for i=1:size(subExpID,1) cd([pre_processing_path&#123;1&#125;,subExpID(i).name]); diary pre_processing_output.txt; % 重定向控制台输出到文件 tic; %开始计时 %1. 获得4个结构像文件 t1ExpID = dir('t1*'); cd([pre_processing_path&#123;1&#125;,subExpID(i).name,'\\',t1ExpID(1).name]);%切换到t1像 runID = dir('run*'); data3D_filenames=cell(4,1);%4个run的结构像文件 for j=1:size(runID,1) cd([pre_processing_path&#123;1&#125;,subExpID(i).name,'\\',t1ExpID(1).name,'\\',runID(j).name]) filenames = dir('s*.img'); data3D_filenames&#123;j&#125; = [pre_processing_path&#123;1&#125;,subExpID(i).name,'\\',t1ExpID(1).name,'\\',runID(j).name,'\\',filenames(1).name,',1']; end %2.获得run的功能像文件 cd([pre_processing_path&#123;1&#125;,subExpID(i).name]); runExpID=dir('ep2d*'); for j=1:size(runExpID,1) cd ([pre_processing_path&#123;1&#125;,subExpID(i).name,'\\',runExpID(j).name]); filenames = dir('f*.img'); funcFilenames = cell(run_num,1);%每个run的文件集合 for k=1:size(filenames,1) funcFilenames&#123;k&#125; = [pre_processing_path&#123;1&#125;,subExpID(i).name,'\\',runExpID(j).name,'\\',filenames(k).name,',1']; end funcFilenames = &#123;funcFilenames&#125;; data3D_filename = &#123; data3D_filenames&#123;j&#125; &#125;; %%================================batch-begin===================================================%% spm_jobman('initcfg') matlabbatch&#123;1&#125;.spm.temporal.st.scans = funcFilenames; matlabbatch&#123;1&#125;.spm.temporal.st.nslices = 33; matlabbatch&#123;1&#125;.spm.temporal.st.tr = 2; matlabbatch&#123;1&#125;.spm.temporal.st.ta = 1.93939393939394; matlabbatch&#123;1&#125;.spm.temporal.st.so = [1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32]; matlabbatch&#123;1&#125;.spm.temporal.st.refslice = 33; matlabbatch&#123;1&#125;.spm.temporal.st.prefix = 'a'; matlabbatch&#123;2&#125;.spm.spatial.realign.estwrite.data&#123;1&#125;(1) = cfg_dep; matlabbatch&#123;2&#125;.spm.spatial.realign.estwrite.data&#123;1&#125;(1).tname = 'Session'; matlabbatch&#123;2&#125;.spm.spatial.realign.estwrite.data&#123;1&#125;(1).tgt_spec&#123;1&#125;(1).name = 'filter'; matlabbatch&#123;2&#125;.spm.spatial.realign.estwrite.data&#123;1&#125;(1).tgt_spec&#123;1&#125;(1).value = 'image'; matlabbatch&#123;2&#125;.spm.spatial.realign.estwrite.data&#123;1&#125;(1).tgt_spec&#123;1&#125;(2).name = 'strtype'; matlabbatch&#123;2&#125;.spm.spatial.realign.estwrite.data&#123;1&#125;(1).tgt_spec&#123;1&#125;(2).value = 'e'; matlabbatch&#123;2&#125;.spm.spatial.realign.estwrite.data&#123;1&#125;(1).sname = 'Slice Timing: Slice Timing Corr. Images (Sess 1)'; matlabbatch&#123;2&#125;.spm.spatial.realign.estwrite.data&#123;1&#125;(1).src_exbranch = substruct('.','val', '&#123;&#125;',&#123;1&#125;, '.','val', '&#123;&#125;',&#123;1&#125;, '.','val', '&#123;&#125;',&#123;1&#125;); matlabbatch&#123;2&#125;.spm.spatial.realign.estwrite.data&#123;1&#125;(1).src_output = substruct('()',&#123;1&#125;, '.','files'); matlabbatch&#123;2&#125;.spm.spatial.realign.estwrite.eoptions.quality = 0.9; matlabbatch&#123;2&#125;.spm.spatial.realign.estwrite.eoptions.sep = 4; matlabbatch&#123;2&#125;.spm.spatial.realign.estwrite.eoptions.fwhm = 5; matlabbatch&#123;2&#125;.spm.spatial.realign.estwrite.eoptions.rtm = 1; matlabbatch&#123;2&#125;.spm.spatial.realign.estwrite.eoptions.interp = 2; matlabbatch&#123;2&#125;.spm.spatial.realign.estwrite.eoptions.wrap = [0 0 0]; matlabbatch&#123;2&#125;.spm.spatial.realign.estwrite.eoptions.weight = ''; matlabbatch&#123;2&#125;.spm.spatial.realign.estwrite.roptions.which = [2 1]; matlabbatch&#123;2&#125;.spm.spatial.realign.estwrite.roptions.interp = 4; matlabbatch&#123;2&#125;.spm.spatial.realign.estwrite.roptions.wrap = [0 0 0]; matlabbatch&#123;2&#125;.spm.spatial.realign.estwrite.roptions.mask = 1; matlabbatch&#123;2&#125;.spm.spatial.realign.estwrite.roptions.prefix = 'r'; matlabbatch&#123;3&#125;.spm.spatial.coreg.estimate.ref(1) = cfg_dep; matlabbatch&#123;3&#125;.spm.spatial.coreg.estimate.ref(1).tname = 'Reference Image'; matlabbatch&#123;3&#125;.spm.spatial.coreg.estimate.ref(1).tgt_spec&#123;1&#125;(1).name = 'filter'; matlabbatch&#123;3&#125;.spm.spatial.coreg.estimate.ref(1).tgt_spec&#123;1&#125;(1).value = 'image'; matlabbatch&#123;3&#125;.spm.spatial.coreg.estimate.ref(1).tgt_spec&#123;1&#125;(2).name = 'strtype'; matlabbatch&#123;3&#125;.spm.spatial.coreg.estimate.ref(1).tgt_spec&#123;1&#125;(2).value = 'e'; matlabbatch&#123;3&#125;.spm.spatial.coreg.estimate.ref(1).sname = 'Realign: Estimate &amp; Reslice: Mean Image'; matlabbatch&#123;3&#125;.spm.spatial.coreg.estimate.ref(1).src_exbranch = substruct('.','val', '&#123;&#125;',&#123;2&#125;, '.','val', '&#123;&#125;',&#123;1&#125;, '.','val', '&#123;&#125;',&#123;1&#125;, '.','val', '&#123;&#125;',&#123;1&#125;); matlabbatch&#123;3&#125;.spm.spatial.coreg.estimate.ref(1).src_output = substruct('.','rmean'); matlabbatch&#123;3&#125;.spm.spatial.coreg.estimate.source = data3D_filename; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% matlabbatch&#123;3&#125;.spm.spatial.coreg.estimate.other = &#123;''&#125;; matlabbatch&#123;3&#125;.spm.spatial.coreg.estimate.eoptions.cost_fun = 'nmi'; matlabbatch&#123;3&#125;.spm.spatial.coreg.estimate.eoptions.sep = [4 2]; matlabbatch&#123;3&#125;.spm.spatial.coreg.estimate.eoptions.tol = [0.02 0.02 0.02 0.001 0.001 0.001 0.01 0.01 0.01 0.001 0.001 0.001]; matlabbatch&#123;3&#125;.spm.spatial.coreg.estimate.eoptions.fwhm = [7 7]; matlabbatch&#123;4&#125;.spm.spatial.preproc.data = data3D_filename ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% matlabbatch&#123;4&#125;.spm.spatial.preproc.output.GM = [0 0 1]; matlabbatch&#123;4&#125;.spm.spatial.preproc.output.WM = [0 0 1]; matlabbatch&#123;4&#125;.spm.spatial.preproc.output.CSF = [0 0 1]; matlabbatch&#123;4&#125;.spm.spatial.preproc.output.biascor = 1; matlabbatch&#123;4&#125;.spm.spatial.preproc.output.cleanup = 1; matlabbatch&#123;4&#125;.spm.spatial.preproc.opts.tpm = innerMatlab_path; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% matlabbatch&#123;4&#125;.spm.spatial.preproc.opts.ngaus = [2 2 2 4]; matlabbatch&#123;4&#125;.spm.spatial.preproc.opts.regtype = 'mni'; matlabbatch&#123;4&#125;.spm.spatial.preproc.opts.warpreg = 1; matlabbatch&#123;4&#125;.spm.spatial.preproc.opts.warpco = 25; matlabbatch&#123;4&#125;.spm.spatial.preproc.opts.biasreg = 0.0001; matlabbatch&#123;4&#125;.spm.spatial.preproc.opts.biasfwhm = 60; matlabbatch&#123;4&#125;.spm.spatial.preproc.opts.samp = 3; matlabbatch&#123;4&#125;.spm.spatial.preproc.opts.msk = &#123;''&#125;; matlabbatch&#123;5&#125;.spm.spatial.normalise.write.subj.matname(1) = cfg_dep; matlabbatch&#123;5&#125;.spm.spatial.normalise.write.subj.matname(1).tname = 'Parameter File'; matlabbatch&#123;5&#125;.spm.spatial.normalise.write.subj.matname(1).tgt_spec&#123;1&#125;(1).name = 'filter'; matlabbatch&#123;5&#125;.spm.spatial.normalise.write.subj.matname(1).tgt_spec&#123;1&#125;(1).value = 'mat'; matlabbatch&#123;5&#125;.spm.spatial.normalise.write.subj.matname(1).tgt_spec&#123;1&#125;(2).name = 'strtype'; matlabbatch&#123;5&#125;.spm.spatial.normalise.write.subj.matname(1).tgt_spec&#123;1&#125;(2).value = 'e'; matlabbatch&#123;5&#125;.spm.spatial.normalise.write.subj.matname(1).sname = 'Segment: Norm Params Subj-&gt;MNI'; matlabbatch&#123;5&#125;.spm.spatial.normalise.write.subj.matname(1).src_exbranch = substruct('.','val', '&#123;&#125;',&#123;4&#125;, '.','val', '&#123;&#125;',&#123;1&#125;, '.','val', '&#123;&#125;',&#123;1&#125;); matlabbatch&#123;5&#125;.spm.spatial.normalise.write.subj.matname(1).src_output = substruct('()',&#123;1&#125;, '.','snfile', '()',&#123;':'&#125;); matlabbatch&#123;5&#125;.spm.spatial.normalise.write.subj.resample(1) = cfg_dep; matlabbatch&#123;5&#125;.spm.spatial.normalise.write.subj.resample(1).tname = 'Images to Write'; matlabbatch&#123;5&#125;.spm.spatial.normalise.write.subj.resample(1).tgt_spec&#123;1&#125;(1).name = 'filter'; matlabbatch&#123;5&#125;.spm.spatial.normalise.write.subj.resample(1).tgt_spec&#123;1&#125;(1).value = 'image'; matlabbatch&#123;5&#125;.spm.spatial.normalise.write.subj.resample(1).tgt_spec&#123;1&#125;(2).name = 'strtype'; matlabbatch&#123;5&#125;.spm.spatial.normalise.write.subj.resample(1).tgt_spec&#123;1&#125;(2).value = 'e'; matlabbatch&#123;5&#125;.spm.spatial.normalise.write.subj.resample(1).sname = 'Realign: Estimate &amp; Reslice: Resliced Images (Sess 1)'; matlabbatch&#123;5&#125;.spm.spatial.normalise.write.subj.resample(1).src_exbranch = substruct('.','val', '&#123;&#125;',&#123;2&#125;, '.','val', '&#123;&#125;',&#123;1&#125;, '.','val', '&#123;&#125;',&#123;1&#125;, '.','val', '&#123;&#125;',&#123;1&#125;); matlabbatch&#123;5&#125;.spm.spatial.normalise.write.subj.resample(1).src_output = substruct('.','sess', '()',&#123;1&#125;, '.','rfiles'); matlabbatch&#123;5&#125;.spm.spatial.normalise.write.roptions.preserve = 0; matlabbatch&#123;5&#125;.spm.spatial.normalise.write.roptions.bb = [-90 -126 -72 90 90 108]; matlabbatch&#123;5&#125;.spm.spatial.normalise.write.roptions.vox = [3 3 3]; matlabbatch&#123;5&#125;.spm.spatial.normalise.write.roptions.interp = 1; matlabbatch&#123;5&#125;.spm.spatial.normalise.write.roptions.wrap = [0 0 0]; matlabbatch&#123;5&#125;.spm.spatial.normalise.write.roptions.prefix = 'w'; matlabbatch&#123;6&#125;.spm.spatial.smooth.data(1) = cfg_dep; matlabbatch&#123;6&#125;.spm.spatial.smooth.data(1).tname = 'Images to Smooth'; matlabbatch&#123;6&#125;.spm.spatial.smooth.data(1).tgt_spec&#123;1&#125;(1).name = 'filter'; matlabbatch&#123;6&#125;.spm.spatial.smooth.data(1).tgt_spec&#123;1&#125;(1).value = 'image'; matlabbatch&#123;6&#125;.spm.spatial.smooth.data(1).tgt_spec&#123;1&#125;(2).name = 'strtype'; matlabbatch&#123;6&#125;.spm.spatial.smooth.data(1).tgt_spec&#123;1&#125;(2).value = 'e'; matlabbatch&#123;6&#125;.spm.spatial.smooth.data(1).sname = 'Normalise: Write: Normalised Images (Subj 1)'; matlabbatch&#123;6&#125;.spm.spatial.smooth.data(1).src_exbranch = substruct('.','val', '&#123;&#125;',&#123;5&#125;, '.','val', '&#123;&#125;',&#123;1&#125;, '.','val', '&#123;&#125;',&#123;1&#125;, '.','val', '&#123;&#125;',&#123;1&#125;); matlabbatch&#123;6&#125;.spm.spatial.smooth.data(1).src_output = substruct('()',&#123;1&#125;, '.','files'); matlabbatch&#123;6&#125;.spm.spatial.smooth.fwhm = [6 6 6]; matlabbatch&#123;6&#125;.spm.spatial.smooth.dtype = 0; matlabbatch&#123;6&#125;.spm.spatial.smooth.im = 0; matlabbatch&#123;6&#125;.spm.spatial.smooth.prefix = 's'; %%================================batch-end===================================================%% spm_jobman('run',matlabbatch); disp('pre_processing successful !'); clear matlabbatch end toc diary off ;end","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"认知神经科学","slug":"技术/认知神经科学","permalink":"http://ff120.github.io/hexoblog/categories/技术/认知神经科学/"}],"tags":[{"name":"fMIRI","slug":"fMIRI","permalink":"http://ff120.github.io/hexoblog/tags/fMIRI/"}]},{"title":"认知神经科学系列目录","slug":"技术/认知神经科学/认知神经科学系列目录","date":"2017-03-09T09:07:26.000Z","updated":"2019-03-28T00:55:00.063Z","comments":true,"path":"2017/03/09/技术/认知神经科学/认知神经科学系列目录/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/03/09/技术/认知神经科学/认知神经科学系列目录/","excerpt":"the outline of a series of article about neuroscience.","text":"the outline of a series of article about neuroscience. ## start ### 神经科学的常用探测方法 1.主要介绍目前比较有效的几种设备。 数据格式和常用软件 介绍常用的数据格式和常用的数据处理软件 功能磁共振成像原理 FMRI数据预处理和统计分析 常用的分析数据的方法 MVPA 功能连接 有效连接 signal change RSA 常用的看图工具和画图工具","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"认知神经科学","slug":"技术/认知神经科学","permalink":"http://ff120.github.io/hexoblog/categories/技术/认知神经科学/"}],"tags":[{"name":"neuroscience","slug":"neuroscience","permalink":"http://ff120.github.io/hexoblog/tags/neuroscience/"}]},{"title":"基于连接信息的脑信息解码研究","slug":"技术/认知神经科学/基于连接的脑信息解码研究","date":"2017-03-09T08:39:24.000Z","updated":"2019-03-28T00:54:59.982Z","comments":true,"path":"2017/03/09/技术/认知神经科学/基于连接的脑信息解码研究/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/03/09/技术/认知神经科学/基于连接的脑信息解码研究/","excerpt":"基于连接信息的脑信息解码研究","text":"基于连接信息的脑信息解码研究 aaa","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"认知神经科学","slug":"技术/认知神经科学","permalink":"http://ff120.github.io/hexoblog/categories/技术/认知神经科学/"}],"tags":[{"name":"解码","slug":"解码","permalink":"http://ff120.github.io/hexoblog/tags/解码/"}]},{"title":"基于贝叶斯网络和隐性知识的AU识别研究","slug":"技术/认知神经科学/基于贝叶斯网络和隐性知识的AU识别研究","date":"2017-03-08T11:17:19.000Z","updated":"2019-03-28T00:54:59.954Z","comments":true,"path":"2017/03/08/技术/认知神经科学/基于贝叶斯网络和隐性知识的AU识别研究/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/03/08/技术/认知神经科学/基于贝叶斯网络和隐性知识的AU识别研究/","excerpt":"贝叶斯网络 人脸检测 AU识别","text":"贝叶斯网络 人脸检测 AU识别 AU AU是一种描述面部运动状态的机制，是Ekman和Friesen[1]首先提出来的。他们在实验中观察人类面部表情的产生和面部肌肉运动的关系，发现肌肉的运动是产生各种不同表情的关键因素。于是，Ekman和Friesen将不同的肌肉运动状态记作不同的AU，然后通过AU或者AU组合分解表情。 FACS是由美国心理学家Ekman和Friesen在研究了脸部肌肉运动和人类面部表情控制之间的关系后所提出来的。Ekman和Friesen通过研究比较人类的各种表情动作，发现几乎所有的表情都与面部肌肉的收缩运动有关系。根据这一特点, 二人将人脸划分成大约46个AU,每个AU表示一个独立的面部肌肉运动状态。 2002年，Ekman等人又给出了FACS的一个新版本FACS+。FACS+共包含55个AU。其中41个描述表情变化的肌肉运动，剩余的14个描述头部和眼睛的运动。新的FACS对AU的描述更加符合人类视觉对面部动作的感知规则，是目前已知的最好的描述面部运动的编码系统。 AU识别的主要步骤： 人脸检测 人脸检测就是要在给定的图像中检测到人脸所在的区域，并将该区域提取出来，处理成统一的格式的过程。人脸检测技术是进行许多人工智能问题研究的前提条件和关键环节，一个完善的人脸检测系统要求能够适应各种复杂条件下的图像，能够处理遮挡，角度，清晰度变化等带来的影响。 基于统计的方法是目前应用较多，发展迅速的一类方法。LDA，PCA，ICA，SVM等都是基于统计的方法。基于统计的方法的优点是对各种条件的变化有比较高的鲁棒性，但是这些算法通常比较复杂。 ## 特征提取 肌肉运动可以从不同的角度表示，这就产生了不同的特征提取方法。一种角度是从静态来看，肌肉的某种运动状态必然对应一种特征。另外一种是从动态来看，肌肉的运动方向和位置也能标识出AU ### 基于几何特征的方法 基于几何特征的特征提取方法主要包含2个关键问题：一是如何选择特征点以及提取什么样的特征，二是如何准确有效的定位跟踪特征点。 一般情况下，特征点应该选择有明显形变或与其他部位易于区分的部位，如嘴巴、眉毛、眼睛、鼻子的边缘点。实验表明，这些关键点信息含量高，易于提取，受光照、头部运动等影响较小，能够取得较好的识别效果。 特征点的精确定位和动态跟踪十分重要，对后续的识别影响很大。现有的定位方法主要有基于先验规则的方法，Snake，ASM，AAM等。 AAM改进了ASM算法，加入的纹理特征。AAM是包含了图像的形状信息和纹理信息的统计模型，具有强大的建模能力，近年来被广泛应用于图像分析。 后来，许多专家学者改进了AAM算法，使它的应用范围更加广泛。例如，Gallou和Guier使用像素的角度信息替代原本的灰度信息，得到对光照和姿态变化有很好鲁棒性的新算法 基于外貌特征的方法 基于外貌特征的提取算法通过获取像素之间的梯度、纹理和相关性等信息作为AU识别的依据。常用的基于外貌特征的方法有很多，KPCA、PCA、ICA、LFA、FLD、LBP、Harr、Garor等都是基于外貌特征的特征提取算法。该类算法通常受光照、肤色、图像质量的影响较大，首先需要进行灰度归一化等处理。归一化处理主要的目的是消除这些变化对算法的影响。 Bazzo提出一种在差分图像上提取Garbor特征的新算法，实现了对不同种族，包含微小头部运动的人脸图像的较高的AU识别率 基于混合特征的方法 不同的特征提取方法都有各自的优势和劣势，所以很自然的研究人员就想到将不同的特征提取算法结合起来，发挥优势，减少劣势，于是出现了各种各样的混合特征的提取算法。 外貌特征反映人脸像素信息，信息详细丰富，但是受姿态、光照、遮挡等影响较大；几何特征反映人脸形变信息，信息量较小，但不容易受影响。将二者结合，也能提高识别效果。在混合使用特征方面。 主动外观模型 am_tools 工具箱 Am_tools是由Tim Cootes开发的特征提取工具箱[57]。它实现了常用的特征提取算法，并提供命令行工具和API供其他研究者使用。利用该工具箱可以方便的实现建立表观模型(am_build_apm)，建立主动外观模型（am_build_aam）,产生和编辑三角剖分（am_tri_editor）,利用模型产生图像(am_make_image)。am_tools实现了所有AAM算法中用到的算法，并提供了友好的交互方式控制各个参数，分析比较实验结果 Am_tools工具包含四个主要的文件夹，images,points,models,win_bin.其中image是存放图像数据的，points是存放图像上的特征点的数据的，models存放的描述模型的数据文件，以上这三个文件夹构成AAM算法的实验材料。Win_bin里面存放的是各种算法工具，这些算法都是编辑好并经过优化的。下面几张图列举了使用am_tools观察的几个算法处理过程。 贝叶斯网络 贝叶斯网是一种基于概率论的图结构。概率的贝叶斯解释认为概率是事件发生的合理信度，可以根据相关的经验给出一个事件的先验概率，这样就可以将已有的经验带入推理当中，提高推理的准确性。 贝叶斯推理 联合概率的推理问题是一个及其复杂的问题，因为其困难度会随着变量的个数指数级增长。贝叶斯网络是联合概率的分解表示，它在一定程度上简化了推理算法，降低了推理过程中算法的复杂度。 BNT工具箱 BNT其实是一个贝叶斯网相关算法的实现集合。BNT中实现了大部分相关算法，非常适合基于MATLAB的编程者引用。使用它，能够大大提高编程效率。 表情数据库 JAFFE数据库 该数据库是在基本表情识别中最常见的数据库。包含的6种基本表情和中性表情。 ### Yale Face 数据库 该数据库共包含165幅图像，它是面部图像种类最齐全的数据库。 ### MMI表情库 MMI表情数据库是记录面部行为最为全面的数据库，包括19-62岁之间的50个人的正面和侧面人脸图像。 ### AAI表情库 AAI表情数据库记录的全部都是自发表情，该数据库记录了60个成年人对童年经历描述时产生的自发表情，每个人持续30-60分钟。 ### CK表情库 CK表情数据库是在AU识别领域使用最为广泛的数据库，目前为止一共有三个版本","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"认知神经科学","slug":"技术/认知神经科学","permalink":"http://ff120.github.io/hexoblog/categories/技术/认知神经科学/"}],"tags":[{"name":"图像处理","slug":"图像处理","permalink":"http://ff120.github.io/hexoblog/tags/图像处理/"}]},{"title":"基于视频的车牌识别和流量统计","slug":"技术/认知神经科学/基于视频的车牌识别和流量统计","date":"2017-03-08T08:12:08.000Z","updated":"2019-03-28T00:54:59.915Z","comments":true,"path":"2017/03/08/技术/认知神经科学/基于视频的车牌识别和流量统计/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/03/08/技术/认知神经科学/基于视频的车牌识别和流量统计/","excerpt":"基于视频的车牌识别和流量统计","text":"基于视频的车牌识别和流量统计 车流量统计功能 读取视频数据 针对读入的每帧图像，转换成灰度图像；cvCvtColor(frame, pFrImg, CV_BGR2GRAY); 做高斯滤波，平滑图像；cvSmooth(pFrameMat, pFrameMat, CV_GAUSSIAN, 3, 0, 0); 背景差分，当前图像和北京图像做差；cvAbsDiff(pFrameMat, pBkMat, pFrMat); 二值化前景图，（前面的是灰度图像，现在是二值图像，只有黑白两色，背景是黑色，运动物体是白色） 更新背景;cvRunningAvg(pFrameMat, pBkMat, 0.1, 0); 上面的步骤完成运动物体的检测，现在视频流被处理成黑白两色，运动的车辆是白色，背景是黑色。下面使用撞线检测的方法检测是否有车辆通过。 统计一个固定区域的像素平均值，当有车辆经过时，这个地方的像素均值急剧增大，当它过去的时候，像素均值急剧减少，通过捕捉这个变化，确定是否有车通过。 针对连续通过的车辆，从时间和中间的变化来判断 针对多个车道，初始的时候有一个检测车道的方法，把车道的数据存储起来，分别对每个车道统计； 针对跨越车道的车辆，就是一半在这个车道，一半在另外一个车道的， 采用两个车道合并的数据，看统一时间相邻的车道是否有宽度合并起来约为一辆车的，计算为一辆车。 每当检测出有车辆经过的时候，捕捉这辆车的车牌位置的彩色高清截图，保存下来。 车牌识别功能 输入是上面保存的图片 在HSV空间判断像素的颜色，提取颜色特征 提取图像的纹理特征。 在颜色特征和纹理特征的基础上，粗定位车牌的位置 精细搜索，定位车牌的位置，保存车牌图片，用于后面的识别。 上面的步骤完成车牌的定位，此时每辆车的车牌图像已经被保存下来了，下面是最关键的文字识别。识别采用的是模版匹配的方法，即我们预先有所有字母和数字和所有省份缩写的模版。 分割图像（依据连通域和字符的宽度和高度） 针对分割出来的每个字符(汉字，数字，字母)， 计算和模版图片的相似度，取相似度最高的作为输出 对ODQ，2Z，5S，8B，等相似字符进行二次检测 HSV二值化： HSV颜色空间：比较适合用来分割不同的颜色。 车牌一般为黄色和蓝色，我们使用HSV颜色空间来寻找车牌的位置 纹理二值化 模版匹配： 模版匹配是寻找目标图像的方法之一，它通过在输入图像上滑动图像块对实际的图像块和输入图像进行匹配。 我们使用预定义的字母模版匹配车牌上分割下来的字母和数字，以识别牌照上的字母和数字。 背景差分 根据前N帧图像的灰度值进行区间统计从而得到一个具有统计意义的初始背景。 当前的最新图像与背景做差，即可求得背景差图，然后根据一定的方法对图进行二值化，就能获得运动物体。 图像二值化的一个关键是阈值的选取，目前采用的方法有最大类间方差法，一维交叉熵阈值法，二维交叉熵阈值法。 背景的更新使用的是OPENCV实现的一个滑动平均的方法 1cvRunningAvg( const CvArr* image, CvArr* acc, double alpha, const CvArr* mask=NULL ); 可以通过设置alpha的值来更新背景，alpha越大，背景更新的越快。","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"认知神经科学","slug":"技术/认知神经科学","permalink":"http://ff120.github.io/hexoblog/categories/技术/认知神经科学/"}],"tags":[{"name":"车牌识别","slug":"车牌识别","permalink":"http://ff120.github.io/hexoblog/tags/车牌识别/"}]},{"title":"circos入门教程","slug":"技术/认知神经科学/circos入门教程","date":"2017-01-03T13:08:48.000Z","updated":"2019-03-28T00:54:59.394Z","comments":true,"path":"2017/01/03/技术/认知神经科学/circos入门教程/","link":"","permalink":"http://ff120.github.io/hexoblog/2017/01/03/技术/认知神经科学/circos入门教程/","excerpt":"","text":"## circos简介 circos是设计用来专门绘制基因图的，但是其应用并不仅仅局限于此，它能胜任任何需要绘制环状图像的地方。 例如在认知神经科学中表示脑区之间的连接。本教程旨在实现绘制以下图像： 该图主要由几个部分组成： 1 chromosome（染色体）； 2 label（标签）；3 links（连接）; 4 间隔 我们要实现这样一个任务： 用chromosome表示脑区，用chromosome长度表示与脑区的关联量，例如脑区体素数量; 用links表示脑区之间的连接,用links线的颜色和粗细以及层次表示连接的强度（例如，连接越强，颜色越鲜艳，线越粗，越靠上层）; 用间隔表示分组，例如分成大脑和小脑。 circos安装 circos是运行在perl环境下的跨平台的工具包，只要安装好perl环境，直接解压缩circos的代码就能运行。 ### 安装perl环境 Linux下可以直接安装perl,windows最好使用集成环境，例如Strawberry Perl Strawberry Perl windows 7 旗舰版 64位安装包下载地址: http://strawberryperl.com/download/5.24.0.1/strawberry-perl-5.24.0.1-64bit.msi 安装过程和普通的Windows程序没有区别，一路下一步就可以。 安装完成后，打开CMD，输入perl -v, 出现版本信息就证明安装成功了。 下载circos circos主程序：http://circos.ca/distribution/circos-0.69-3.tgz circos示例程序：http://circos.ca/distribution/circos-tutorials-0.67.tgz 下载完后解压缩到任意位置（需要解压缩两次，推荐用7z）,切换到bin目录下，键入circos: 如果出现missing …是因为有些circos需要的模块没有安装。 安装perl模块 在CMD键入cpan命令，进入cpan环境 输入install 模块名 就会完成自动下载安装过程。 模块名可以从上面的报错信息中找到。 丢失的模块全部完后，可以按照一下方法做一个测试。 在bin文件夹下面新建一个test文件夹，test内新建一个名称为helloword.conf的文件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# MINIMUM CIRCOS CONFIGURATION## The 'hello world' Circos tutorial. Only required# configuration elements are included.## Common optional elements are commented out.# Defines unit length for ideogram and tick spacing, referenced# using \"u\" prefix, e.g. 10u#chromosomes_units = 1000000# Show all chromosomes in karyotype file. By default, this is# true. If you want to explicitly specify which chromosomes# to draw, set this to 'no' and use the 'chromosomes' parameter.# chromosomes_display_default = yes# Chromosome name, size and color definitionkaryotype = data/karyotype/karyotype.human.txt&lt;ideogram&gt;&lt;spacing&gt;# spacing between ideogramsdefault = 0.05r&lt;/spacing&gt;# ideogram position, thickness and fillradius = 0.20rthickness = 100pfill = yes#stroke_thickness = 1#stroke_color = black# ideogram labels# &lt;&lt;include ideogram.label.conf&gt;&gt;# ideogram cytogenetic bands, if defined in the karyotype file# &lt;&lt;include bands.conf&gt;&gt;&lt;/ideogram&gt;# image size, background color, angular position# of first ideogram, transparency levels, output# file and directory## it is best to include these parameters from etc/image.conf# and override any using param* syntax## e.g.# &lt;image&gt;# &lt;&lt;include etc/image.conf&gt;&gt;# radius* = 500# &lt;/image&gt;&lt;image&gt;&lt;&lt;include etc/image.conf&gt;&gt; # included from Circos distribution&lt;/image&gt;# RGB/HSV color definitions, color lists, location of fonts,# fill patterns&lt;&lt;include etc/colors_fonts_patterns.conf&gt;&gt; # included from Circos distribution# debugging, I/O an dother system parameters&lt;&lt;include etc/housekeeping.conf&gt;&gt; # included from Circos distribution# &lt;ticks&gt; blocks to define ticks, tick labels and grids## requires that chromosomes_units be defined## &lt;&lt;include ticks.conf&gt;&gt; 然后在CMD输入命令perl circos -conf test\\helloword.conf,会有类似下面的输出 默认会在当前目录下生成circos.png 和 circos,svg两个文件 至此，完成了circos的安装，生成了一个最简单的图像。 circos基本概念 组织结构 circos 生成图像所需要的所有内容都保存在一个配置文件中，例如 helloword.conf 这个配置文件以XML的格式来组织。 - &lt;ideogram&gt;&lt;/ideagram&gt; 标签内定义chromosome的相关属性，例如radius，thickness，fill，，， 12345678910111213141516171819202122&lt;ideogram&gt; &lt;spacing&gt; # spacing between ideograms default = 0.05r &lt;/spacing&gt;# ideogram position, thickness and fillradius = 0.20rthickness = 100pfill = yes#stroke_thickness = 1#stroke_color = black# ideogram labels# &lt;&lt;include ideogram.label.conf&gt;&gt;# ideogram cytogenetic bands, if defined in the karyotype file# &lt;&lt;include bands.conf&gt;&gt;&lt;/ideogram&gt; &lt;image&gt;&lt;/image&gt;标签内定义生成的图像的一些属性，例如生成路径，文件名等 12345678&lt;image&gt;&lt;&lt;include etc/image.conf&gt;&gt;# generated image pathdir* = D:\\FMRI_ROOT\\YIYU\\CONN\\PNG# generated image namefile* = 1.png&lt;/image&gt; &lt;links&gt;&lt;/links&gt; 标签内可定义若干标签，每一对都是一组连接 1234567891011121314151617181920212223242526272829&lt;links&gt;#ribbon = yes#flat = yes&lt;link&gt;file = links1000.data.txt # links 文件路径radius = 0.99rcolor = red# Curves look best when this value is small (e.g. 0.1r or 0r)bezier_radius = 0.1rthickness = 2# These parameters have default values. To unset them# use &apos;undef&apos;#crest = undef#bezier_radius_purity = undef# Limit how many links to read from file and drawrecord_limit = 40000#&lt;rule&gt;#condition = var(intrachr) &amp;&amp; abs(var(pos1)-var(pos2)) &lt; 10Mb#show = no#color = red#&lt;/rule&gt;&lt;/link&gt;&lt;/links&gt; karyotype 定义染色体文件路径 1karyotype = brainnetome.data.txt 染色体文件 染色体文件在配置文件中用关键字karyotype = data.txt指明。染色体就是环上要显示的实体。数据格式如下： 1234b parent ID label start end color optionschr - hs1 g1 0 100 red thickness=3chr - hs2 g2 0 88 blue color=blue,thickness=5 b 是circos中的保留关键字，可以是chr，代表该行定义的是染色体，可以是band，代表该行定义的是band. band就是染色体上一条染色带。 parent 定义该行的父元素，-表示没有父元素。 ID 该行的标识符，通过ID可以唯一的找到该行 label 将来显示在图像中的该染色体的名字 start 起始位置 end 终止位置 color 定义显示时的颜色 options 可选，前面的字段都是必须的，这里额外添加需要的内容，格式为key1=value1,key2=value2,key3=value3 注意 start end 可以用来控制染色体显示时候的相对比例，例如，如果希望所有的染色体都一样长，可以全部设为 0 1 或者全部设为0 100； 如果希望染色体体积越大越长，则可以start设置为0，end设置为每个染色体的体积。（这里体积只是举例，可以为染色体的任意一个属性） 连接文件 连接文件在&lt;links&gt;&lt;link&gt; file = link.data.txt&lt;/link&gt;&lt;links&gt;中定义，它有两种格式： 第一种： 1234ID1 start1 end1 ID2 start2 end2 options 定义ID1到ID2的连接hs1 0 1 hs2 0 1 color=red,thickness=2，z=100hs1 1 2 hs3 0 1 第二种： 12b1 ID1 start1 end1b1 ID2 start2 end2 # 两行定义一个由ID1到ID2的连接 这里的ID都是指karyotype文件中定义的ID。 所以，要实现连接的变化，只需要在定义的每个连接后面定义好相应的颜色，线宽，层次就可以了。 颜色 默认的颜色定义在etc\\colors.conf中，默认的颜色定义已经能够满足大部分的要求，使用的时候只需要指定其中的名称即可。 也可以定义自己的颜色文件，在etc\\colors.conf添加&lt;&lt;include colors.me.conf&gt;&gt;,然后在etc下新建文件colors.me.conf 颜色文件的定义格式是： 123colorname = R,G,Bblack=0,0,0white=255,255,255 显示配置选项 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;image&gt;&lt;&lt;include etc/image.conf&gt;&gt;# generated image pathdir* = D:\\FMRI_ROOT\\YIYU\\CONN\\PNG # 图像生成路径# generated image namefile* = 1.png # 生成图像名称&lt;/image&gt;&lt;ideogram&gt;show_label = yes # 是否显示labellabel_font = defaultlabel_radius = dims(ideogram,radius) + 0.025r #控制labels的位置label_with_tag = nolabel_size = 20 # labels的大小label_parallel = no # 控制labels是否水平显示，label较长时应该设为nolabel_case = upper # 控制labels的大小写label_format = eval(sprintf(&quot;%s&quot;,var(label))) # 控制labels的格式radius = 0.70r #染色体的半径thickness = 100p #染色体线的厚度fill = yesfill_color = blackstroke_thickness = 2 # 中间线的颜色和宽度stroke_color = blue&lt;ticks&gt;show_ticks = no # 是否显示染色体上的刻度show_tick_labels = yes&lt;/ticks&gt;&lt;bands&gt;show_bands = yes # 是否显示bandsfill_bands = noband_stroke_thickness = 2band_stroke_color = whiteband_transparency = 0max_ideograms* = 250 # 显示的染色体的最大数目max_links* = 35000 # 显示的连接的最大数目&lt;links&gt;#ribbon = yes#flat = yes&lt;link&gt;file = links1000.data.txt # 连接数据文件radius = 0.99r # 连接的大小color = red # 连接的颜色# Curves look best when this value is small (e.g. 0.1r or 0r)bezier_radius = 0.1rthickness = 2 # 线的宽度# These parameters have default values. To unset them# use &apos;undef&apos;#crest = undef#bezier_radius_purity = undef# Limit how many links to read from file and drawrecord_limit = 40000#&lt;rule&gt; # 可以用条件语句控制连接的格式#condition = var(intrachr) &amp;&amp; abs(var(pos1)-var(pos2)) &lt; 10Mb#show = no#color = red#&lt;/rule&gt;&lt;/link&gt;&lt;/links&gt;&lt;/bands&gt;&lt;/ideogram&gt; circos实例 要生成的图像： 所需文件： 12345678910test\\me\\circos.conftest\\me\\ideogram.conftest\\me\\ideogram.label.conftest\\me\\ideogram.position.conftest\\me\\links.me.conftest\\me\\ticks.conftest\\me\\bands.conftest\\me\\brainnetome.data.txttest\\me\\links50.data.txtetc\\colors.me.conf 链接: https://pan.baidu.com/s/1eSebD9w 密码: nham CMD中键入命令perl circos -conf test\\me\\circos.conf,OK . 其中colors.me.conf是自己根据colorbar生成的颜色，用来实现不同的颜色代表不同的强度值的目的。 该颜色主题用红色代表最大值，用蓝色表示最小值，值又大变小的过程 对应着 颜色由暖变冷的过程。 下面贴上生成colors.me.conf的matlab代码： 12345678910111213141516% 生成color bar 原始数据集% colorname1 R G B% colorname2 R G B% 产生颜色的种类color_num = 60;colors_unit = jet(color_num);colors = colors_unit * 255;fid=fopen(&apos;D:\\FMRI_ROOT\\TOOLS\\circos-0.69-3\\etc\\colors.me.conf&apos;,&apos;w+&apos;);for i =1:size(colors,1) fprintf(fid,[&apos;mecolor&apos;,num2str(size(colors,1)-i+1),&apos;=&apos;,num2str(colors(i,1)),&apos;,&apos;,num2str(colors(i,2)),&apos;,&apos;,num2str(colors(i,3)),&apos;\\n&apos;]);endfclose(fid);colormap(colors_unit);colorbar(); brainnetome.data.txt部分内容: 1234567chr - SFG_L_7_1 SFG_L_7_1 0 100 chr0chr - SFG_R_7_1 SFG_R_7_1 0 100 chr1chr - SFG_L_7_2 SFG_L_7_2 0 100 chr2chr - SFG_R_7_2 SFG_R_7_2 0 100 chr3chr - SFG_L_7_3 SFG_L_7_3 0 100 chr4chr - SFG_R_7_3 SFG_R_7_3 0 100 chr5chr - SFG_L_7_4 SFG_L_7_4 0 100 chr6 colors.me.conf部分内容： 123456mecolor6=221,0,0mecolor5=204,0,0mecolor4=187,0,0mecolor3=170,0,0mecolor2=153,0,0mecolor1=136,0,0 生成带分组的图形 先看一个示例 要想在染色体中间加入分割，可以在ideogram.conf文件中添加如下语句： 12345678910111213&lt;spacing&gt;default = 0.001r # 每个染色体的间隔break = 0.01raxis_break_at_edge = yesaxis_break = yes &lt;pairwise Cingulum_Ant_L Caudate_R&gt; spacing = 10r &lt;/pairwise&gt; # 定义相邻的两个染色体的间隔 &lt;pairwise Temporal_Pole_Mid_L Calcarine_R&gt; spacing = 10r &lt;/pairwise&gt;&lt;/spacing&gt; 这里需要注意的是，定义两个相邻的染色体之间的间隔的时候，如果用r为单位，是相对于default的倍数。 如果default设置成0，则无论多少倍都是0，这时候设置的特定的两个染色体的间隔也不会出现任何效果。","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"认知神经科学","slug":"技术/认知神经科学","permalink":"http://ff120.github.io/hexoblog/categories/技术/认知神经科学/"}],"tags":[{"name":"circos","slug":"circos","permalink":"http://ff120.github.io/hexoblog/tags/circos/"}]},{"title":"机器学习_Matplolib使用技巧","slug":"技术/机器学习/机器学习_Matplolib使用技巧","date":"2016-07-11T03:11:36.000Z","updated":"2019-03-28T00:54:57.798Z","comments":true,"path":"2016/07/11/技术/机器学习/机器学习_Matplolib使用技巧/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/07/11/技术/机器学习/机器学习_Matplolib使用技巧/","excerpt":"matplotlib","text":"matplotlib Matplotlib是一个使用Python实现的画图函数库。它可以以Python脚本，或者IPython Shell的形式被被使用。它是最著名的python绘图库，它提供了一整套和Matlab相似的命令API，十分适合交互式的进行制图。而且也可以方便的将它作为绘图控件，嵌入到GUI程序中去。它的文档相当完备，并且Gallery页面中有上百幅缩略图，打开之后都有源程序。因此如果你需要绘制某种类型的图，只需要在这个页面中浏览/复制/粘贴一下，基本上都能搞定。 Matplotlib官方网站：http://matplotlib.org/ Gallery页面地址：http://matplotlib.org/gallery.html pyplot pyplot是一个仿照MATLAB画图的接口设计的一个画图的库，接口的函数名称和使用规则都和MATLAB类似。 引入 1import matplotlib.pyplot as plt 画线 plt.plot(x,y,commond) x表示横坐标的取值，y表示纵坐标的取值，commond是可选的控制参数。如果只传递一个参数，例如plot(a), a被认为是纵坐标，横坐标为从0开始的自然数 0,1,2,3,… 还可以以两个或者三个参数为一组传递参数进入plot,这样可以一次画多条线段，plot(x1,y1,x2,y2,x3,y3) commond的取值： b- : 蓝色直线 ro : 红色圆点 r– : 红色虚线 bs : 蓝色实心方框 g^ : 绿色实心三角 12345%matplotlib inlineplt.plot([8,2,5,7])plt.plot([1,2,3,4],[2,3,3,2],'go')plt.plot([1,2,3,4],[3,3,3,3],'r--',[1,2,3,4],[4,4,4,4],'r^',[1,2,3,4],[5,5,5,5],'rs')plt.show() png 控制样式 设置横坐标和纵坐标的取值范围：plt.axis([xmin.xmax,ymin,ymax]) 设置线宽：plt.plot(x,y,linewidth = 2) 或者使用set方法：line, = plot(x,y,'-') line.set_antialiased(False) plt.setp(lines, color='r', linewidth=2.0) 要查看所有可以设置的属性，可以使用plt.setp(lines) 设置坐标标识： 12345plt.xlable('x轴说明',fontsize=14,color='red')plt.ylabel('y轴说明')plt.title('图表标题')plt.text('图表中说明性文字')plt.grid(True) #是否显示网格线 每个设置都有更多的选项可以控制显示的各个方面，详细的属性信息参考Text properties and layout,关于图表上数学公式的书写，参考Text rendering With LaTeX 1234567891011121314151617import numpy as npimport matplotlib.pyplot as pltmu, sigma = 100, 15x = mu + sigma * np.random.randn(10000)# the histogram of the datan, bins, patches = plt.hist(x, 50, normed=1, facecolor='g', alpha=0.75)plt.xlabel('Smarts')plt.ylabel('Probability')plt.title('Histogram of IQ')plt.text(60, .025, r'$\\mu=100,\\ \\sigma=15$')plt.axis([40, 160, 0, 0.03])plt.grid(True)plt.show() png 同时画多个图 123456plt.figure(1) #创建图对象，括号里面的数字是这个图的标识plt.subplot(211) # 创建子图，括号里的数字是numrows, numcols, fignum，这里这个子图所在的位置是第二行，第一列，在上面创建的那个figure1中。plt.plot(x1,y1)plt.subplot(221)plt.plot(x2,y2) 12345678910111213141516import numpy as npimport matplotlib.pyplot as pltdef f(t): return np.exp(-t) * np.cos(2*np.pi*t)t1 = np.arange(0.0, 5.0, 0.1)t2 = np.arange(0.0, 5.0, 0.02)plt.figure(2)plt.subplot(211)plt.plot(t1, f(t1), 'bo', t2, f(t2), 'k')plt.subplot(212)plt.plot(t2, np.cos(2*np.pi*t2), 'r--')plt.show() png 图例 123456import matplotlib.patches as mpatchesimport matplotlib.pyplot as pltline_up, = plt.plot([1,2,3], label='Line 2')line_down, = plt.plot([3,2,1], label='Line 1')plt.legend([line_up, line_down], ['Line AA', 'Line BB']) &lt;matplotlib.legend.Legend at 0xb95ce10&gt; png 1234import matplotlib.lines as mlinesblue_line = mlines.Line2D([], [], color='blue', marker='*', markersize=15, label='Blue stars')plt.legend(handles=[blue_line]) &lt;matplotlib.legend.Legend at 0xc4013c8&gt; png 各种图 基本图表(plot) 123456789101112import matplotlib.pyplot as pltimport numpy as npt = np.arange(0.0, 2.0, 0.01)s = np.sin(2*np.pi*t)plt.plot(t, s)plt.xlabel('time (s)')plt.ylabel('voltage (mV)')plt.title('About as simple as it gets, folks')plt.grid(True)plt.show() png 多个子图绘制在一起(subplot) 123456789101112131415161718192021222324\"\"\"Simple demo with multiple subplots.\"\"\"import numpy as npimport matplotlib.pyplot as pltx1 = np.linspace(0.0, 5.0)x2 = np.linspace(0.0, 2.0)y1 = np.cos(2 * np.pi * x1) * np.exp(-x1)y2 = np.cos(2 * np.pi * x2)plt.subplot(2, 1, 1)plt.plot(x1, y1, 'yo-')plt.title('A tale of 2 subplots')plt.ylabel('Damped oscillation')plt.subplot(2, 1, 2)plt.plot(x2, y2, 'r.-')plt.xlabel('time (s)')plt.ylabel('Undamped')plt.show() png 直方图(hist) 下面这个程序展示了如何使用hist函数绘制直方图和如何绘制一条拟合直方图的曲线。 n, bins, patches = hist(x,num_bins) x 构建直方图的数据，x = [n_samples,] num_bins 要分成的组数，最后生成的直方图有num_bins个方框。 n 每个直方的值 bins 每个直方的起始位置 patches :Silent list of individual patches used to create the histogram or list of such list if multiple input datasets. 1234567891011121314151617181920212223242526272829303132333435\"\"\"Demo of the histogram (hist) function with a few features.In addition to the basic histogram, this demo shows a few optional features: * Setting the number of data bins * The ``normed`` flag, which normalizes bin heights so that the integral of the histogram is 1. The resulting histogram is a probability density. * Setting the face color of the bars * Setting the opacity (alpha value).\"\"\"import numpy as npimport matplotlib.mlab as mlabimport matplotlib.pyplot as plt# example datamu = 100 # mean of distributionsigma = 15 # standard deviation of distributionx = mu + sigma * np.random.randn(10000)num_bins = 50# the histogram of the datan, bins, patches = plt.hist(x, num_bins, normed=1, facecolor='green', alpha=0.5)# add a 'best fit' liney = mlab.normpdf(bins, mu, sigma)plt.plot(bins, y, 'r--')plt.xlabel('Smarts')plt.ylabel('Probability')plt.title(r'Histogram of IQ: $\\mu=100$, $\\sigma=15$')# Tweak spacing to prevent clipping of ylabelplt.subplots_adjust(left=0.15)plt.show() png 饼状图(pie) plt.pie(size,explode,labels,colors) size: 绘制图的数据 explode: 分割出来显示的某个数据 lables:文字说明 colors: 饼状图对应部分的颜色 1234567891011121314import matplotlib.pyplot as plt# The slices will be ordered and plotted counter-clockwise.labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'sizes = [15, 30, 45, 10]colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']explode = (0.1, 0, 0.2, 0) # only \"explode\" the 2nd slice (i.e. 'Hogs')plt.pie(sizes, explode=explode, labels=labels, colors=colors, autopct='%1.1f%%', shadow=True, startangle=90)plt.show() png 表格 1plt.table(cellText=data,rowLabels=rows,colLabels=columns,loc='bottom',bbox=[0.25, -0.5, 0.5, 0.3]) cellText: 表格中的数据 [n_rows,n_colums] rowLabels: 行标签 collabels: 列标签 loc: 相对于图表的位置，top,right,left,bottom bbox: 边距 123456789101112131415161718192021222324\"\"\"Demo of table function to display a table within a plot.\"\"\"import matplotlib.pyplot as pltimport numpy as npdata = [[ 100, 200, 300 ], [ 200, 100, 50 ], [ 40, 200, 100 ], [ 100, 200, 300 ]]y = np.array(data)y = y.reshape(1,-1)columns = ('Freeze', 'Wind', 'Flood', 'Quake', 'Hail')rows = ['%d year' % x for x in (50, 20, 10, 5)]# Add a table at the bottom of the axesthe_table = plt.table(cellText=data, rowLabels=rows, colLabels=columns, loc='bottom', bbox=[0.25, -0.5, 0.5, 0.3])plt.plot([1,2,3],[2,3,4])plt.show() png 极坐标下绘图 12ax = plt.subplot(211, projection=&apos;polar&apos;)ax.plot(theta, r, color=&apos;r&apos;, linewidth=3) projection=‘polar’ 指定是极坐标 theta： 横坐标 r: 纵坐标 12345678910111213141516171819\"\"\"Demo of a line plot on a polar axis.\"\"\"import numpy as npimport matplotlib.pyplot as pltr = np.arange(0, 3.0, 0.01)theta = 2 * np.pi * rax = plt.subplot(211, projection='polar')ax.plot(theta, r, color='r', linewidth=3)ax.set_rmax(2.0)ax.grid(True)ax.set_title(\"A line plot on a polar axis\", va='bottom')ax2 = plt.subplot(212)ax2.plot(theta,r,color='g',linewidth=2)plt.show() png 颜色（Colormaps） 动画（animation） import matplotlib.animation as animation animation.FuncAnimation(fig1, update_line, num, fargs=(data, l), interval=200, blit=True,repeat=False) FuncAnimation是根据自定义函数生成动画的一个接口， fig1 是画布，用plt.figure()生成 uodate_line 是更新图像的函数，一般返回的是一个2D或者3D的line对象，FuncAnimation会自动循环调用该函数设置图像显示的line,以达到动画的效果。 num是传入update_line的第一个参数，该参数会从0开始每次递增1，直到结束。 fargs可以传入额外的参数，这里我的update_line有三个参数，第一个是num,第二个和第三个就是靠指定fargs参数传入进去的，通过fargs传递的参数不会自动递增。 interval 指定调用update_line的间隔，就是动画间隔 repeat 设置动画播放完后是否重复 12345678910111213141516171819202122import numpy as npimport matplotlib.pyplot as pltimport matplotlib.animation as animationdef update_line(num, data, line): xxdata = data yydata = 4 * data + num line.set_xdata(xxdata) line.set_ydata(yydata) return line,fig1 = plt.figure()data = np.array([1,2,3])l, = plt.plot([], [], 'r-')plt.xlim(1,3)plt.ylim(1,30)plt.xlabel('x')plt.ylabel('y')plt.title('test')line_ani = animation.FuncAnimation(fig1, update_line, 25, fargs=(data, l), interval=200, blit=True,repeat=False)plt.show() png 配色 不同种类的颜色，渐变色等的搭配，可以从这里生成。 统计绘图(seaborn) 需要各种带有统计量的图形的时候，一种选择是自己计算各种统计量，然后使用Matplotlib手动绘制，另外一种方法就是使用专门用来绘制统计图形的工具，好处是不需要自己计算各种统计量，只需要传入原始的数据，工具包会自己计算需要的统计量。一个比较流行的统计绘图工具是seaborn. 箱线图 反应数据分布规律的一种图形，可以把数据的中位数，四分位数等都显示在一张图上。使用来观察数据分布的较好方法。图形类似下面这样。 seaborn自带的函数支持pandas.DataFrame格式的数据，所以使用起来非常方便。但是如果想要把两个DataFrame每一列的数据作为对比，制作成箱线图，seaborn并没有提供这样的方法，需要修改DataFrame的格式，使之符合要求。 1234567891011121314151617181920212223242526272829def plotBox(self,dflist,palette=\"Set3\",rotation=45): \"\"\" 绘制箱线图 Parameters ---------- dflist : list of pandas.DataFrame, each of the DataFrame as a class and will be plot together pallette : pallette in sns rotation : x_lable rotation to show whole word \"\"\" sdata =pd.Series() sxx = pd.Series() slabel = pd.Series() for i in range(len(dflist)): pdd = dflist[i] columns = pdd.columns.values ds = pd.Series([i+1]*(pdd.shape[0]*pdd.shape[1])) slabel = slabel.append(ds) for cc in columns: sdata = sdata.append(pdd[cc]) sxx = sxx.append(pd.Series([cc]*len(pdd[cc]))) snsdata = pd.DataFrame(&#123;\"y\":sdata.values,\"x\":sxx.values,\"label\":slabel&#125;) sns.set(style=\"ticks\") ax = sns.boxplot(data=snsdata,x='x',y='y',hue='label',palette=palette) ax.set_xticklabels(ax.xaxis.get_ticklabels(), rotation=rotation) sns.despine(offset=10, trim=True) 矩阵可视化 把矩阵的值作为颜色的取值，可视化的表示出矩阵的情况。图形类似下面这样： 12345678import seaborn as snssns.set(context=\"paper\", font=\"monospace\",palette=\"Set3\")f, ax = plt.subplots(figsize=(10, 10))# Draw the heatmap using seabornsns.heatmap(matrix, vmax=.8,square=True,annot=True, fmt=\".1f\",linewidths=.5)ax.set_xticklabels(ax.xaxis.get_ticklabels(), rotation=90)ax.set_yticklabels(ax.yaxis.get_ticklabels(), rotation=0) 牛逼的绘图 http://www.bugman123.com/index.html 参考文献 https://www.zhihu.com/question/21664179","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"}],"tags":[{"name":"matplotlib","slug":"matplotlib","permalink":"http://ff120.github.io/hexoblog/tags/matplotlib/"}]},{"title":"Bootsharp学习笔记","slug":"技术/Web开发/前端_bootsharp学习笔记","date":"2016-06-30T14:51:32.000Z","updated":"2019-03-28T00:54:58.597Z","comments":true,"path":"2016/06/30/技术/Web开发/前端_bootsharp学习笔记/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/30/技术/Web开发/前端_bootsharp学习笔记/","excerpt":"","text":"# 简介 Bootstrap 是一个用于快速开发 Web 应用程序和网站的前端框架。Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的。 Bootstrap，来自 Twitter，是目前最受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的，它简洁灵活，使得 Web 开发更加快捷。 安装 从 http://getbootstrap.com/ 上下载 Bootstrap 的最新版本。 - • Download Bootstrap：下载 Bootstrap。点击该按钮，您可以下载 Bootstrap CSS、JavaScript 和字体的预编译的压缩版本。不包含文档和最初的源代码文件。 - • Download Source：下载源代码。点击该按钮，您可以直接从 from 上得到最新的 Bootstrap LESS 和 JavaScript 源代码。 使用 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;在线尝试 Bootstrap 实例&lt;/title&gt; &lt;link href=\"/bootstrap/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;script src=\"/scripts/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"/bootstrap/js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 解释说明： 1. Bootstrap 使用了一些 HTML5 元素和 CSS 属性。为了让这些正常工作，您需要使用 HTML5 文档类型（Doctype）。因此，请在使用 Bootstrap 项目的开头包含下面的代码段。 &lt;!DOCTYPE html&gt; 2. bootstrap 不需要任何安装部署 和 开发环境，只需要包含以下几个文件： 123&lt;link href=\"/bootstrap/css/bootstrap.min.css\" rel=\"stylesheet\"&gt;&lt;script src=\"/scripts/jquery.min.js\"&gt;&lt;/script&gt;&lt;script src=\"/bootstrap/js/bootstrap.min.js\"&gt;&lt;/script&gt; 就可以使用bootstrap的各种效果了。 3. Bootstrap 3 的设计目标是移动设备优先，然后才是桌面设备。 为了让 Bootstrap 开发的网站对移动设备友好，确保适当的绘制和触屏缩放，需要在网页的 head 之中添加 viewport meta 标签，如下所示： &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; 注释： - initial-scale=1.0 确保网页加载时，以 1:1 的比例呈现，不会有任何的缩放。 - 在移动设备浏览器上，通过为 viewport meta 标签添加 user-scalable=no 可以禁用其缩放（zooming）功能。通常情况下，maximum-scale=1.0 与 user-scalable=no 一起使用。这样禁用缩放功能后，用户只能滚动屏幕，就能让您的网站看上去更像原生应用的感觉。 - 移动设备通常使用的meta标签：&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;&gt; 响应式图像 1&lt;img src=\"...\" class=\"img-responsive\" alt=\"Responsive image\"&gt; 通过添加为img标签添加class=&quot;img-responsive&quot;可以使图像的响应式布局更友好。 12345.img-responsive &#123; display: inline-block; height: auto; max-width: 100%;&#125; Bootstrap 的css中的img-responsive是这样写的，保证了响应式布局。从这里可以看出，bootstrap做的事情其实就是定义了一些css类的样式，你只要包含这些文件，就能直接使用这些样式，而这些样式是经过精心设计的，保证了满足响应式布局的需要。 网格系统 Bootstrap 响应式的网格系统可以根据设备大小进行灵活的适应，保证内容的显示效果。 Bootstrap的网格系统将屏幕分为12列，在定义每一列的时候，可以指定一个数字，代表占用几列，bootstrap 自动用相应的比例显示他们。 &lt;div class=&quot;container&quot;&gt;...&lt;/div&gt; 元素被添加，确保居中和最大宽度。 一旦添加了容器，接下来您需要考虑以行为单位。添加&lt;div class=&quot;row&quot;&gt;...&lt;/div&gt;，并在行内添加列 &lt;div class=&quot;col-md-6&quot;&gt;&lt;/div&gt;。 有两个列，每个列由 6 个单元组成，即 6+6=12。 在大型设备显示时修改布局： 12&lt;div class=\"col-md-6 col-lg-4\"&gt;....&lt;/div&gt;&lt;div class=\"col-md-6 col-lg-8\"&gt;....&lt;/div&gt; 这样，当在middle设备上显示时，会显示col-md-6这个Class，在large设备上显示时，会显示col-g-4这个Class。 所以，在中型设备上，两列宽度是1：1，在大型设备上，两列宽度是2：3. 12&lt;div class=\"col-sm-3 col-md-6 col-lg-4\"&gt;....&lt;/div&gt;&lt;div class=\"col-sm-9 col-md-6 col-lg-8\"&gt;....&lt;/div&gt; 同理，如果这样设置，就能实现在小型、中型、大型设备上以不同的比例显示列。 响应式的列重置： 12345&lt;div class=\"col-xs-6 col-sm-3\"&lt;div class=\"col-xs-6 col-sm-3\"&lt;div class=\"clearfix visible-xs\"&gt;&lt;/div&gt;&lt;div class=\"col-xs-6 col-sm-3\"&lt;div class=\"col-xs-6 col-sm-3\" 当屏幕足够大时，四列同宽（3:3:3:3），显示在同一行；当不够宽时，分两行显示，第一行显示前两列，第二行显示后两列。宽度是（6：6） 偏移列： &lt;div class=&quot;col-xs-6 col-md-offset-3&quot;偏移3列，占据6列，右边还剩3列，所以这句的效果就是 居中。 嵌套： 123456789&lt;div class=\"row\"&gt; &lt;div class=\"col-md-3\" &lt;div class=\"col-md-9\" &lt;div class=\"row\"&gt; &lt;div class=\"col-md-6\" &lt;div class=\"col-md-6\" &lt;div class=\"row\"&gt; &lt;div class=\"col-md-6\" &lt;div class=\"col-md-6\" 这样就能嵌套出这样的一个表格： 列排序： 1. &lt;div class=&quot;col-md-4 col-md-push-8&quot; 2. &lt;div class=&quot;col-md-8 col-md-pull-4&quot; 第一列占四列，第二列占8列，这样显示出来是左变窄，右边宽的一个布局。我们可以通过col-md-push-8 和col-md-pull-4 改变这两列的显示顺序，形成左边宽，右边窄的布局。Push-8 的意思就是将占8行的列提前，pull-4的意思就是将占4行的列退后。 响应式表格","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"Web开发","slug":"技术/Web开发","permalink":"http://ff120.github.io/hexoblog/categories/技术/Web开发/"}],"tags":[{"name":"bootsharp","slug":"bootsharp","permalink":"http://ff120.github.io/hexoblog/tags/bootsharp/"}]},{"title":"JQuery EasyUI 学习笔记","slug":"技术/Web开发/前端_jQuery-EasyUI-学习笔记","date":"2016-06-30T14:44:37.000Z","updated":"2019-03-28T00:54:58.625Z","comments":true,"path":"2016/06/30/技术/Web开发/前端_jQuery-EasyUI-学习笔记/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/30/技术/Web开发/前端_jQuery-EasyUI-学习笔记/","excerpt":"","text":"安装 下载jquery EasyUI 安装包 解压缩之后的目录结构为 要使用easyui只需要在HTML页面包含 123&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"themes/default/easyui.css\"&gt;&lt;script type=\"text/javascript\" src=\"jquery.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"jquery.easyui.min.js\"&gt;&lt;/script&gt; 指定下载的文件的位置就可以直接使用里面定义好的控件了。 主要内容 网格系统 表头： 12345&lt;thead&gt;&lt;tr&gt;&lt;td&gt;第一列&lt;/td&gt; &lt;td&gt;第二列&lt;/td&gt; &lt;td&gt;第三列&lt;/td&gt;&lt;/tr&gt;&lt;/thead&gt; 表体: 12345&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;第一列&lt;/td&gt; &lt;td&gt;第二列&lt;/td&gt; &lt;td&gt;第三列&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"Web开发","slug":"技术/Web开发","permalink":"http://ff120.github.io/hexoblog/categories/技术/Web开发/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"http://ff120.github.io/hexoblog/tags/jquery/"}]},{"title":"PHP读写XLS","slug":"技术/Web开发/后台开发_PHP读写XLS","date":"2016-06-23T02:53:27.000Z","updated":"2019-03-28T00:54:58.905Z","comments":true,"path":"2016/06/23/技术/Web开发/后台开发_PHP读写XLS/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/23/技术/Web开发/后台开发_PHP读写XLS/","excerpt":"","text":"PHP实现读取和生成XLS文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public function read_xls()&#123; $file = \"D:/TaskHistory/123/template.xls\"; vendor(\"PHPEXCEL\\PHPExcel\"); vendor(\"PHPEXCEL\\PHPExcel\\IOFactory\"); $excel = new \\PHPExcel(); date_default_timezone_set('Asia/ShangHai'); if (!file_exists($file)) &#123; exit(\"not found 31excel5.xls.\\n\"); &#125; $reader = \\PHPExcel_IOFactory::createReader('Excel5'); //设置以Excel5格式(Excel97-2003工作簿) $PHPExcel = $reader-&gt;load($file); // 载入excel文件 $sheet = $PHPExcel-&gt;getSheet(0); // 读取第一个工作表 $highestRow = $sheet-&gt;getHighestRow(); // 取得总行数 $highestColumm = $sheet-&gt;getHighestColumn(); // 取得总列数 /** 循环读取每个单元格的数据 */ for ($row = 1; $row &lt;= $highestRow; $row++)&#123;//行数是以第1行开始 for ($column = 'A'; $column &lt;= $highestColumm; $column++) &#123;//列数是以A列开始 $value = $sheet-&gt;getCell($column.$row)-&gt;getValue(); $dataset[$row-1][] = $sheet-&gt;getCell($column.$row)-&gt;getValue(); &#125; &#125; dump($dataset); &#125; public function write_xls() &#123; $file = \"D:/TaskHistory/123/bak.xls\"; vendor(\"PHPEXCEL\\PHPExcel\"); vendor(\"PHPEXCEL\\PHPExcel\\IOFactory\"); $product = D('product'); $data = $product-&gt;Relation(true)-&gt;select(); $objPHPExcel = new \\PHPExcel(); /*以下是一些设置 ，什么作者 标题啊之类的*/ $objPHPExcel-&gt;getProperties()-&gt;setCreator(\"转弯的阳光\") -&gt;setLastModifiedBy(\"转弯的阳光\") -&gt;setTitle(\"数据EXCEL导出\") -&gt;setSubject(\"数据EXCEL导出\") -&gt;setDescription(\"备份数据\") -&gt;setKeywords(\"excel\") -&gt;setCategory(\"result file\"); //设置标题 $objPHPExcel-&gt;setActiveSheetIndex(0) -&gt;setCellValue('A' . 1, '品种') -&gt;setCellValue('B' . 1, '材质') -&gt;setCellValue('C' . 1, '规格') -&gt;setCellValue('D' . 1, '宽') -&gt;setCellValue('E' . 1, '长') -&gt;setCellValue('F' . 1, '生产厂家') -&gt;setCellValue('G' . 1, '交货地点') -&gt;setCellValue('H' . 1, '交货仓库') -&gt;setCellValue('I' . 1, '价格（元/吨）') -&gt;setCellValue('G' . 1, '重量（吨）') -&gt;setCellValue('K' . 1, '计重方式') -&gt;setCellValue('L' . 1, '备注'); foreach ($data as $k =&gt; $v) &#123; $num = $k + 2; $objPHPExcel-&gt;setActiveSheetIndex(0) //Excel的第A列，uid是你查出数组的键值，下面以此类推 -&gt;setCellValue('A' . $num, $v['product_id']) -&gt;setCellValue('B' . $num, $v['product_name']) -&gt;setCellValue('C' . $num, $v['product_price']); //这里添加要加入进去的数据，我没写完 &#125; $objPHPExcel-&gt;getActiveSheet()-&gt;setTitle('User'); $objPHPExcel-&gt;setActiveSheetIndex(0); header('Content-Type: application/vnd.ms-excel'); header('Content-Disposition: attachment;filename=\"' . $file . '.xls\"'); header('Cache-Control: max-age=0'); $objWriter = \\PHPExcel_IOFactory::createWriter($objPHPExcel, 'Excel5'); $objWriter-&gt;save('php://output'); &#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"Web开发","slug":"技术/Web开发","permalink":"http://ff120.github.io/hexoblog/categories/技术/Web开发/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://ff120.github.io/hexoblog/tags/PHP/"}]},{"title":"Spark环境下的Kmeans-Python实现","slug":"技术/大数据/大数据_Spark环境下的Kmeans-Python实现","date":"2016-06-23T02:45:57.000Z","updated":"2019-03-28T00:54:55.352Z","comments":true,"path":"2016/06/23/技术/大数据/大数据_Spark环境下的Kmeans-Python实现/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/23/技术/大数据/大数据_Spark环境下的Kmeans-Python实现/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#设置应用名称，显示在spark监控页面上sc = SparkContext(appName=\"MySparkApplication\")#读取数据,data文件夹下有6个数据文件，这样写能全部读取，需要注意的是，在其他worker的相同路径下也需要有这些文件lines = sc.textFile(\"/home/fei/sparkcode/data/\")#原来的数据使用TAB分割的，现在把它转换成python中list形式data = lines.map(lambda x:x.split('\\t'))#定义一个函数，将源文件中用字母数字表示的天数化成数字，转换后的格式为天数0-48，网站0-9。def dayToNum(data): list1 = [] list1.append(data[0]) strs = data[1] day = (int(strs[1])-1)*7 + int(strs[3])-1 list1.append(day) sitestr = data[2] site = int(sitestr[1:])-1 list1.append(site) list1.append(int(data[3])) return list1#使用定义的函数转换data中的数据data2 = data.map(dayToNum)#合并相同用户的数据，一个用户占一条记录data4 = data3.reduceByKey(lambda v1,v2:list(map(lambda x: x[0]+x[1], zip(v2, v1))))#保存合并后的数据，从这个数据能够知道有多少个用户，该用户7周对10个网站的点击情况是什么，保存下来便于以后需要直接处理data4.saveAsTextFile(\"/home/fei/combinedData\")#为kmeans聚类准备数据data5 = data4.map(lambda x:np.array(x[1]))#设置kmeans参数：K=100，initializationMode=\"k-means||\"k = 100mode = \"k-means||\"#开始kmeans聚类model = KMeans.train(data5,k,initializationMode=mode)#保存聚类结果output = open('/home/fei/kmeans_result.txt', 'w')output.write(\"Final centers: \" + str(model.clusterCenters))output.write(\"Final centers: \" + str(model.clusterCenters))output.close()#输出聚类结果print(\"Final centers: \" + str(model.clusterCenters))print(\"Total Cost: \" + str(model.computeCost(data5)))#聚类完成后，预测每个用户的聚类类别ID：#reduceByKey会对相同key的记录进行reduce，这里将类别作为key,便于依据类别分别处理belongs= data5.map(lambda x:(model.predict(x),(list)(x)))#为线性回归准备训练数据data6 = belongs.map(lambda x: (x[0],np.array(x[1]).reshape(8,7,10))).cache()data00 = data6.map(lambda x:x[1]).map(lambda x:x[:,0,0])data_train = data00.map(lambda x : LabeledPoint(x[6],x[:6]))#开始训练model = LinearRegressionWithSGD.train(data_train)#预测并保存预测结果result = model.predict(data[1][1:7,0,0])result.saveAsTextFile('/home/fei/lines')#停止程序sc.stop()","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"大数据","slug":"技术/大数据","permalink":"http://ff120.github.io/hexoblog/categories/技术/大数据/"}],"tags":[{"name":"spark","slug":"spark","permalink":"http://ff120.github.io/hexoblog/tags/spark/"}]},{"title":"改进PHP的var_dump()方法使之适应显示从数据库中查出来的数据","slug":"技术/Web开发/后台开发_改进PHP的var-dump-方法使之适应显示从数据库中查出来的数据","date":"2016-06-23T02:44:06.000Z","updated":"2019-03-28T00:54:59.018Z","comments":true,"path":"2016/06/23/技术/Web开发/后台开发_改进PHP的var-dump-方法使之适应显示从数据库中查出来的数据/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/23/技术/Web开发/后台开发_改进PHP的var-dump-方法使之适应显示从数据库中查出来的数据/","excerpt":"改进PHP的var_dump使之拥有良好的显示格式。","text":"改进PHP的var_dump使之拥有良好的显示格式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * array(7) &#123;[0] =&gt; array(32) &#123;[\"order_id\"] =&gt; string(2) \"34\"[\"shipping_time\"] =&gt; string(1) \"0\"[\"created_at\"] =&gt; string(10) \"1433565988\"&#125;[1] =&gt; array(32) &#123;[\"order_id\"] =&gt; string(2) \"35\"[\"shipping_time\"] =&gt; string(1) \"0\"[\"created_at\"] =&gt; string(10) \"1433573933\"&#125;[2] =&gt; array(32) &#123;[\"order_id\"] =&gt; string(2) \"36\"[\"order_sn\"] =&gt; string(9) \"BJA000036\"[\"wx_trade_no\"] =&gt; string(32) \"wx712cd30713b968c114336440083628\"&#125; * 形如上面这样的数组，使用var_dump()函数打印的时候会打印出所有的数据项，尤其是在数据库字段较多的情况下， * 不便于找到自己感兴趣的数据。 * 本方法改进了var_dump()方法，可以指定要打印的键。例如想看从order表中查处的order_id和city_id, * 可以这样使用：du($order,['order_id','city_id']) * 输出如下格式： *array[7] &#123;[0] =&gt;array[32] &#123;[order_id] =&gt; string(2) : 34[city_id] =&gt; string(1) : 0&#125;[1] =&gt;array[32] &#123;[order_id] =&gt; string(2) : 35[city_id] =&gt; string(1) : 0&#125;[2] =&gt;array[32] &#123;[order_id] =&gt; string(2) : 36[city_id] =&gt; string(1) : 0&#125;[3] =&gt;array[32] &#123;[order_id] =&gt; string(2) : 37[city_id] =&gt; string(1) : 0&#125;&#125; * @param $data 要显示结构的变量 * @param $keys 要显示的键，为空则显示所有的键 * @param $echo 是否输出结果到浏览器 */function du($data,$keys='',$echo=true)&#123; $message = \"\"; $message .= gettype($data) . \"[\" . count($data) . \"] &#123;\" . \"&lt;br&gt;\"; foreach ($data as $cc =&gt; $c) &#123; $message .= \" [\" . $cc . \"] =&gt;\" . gettype($c) . \"[\" . count($c) . \"] &#123;\" . \"&lt;br&gt;\"; foreach ($c as $key =&gt; $value) &#123; if (empty($keys)) &#123; $message .= \" [\" . $key . \"]\" . \" =&gt; \" . gettype($value) . \"(\" . strlen($value) . \")\" . \" : \".$value; $message .= \"&lt;br&gt;\"; &#125; else if (in_array($key, $keys)) &#123; $message .= \" [\" . $key . \"]\" . \" =&gt; \" . gettype($value) . \"(\" . strlen($value) . \")\" . \" : \".$value; $message .= \"&lt;br&gt;\"; &#125; &#125; $message .= \" &#125;\"; $message .= \"&lt;br&gt;\"; &#125; $message .= \"&#125;\"; if ($echo) &#123; echo $message; &#125; else &#123; $a = str_replace(\"&lt;br&gt;\",\"\\r\\n\",$message); $a = str_replace(\" \",\" \",$a); return $a; &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"Web开发","slug":"技术/Web开发","permalink":"http://ff120.github.io/hexoblog/categories/技术/Web开发/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://ff120.github.io/hexoblog/tags/PHP/"}]},{"title":"中英文对照","slug":"技术/认知神经科学/中英文对照","date":"2016-06-22T10:21:45.000Z","updated":"2019-03-28T00:54:59.665Z","comments":true,"path":"2016/06/22/技术/认知神经科学/中英文对照/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/22/技术/认知神经科学/中英文对照/","excerpt":"","text":"机构 The Chinese Academy of Sciences –中国科学院 National Aeronautics and Space Administration(NASA) –美国国家航空航天局 NASA Jet Propulsion Laboratory (NASA-JPL) – 美国国家航空航天局喷气推进实验室 University of Zurich – 苏黎世大学 杂志 科学杂志 –Science url:http://www.sciencemag.org/journals FMRI VOI – Volume of Interest","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"认知神经科学","slug":"技术/认知神经科学","permalink":"http://ff120.github.io/hexoblog/categories/技术/认知神经科学/"}],"tags":[{"name":"English","slug":"English","permalink":"http://ff120.github.io/hexoblog/tags/English/"}]},{"title":"机器学习_手写数字识别","slug":"技术/机器学习/机器学习_手写数字识别","date":"2016-06-20T11:49:11.000Z","updated":"2019-03-28T00:54:58.054Z","comments":true,"path":"2016/06/20/技术/机器学习/机器学习_手写数字识别/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/20/技术/机器学习/机器学习_手写数字识别/","excerpt":"MINIST 数据文件（http://yann.lecun.com/exdb/mnist/）","text":"MINIST 数据文件（http://yann.lecun.com/exdb/mnist/） 数据读取参考教程（http://blog.csdn.net/dream_angel_z/article/details/50739817） 读取数据保存成图片 读取MINIST原始数据格式的工具函数，来源：http://blog.csdn.net/dream_angel_z/article/details/50739817 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112# -*- coding: utf-8 -*-\"\"\"Created on Thu Feb 25 14:40:06 2016load MNIST dataset@author: liudiwei\"\"\"import numpy as npimport structimport matplotlib.pyplot as pltimport osclass DataUtils(object): \"\"\" MNIST数据集加载 输出格式为：numpy.array() 使用方法如下 from data_util import DataUtils def main(): trainfile_X = '../dataset/MNIST/train-images.idx3-ubyte' trainfile_y = '../dataset/MNIST/train-labels.idx1-ubyte' testfile_X = '../dataset/MNIST/t10k-images.idx3-ubyte' testfile_y = '../dataset/MNIST/t10k-labels.idx1-ubyte' train_X = DataUtils(filename=trainfile_X).getImage() train_y = DataUtils(filename=trainfile_y).getLabel() test_X = DataUtils(testfile_X).getImage() test_y = DataUtils(testfile_y).getLabel() #以下内容是将图像保存到本地文件中 #path_trainset = \"../dataset/MNIST/imgs_train\" #path_testset = \"../dataset/MNIST/imgs_test\" #if not os.path.exists(path_trainset): # os.mkdir(path_trainset) #if not os.path.exists(path_testset): # os.mkdir(path_testset) #DataUtils(outpath=path_trainset).outImg(train_X, train_y) #DataUtils(outpath=path_testset).outImg(test_X, test_y) return train_X, train_y, test_X, test_y \"\"\" def __init__(self, filename=None, outpath=None): self._filename = filename self._outpath = outpath self._tag = '&gt;' self._twoBytes = 'II' self._fourBytes = 'IIII' self._pictureBytes = '784B' self._labelByte = '1B' self._twoBytes2 = self._tag + self._twoBytes self._fourBytes2 = self._tag + self._fourBytes self._pictureBytes2 = self._tag + self._pictureBytes self._labelByte2 = self._tag + self._labelByte def getImage(self): \"\"\" 将MNIST的二进制文件转换成像素特征数据 \"\"\" binfile = open(self._filename, 'rb') #以二进制方式打开文件 buf = binfile.read() binfile.close() index = 0 numMagic,numImgs,numRows,numCols=struct.unpack_from(self._fourBytes2,\\ buf,\\ index) index += struct.calcsize(self._fourBytes) images = [] for i in range(numImgs): imgVal = struct.unpack_from(self._pictureBytes2, buf, index) index += struct.calcsize(self._pictureBytes2) imgVal = list(imgVal) for j in range(len(imgVal)): if imgVal[j] &gt; 1: imgVal[j] = 1 images.append(imgVal) return np.array(images) def getLabel(self): \"\"\" 将MNIST中label二进制文件转换成对应的label数字特征 \"\"\" binFile = open(self._filename,'rb') buf = binFile.read() binFile.close() index = 0 magic, numItems= struct.unpack_from(self._twoBytes2, buf,index) index += struct.calcsize(self._twoBytes2) labels = []; for x in range(numItems): im = struct.unpack_from(self._labelByte2,buf,index) index += struct.calcsize(self._labelByte2) labels.append(im[0]) return np.array(labels) def outImg(self, arrX, arrY): \"\"\" 根据生成的特征和数字标号，输出png的图像 \"\"\" m, n = np.shape(arrX) #每张图是28*28=784Byte for i in range(m): img = np.array(arrX[i]) img = img.reshape(28,28) outfile = str(i) + \"_\" + str(arrY[i]) + \".png\" #plt.imshow(img, cmap = 'binary') #将图像黑白显示 #plt.savefig(self._outpath + \"/\" + outfile) plt.imsave(self._outpath + \"/\" + outfile, img, cmap=plt.cm.gray) 读取数据并保存成图片输出到本地 1234567891011121314151617181920212223242526import sysimport osfrom data_utils import DataUtilsimport numpy as npreload(sys)sys.setdefaultencoding('utf8') #主要是解决编码不一致问题，没有问题这句可以不加trainfile_X = 'D:/train-images.idx3-ubyte'trainfile_y = 'D:/train-labels.idx1-ubyte'testfile_X = 'D:/t10k-images.idx3-ubyte'testfile_y = 'D:/t10k-labels.idx1-ubyte'train_X = DataUtils(filename=trainfile_X).getImage()train_y = DataUtils(filename=trainfile_y).getLabel()test_X = DataUtils(testfile_X).getImage()test_y = DataUtils(testfile_y).getLabel()#以下内容是将图像保存到本地文件中path_trainset = \"D:\\imgs_train\"path_testset = \"D:\\imgs_test\"if not os.path.exists(path_trainset): os.mkdir(path_trainset)if not os.path.exists(path_testset): os.mkdir(path_testset)DataUtils(outpath=path_trainset).outImg(train_X, train_y)DataUtils(outpath=path_testset).outImg(test_X, test_y) 程序执行完成后会在本地保存好60000张训练图片和10000张测试图片 加载数据 下面以这些图片作为原始数据，开始手写数字识别。","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"}],"tags":[{"name":"scikit-learn","slug":"scikit-learn","permalink":"http://ff120.github.io/hexoblog/tags/scikit-learn/"},{"name":"手写数字识别","slug":"手写数字识别","permalink":"http://ff120.github.io/hexoblog/tags/手写数字识别/"}]},{"title":"机器学习_学习路线","slug":"技术/机器学习/机器学习_学习路线","date":"2016-06-20T01:45:53.000Z","updated":"2019-03-28T00:54:57.991Z","comments":true,"path":"2016/06/20/技术/机器学习/机器学习_学习路线/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/20/技术/机器学习/机器学习_学习路线/","excerpt":"机器学习的入门资料。","text":"机器学习的入门资料。 # 参考资料 1. 路线图The Missing Roadmap to Self-Study Machine Learning 机器学习入门资源简书 我的路径 看一遍介绍Python语法的书，掌握基本的python语法。 在官网学习Numpy,掌握基本的操作。 自学scikit-learn,掌握其中涉及到的算法 和 Python的一些使用方法。 拿一些有数据集有解题思路有程序的例子自己理解一下。 去各个算法网站找一些历年的比赛题自己做一下。 参加各个算法网站的比赛，熟悉什么情况下应该使用什么算法。 深度学习 深度学习资料 An NIT Press Book,Deep Learning 该书有开源的电子版本，原书是英文的，现在也有了中文的电子版，也是开源的。但是可能质量不如纸质版的出版书。https://github.com/exacity/deeplearningbook-chinese","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"}],"tags":[{"name":"ML","slug":"ML","permalink":"http://ff120.github.io/hexoblog/tags/ML/"}]},{"title":"机器学习_范数","slug":"技术/机器学习/机器学习_范数","date":"2016-06-16T09:42:54.000Z","updated":"2019-03-28T00:54:58.224Z","comments":true,"path":"2016/06/16/技术/机器学习/机器学习_范数/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/16/技术/机器学习/机器学习_范数/","excerpt":"监督学习的一般过程是训练一个模型，根据给出的X计算出y, 然后最小化计算出来的y与真实的y之间的误差。 如果仅仅考虑最小化这个误差，很容易使这个误差为0，就是所有的训练数据都得到了正确的y.但是真实的情况是 训练数据中往往存在噪声，这些噪声和y并没有关系，当训练好的模型应用到模型没有见过的测试数据上时，效果会很差， 这就是过拟合(overfitting)。范数就是一种为了减小过拟合现象引入的参数。常用的范数有L0,L1,L2,核范数等。","text":"监督学习的一般过程是训练一个模型，根据给出的X计算出y, 然后最小化计算出来的y与真实的y之间的误差。 如果仅仅考虑最小化这个误差，很容易使这个误差为0，就是所有的训练数据都得到了正确的y.但是真实的情况是 训练数据中往往存在噪声，这些噪声和y并没有关系，当训练好的模型应用到模型没有见过的测试数据上时，效果会很差， 这就是过拟合(overfitting)。范数就是一种为了减小过拟合现象引入的参数。常用的范数有L0,L1,L2,核范数等。 L0 范数 L0范数是指 向量（模型参数组成的向量）中非0元素的个数。L0范数也可以用来实现稀疏，但是不如L1范数应用广泛。 L1范数（Lasso） L1范数是指 向量中各个元素绝对值之和。可以用来实现稀疏，使用L1范数会使求的的参数很多为0，这样就可以实现稀疏。 稀疏可以用来做特征选择。那些系数为0的参数代表的特征就去掉了。 L2范数 （Ridge） L2范数是指 向量各元素的平方和然后求平方根。L2范数可以使得参数很小，接近于0，但是不是0（L1范数参数是0）防止过拟合，提升模型的泛化能力。 L2范数的作用 有利于处理ill-condition的情况，所谓的ill-condition,就是X变化很小的时候，y的变化很大。因为X都是存在误差的，这样如果X矩阵是ill-condition的， 推测出的结果就不可信。参考资料（http://blog.csdn.net/zouxy09/article/details/24971995/） 核范数 核范数是指 矩阵奇异值的和 参考资料： 123456789[1] http://fastml.com/large-scale-l1-feature-selection-with-vowpal-wabbit/[2] http://www.stat.purdue.edu/~vishy/introml/notes/Optimization.pdf[3] http://www.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf[4] GradientDescent, Wolfe's Condition and Logistic Regression[5] http://nm.mathforcollege.com/mws/gen/04sle/mws_gen_sle_spe_adequacy.pdf","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"}],"tags":[{"name":"范数","slug":"范数","permalink":"http://ff120.github.io/hexoblog/tags/范数/"}]},{"title":"同时使用多个分类器(Scikit-Learn)","slug":"技术/机器学习/机器学习_Scikit-Learn-ManyClassifier","date":"2016-06-16T07:11:46.000Z","updated":"2019-03-28T00:54:57.873Z","comments":true,"path":"2016/06/16/技术/机器学习/机器学习_Scikit-Learn-ManyClassifier/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/16/技术/机器学习/机器学习_Scikit-Learn-ManyClassifier/","excerpt":"scikit-learn里面实现的所有分类器都遵循类似的形式，所以我们使用一个循环语句就可以很方便的应用多种分类器在同一个数据集上。","text":"scikit-learn里面实现的所有分类器都遵循类似的形式，所以我们使用一个循环语句就可以很方便的应用多种分类器在同一个数据集上。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131import numpy as npimport sysfrom time import timeimport matplotlib.pyplot as pltfrom sklearn.datasets import fetch_20newsgroupsfrom sklearn.feature_extraction.text import TfidfVectorizerfrom sklearn.feature_extraction.text import HashingVectorizerfrom sklearn.feature_selection import SelectKBest, chi2from sklearn.feature_selection import SelectFromModelfrom sklearn.linear_model import RidgeClassifierfrom sklearn.linear_model import SGDClassifierfrom sklearn.linear_model import Perceptronfrom sklearn.linear_model import PassiveAggressiveClassifierfrom sklearn.pipeline import Pipelinefrom sklearn.svm import LinearSVCfrom sklearn.naive_bayes import BernoulliNB, MultinomialNBfrom sklearn.neighbors import KNeighborsClassifierfrom sklearn.neighbors import NearestCentroidfrom sklearn.ensemble import RandomForestClassifierfrom sklearn.utils.extmath import densityfrom sklearn import metricscategories = [ 'alt.atheism', 'talk.religion.misc', 'comp.graphics', 'sci.space', ]data_train = fetch_20newsgroups(subset='train',categories=categories,shuffle=True, random_state=42)data_test = fetch_20newsgroups(subset='test',categories=categories,shuffle=True, random_state=42)categories = data_train.target_names def size_mb(docs): return sum(len(s.encode('utf-8')) for s in docs) / 1e6data_train_size_mb = size_mb(data_train.data)data_test_size_mb = size_mb(data_test.data)#print the size and categoiesprint(\"%d documents - %0.3fMB (training set)\" % ( len(data_train.data), data_train_size_mb))print(\"%d documents - %0.3fMB (test set)\" % ( len(data_test.data), data_test_size_mb))print(\"%d categories\" % len(categories))print()y_train, y_test = data_train.target, data_test.targetvectorizer = TfidfVectorizer(sublinear_tf=True, max_df=0.5,stop_words='english')X_train = vectorizer.fit_transform(data_train.data)X_test = vectorizer.transform(data_test.data)feature_names = vectorizer.get_feature_names()feature_names = np.asarray(feature_names)def benchmark(clf): print('-' * 80) print(\"Training: \") print(clf) t0 = time() clf.fit(X_train, y_train) train_time = time() - t0 print(\"train time: %0.3fs\" % train_time) t0 = time() pred = clf.predict(X_test) test_time = time() - t0 print(\"test time: %0.3fs\" % test_time) score = metrics.accuracy_score(y_test, pred) print(\"accuracy: %0.3f\" % score) if hasattr(clf, 'coef_'): print(\"dimensionality: %d\" % clf.coef_.shape[1]) print(\"density: %f\" % density(clf.coef_)) clf_descr = str(clf).split('(')[0] return clf_descr, score, train_time, test_timeresults = []for clf, name in ( (RidgeClassifier(tol=1e-2, solver=\"sag\"), \"Ridge Classifier\"), (Perceptron(n_iter=50), \"Perceptron\"), (PassiveAggressiveClassifier(n_iter=50), \"Passive-Aggressive\"), (KNeighborsClassifier(n_neighbors=10), \"kNN\"), (LinearSVC(loss='l2', penalty='l2',dual=False, tol=1e-3), \"Liblinear model with l2\"), (LinearSVC(loss='l2', penalty='l1',dual=False, tol=1e-3), \"Liblinear model with l1\"), (SGDClassifier(alpha=.0001, n_iter=50,penalty='l2'), \"SGD model with l2\"), (SGDClassifier(alpha=.0001, n_iter=50,penalty='l1'), \"SGD model with l1\"), (SGDClassifier(alpha=.0001, n_iter=50,penalty=\"elasticnet\"),\"SGD model with Elastic-Net penalty\" ), (NearestCentroid(), \"NearestCentroid without threshold\"), (MultinomialNB(alpha=.01),\"MultinomialNB\"), (BernoulliNB(alpha=.01),\"BernoulliNB\"), (RandomForestClassifier(n_estimators=100), \"Random forest\"), (Pipeline([('feature_selection', SelectFromModel(LinearSVC(penalty=\"l1\", dual=False, tol=1e-3))),('classification', LinearSVC())]),\"LinearSVC with L1-based feature selection\"), ): print('=' * 80) print(name) results.append(benchmark(clf))# make some plotsindices = np.arange(len(results))results = [[x[i] for x in results] for i in range(4)]clf_names, score, training_time, test_time = resultstraining_time = np.array(training_time) / np.max(training_time)test_time = np.array(test_time) / np.max(test_time)plt.figure(figsize=(12, 8))plt.title(\"Score\")plt.barh(indices, score, .2, label=\"score\", color='r')plt.barh(indices + .3, training_time, .2, label=\"training time\", color='g')plt.barh(indices + .6, test_time, .2, label=\"test time\", color='b')plt.yticks(())plt.legend(loc='best')plt.subplots_adjust(left=.25)plt.subplots_adjust(top=.95)plt.subplots_adjust(bottom=.05)for i, c in zip(indices, clf_names): plt.text(-.3, i, c)plt.show() 运行结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176&gt;&gt;&gt;2034 documents - 3.980MB (training set)1353 documents - 2.867MB (test set)4 categories()================================================================================Ridge Classifier--------------------------------------------------------------------------------Training: RidgeClassifier(alpha=1.0, class_weight=None, copy_X=True, fit_intercept=True, max_iter=None, normalize=False, random_state=None, solver=&apos;sag&apos;, tol=0.01)train time: 0.125stest time: 0.016saccuracy: 0.897dimensionality: 33810density: 1.000000================================================================================Perceptron--------------------------------------------------------------------------------Training: Perceptron(alpha=0.0001, class_weight=None, eta0=1.0, fit_intercept=True, n_iter=50, n_jobs=1, penalty=None, random_state=0, shuffle=True, verbose=0, warm_start=False)train time: 0.093stest time: 0.000saccuracy: 0.885dimensionality: 33810density: 0.240158================================================================================Passive-Aggressive--------------------------------------------------------------------------------Training: PassiveAggressiveClassifier(C=1.0, class_weight=None, fit_intercept=True, loss=&apos;hinge&apos;, n_iter=50, n_jobs=1, random_state=None, shuffle=True, verbose=0, warm_start=False)train time: 0.125stest time: 0.000saccuracy: 0.902dimensionality: 33810density: 0.698994================================================================================kNN--------------------------------------------------------------------------------Training: KNeighborsClassifier(algorithm=&apos;auto&apos;, leaf_size=30, metric=&apos;minkowski&apos;, metric_params=None, n_jobs=1, n_neighbors=10, p=2, weights=&apos;uniform&apos;)train time: 0.000stest time: 0.187saccuracy: 0.858================================================================================Liblinear model with l2--------------------------------------------------------------------------------Training: LinearSVC(C=1.0, class_weight=None, dual=False, fit_intercept=True, intercept_scaling=1, loss=&apos;l2&apos;, max_iter=1000, multi_class=&apos;ovr&apos;, penalty=&apos;l2&apos;, random_state=None, tol=0.001, verbose=0)train time: 0.171sC:\\Anaconda2\\lib\\site-packages\\sklearn\\svm\\classes.py:197: DeprecationWarning: loss=&apos;l2&apos; has been deprecated in favor of loss=&apos;squared_hinge&apos; as of 0.16. Backward compatibility for the loss=&apos;l2&apos; will be removed in 1.0 DeprecationWarning)C:\\Anaconda2\\lib\\site-packages\\sklearn\\svm\\classes.py:197: DeprecationWarning: loss=&apos;l2&apos; has been deprecated in favor of loss=&apos;squared_hinge&apos; as of 0.16. Backward compatibility for the loss=&apos;l2&apos; will be removed in 1.0 DeprecationWarning)test time: 0.000saccuracy: 0.900dimensionality: 33810density: 1.000000================================================================================Liblinear model with l1--------------------------------------------------------------------------------Training: LinearSVC(C=1.0, class_weight=None, dual=False, fit_intercept=True, intercept_scaling=1, loss=&apos;l2&apos;, max_iter=1000, multi_class=&apos;ovr&apos;, penalty=&apos;l1&apos;, random_state=None, tol=0.001, verbose=0)train time: 0.203stest time: 0.000saccuracy: 0.873dimensionality: 33810density: 0.005553================================================================================SGD model with l2--------------------------------------------------------------------------------Training: SGDClassifier(alpha=0.0001, average=False, class_weight=None, epsilon=0.1, eta0=0.0, fit_intercept=True, l1_ratio=0.15, learning_rate=&apos;optimal&apos;, loss=&apos;hinge&apos;, n_iter=50, n_jobs=1, penalty=&apos;l2&apos;, power_t=0.5, random_state=None, shuffle=True, verbose=0, warm_start=False)train time: 0.094stest time: 0.000saccuracy: 0.902dimensionality: 33810density: 0.671813================================================================================SGD model with l1--------------------------------------------------------------------------------Training: SGDClassifier(alpha=0.0001, average=False, class_weight=None, epsilon=0.1, eta0=0.0, fit_intercept=True, l1_ratio=0.15, learning_rate=&apos;optimal&apos;, loss=&apos;hinge&apos;, n_iter=50, n_jobs=1, penalty=&apos;l1&apos;, power_t=0.5, random_state=None, shuffle=True, verbose=0, warm_start=False)train time: 0.327stest time: 0.000saccuracy: 0.883dimensionality: 33810density: 0.020475================================================================================SGD model with Elastic-Net penalty--------------------------------------------------------------------------------Training: SGDClassifier(alpha=0.0001, average=False, class_weight=None, epsilon=0.1, eta0=0.0, fit_intercept=True, l1_ratio=0.15, learning_rate=&apos;optimal&apos;, loss=&apos;hinge&apos;, n_iter=50, n_jobs=1, penalty=&apos;elasticnet&apos;, power_t=0.5, random_state=None, shuffle=True, verbose=0, warm_start=False)train time: 0.499stest time: 0.000saccuracy: 0.899dimensionality: 33810density: 0.188191================================================================================NearestCentroid without threshold--------------------------------------------------------------------------------Training: NearestCentroid(metric=&apos;euclidean&apos;, shrink_threshold=None)train time: 0.016stest time: 0.000saccuracy: 0.855================================================================================MultinomialNB--------------------------------------------------------------------------------Training: MultinomialNB(alpha=0.01, class_prior=None, fit_prior=True)train time: 0.015stest time: 0.000saccuracy: 0.900dimensionality: 33810density: 1.000000================================================================================BernoulliNB--------------------------------------------------------------------------------Training: BernoulliNB(alpha=0.01, binarize=0.0, class_prior=None, fit_prior=True)train time: 0.000stest time: 0.016saccuracy: 0.884dimensionality: 33810density: 1.000000================================================================================Random forest--------------------------------------------------------------------------------Training: RandomForestClassifier(bootstrap=True, class_weight=None, criterion=&apos;gini&apos;, max_depth=None, max_features=&apos;auto&apos;, max_leaf_nodes=None, min_samples_leaf=1, min_samples_split=2, min_weight_fraction_leaf=0.0, n_estimators=100, n_jobs=1, oob_score=False, random_state=None, verbose=0, warm_start=False)train time: 2.730stest time: 0.094saccuracy: 0.842================================================================================LinearSVC with L1-based feature selection--------------------------------------------------------------------------------Training: Pipeline(steps=[(&apos;feature_selection&apos;, SelectFromModel(estimator=LinearSVC(C=1.0, class_weight=None, dual=False, fit_intercept=True, intercept_scaling=1, loss=&apos;squared_hinge&apos;, max_iter=1000, multi_class=&apos;ovr&apos;, penalty=&apos;l1&apos;, random_state=None, tol=0.001, verbose=0), prefit=False, thresho...ax_iter=1000, multi_class=&apos;ovr&apos;, penalty=&apos;l2&apos;, random_state=None, tol=0.0001, verbose=0))])train time: 0.218stest time: 0.016saccuracy: 0.880 many_classfier 上面是使用稀疏矩阵存放特征的一个例子，当然普通的特征也是可以这样做的，例如，可以将上面的数据换成手写数字识别的数据。 1234567iris = load_iris()X, y = iris.data, iris.targetX_train = XX_test = Xy_train = yy_test = y many_classfier2","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"机器学习","slug":"技术/机器学习","permalink":"http://ff120.github.io/hexoblog/categories/技术/机器学习/"}],"tags":[{"name":"scikit-learn","slug":"scikit-learn","permalink":"http://ff120.github.io/hexoblog/tags/scikit-learn/"}]},{"title":"Hexo的使用01-搭建","slug":"技术/工具/Hexo/Hexo的使用01-搭建","date":"2016-06-13T06:22:06.000Z","updated":"2019-03-28T00:54:55.470Z","comments":true,"path":"2016/06/13/技术/工具/Hexo/Hexo的使用01-搭建/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/13/技术/工具/Hexo/Hexo的使用01-搭建/","excerpt":"hexo是一个快速、简洁且高效的博客框架，它使用渲染引擎渲染markdown文本，生成静态网页。任何可以托管静态网页的空间都可以部署hexo博客。目前流行的组合是hexo + git + github. 可以实现像管理代码的版本那样管理自己的文档。","text":"hexo是一个快速、简洁且高效的博客框架，它使用渲染引擎渲染markdown文本，生成静态网页。任何可以托管静态网页的空间都可以部署hexo博客。目前流行的组合是hexo + git + github. 可以实现像管理代码的版本那样管理自己的文档。 安装 Hexo的安装和部署十分简单，它是基于Node.js的，所以首先确保安装了Node.js.在系统环境中npm命令是可以使用的。 12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server 配置 Hexo分成了两个层级，Hexo应用层面的配置，配置文件在博客根目录的_config.yml,另外一个是主题配置文件，在themes\\[主题名]\\_config.yml中。主题的配置参考你使用的主题的相关的文档配置。 网站的配置参考：https://hexo.io/zh-cn/docs/configuration.html 添加RSS订阅功能 安装 1npm isntall hexo-generator-feed --save 配置 123456在博客配置文件 _config.yml 中添加#添加RSS订阅feed: type: atom path: atom.xml limit: 20 在主题配置文件中 _config.yml 中添加 1rss: /atom.xml nexT主题的配置 nexT是一个界面简洁，干净的主题，很流行。 修改网页背景颜色 主题颜色 打开hexo/themes/next/source/css/_variables/base.styl找到Colors代码段，如下： 123456789101112131415161718// Colors// colors for use across theme.// -------------------------------------------------- $whitesmoke = #f5f5f5 $gainsboro = #eee //这个是边栏头像外框的颜色， $gray-lighter = #ddd //文章中插入图片边框颜色 $grey-light = #ccc //文章之间分割线、下划线颜色 $grey = #bbb //页面选中圆点颜色 $grey-dark = #999 $grey-dim = #666 //侧边栏目录字体颜色 $black-light = #555 //修改文章字体颜色 $black-dim = #333 $black-deep = #495a80 //修改主题的颜色，这里我已经改成老蓝色了。 $red = #ff2a2a $blue-bright = #87daff $blue = #0684bd $blue-deep = #262a30 $orange = #F39D01 //浏览文章时，目录选中的颜色 主题背景 打开hexo/themes/next/source/css/_schemes/Pisces/index.styl(Pisces为NexT提供的三种主题之一，根据使用的主题选择）修改body{}内的值，如下： 背景颜色直接更改即可：body { background: #F0F0F0; } 添加背景：body { background: url（‘/images/background.jpg’); }(将背景图片放到hexo/source/images中即可。 内容背景 修改博客背景颜色 /themes/next/source/css/_schemes/Pisces/_layout.styl 123.content-wrap &#123; background: #222222;&#125; 添加disqus评论支持 https://disqus.com 是一个国际上使用最广泛的评论系统，可以方便的安装在任何网站之上。nexT主题自带了DISQUS评论代码，只需要在配置文件中填上子集的short_name就可以了。 disqus帐号的申请和使用 首先到disqus的官方网站申请一个帐号，登陆。 选择add disqus to site, 在网页的最下端选择get start 选择第二个，我要简历一个网站， 填写网站的相关信息，其中Website Name是唯一的，也就是NexT主题中填入的shor_name. 设置成功之后的样子： maupassant主题配置 另外一个比较简洁的主题，风格类似nexT. https://github.com/tufu9441/maupassant-hexo","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"工具","slug":"技术/工具","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/"},{"name":"Hexo","slug":"技术/工具/Hexo","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://ff120.github.io/hexoblog/tags/hexo/"}]},{"title":"使用Python处理fMRI数据","slug":"技术/认知神经科学/使用Python处理fMRI数据","date":"2016-06-12T12:50:50.000Z","updated":"2019-03-28T00:54:59.713Z","comments":true,"path":"2016/06/12/技术/认知神经科学/使用Python处理fMRI数据/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/12/技术/认知神经科学/使用Python处理fMRI数据/","excerpt":"Python是一种解释型、面向对象、动态数据类型的高级程序设计语言。目前主流的算法基本上都有Python的实现版本，所以能够使用Python处理fMRI数据对于直接使用多种多样的机器学习算法是十分有帮助的。 本文主要涉及的内容有Python,Scikit-lean,nibabel,nilean等。","text":"Python是一种解释型、面向对象、动态数据类型的高级程序设计语言。目前主流的算法基本上都有Python的实现版本，所以能够使用Python处理fMRI数据对于直接使用多种多样的机器学习算法是十分有帮助的。 本文主要涉及的内容有Python,Scikit-lean,nibabel,nilean等。 ## Python 安装Python环境，Windows下使用建议使用Anaconda,一个类似matlab界面的Python环境。 Anaconda 安装完成后，打开cmd键入spyder打开软件 ## scikit-learn scikit-learn是一个很有名的机器学习库，设计了一系列的通用接口以使不同的机器学习算法符合相似的流程。里面实现了大部分目前流行的机器学习算法，而且文档良好，更新速度很快。 &gt;安装 1conda install scikit-learn 卸载 1conda remove scikit-learn 更新 1conda update scikit-learn NiBabel NiBabel是一个读写常见的神经影像数据的Python语言的程序包，可以实现读取和生成大部分常见的神经影像数据格式。 &gt;安装 1pip install nibabel 测试是否成功安装 在Python控制台键入import nibabel没有报错信息证明安装成功 神经影像数据格式 使用fMRI得到的原始数据一般是.IMA结尾的数据，每个TR一个文件，我们可以使用mricron的dcm2niigui.exe转换成.nii结尾的4D文件格式 ### 读取数据 123import nibabel as nib img = nib.load(\"image.nii\") 以上代码将image.nii文件读取到img中，img是nibabel.nifti1.Nifti1Image类型的。 一个nibabel.nifti1.Nifti1Image类型的数据包含三个主要的部分 - image data array 存放图像数据的矩阵 - an affine array 定义了图像数据在参考空间的位置 - image metadata 存放图像的一些属性信息，采集设备名称，体素的大小，扫描层数等等。 &gt;image data array 虽然存储了每个体素的取值信息，但是并没有存储位置信息。也就是说我们并不知道某个体素来自由大脑哪个具体的位置 &gt;affine数组定义了一个从image data array 到标准的参考空间的映射，每个体素经过这个数组映射后都会到一个标准的参考空间，在那个空间中，我们精确的知道每个体素所处的位置。 &gt;结构像和功能像扫描的区域和方向均有所差异，所以都需要使用affine数组映射到参考空间，以确定体素在真实大脑中的位置 ### 显示数据 12345678910img_array = img.get_data() //get image data arrayaffine_array = img.affine //get the affine arrayimg_head = img.header; //get image metadata//获取其他一些信息的方法img.shape // 获得维数信息img.get_data_dtype() // 获得数据类型img_head.get_data_dtype() // 获得头信息的数据类型img_head.get_data_shape() // 获得维数信息img_head.get_zooms() //获得体素大小 Nilearn Nilearn是一个Python实现的适用于处理Neuro-Image数据的机器学习工具包，它可以和scikit-learn很好的结合，用很少的代码就能将大部分机器学习方法用来处理神经影像数据。 实验和数据介绍 该工具包中大部分说明都是使用The Haxby 2001 experiment的实验数据，这里我们介绍一下该实验的相关信息和采集的数据的结构。 #### 实验内容 实验一个选取了六个被试，每个被试的实验内容都有一样。每个被试在实验的时候观看一些图片，使用功能核磁共振获取被试此时大脑的激活信息，利用获得的信息看是否能够分类被试看到的图片的种类。 给被试看的图片分为八类 - 人脸 - 猫 - 房屋 - 椅子 - 剪刀 - 鞋 - 瓶子 - 毫无意义的照片（使用随机噪声生成的图片） 数据结构 数据的获取可以使用内建的方法 12from nilearn import datasetshaxby_dataset = datasets.fetch_haxby() haxby_dataset的结构是这样的 &gt;- anat 是被试1的结构像，T1像，是124X256X256的，是一个3D图像，是被试在静息态的扫描图像 &gt;- func 是被试1的功能图像，就是被试在实验过程中做任务的时候扫描的图像，是40X64X64X1452的，是个4D的图像，前三维是一次TR扫描到的图像，是三维的，最后一维1452代表被试1的功能像一共扫描了1452个TR，也就是有1452个功能图像。 &gt;- mask 是感兴趣的脑区的一个掩膜，想要留下的部分都是1，不需要的部分都是0，是一个和原来图像一样大的矩阵，这个mask是应用到功能像上的，所以它的大小是40X64X64 &gt;- session_target是一个文本文件，里面一共1452行，每一行代表一个TR，表示该TR进行的时候被试受到的刺激的类型。 使用内建方法获得的数据只有一个被试的数据，不过该数据集已经公开，完整数据可以去网站下载。 解码实验 使用fMRI测量得到的大脑状态信息(这里表现为一个40X64X64X1452的矩阵)，解码出被试所受刺激的种类(这里是图片的八种类别)。 基本思路是：从原始数据中用一定的策略提取有用的特征作为输入，session_target中的信息作为输出，训练一个分类器，尽可能的根据输入的特征得出正确的分类结果。 特征选择可以使用的方法： - 选择感兴趣的脑区 - 使用统计方法，计算体素T值和F值，只选择那些有显著变化的体素 - 使用无监督的降维方法，例如PCA 分类器可以选择的方法： - 线性的支持向量机 - LDA，ICA - 决策树 - 神经网络 以下分成四个部分介绍分析的过程： - 特征选择 - 数据准备 - 模型训练和测试 - 结果分析和可视化显示 特征选择 使用mask 这里我们选择使用mask的方法降低特征的数量。mask一般定位在某一个或几个脑区，感兴趣的脑区是根据以前的相关研究确定的，比如研究视觉刺激，就找大脑皮层处理视觉的相关区域。 123456789101112from nilearn.input_data import NiftiMasker#模版文件的路径mask_vt_filename = haxby_dataset.mask_vt[0]#加载模版并标准化nifti_masker = NiftiMasker(mask_img=mask_vt_filename, standardize=True)#功能像4D文件func_filename = haxby_dataset.func[0]#应用mask，并将数据合适转换成（n_sample,n_features）的形式fmri_vt_masked = nifti_masker.fit_transform(func_filename)&gt;&gt;&gt;fmri_vt_masked&gt;&gt;&gt;(1452L, 577L) 功能像文件本来是40*64*64*1452的，如果不做特征选择，直接转换成(n_samples,n_features)的形式,应该是1452*163840的规模，显然特征数量太大了。 应用完mask之后，现在fmri_masked是1452*577的，特征一下少了很多。 我们推测，mask文件中应该有577个1，其余的都是0， &gt; 12345import nibabel as nibmask_v4 = nib.load(&apos;mask4_vt.nii.gz&apos;)mask_v4data = mask_v4.get_data()import numpy as np print np.sum(mask_v4data) 输出577.0,所以经过mask之后的特征变成了577维。 使用F检验 这里我们使用数据提供的一个比较大的mask先选择一个比较大的感兴趣的区域hsxby2001\\mask.nii.gz，然后使用F检验找出影响程度最大的前577个特征，与上面直接使用一个小的mask的分类结果做对比。 123456789101112from nilearn.input_data import NiftiMasker#模版文件的路径mask_filename = haxby_dataset.mask#加载模版并标准化nifti_masker = NiftiMasker(mask_img=mask_filename, standardize=True)#功能像4D文件func_filename = haxby_dataset.func[0]#应用mask，并将数据合适转换成（n_sample,n_features）的形式fmri_masked = nifti_masker.fit_transform(func_filename)&gt;&gt;&gt;fmri_masked&gt;&gt;&gt;(1452L, 39912L) 1234567from sklearn.svm import SVCsvc = SVC(kernel='linear')from sklearn.feature_selection import SelectKBest, f_classiffeature_selection = SelectKBest(f_classif, k=577) #选择排名前577的特征from sklearn.pipeline import Pipelineanova_svc = Pipeline([('anova', feature_selection), ('svc', svc)]) 此处的anova_svc相当于下面的svc,只不过anova_svc会首先执行特征选择过程，再把特征选择的结果送入SVM分类器，anova_svc和svc的使用在形式上完全一样，都是.fit(X,y),.predict(X)的形式。 数据准备 在这一步，我们要对数据的组织格式进行处理，使之符合scikit-learn的输入格式。 &gt;scikit-learn训练器的输入格式一般为train_data,target_data;train_data的格式为(n_samples,n_features) 1234567891011#实验包含八类，这里我们只选择其中的两类数据进行实验#加载target数据labels = np.recfromcsv(haxby_dataset.session_target[0], delimiter=\" \")target = labels['labels']condition_mask = np.logical_or(labels['labels'] == b'face', labels['labels'] == b'cat')target_data = target[condition_mask]#使用mask的特征train_data = fmri_vt_masked[condition_mask]#使用F检验的特征train_f_data = fmri_masked[condition_mask] 现在我们准备好了数据，train_data是216*577的，target_data是216*1的，正好能对应上。 模型训练和测试 实际的模型训练和测试中，常使用交叉验证的方式来保证可靠性。所谓的交叉验证，就是使用一部分数据训练模型，使用另外一部分测试准确率；然后反过来。每次训练数据和测试数据都是互斥的，没有交集。 scikit-learn提供了接口，我们可以很方便的实现交叉验证。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#使用SVM分类和预测from sklearn.svm import SVCsvc = SVC(kernel='linear')from sklearn.cross_validation import KFoldcv = KFold(n=len(train_data), n_folds=5)#使用maskcv_scores = [] #存储每次测试的准确率for train, test in cv: svc.fit(train_data[train], target_data[train]) prediction = svc.predict(train_data[test]) cv_scores.append( np.sum(prediction == target_data[test]) / float(np.size(target_data[test])) ) classification_accuracy = np.mean(cv_scores) #计算平均的分类准确率&gt;&gt;&gt;cv_scores&gt;&gt;&gt;[0.72727272727272729, 0.46511627906976744, 0.72093023255813948, 0.58139534883720934, 0.7441860465116279] &gt;&gt;&gt;classification_accuracy&gt;&gt;&gt;0.64778012684989428#使用F检验cv_f_scores = []for train, test in cv: anova_svc.fit(train_f_data[train], target_data[train]) y_pred = anova_svc.predict(train_f_data[test]) cv_f_scores.append(np.sum(y_pred == target_data[test]) / float(np.size(target_data[test])))classification_f_accuracy = np.mean(cv_f_scores) #计算平均的分类准确率&gt;&gt;&gt;cv_f_scores&gt;&gt;&gt;Out[133]: [0.59090909090909094, 0.39534883720930231, 0.76744186046511631, 0.65116279069767447, 0.55813953488372092] &gt;&gt;&gt;classification_f_accuracy&gt;&gt;&gt;0.59260042283298098#计算change levelfrom sklearn.dummy import DummyClassifierfrom sklearn.cross_validation import cross_val_scorenull_cv_scores = cross_val_score(DummyClassifier(), train_data, target_data, cv=cv) null_accuracy = np.mean(null_cv_scores)&gt;&gt;&gt;null_cv_scores&gt;&gt;&gt;array([ 0.54545455, 0.48837209, 0.48837209, 0.34883721, 0.55813953])&gt;&gt;&gt;null_accuracy&gt;&gt;&gt;0.48583509513742068print cv_scores,classification_accuracyprint cv_f_scores,classification_f_accuracyprint null_cv_scores,null_accuracy 可以看到，简单的使用F检验的结果并没有使用先验的小mask获得的准确率高，但是F检验获得的分类准确率也显著高于chance level. #### 结果分析和可视化显示 获得模型参数 12345678# Retrieve the SVC discriminating weightscoef_ = svc.coef_# Reverse masking thanks to the Nifti Maskercoef_img = nifti_masker.inverse_transform(coef_)# Save the coefficients as a Nifti imagecoef_img.to_filename('haxby_svc_weights.nii') svc.coef_是SVM模型的参数，从中可以看出各个特征对分类结果的贡献的大小。 显示图像 12345678910# Create the figurefrom nilearn import imagefrom nilearn.plotting import plot_stat_map, showimport nibabel as nib# Plot the mean image because we have no anatomic datamean_img = image.mean_img(func_filename)weight_img = nib.load('haxby_svc_weights.nii')plot_stat_map(weight_img, mean_img, title='SVM weights')show() &gt; 从该图像中，我们能够看到那些对分类结果影响较大的体素，这些地方很可能就是大脑内专门负责这两个不同的类别的区分任务的。","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"认知神经科学","slug":"技术/认知神经科学","permalink":"http://ff120.github.io/hexoblog/categories/技术/认知神经科学/"}],"tags":[{"name":"fMRI","slug":"fMRI","permalink":"http://ff120.github.io/hexoblog/tags/fMRI/"}]},{"title":"Hexo的使用02-同步","slug":"技术/工具/Hexo/Hexo的使用02-同步","date":"2016-06-12T12:02:43.000Z","updated":"2019-03-28T00:54:55.494Z","comments":true,"path":"2016/06/12/技术/工具/Hexo/Hexo的使用02-同步/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/12/技术/工具/Hexo/Hexo的使用02-同步/","excerpt":"Hexo生成的博客在Public文件夹中。我们使用命令hexo d部署的时候，是吧该文件夹下的内容上传到了github的以用户名为仓库名的master分支上。 由于生成之后的文件是HTML格式的，不便于再编辑，所以存一份markdown格式的源代码也是很有必要的。在GitHub新建一个仓库hexoblog,使用这个仓库 存储Hexo的源代码。Coding.net与GitHub高度相似，不同的是它的Pages读取的是用户名为仓库名的gh-pages分支的代码，而不是master分支的代码，所以master分支正好可以用来 存储Hexo的源代码。","text":"Hexo生成的博客在Public文件夹中。我们使用命令hexo d部署的时候，是吧该文件夹下的内容上传到了github的以用户名为仓库名的master分支上。 由于生成之后的文件是HTML格式的，不便于再编辑，所以存一份markdown格式的源代码也是很有必要的。在GitHub新建一个仓库hexoblog,使用这个仓库 存储Hexo的源代码。Coding.net与GitHub高度相似，不同的是它的Pages读取的是用户名为仓库名的gh-pages分支的代码，而不是master分支的代码，所以master分支正好可以用来 存储Hexo的源代码。 具体配置过程 .git中的conf文件中这样配置 123456789101112131415[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true hideDotFiles = dotGitOnly[remote \"origin\"] url = https://username:password@git.coding.net/username/username.git url = https://github.com/username/hexoblog.git fetch = +refs/heads/*:refs/remotes/origin/*[branch \"master\"] remote = origin merge = refs/heads/master .gitignore文件中这样配置 1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ .deploy_git文件夹中是执行hexo d提交的内容，在hexo配置文件_config.yml中这样配置 1234567891011# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: - type: git repo: https://username:password@git.coding.net/username/username.git branch: coding-pages message: - type: git repo: https://username:password@github.com/username/username.github.io.git branch: master message: 这样就可以实现生成的网站和网站源代码分别维护了。需要发布网站的时候，执行hexo d 需要备份博客数据的时候执行git commit -a -m和git push origin master。 &gt;注意：把以上的username换成你自己的用户名，password换成自己的密码","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"工具","slug":"技术/工具","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/"},{"name":"Hexo","slug":"技术/工具/Hexo","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/Hexo/"}],"tags":[{"name":"git","slug":"git","permalink":"http://ff120.github.io/hexoblog/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"http://ff120.github.io/hexoblog/tags/hexo/"}]},{"title":"Windows手工修改路由表","slug":"技术/工具/网络软件/Windows手工修改路由表","date":"2016-06-12T10:49:09.000Z","updated":"2019-03-28T00:54:55.743Z","comments":true,"path":"2016/06/12/技术/工具/网络软件/Windows手工修改路由表/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/12/技术/工具/网络软件/Windows手工修改路由表/","excerpt":"当电脑开启VPN后，局域网内远程桌面连接就会失效，因为此时电脑所有网络都走VPN连接，走VPN后不再是一个局域网的地址了。要解决这个问题，可以手工控制路由表，实现远程桌面连接。","text":"当电脑开启VPN后，局域网内远程桌面连接就会失效，因为此时电脑所有网络都走VPN连接，走VPN后不再是一个局域网的地址了。要解决这个问题，可以手工控制路由表，实现远程桌面连接。 例如，有A，B两台电脑在同一个局域网。B通过A的本地连接的IP地址可以远程到A，这时候A拨号上网之后获得一个新的IP，B能通过这个新的IP连接到A，但是通过本地连接连接不到了。 这时候可以修改A的路由表，让B通过A的本地连接IP地址连接A，这样可以实现A无论上不上外网，B都可以远程到A，不管A的网络环境如何变化。 以管理员身份运行cmd 1route add 172.23.0.0 mask 255.255.0.0 172.24.8.1 -p B 的IP地址所在的子网是 172.23.0. A 的出口网关地址是172.24.8.1 -p 是永久加入路由表，即使机器重启，如果只是临时使用，不用加参数-p 路由操作常用命令 12345route print 打印当前路由表route add 添加一条路由route delete 删除一条路由route change 修改一条现有的路由route /? 查看该命令的帮助文件","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"工具","slug":"技术/工具","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/"},{"name":"网络软件","slug":"技术/工具/网络软件","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/网络软件/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://ff120.github.io/hexoblog/tags/网络/"}]},{"title":"Windows全局代理软件Proxifier","slug":"技术/工具/网络软件/Windows全局代理软件Proxifier","date":"2016-06-12T10:28:28.000Z","updated":"2019-03-28T00:54:55.722Z","comments":true,"path":"2016/06/12/技术/工具/网络软件/Windows全局代理软件Proxifier/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/12/技术/工具/网络软件/Windows全局代理软件Proxifier/","excerpt":"Proxifier 是一款功能非常强大的socks5代理服务器，可以让不支持通过代理服务器工作的网络程序能通过HTTPS或SOCKS代理或代理链。支持64位系统，支持Xp，Vista，Win7，支持socks4，socks5，http代理协议，支持TCP，UDP协议，可以指定端口，指定IP，指定程序等运行模式，兼容性非常好。","text":"Proxifier 是一款功能非常强大的socks5代理服务器，可以让不支持通过代理服务器工作的网络程序能通过HTTPS或SOCKS代理或代理链。支持64位系统，支持Xp，Vista，Win7，支持socks4，socks5，http代理协议，支持TCP，UDP协议，可以指定端口，指定IP，指定程序等运行模式，兼容性非常好。 安装 Proxifier 配置 只需要配置代理服务器地址和端口号，Proxifier就可以默认为所有应用程序提供代理 Profile-&gt;Proxy Servers打开代理服务器配置窗口 Address port填代理服务器的地址和端口号，Protocol选择SOCKS Version 5,然后ok 设置代理规则 实际使用的时候，可能某个应用程序不想使用代理，例如utorrent,可能某些网站不想使用代理，例如学校内网的网站，PT站点等无需认证就能上的站点，可能有的网站需要不同的代理，例如访问国外网站需要一个能翻墙的代理，这些都可以通过配置代理规则来实现。 profile-&gt;Proxification Rules打开代理规则配置窗口 hexo 可以按照程序，目标网站，端口三种类型配置代理规则，配置完成后确定即可启用。","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"工具","slug":"技术/工具","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/"},{"name":"网络软件","slug":"技术/工具/网络软件","permalink":"http://ff120.github.io/hexoblog/categories/技术/工具/网络软件/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://ff120.github.io/hexoblog/tags/网络/"}]},{"title":"校园网多终端上网方案","slug":"技术/计算机基础/计算机网络/网络_校园网多终端上网方案","date":"2016-06-12T09:09:50.000Z","updated":"2019-03-28T00:54:59.334Z","comments":true,"path":"2016/06/12/技术/计算机基础/计算机网络/网络_校园网多终端上网方案/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/12/技术/计算机基础/计算机网络/网络_校园网多终端上网方案/","excerpt":"现在有不少学校的校园网同一个帐号只能同时在一个或者两个设备登陆，一旦你使用的设备超过这个数量，就会很麻烦，这里介绍两种代理上网的方案，适用于那种有一台电脑常开着的情况。 如果你有一台可以上网的电脑A，如何通过让其他设备都通过A上网呢？最常见的就是在A电脑上开一个热点，其他设备连接这个热点。但是这样做能够使用的范围很小，如果你在一个很大的局域网内，局域网内的机器不需要登陆帐号就可以互相Ping通，那么有更好的方式实现这一点。","text":"现在有不少学校的校园网同一个帐号只能同时在一个或者两个设备登陆，一旦你使用的设备超过这个数量，就会很麻烦，这里介绍两种代理上网的方案，适用于那种有一台电脑常开着的情况。 如果你有一台可以上网的电脑A，如何通过让其他设备都通过A上网呢？最常见的就是在A电脑上开一个热点，其他设备连接这个热点。但是这样做能够使用的范围很小，如果你在一个很大的局域网内，局域网内的机器不需要登陆帐号就可以互相Ping通，那么有更好的方式实现这一点。 ## 使用代理软件 在机器Ａ上下载安装CCProxy,虽然是收费软件，但是可以免费使用，免费版本限制3个用户连接，自己使用的话应该够了。 开启服务器 然后在设置—高级—网络中取消禁止局域网外部用户访问的对勾，确定 在设置里面的本机局域网IP地址选择自动检测，如果自动检测不能上网，请手动选择机器A能够连接外网的那个IP。 保持主机A CCPROXY软件的运行。在主机B上配置ＨＴＴＰ代理或者scoket5代理，代理的地址是A的局域网IP地址，就是B能ping 通的那个IP地址，端口号默认HTTP是808，socket5是1080. 好了，现在主机B就可以上网了。现在的许多智能手机都原生支持HTTP代理，如何设置自行百度。 搭建VPN 使用代理的好处是配置简单，可以配置自定义的规则，让不同的程序使用不同的网络连接。但是有的程序不支持使用代理连接，这时候可以考虑使用VPN。 openvpn 在A上安装OpenVPN以Server方式运行，并将A可以上网的网络适配器共享给OpenVPN的虚拟适配器。 在需要上网的手机或者电脑安装OpenVPN，并以Client方式运行，配置文件中填写A的ip地址，这里可以是IPv4，也可以是IPv6.IPv4可以在同一个学校通用，如果是IPv6地址，可以跨越学校，A机器在国内其他高校时，也可以使用。 这是一种使用其他学校校园网资源的方法，例如，可以通过这样的方法下载Ａ所在学校购买的数据库。 softether softether也是一个VPN软件，提供友好的操作界面，客户端可以直接使用Windows自带的VPN连接，支持大部分手机使用自带的VPN连接。而且还支持动态DNS服务，如果Ａ所在地方的IP经常变动，推荐使用这个软件。 通过它还可以建立级联连接，只要双方单向联通，就可以建立一条专用通道，实现互联互通。","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"计算机基础","slug":"技术/计算机基础","permalink":"http://ff120.github.io/hexoblog/categories/技术/计算机基础/"},{"name":"计算机网络","slug":"技术/计算机基础/计算机网络","permalink":"http://ff120.github.io/hexoblog/categories/技术/计算机基础/计算机网络/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://ff120.github.io/hexoblog/tags/网络/"}]},{"title":"Apache 配置虚拟主机","slug":"技术/Web开发/后台开发_Apache-配置虚拟主机","date":"2016-06-12T08:44:58.000Z","updated":"2019-03-28T00:54:58.648Z","comments":true,"path":"2016/06/12/技术/Web开发/后台开发_Apache-配置虚拟主机/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/12/技术/Web开发/后台开发_Apache-配置虚拟主机/","excerpt":"Apache支持多个虚拟主机的设置，可以实现在一个IP上部署多个网站的效果。例如，在本机实现每个域名访问一个对应的网站，Apache应该如下配置。","text":"Apache支持多个虚拟主机的设置，可以实现在一个IP上部署多个网站的效果。例如，在本机实现每个域名访问一个对应的网站，Apache应该如下配置。 修改http.conf文件 1234&lt;Directory \"E:/WebRoot\"&gt; AllowOverride All Require all granted&lt;/Directory&gt; 上面的代码将文件夹W:/WebRoot设置成可访问 1Include \"conf/extra/httpd-vhost.conf\" 在主配置文件中包含虚拟主机配置文件，虚拟主机的信息在httpd-vhost.conf中配置 修改httpd-vhost.conf文件 12345678&lt;VirtualHost *:80&gt; ##ServerAdmin webmaster@dummy-host.example.com DocumentRoot \"E:/WebRoot\" ServerName localhost ServerAlias localhost ErrorLog \"logs/blog.com-error.log\" CustomLog \"logs/blog.com-access.log\" common&lt;/VirtualHost&gt; 第一个节点是默认节点，所有没有匹配到的域名都会走这个节点，所以一般把这里设置成Web根目录，域名就是localhost,这样以后可以用localhost访问到这个web根目录的内容。 12345678&lt;VirtualHost *:80&gt; ##ServerAdmin webmaster@dummy-host.example.com DocumentRoot \"E:/WebRoot/laravel-5-blog/public/\" ServerName my.blog.com ServerAlias my.blog.com ErrorLog \"logs/blog.com-error.log\" CustomLog \"logs/blog.com-access.log\" common&lt;/VirtualHost&gt; 像上面这样配置，当在浏览器输入my.blog.com的时候，就会访问到E:/WebRoot/laravel-5-blog/public/下，这里需要注意的是，一定要在httpd.conf里面设置了该文件夹的可访问权限，否则是会拒绝访问的。 1234567&lt;VirtualHost *:80&gt; ServerAdmin webmaster@dummy-host2.example.com DocumentRoot \"E:/WebRoot/wordpress/\" ServerName my.wordpress.com ErrorLog \"logs/wordpress.com-error.log\" CustomLog \"logs/wordpress.com-access.log\" common&lt;/VirtualHost&gt; 上面增加了一个域名为my.wordpress.com的站点。 修改系统hosts文件 12127.0.0.1 my.blog.com127.0.0.1 my.wordpress.com 然后就可以在浏览器使用对应的域名访问对应的网站了。这样设置的好处是对于那些路由有特殊要求的框架适应性比较好，不会出现资源找不到情况。另外，如果想在一台服务器上安装多个网站，这也是一个可行的方法。","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"Web开发","slug":"技术/Web开发","permalink":"http://ff120.github.io/hexoblog/categories/技术/Web开发/"}],"tags":[{"name":"php","slug":"php","permalink":"http://ff120.github.io/hexoblog/tags/php/"},{"name":"apache","slug":"apache","permalink":"http://ff120.github.io/hexoblog/tags/apache/"}]},{"title":"参考文献书写格式","slug":"技术/认知神经科学/参考文献书写格式","date":"2016-06-12T08:37:10.000Z","updated":"2019-03-28T00:54:59.859Z","comments":true,"path":"2016/06/12/技术/认知神经科学/参考文献书写格式/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/12/技术/认知神经科学/参考文献书写格式/","excerpt":"国标格式 【图书】 作者. 书名[M]. 出版地: 出版社, 出版年. 【期刊论文】 作者. 论文标题[J]. 来源期刊, 年, 卷(期): 页码. 【学位论文】 作者. 论文标题[D]. 毕业院校所在地: 院校名称, 毕业年份. 【会议论文】 作者. 论文标题[C]// 会议论文集名称, 年代: 页码. 【专利】 申请人(发明人). 专利名称: 国别, 申请号[P]. 公开日. 【网络文献】 作者. 论文标题[EB/OL]. [检索日期].网址.","text":"国标格式 【图书】 作者. 书名[M]. 出版地: 出版社, 出版年. 【期刊论文】 作者. 论文标题[J]. 来源期刊, 年, 卷(期): 页码. 【学位论文】 作者. 论文标题[D]. 毕业院校所在地: 院校名称, 毕业年份. 【会议论文】 作者. 论文标题[C]// 会议论文集名称, 年代: 页码. 【专利】 申请人(发明人). 专利名称: 国别, 申请号[P]. 公开日. 【网络文献】 作者. 论文标题[EB/OL]. [检索日期].网址. 示例 [1] 王蔷. 小学英语教学法教程[M]. 北京：高等教育出版社，2003. [2] 陶仁骥. 密码学与数学[J]. 自然杂志，1984，7（7）：527-530. [3] 华南理工大学. 一种长效矿物钾肥及其制备方法: 中国,200410026621.3[P].2004-03-25. [4] 王亚军.整装催化剂及催化转化器若干研究[D].北京:北京理工大学,2000. [5] 余晓蔚. 图书馆信息素养课程建设的实践与创新[C]// 全国文献检索课程教学研讨会, 2010: 25-33. [6] 信息[EB/OL]. [2013-02-22]. http://baike.baidu.com/view/1527.htm.","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"认知神经科学","slug":"技术/认知神经科学","permalink":"http://ff120.github.io/hexoblog/categories/技术/认知神经科学/"}],"tags":[{"name":"文献格式","slug":"文献格式","permalink":"http://ff120.github.io/hexoblog/tags/文献格式/"}]},{"title":"文献检索方法","slug":"技术/认知神经科学/文献检索方法","date":"2016-06-12T04:14:48.000Z","updated":"2019-03-28T00:55:00.039Z","comments":true,"path":"2016/06/12/技术/认知神经科学/文献检索方法/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/12/技术/认知神经科学/文献检索方法/","excerpt":"中国专利检索 专利是一种公开、免费、详细的资料，通常情况下比论文更新及时，了解专利申请情况，有利于把握住研究课题的前沿。","text":"中国专利检索 专利是一种公开、免费、详细的资料，通常情况下比论文更新及时，了解专利申请情况，有利于把握住研究课题的前沿。 ## 常用的专利检索网站 - 中国知识产权局 - 中国知识产权网 - SooPAT 西文专利检索 常用的专利检索网站 Derwent 美国专业与商标局 欧洲Espacenet 日本JPO","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"认知神经科学","slug":"技术/认知神经科学","permalink":"http://ff120.github.io/hexoblog/categories/技术/认知神经科学/"}],"tags":[{"name":"文献检索","slug":"文献检索","permalink":"http://ff120.github.io/hexoblog/tags/文献检索/"}]},{"title":"使用Database Configuration Assist 工具创建oracle数据库","slug":"技术/数据库/数据库_使用Database-Configuration-Assist-工具创建oracle数据库","date":"2016-06-12T01:59:52.000Z","updated":"2019-03-28T00:54:55.887Z","comments":true,"path":"2016/06/12/技术/数据库/数据库_使用Database-Configuration-Assist-工具创建oracle数据库/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/12/技术/数据库/数据库_使用Database-Configuration-Assist-工具创建oracle数据库/","excerpt":"启动Database Configuration Assist 工具,在oracle用户下输入dbca，如果出现图形化安装界面就说明启动成功了，如果提示错误，就比较麻烦了，第一个方法是先回到root用户下，输入xhost +，回车，然后再回到oracle用户下，重新输入dbca，如果还打不开图形界面，那么就麻烦了，要重新装一下昨天装的软件，直接输入cd /soft/database/，然后ls，然后./runInstall，重新装一遍，有一个界面是提示出现一个错误和一个警告，把那两个都打上对勾，然后完成安装，之后在oracle中接着输入dbca就Ok了，进入到图形安装界面。","text":"启动Database Configuration Assist 工具,在oracle用户下输入dbca，如果出现图形化安装界面就说明启动成功了，如果提示错误，就比较麻烦了，第一个方法是先回到root用户下，输入xhost +，回车，然后再回到oracle用户下，重新输入dbca，如果还打不开图形界面，那么就麻烦了，要重新装一下昨天装的软件，直接输入cd /soft/database/，然后ls，然后./runInstall，重新装一遍，有一个界面是提示出现一个错误和一个警告，把那两个都打上对勾，然后完成安装，之后在oracle中接着输入dbca就Ok了，进入到图形安装界面。 创建数据库 ## 选择一般数据库 ## 给数据库命名要求为：组号+姓名首字母缩写 ## 选择使用EM配置数据库，使用Database Control管理数据库 ## 密码统一使用oracle ## 选择文件系统 ## 选择数据文件的目录 ## 指定闪回恢复区 ## 选择sample Schema ## 字符集选择如下 ## database storage 概览 ## 创建数据库，保存为数据库模板，并生成创建脚本 ## 数据库配置概览 ## 模板创建完成及脚本生成 ## 如下创建过程直至退出","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据库","slug":"技术/数据库","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据库/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://ff120.github.io/hexoblog/tags/oracle/"}]},{"title":"测试_Apache JMeter的使用","slug":"技术/Web开发/测试_Apache-JMeter的使用","date":"2016-06-11T12:37:39.000Z","updated":"2019-03-28T00:54:59.218Z","comments":true,"path":"2016/06/11/技术/Web开发/测试_Apache-JMeter的使用/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/11/技术/Web开发/测试_Apache-JMeter的使用/","excerpt":"jmeter","text":"jmeter 1. 安装 安装Java运行环境 下载Apache JMeter安装包 http://jmeter.apache.org/download_jmeter.cgi 下载apache-jmeter-2.12.zip md5 pgp 解压至任意文件夹，运行bin里面的jmeter,出现图形界面 Apache JMeter 教程： http://www.ltesting.net/ceshi/open/kyxncsgj/jmeter/ 2.JMeter 录制操作脚本 2.1 使用badboy http://www.badboy.com.au/ file-&gt;new 开始录制 file-&gt;Export to JMeter 导出脚本 使用Jmeter file-&gt;open 打开脚本，添加Listener后开始测试 ###2.2 使用自带的代理服务器录制脚本 右击Test Plan Add-&gt;Threads(users)-&gt;Threads Group 右击Threads Group Add-&gt;Logic Controller-&gt;Recording Controller 右击WorkBench Add-&gt;Non-test Elements-&gt;HTTP(S) Test Script Recorder 在Target Controller选择Test Plan-&gt;Thread Group-&gt;Recording Controller 在Grouping选择Put each group in a new transaction controller 单击底部的Start开启代理服务器 IE配置： Internet Options-&gt;Connections-&gt;LAN Settings 在Proxy server下面的方框打钩，Adress: localhost Port:8080 单击OK 在浏览器输入录制的网址，就可以开始录制了。录制完成后，停止代理服务器，取消IE的代理设置即可。 要访问HTTPS的网站，需要将证书加入到浏览器中， 证书位置：JMeter-&gt;bin目录中的ApacheJMeterTemporaryRootCA.crt FireFox加入办法：Options-&gt;Advanced-&gt;Certificates-&gt;View Certificates-&gt;Import 数字证书安装参考：http://jmeter.apache.org/usermanual/component_reference.html#HTTP%28S%29_Test_Script_Recorder 在根证书里面加上bin里面自动生成的证书。 3. 查看并分析测试结果 通过上一步得到测试脚本后，下一步就是Add-&gt;Listener-&gt;Aggregate Report,Add-&gt;Listener-&gt;View Result in Table等查看测试结果了。 ###3.1 Aggregate Report - Label element(例如HTTP Request) 的名称 - Samples 发出的请求的数量 - Average 平均的响应时间 - Median 所有响应时间的中位数 - 90%Line 90%用户的响应时间 - Min 最小的响应时间 - Max 最大的响应时间 - Error% 出现错误的请求的数量 / 请求的总数 - Throughput 每秒完成的请求数量（Request Per Sencond） - KB/sec 每秒从服务器接收到的数据量 ###3.2 View Result in Table - Sample 请求的序号 - StartTime 请求开始的时间 - ThreadName 本次请求的线程的名称 - Sample Time 请求花费的时间 - Status 请求是否成功 - Bytes 请求返回的数据量 3. New Relic（在线监测平台） 3.1 配置 注册账户 http://newrelic.com/ 选择最上面的APM，然后选择PHP，安装PHP Agent https://docs.newrelic.com/docs/agents/php-agent/installation/php-agent-installation-redhat-centos 安装完成之后重启服务器，出现PHP Application，单击进入有监控界面 PHPAplication_NewRelic.png 参考网站：http://code.tutsplus.com/tutorials/new-relic-jmeter-perfect-performance-testing–net-34978 ###3.2 监测结果分析 参考网址：https://cnodejs.org/topic/53fde58d7c1e2284785cd39e ####3.2.1 Overview 后台统计总图，分为5个部分 - Web transactions response time 网站平均响应时间 - Apdex score 应用性能指数：蓝色表示优异，绿色表示好，黄色表示一般 - Throughput 每分钟请求数 （request per minute） - Transaction 接口的响应时间 - Error rate 引起错误的请求 / 总请求数量 图：image-&gt;New Relic入门-&gt;Overview_NewRelic.png ####3.2.2 Map 系统用到的各个应用之间的关系 和 每个应用的平均响应时间 图：image-&gt;New Relic入门-&gt;Map_NewRelic.png ####3.2.3 Transactions 应用请求的每个URL地址的响应时间。在这里可以看到每个接口的响应时间。 单击某个能看到详细的信息。 图：image-&gt;New Relic入门-&gt;Transactions_NewRelic.png ####3.2.4 Database 数据库的各种操作的平均响应时长 ### browser 参考网站：http://code.tutsplus.com/tutorials/front-end-monitoring-with-new-relic-browser–cms-22424 在每一个展示给用户的页面加载完成的时候，Browser都会捕捉一下信息： - 页面加载完毕花费的时间 - 代码和动作（包括JS，Ajax, 用户与浏览器交互的时间）执行的时间 - 在网络上和服务器上花费的时间 - 浏览器信息，操作系统信息 Overview:概要视图 browser -&gt; Session traces: 跟踪一个真正的用户从开始到结束的经历。监控的信息包括，用户交互，资源加载，iframes,等待Ajax调用的时间，出现的错误和其他相关信息。 在这里，你能看到一个错误发生之前和之后用户做了什么。 Session traces help you understand: How users experience your page load, including time to DOM load, time waiting for Ajax requests to complete, and the user’s interactions with the page How the New Relic metrics reflect your end users’ experiences The sequence of JavaScript and browser events, which take longer than others, and when each event occurs Where bottlenecks occur, and what may be causing them Why one page load may be slower than others, by providing the context for individual events during a session browser -&gt; Page Views: 提供被频繁访问的页面的详细信息 broeser -&gt; Browsers: 查看你的网站在不同浏览器下的表现。 Synthetics 为你的网站设置定期的测试，当问题出现后立刻通知你。 ### Server 监控服务器 硬盘 内存 网络 CPU使用情况。 Server -&gt; Processes: 显示每个进程的CPU和内存使用情况","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"Web开发","slug":"技术/Web开发","permalink":"http://ff120.github.io/hexoblog/categories/技术/Web开发/"}],"tags":[{"name":"性能测试","slug":"性能测试","permalink":"http://ff120.github.io/hexoblog/tags/性能测试/"},{"name":"jmeter","slug":"jmeter","permalink":"http://ff120.github.io/hexoblog/tags/jmeter/"}]},{"title":"测试_Selenium Action","slug":"技术/Web开发/测试_Selenium-Action","date":"2016-06-11T12:36:31.000Z","updated":"2019-03-28T00:54:59.256Z","comments":true,"path":"2016/06/11/技术/Web开发/测试_Selenium-Action/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/11/技术/Web开发/测试_Selenium-Action/","excerpt":"action用于模拟用户与浏览器之间的交互","text":"action用于模拟用户与浏览器之间的交互 &gt; - open(url) 打开网页 &gt; - click() 单击 &gt; - clickAndWait() 单击并等待，生成代码时，比上一句多一个$this-waitForPageLoad('3000'); &gt; - type( , ) 输入文本 &gt; - select() 选择下拉菜单 &gt; - goBack() 单击浏览器返回按钮 &gt; - close() 模拟单击关闭按钮 &gt; - setSpeed() 设置执行速度 &gt; - pause() 等待指定的时间后继续执行 &gt; - setTinmeout() 指定过期时间","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"Web开发","slug":"技术/Web开发","permalink":"http://ff120.github.io/hexoblog/categories/技术/Web开发/"}],"tags":[{"name":"selenium","slug":"selenium","permalink":"http://ff120.github.io/hexoblog/tags/selenium/"}]},{"title":"测试_Selenium定位元素的几种方式","slug":"技术/Web开发/测试_Selenium-定位元素的几种方式","date":"2016-06-11T12:34:48.000Z","updated":"2019-03-28T00:54:59.283Z","comments":true,"path":"2016/06/11/技术/Web开发/测试_Selenium-定位元素的几种方式/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/11/技术/Web开发/测试_Selenium-定位元素的几种方式/","excerpt":"1. 默认方式 形如identifier = location的定位方式在HTNL文件中寻找第一个ID等于location的元素，如果没有，则匹配第一个name等于location的元素，也可以直接简写成location","text":"1. 默认方式 形如identifier = location的定位方式在HTNL文件中寻找第一个ID等于location的元素，如果没有，则匹配第一个name等于location的元素，也可以直接简写成location 2. 通过ID定位 形如id = id_name的定位方式在HTML文件中匹配ID等于id_name的元素。 ## 3. 通过name定位 形如name = name_name的定位方式可以匹配文件中第一个name等于name_name的元素。通常，在HTNL中，name与ID不同，name并不一定是唯一的，可能许多不同的元素有相同的name，为了匹配到不同的元素，可以加上不同于其他元素的特征，例如： 12345678910&lt;html&gt; &lt;body&gt; &lt;form id=&quot;loginForm&quot;&gt; &lt;input name=&quot;username&quot; type=&quot;text&quot; /&gt; &lt;input name=&quot;password&quot; type=&quot;password&quot; /&gt; &lt;input name=&quot;continue&quot; type=&quot;submit&quot; value=&quot;Login&quot; /&gt; &lt;input name=&quot;continue&quot; type=&quot;button&quot; value=&quot;Clear&quot; /&gt; &lt;/form&gt; &lt;/body&gt; &lt;html&gt; &gt; - name = username 定位到第四行 &gt; - name = continue value = clear name = continue clear name = continue type=button 都会定位到第七行。 过上面的三种方法，可以独立的测试某个元素，与HTML结构没有关系。所以，当你的网页结构经常变化又希望不要经常改变测试代码的时候，尽量使用上面三种方式就显得十分重要。 # 4. 通过XPath定位 XPath是XML中定位结点的一种方式，因为HTML也可以实现XML接口，所以也可以XPath语法定位HTML元素。 XPath有两种定位方式，绝对定位和相对定位。 - 绝对定位从html元素开始一级一级找到需要的元素，HTML文件很小的改动也可能打破这种层级关系，所以不推荐使用这种定位方式。 - 相对定位是从某一个容易定位的元素开始，以它为参照找到需要的元素，原HTML文件部分改动时，对这种相对关系影响较小，推荐使用这种定位方式。 只有当用以上三种方式不容易定位到需要的元素时，才推荐使用XPath定位。 用上面的HTML举几个例子： 1. xpath = /html/body/form[1] 对定位，定位到第三行form 2. //form[1] 对定位，定位到HTML中第一个form元素 3. xpath=//form[@id='loginForm'] 位到id='loginForm'的form元素 4. xpath=//form[input/@name='username'] 位到有一个name=username的input元素的form中 5. //input[@name='username'] 一个name=username的input元素 6. //form[@id='loginForm']/input[1] 位到Id=’loginForm’的form中的第一个input元素 7. //input[@name='continue'][@type='button'] 位到name=continue type=button的input元素 8. //form[@id='loginForm']/input[4] 位到ID=loginForm的form元素中的第四个元素。 # 5. 通过超链接定位 合定位带超链接的元素 1. link=www.baidu.com 2. link=首页 果HTML中存在多个href相同的字段，总是返回第一个。 # 6. 通过DOM定位 用JavaScript定位元素的方式： dom=document.getElementById(‘loginForm’) (3) dom=document.forms[‘loginForm’] (3) dom=document.forms[0] (3) document.forms[0].username (4) document.forms[0].elements[‘username’] (4) document.forms[0].elements[0] (4) document.forms[0].elements[3] (7) # 7. 通过CSS样式定位 SS通过选择器将定义的样式与文档中的元素绑定在一起。CSS定位元素的策略也可以在Selenium中使用。 css=form#loginForm (3) css=input[name=“username”] (4) css=input.required[type=“text”] (4) css=input.passfield (5) css=#loginForm input[type=“button”] (7) css=#loginForm input:nth-child(2) (5) 小括号中的数字代码定位到HTML代码的第几行。","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"Web开发","slug":"技术/Web开发","permalink":"http://ff120.github.io/hexoblog/categories/技术/Web开发/"}],"tags":[{"name":"selenium","slug":"selenium","permalink":"http://ff120.github.io/hexoblog/tags/selenium/"}]},{"title":"Redis入门","slug":"技术/数据库/数据库_Redis入门","date":"2016-06-11T12:33:14.000Z","updated":"2019-03-28T00:54:55.861Z","comments":true,"path":"2016/06/11/技术/数据库/数据库_Redis入门/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/11/技术/数据库/数据库_Redis入门/","excerpt":"1. 安装 Windows 平台 下载地址：链接: http://pan.baidu.com/s/1ntkhsxF 密码: 9c27","text":"1. 安装 Windows 平台 下载地址：链接: http://pan.baidu.com/s/1ntkhsxF 密码: 9c27 32位系统选择redisbin_x32.zip,64位系统选择redisbin_x64.zip,解压到任意文件夹，文件结构如下： &gt; redis-server.exe 服务器端程序 &gt; redis-cli.exe 客户端程序，用来连接服务器 &gt; redis-check-dump.exe 本地数据库检查程序 &gt; resdis-benchmark.exe 性能测试工具 2. 启动服务 redis-server.exe redis.conf ##3. 连接服务器 redis-cli.exe -h 127.0.0.1 -p 6379 ##4. 基本操作 - set key value 插入数据 - get key 获取数据 - mget key1 key2 key3 一次获取多个数据 - del key 删除数据 - exits key 判断是否存在 - select 0 选择第一个数据库（默认有0-15共16个数据库） - keys * 查看所有的key","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"数据库","slug":"技术/数据库","permalink":"http://ff120.github.io/hexoblog/categories/技术/数据库/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://ff120.github.io/hexoblog/tags/redis/"}]},{"title":"微信发送模板消息的代码","slug":"技术/Web开发/微信开发_发送模板消息的代码","date":"2016-06-11T12:31:44.000Z","updated":"2019-03-28T00:54:59.093Z","comments":true,"path":"2016/06/11/技术/Web开发/微信开发_发送模板消息的代码/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/11/技术/Web开发/微信开发_发送模板消息的代码/","excerpt":"PHP实现的获取模版消息的方法","text":"PHP实现的获取模版消息的方法 1234567891011121314151617181920212223242526272829303132333435function http_request($url,$data=array()) &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE); curl_setopt($ch, CURLOPT_POST, 1); curl_setopt($ch, CURLOPT_POSTFIELDS, $data); $output = curl_exec($ch); curl_close($ch); return $output; &#125; public function getWechate() &#123; $acess_token = \"5i8vEVj4OsH7GGDbER778OhfGZTIwZgqecnr1yPrxK-1kfXDSJzEWVRax1sUD-v6CPrSdJI--qXvLgZ_KbFe5rrVNM2zJvWeY__JzKXRP3c\"; $template=array( 'touser'=&gt;\"oN3CtjnmV68ieh-0_6p_kvX14-l4\", 'template_id'=&gt;\"mHFY7Au5sA1a4fv6CoFO-YOAsxirOpMijRa3DmWef-k\", 'url'=&gt;\"http://www.baidu.com\", 'topcolor'=&gt;\"#7B68EE\", 'data'=&gt;array( 'first'=&gt;array('value'=&gt;urlencode(\"您好,您已购买成功\"),'color'=&gt;\"#743A3A\"), 'tradeDateTime'=&gt;array('value'=&gt;date(\"Y-m-d H:i:s\",time()),'color'=&gt;'#743A3A'), 'orderType'=&gt;array('value'=&gt;urlencode('货到付款'),'color'=&gt;'#743A3A'), 'customerInfo'=&gt;array('value'=&gt;urlencode('似水流年'),'color'=&gt;'#743A3A'), 'orderItemName'=&gt;array('value'=&gt;urlencode('订单号码：'),'color'=&gt;'#743A3A'), 'orderItemData'=&gt;array('value'=&gt;urlencode('1234567890'),'color'=&gt;'#743A3A'), 'remark'=&gt;array('value'=&gt;urlencode('点击查看详情'),'color'=&gt;'#743A3A'), ) ); $json_template=json_encode($template); $url=\"https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=\".$acess_token; $res=$this-&gt;http_request($url,urldecode($json_template)); var_dump($res);","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"Web开发","slug":"技术/Web开发","permalink":"http://ff120.github.io/hexoblog/categories/技术/Web开发/"}],"tags":[{"name":"微信公众号","slug":"微信公众号","permalink":"http://ff120.github.io/hexoblog/tags/微信公众号/"}]},{"title":"微信获取地理位置 ","slug":"技术/Web开发/微信开发_获取地理位置","date":"2016-06-11T12:30:00.000Z","updated":"2019-03-28T00:54:59.193Z","comments":true,"path":"2016/06/11/技术/Web开发/微信开发_获取地理位置/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/11/技术/Web开发/微信开发_获取地理位置/","excerpt":"适用于网页前端的地理位置获取代码","text":"适用于网页前端的地理位置获取代码 123456789101112131415161718192021222324252627282930313233343536wx.config(&#123; debug: false, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。 appId:getAppId(), // 必填，公众号的唯一标识 timestamp:getTimestamp(), // 必填，生成签名的时间戳 nonceStr:getNonceStr2(), // 必填，生成签名的随机串 signature:getSignature(),// 必填，签名，见附录1 jsApiList:$jsApiList// 必填，需要使用的JS接口列表，所有JS接口列表见附录2 &#125;); wx.ready(function() &#123; wx.getLocation( &#123; success: function (res) &#123; var latitude = res.latitude; // 纬度，浮点数，范围为90 ~ -90 var longitude = res.longitude; // 经度，浮点数，范围为180 ~ -180。 var speed = res.speed; // 速度，以米/每秒计 var accuracy = res.accuracy; // 位置精度 $.ajax( &#123; type: \"POST\", url : \"/store/distance\", data : &#123; order_id : $(\"#order_id\").val(), latitude : latitude, longitude : longitude &#125;, dataType : 'json' &#125;); &#125; &#125;); &#125;); wx.error(function(res)&#123; &#125;);","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"Web开发","slug":"技术/Web开发","permalink":"http://ff120.github.io/hexoblog/categories/技术/Web开发/"}],"tags":[{"name":"微信公众号","slug":"微信公众号","permalink":"http://ff120.github.io/hexoblog/tags/微信公众号/"}]},{"title":"微信发送消息PHP SDK","slug":"技术/Web开发/微信开发_微信发送消息PHP-SDK","date":"2016-06-11T12:27:39.000Z","updated":"2019-03-28T00:54:59.170Z","comments":true,"path":"2016/06/11/技术/Web开发/微信开发_微信发送消息PHP-SDK/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/11/技术/Web开发/微信开发_微信发送消息PHP-SDK/","excerpt":"一个实现好的PHP SDK，用于微信公众号处理和消息有关的所有事情","text":"一个实现好的PHP SDK，用于微信公众号处理和消息有关的所有事情 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386&lt;?php/* 方倍工作室 http://www.cnblogs.com/txw1958/ CopyRight 2014 All Rights Reserved*/define(\"TOKEN\", \"weixin\");$wechatObj = new wechatCallbackapiTest();if (!isset($_GET['echostr'])) &#123; $wechatObj-&gt;responseMsg();&#125;else&#123; $wechatObj-&gt;valid();&#125;class wechatCallbackapiTest&#123; //验证签名 public function valid() &#123; $echoStr = $_GET[\"echostr\"]; $signature = $_GET[\"signature\"]; $timestamp = $_GET[\"timestamp\"]; $nonce = $_GET[\"nonce\"]; $token = TOKEN; $tmpArr = array($token, $timestamp, $nonce); sort($tmpArr); $tmpStr = implode($tmpArr); $tmpStr = sha1($tmpStr); if($tmpStr == $signature)&#123; echo $echoStr; exit; &#125; &#125; //响应消息 public function responseMsg() &#123; $postStr = $GLOBALS[\"HTTP_RAW_POST_DATA\"]; if (!empty($postStr))&#123; $this-&gt;logger(\"R \".$postStr); $postObj = simplexml_load_string($postStr, 'SimpleXMLElement', LIBXML_NOCDATA); $RX_TYPE = trim($postObj-&gt;MsgType); //消息类型分离 switch ($RX_TYPE) &#123; case \"event\": $result = $this-&gt;receiveEvent($postObj); break; case \"text\": $result = $this-&gt;receiveText($postObj); break; case \"image\": $result = $this-&gt;receiveImage($postObj); break; case \"location\": $result = $this-&gt;receiveLocation($postObj); break; case \"voice\": $result = $this-&gt;receiveVoice($postObj); break; case \"video\": $result = $this-&gt;receiveVideo($postObj); break; case \"link\": $result = $this-&gt;receiveLink($postObj); break; default: $result = \"unknown msg type: \".$RX_TYPE; break; &#125; $this-&gt;logger(\"T \".$result); echo $result; &#125;else &#123; echo \"\"; exit; &#125; &#125; //接收事件消息 private function receiveEvent($object) &#123; $content = \"\"; switch ($object-&gt;Event) &#123; case \"subscribe\": $content = \"欢迎关注方倍工作室 \"; $content .= (!empty($object-&gt;EventKey))?(\"\\n来自二维码场景 \".str_replace(\"qrscene_\",\"\",$object-&gt;EventKey)):\"\"; break; case \"unsubscribe\": $content = \"取消关注\"; break; case \"SCAN\": $content = \"扫描场景 \".$object-&gt;EventKey; break; case \"CLICK\": switch ($object-&gt;EventKey) &#123; case \"COMPANY\": $content = array(); $content[] = array(\"Title\"=&gt;\"多图文1标题\", \"Description\"=&gt;\"\", \"PicUrl\"=&gt;\"http://discuz.comli.com/weixin/weather/icon/cartoon.jpg\", \"Url\" =&gt;\"http://m.cnblogs.com/?u=txw1958\"); break; default: $content = \"点击菜单：\".$object-&gt;EventKey; break; &#125; break; case \"LOCATION\": $content = \"上传位置：纬度 \".$object-&gt;Latitude.\";经度 \".$object-&gt;Longitude; break; case \"VIEW\": $content = \"跳转链接 \".$object-&gt;EventKey; break; case \"MASSSENDJOBFINISH\": $content = \"消息ID：\".$object-&gt;MsgID.\"，结果：\".$object-&gt;Status.\"，粉丝数：\".$object-&gt;TotalCount.\"，过滤：\".$object-&gt;FilterCount.\"，发送成功：\".$object-&gt;SentCount.\"，发送失败：\".$object-&gt;ErrorCount; break; default: $content = \"receive a new event: \".$object-&gt;Event; break; &#125; if(is_array($content))&#123; if (isset($content[0]))&#123; $result = $this-&gt;transmitNews($object, $content); &#125;else if (isset($content['MusicUrl']))&#123; $result = $this-&gt;transmitMusic($object, $content); &#125; &#125;else&#123; $result = $this-&gt;transmitText($object, $content); &#125; return $result; &#125; //接收文本消息 private function receiveText($object) &#123; $keyword = trim($object-&gt;Content); //多客服人工回复模式 if (strstr($keyword, \"您好\") || strstr($keyword, \"你好\") || strstr($keyword, \"在吗\"))&#123; $result = $this-&gt;transmitService($object); &#125; //自动回复模式 else&#123; if (strstr($keyword, \"文本\"))&#123; $content = \"这是个文本消息\"; &#125;else if (strstr($keyword, \"单图文\"))&#123; $content = array(); $content[] = array(\"Title\"=&gt;\"单图文标题\", \"Description\"=&gt;\"单图文内容\", \"PicUrl\"=&gt;\"http://discuz.comli.com/weixin/weather/icon/cartoon.jpg\", \"Url\" =&gt;\"http://m.cnblogs.com/?u=txw1958\"); &#125;else if (strstr($keyword, \"图文\") || strstr($keyword, \"多图文\"))&#123; $content = array(); $content[] = array(\"Title\"=&gt;\"多图文1标题\", \"Description\"=&gt;\"\", \"PicUrl\"=&gt;\"http://discuz.comli.com/weixin/weather/icon/cartoon.jpg\", \"Url\" =&gt;\"http://m.cnblogs.com/?u=txw1958\"); $content[] = array(\"Title\"=&gt;\"多图文2标题\", \"Description\"=&gt;\"\", \"PicUrl\"=&gt;\"http://d.hiphotos.bdimg.com/wisegame/pic/item/f3529822720e0cf3ac9f1ada0846f21fbe09aaa3.jpg\", \"Url\" =&gt;\"http://m.cnblogs.com/?u=txw1958\"); $content[] = array(\"Title\"=&gt;\"多图文3标题\", \"Description\"=&gt;\"\", \"PicUrl\"=&gt;\"http://g.hiphotos.bdimg.com/wisegame/pic/item/18cb0a46f21fbe090d338acc6a600c338644adfd.jpg\", \"Url\" =&gt;\"http://m.cnblogs.com/?u=txw1958\"); &#125;else if (strstr($keyword, \"音乐\"))&#123; $content = array(); $content = array(\"Title\"=&gt;\"最炫民族风\", \"Description\"=&gt;\"歌手：凤凰传奇\", \"MusicUrl\"=&gt;\"http://121.199.4.61/music/zxmzf.mp3\", \"HQMusicUrl\"=&gt;\"http://121.199.4.61/music/zxmzf.mp3\"); &#125;else&#123; $content = date(\"Y-m-d H:i:s\",time()).\"\\n技术支持 方倍工作室\"; &#125; if(is_array($content))&#123; if (isset($content[0]['PicUrl']))&#123; $result = $this-&gt;transmitNews($object, $content); &#125;else if (isset($content['MusicUrl']))&#123; $result = $this-&gt;transmitMusic($object, $content); &#125; &#125;else&#123; $result = $this-&gt;transmitText($object, $content); &#125; &#125; return $result; &#125; //接收图片消息 private function receiveImage($object) &#123; $content = array(\"MediaId\"=&gt;$object-&gt;MediaId); $result = $this-&gt;transmitImage($object, $content); return $result; &#125; //接收位置消息 private function receiveLocation($object) &#123; $content = \"你发送的是位置，纬度为：\".$object-&gt;Location_X.\"；经度为：\".$object-&gt;Location_Y.\"；缩放级别为：\".$object-&gt;Scale.\"；位置为：\".$object-&gt;Label; $result = $this-&gt;transmitText($object, $content); return $result; &#125; //接收语音消息 private function receiveVoice($object) &#123; if (isset($object-&gt;Recognition) &amp;&amp; !empty($object-&gt;Recognition))&#123; $content = \"你刚才说的是：\".$object-&gt;Recognition; $result = $this-&gt;transmitText($object, $content); &#125;else&#123; $content = array(\"MediaId\"=&gt;$object-&gt;MediaId); $result = $this-&gt;transmitVoice($object, $content); &#125; return $result; &#125; //接收视频消息 private function receiveVideo($object) &#123; $content = array(\"MediaId\"=&gt;$object-&gt;MediaId, \"ThumbMediaId\"=&gt;$object-&gt;ThumbMediaId, \"Title\"=&gt;\"\", \"Description\"=&gt;\"\"); $result = $this-&gt;transmitVideo($object, $content); return $result; &#125; //接收链接消息 private function receiveLink($object) &#123; $content = \"你发送的是链接，标题为：\".$object-&gt;Title.\"；内容为：\".$object-&gt;Description.\"；链接地址为：\".$object-&gt;Url; $result = $this-&gt;transmitText($object, $content); return $result; &#125; //回复文本消息 private function transmitText($object, $content) &#123; $xmlTpl = \"&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;%s&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;&lt;Content&gt;&lt;![CDATA[%s]]&gt;&lt;/Content&gt;&lt;/xml&gt;\"; $result = sprintf($xmlTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time(), $content); return $result; &#125; //回复图片消息 private function transmitImage($object, $imageArray) &#123; $itemTpl = \"&lt;Image&gt; &lt;MediaId&gt;&lt;![CDATA[%s]]&gt;&lt;/MediaId&gt;&lt;/Image&gt;\"; $item_str = sprintf($itemTpl, $imageArray['MediaId']); $xmlTpl = \"&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;%s&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[image]]&gt;&lt;/MsgType&gt;$item_str&lt;/xml&gt;\"; $result = sprintf($xmlTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time()); return $result; &#125; //回复语音消息 private function transmitVoice($object, $voiceArray) &#123; $itemTpl = \"&lt;Voice&gt; &lt;MediaId&gt;&lt;![CDATA[%s]]&gt;&lt;/MediaId&gt;&lt;/Voice&gt;\"; $item_str = sprintf($itemTpl, $voiceArray['MediaId']); $xmlTpl = \"&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;%s&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[voice]]&gt;&lt;/MsgType&gt;$item_str&lt;/xml&gt;\"; $result = sprintf($xmlTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time()); return $result; &#125; //回复视频消息 private function transmitVideo($object, $videoArray) &#123; $itemTpl = \"&lt;Video&gt; &lt;MediaId&gt;&lt;![CDATA[%s]]&gt;&lt;/MediaId&gt; &lt;ThumbMediaId&gt;&lt;![CDATA[%s]]&gt;&lt;/ThumbMediaId&gt; &lt;Title&gt;&lt;![CDATA[%s]]&gt;&lt;/Title&gt; &lt;Description&gt;&lt;![CDATA[%s]]&gt;&lt;/Description&gt;&lt;/Video&gt;\"; $item_str = sprintf($itemTpl, $videoArray['MediaId'], $videoArray['ThumbMediaId'], $videoArray['Title'], $videoArray['Description']); $xmlTpl = \"&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;%s&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[video]]&gt;&lt;/MsgType&gt;$item_str&lt;/xml&gt;\"; $result = sprintf($xmlTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time()); return $result; &#125; //回复图文消息 private function transmitNews($object, $newsArray) &#123; if(!is_array($newsArray))&#123; return; &#125; $itemTpl = \" &lt;item&gt; &lt;Title&gt;&lt;![CDATA[%s]]&gt;&lt;/Title&gt; &lt;Description&gt;&lt;![CDATA[%s]]&gt;&lt;/Description&gt; &lt;PicUrl&gt;&lt;![CDATA[%s]]&gt;&lt;/PicUrl&gt; &lt;Url&gt;&lt;![CDATA[%s]]&gt;&lt;/Url&gt; &lt;/item&gt;\"; $item_str = \"\"; foreach ($newsArray as $item)&#123; $item_str .= sprintf($itemTpl, $item['Title'], $item['Description'], $item['PicUrl'], $item['Url']); &#125; $xmlTpl = \"&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;%s&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[news]]&gt;&lt;/MsgType&gt;&lt;ArticleCount&gt;%s&lt;/ArticleCount&gt;&lt;Articles&gt;$item_str&lt;/Articles&gt;&lt;/xml&gt;\"; $result = sprintf($xmlTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time(), count($newsArray)); return $result; &#125; //回复音乐消息 private function transmitMusic($object, $musicArray) &#123; $itemTpl = \"&lt;Music&gt; &lt;Title&gt;&lt;![CDATA[%s]]&gt;&lt;/Title&gt; &lt;Description&gt;&lt;![CDATA[%s]]&gt;&lt;/Description&gt; &lt;MusicUrl&gt;&lt;![CDATA[%s]]&gt;&lt;/MusicUrl&gt; &lt;HQMusicUrl&gt;&lt;![CDATA[%s]]&gt;&lt;/HQMusicUrl&gt;&lt;/Music&gt;\"; $item_str = sprintf($itemTpl, $musicArray['Title'], $musicArray['Description'], $musicArray['MusicUrl'], $musicArray['HQMusicUrl']); $xmlTpl = \"&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;%s&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[music]]&gt;&lt;/MsgType&gt;$item_str&lt;/xml&gt;\"; $result = sprintf($xmlTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time()); return $result; &#125; //回复多客服消息 private function transmitService($object) &#123; $xmlTpl = \"&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;%s&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[transfer_customer_service]]&gt;&lt;/MsgType&gt;&lt;/xml&gt;\"; $result = sprintf($xmlTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time()); return $result; &#125; //日志记录 private function logger($log_content) &#123; if(isset($_SERVER['HTTP_APPNAME']))&#123; //SAE sae_set_display_errors(false); sae_debug($log_content); sae_set_display_errors(true); &#125;else if($_SERVER['REMOTE_ADDR'] != \"127.0.0.1\")&#123; //LOCAL $max_size = 10000; $log_filename = \"log.xml\"; if(file_exists($log_filename) and (abs(filesize($log_filename)) &gt; $max_size))&#123;unlink($log_filename);&#125; file_put_contents($log_filename, date('H:i:s').\" \".$log_content.\"\\r\\n\", FILE_APPEND); &#125; &#125;&#125;?&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"Web开发","slug":"技术/Web开发","permalink":"http://ff120.github.io/hexoblog/categories/技术/Web开发/"}],"tags":[{"name":"微信公众号","slug":"微信公众号","permalink":"http://ff120.github.io/hexoblog/tags/微信公众号/"}]},{"title":"PhpStorm常用快捷键","slug":"技术/Web开发/后台开发_PhpStorm常用快捷键","date":"2016-06-11T12:23:39.000Z","updated":"2019-03-28T00:54:58.837Z","comments":true,"path":"2016/06/11/技术/Web开发/后台开发_PhpStorm常用快捷键/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/11/技术/Web开发/后台开发_PhpStorm常用快捷键/","excerpt":"PhpStrom的常用快捷键以后都总结在这里","text":"PhpStrom的常用快捷键以后都总结在这里 - Ctrl+D 复制一行 - Ctrl+Y 删除一行 - Ctrl+B 跳到变量声明处 - Ctrl+G 跳转到某行 - Ctrl+Q 查看代码的注释 - Ctrl+J 插入活动代码提示 - Alt+Shift+up 交换本行和上一行的位置 - Alt+Shift+dowm 交换本行和下一行的位置 - Ctrl+Shift+up 语句上移一行 - Ctrl+Shift+down 语句下移一行 - Alt+up 上一个方法 - Alt+down 下一个方法 - Alt+left 切换到左侧标签 - Alt+right 切换到右侧标签 - Ctrl+Z 撤销 - Ctrl+Shift+Z 重做 - Ctrl+Shift+N 打开文件 - Ctrl+F 本文件中查找 - Ctrl+Shift+F 在多个文件中查找 - Ctrl+Shift+V 多次粘贴 - Ctrl+ ‘+’ 展开代码块 - Ctrl+ ‘-’ 折叠代码块 - Ctrl+Shift+ ‘+’ 全部展开 - Ctrl+Shift+ ‘-’ 全部折叠 - Alt + F1当前文件的一些选择模式，很有用 - Shift+F6 重命名","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"Web开发","slug":"技术/Web开发","permalink":"http://ff120.github.io/hexoblog/categories/技术/Web开发/"}],"tags":[{"name":"phpStorm","slug":"phpStorm","permalink":"http://ff120.github.io/hexoblog/tags/phpStorm/"}]},{"title":"测试_使用Selenium测试UI","slug":"技术/Web开发/测试_使用Selenium测试UI","date":"2016-06-11T12:21:44.000Z","updated":"2019-03-28T00:54:59.307Z","comments":true,"path":"2016/06/11/技术/Web开发/测试_使用Selenium测试UI/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/11/技术/Web开发/测试_使用Selenium测试UI/","excerpt":"1. 安装Selenium Server 1.1 下载Server http://docs.seleniumhq.org/download/ 选择Selenium Server（formerly the Selenium RC Server）下载。","text":"1. 安装Selenium Server 1.1 下载Server http://docs.seleniumhq.org/download/ 选择Selenium Server（formerly the Selenium RC Server）下载。 1.2 安装Java环境，确保Java命令可以使用。 1.3 开启服务器 java -jar selenium-server-standalone-xxx.jar 2. 安装 PHPUnit_Selenium Package 2.1 在项目的composer.json中的require-dev结点添加：&quot;phpunit/phpunit-selenium&quot;: &quot;&gt;=1.2&quot; 2.2 在项目目录运行 composer update 3. 编写测试用例检测环境是否安装正确 1234567891011121314151617&lt;?phpclass WebTest extends PHPUnit_Extensions_Selenium2TestCase&#123; protected function setUp() &#123; $this-&gt;setBrowser('firefox'); $this-&gt;setBrowserUrl('http://www.example.com/'); &#125; public function testTitle() &#123; $this-&gt;url('http://www.example.com/'); $this-&gt;assertEquals('this is a title', $this-&gt;title()); &#125;&#125;?&gt; 网页： 123456789&lt;html&gt;&lt;head&gt; &lt;title&gt; this is a title &lt;/title&gt;&lt;/head&gt;&lt;body&gt; this is the body.&lt;/body&gt; 返回 &gt;Time: 2.56 seconds, Memory: 3.25Mb OK (1 test, 1 assertion) 环境配置成功。 4. 断言失败时保存网页截图 12345678910111213141516171819202122&lt;?phprequire_once 'PHPUnit/Extensions/SeleniumTestCase.php';class WebTest extends PHPUnit_Extensions_SeleniumTestCase&#123; protected $captureScreenshotOnFailure = TRUE; protected $screenshotPath = 'c:/xampp/htdocs/screenshots'; protected $screenshotUrl = 'http://localhost/screenshots'; protected function setUp() &#123; $this-&gt;setBrowser('*firefox'); $this-&gt;setBrowserUrl('http://www.example.com/'); &#125; public function testTitle() &#123; $this-&gt;open('http://www.example.com/'); $this-&gt;assertTitle('Example WWW Page'); &#125;&#125;?&gt; 你需要确保有screenshots文件夹，这样失败时就会保存网页截图到screenshots目录下。 5. 录制脚本测试UI 5.1 下载火狐插件Selenium IDE，安装 链接: http://pan.baidu.com/s/1eQ1WkMI 密码: rt1d ### 5.2 打开要测试的网页录制脚本 一个简单的测试页： 123456789101112&lt;html&gt;&lt;head&gt; &lt;title&gt; this is a title &lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form id = 'login'&gt; &lt;input id = 'user' type = 'text'/&gt; &lt;input id = 'pass' type = 'password'/&gt; &lt;input type = 'submit' value = 'login'/&gt;&lt;/body&gt; 这里录制一个填写用户名密码的动作。然后在Selenium IDE中File-&gt;Export Test Case As-&gt;Java/Unit4/Remote Control导出，导出之后得到类似这样的代码： 1234567891011121314151617181920212223242526272829303132package com.example.tests;import com.thoughtworks.selenium.*;import org.junit.After;import org.junit.Before;import org.junit.Test;import static org.junit.Assert.*;import java.util.regex.Pattern;public class qq &#123; private Selenium selenium; @Before public void setUp() throws Exception &#123; selenium = new DefaultSelenium(\"localhost\", 4444, \"*chrome\", \"http://localhost/\"); selenium.start(); &#125; @Test public void testQq() throws Exception &#123; selenium.open(\"/test/1.html\"); selenium.type(\"id=user\", \"123456\"); selenium.type(\"id=pass\", \"12\"); selenium.click(\"css=input[type=\\\"submit\\\"]\"); selenium.waitForPageToLoad(\"30000\"); &#125; @After public void tearDown() throws Exception &#123; selenium.stop(); &#125;&#125; 对照这里的代码，写完测试代码： 123456789101112131415161718192021222324252627&lt;?phprequire_once 'PHPUnit/Extensions/SeleniumTestCase.php';class WebTest extends PHPUnit_Extensions_SeleniumTestCase&#123; protected $captureScreenshotOnFailure = TRUE; protected $screenshotPath = 'C:\\xampp\\htdocs\\test\\screenshots'; protected $screenshotUrl = 'http://localhost/test/screenshots'; protected function setUp() &#123; $this-&gt;setBrowser('*firefox'); $this-&gt;setBrowserUrl('http://localhost/'); &#125; public function testTitle() &#123; $this-&gt;setSpeed('3000'); $this-&gt;open('http://localhost/test/1.html'); $this-&gt;type(\"id=user\",\"123456\"); $this-&gt;type(\"id=pass\",\"12\"); $this-&gt;click(\"css=input[type=\\\"submit\\\"]\"); $this-&gt;assertElementValueEquals(\"user\", \"123456\"); $this-&gt;assertElementValueEquals(\"pass\", \"12\"); &#125;&#125;?&gt; 一般情况下只需要把setUp和Test中的代码对应到测试中即可，通常只需要改一下格式，函数名称都是通用的。 ### 5.3 可用的断言 &gt; - void assertElementValueEquals(string $locator, string $text) &gt; - void assertElementValueNotEquals(string $locator, string $text) &gt; - void assertElementValueContains(string $locator, string $text) &gt; - void assertElementValueNotContains(string $locator, string $text) &gt; - void assertElementContainsText(string $locator, string $text) &gt; - void assertElementNotContainsText(string $locator, string $text) &gt; - void assertSelectHasOption(string $selectLocator, string $option) &gt; - assertSelectNotHasOption(string $selectLocator, string \\(option) &gt; - assertTextPresent（检查在当前给用户显示的页面上是否有出现指定的文本）、 &gt; - assertTextNotPresent（检查在当前给用户显示的页面上是否没有出现指定的文本）、 ### 5.4 有用的设置 - 调整每个语句的执行速度 `\\)this-&gt;setSpeed(‘3000’);- 使UI延长显示sleep(100);`","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"Web开发","slug":"技术/Web开发","permalink":"http://ff120.github.io/hexoblog/categories/技术/Web开发/"}],"tags":[{"name":"UI测试","slug":"UI测试","permalink":"http://ff120.github.io/hexoblog/tags/UI测试/"},{"name":"selenium","slug":"selenium","permalink":"http://ff120.github.io/hexoblog/tags/selenium/"}]},{"title":"配置Apache支持使用HTTPS","slug":"技术/Web开发/后台开发_配置Apache支持使用HTTPS","date":"2016-06-11T12:20:13.000Z","updated":"2019-03-28T00:54:59.065Z","comments":true,"path":"2016/06/11/技术/Web开发/后台开发_配置Apache支持使用HTTPS/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/11/技术/Web开发/后台开发_配置Apache支持使用HTTPS/","excerpt":"1. 安装mod_ssl 1yum isntall mod_ssl","text":"1. 安装mod_ssl 1yum isntall mod_ssl 安装完成后再/etc/httpd/conf.d/下面有一个ssl.conf.打开查看下面两项配置的内容： 12SSLCertificateFile /etc/pki/tls/certs/localhost.crtSSLCertificateKeyFile /etc/pki/tls/private/localhost.key 2. 生成密钥 123cd /etc/pki/tls/privaterm -f localhost.keyopenssl genrsa 1024 &gt; localhost.key 3. 生成证书 123cd /etc/pki/certsrm -f localhhost.crtopenssl req -new -x509 -days -key ../private/localhost.key -out localhost.crt 然后填写证书的各项信息，证书生成。 重启Apache，就可以使用https访问了。","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"Web开发","slug":"技术/Web开发","permalink":"http://ff120.github.io/hexoblog/categories/技术/Web开发/"}],"tags":[{"name":"php","slug":"php","permalink":"http://ff120.github.io/hexoblog/tags/php/"},{"name":"apache","slug":"apache","permalink":"http://ff120.github.io/hexoblog/tags/apache/"}]},{"title":"短信验证码的实现","slug":"技术/Web开发/后台开发_短信验证码的实现","date":"2016-06-11T12:18:56.000Z","updated":"2019-03-28T00:54:59.042Z","comments":true,"path":"2016/06/11/技术/Web开发/后台开发_短信验证码的实现/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/11/技术/Web开发/后台开发_短信验证码的实现/","excerpt":"","text":"1. 在云片网注册账号 2. 设置 2.1 找到APIKEY 2.2 将自己的IP地址添加到IP白名单 2.3 选择自己需要的短信模板，短信内容要和模板匹配才能成功发送出去。 3. 代码实例 1234567891011121314151617181920212223242526272829303132333435363738394041/*** url 为服务的url地址* query 为请求串*/function sock_post($url,$query)&#123; $data = \"\"; $info=parse_url($url); $fp=fsockopen($info[\"host\"],80,$errno,$errstr,30); if(!$fp)&#123; return $data; &#125; $head=\"POST \".$info['path'].\" HTTP/1.0\\r\\n\"; $head.=\"Host: \".$info['host'].\"\\r\\n\"; $head.=\"Referer: http://\".$info['host'].$info['path'].\"\\r\\n\"; $head.=\"Content-type: application/x-www-form-urlencoded\\r\\n\"; $head.=\"Content-Length: \".strlen(trim($query)).\"\\r\\n\"; $head.=\"\\r\\n\"; $head.=trim($query); $write=fputs($fp,$head); $header = \"\"; while ($str = trim(fgets($fp,4096))) &#123; $header.=$str; &#125; while (!feof($fp)) &#123; $data .= fgets($fp,4096); &#125; return $data;&#125;/*** 普通接口发短信* apikey 为云片分配的apikey* text 为短信内容* mobile 为接受短信的手机号*/function send_sms($apikey, $text, $mobile)&#123; $url=\"http://yunpian.com/v1/sms/send.json\"; $encoded_text = urlencode(\"$text\"); $post_string=\"apikey=$apikey&amp;text=$encoded_text&amp;mobile=$mobile\"; return sock_post($url, $post_string);&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"Web开发","slug":"技术/Web开发","permalink":"http://ff120.github.io/hexoblog/categories/技术/Web开发/"}],"tags":[{"name":"短信验证码","slug":"短信验证码","permalink":"http://ff120.github.io/hexoblog/tags/短信验证码/"}]},{"title":"PHP基本操作","slug":"技术/Web开发/后台开发_PHP基本操作","date":"2016-06-11T12:17:07.000Z","updated":"2019-03-28T00:54:58.861Z","comments":true,"path":"2016/06/11/技术/Web开发/后台开发_PHP基本操作/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/11/技术/Web开发/后台开发_PHP基本操作/","excerpt":"1. 字符串的截取 取得https://images.shiliujishi.com/sdlakfjadfosdfji.jpg中的sdlakfjadfosdfji.jpg","text":"1. 字符串的截取 取得https://images.shiliujishi.com/sdlakfjadfosdfji.jpg中的sdlakfjadfosdfji.jpg 123$url = strrchr ( $long_url, '/' ) ;$url_length = -(strlen($url)-1);$short_url = substr ($long_url, $url_length);","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"Web开发","slug":"技术/Web开发","permalink":"http://ff120.github.io/hexoblog/categories/技术/Web开发/"}],"tags":[{"name":"php","slug":"php","permalink":"http://ff120.github.io/hexoblog/tags/php/"}]},{"title":"Linux主机之间同步文件","slug":"技术/Web开发/后台开发_Linux主机之间同步文件","date":"2016-06-11T12:10:39.000Z","updated":"2019-03-28T00:54:58.769Z","comments":true,"path":"2016/06/11/技术/Web开发/后台开发_Linux主机之间同步文件/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/11/技术/Web开发/后台开发_Linux主机之间同步文件/","excerpt":"1. scp命令 在主机A上操作 ### 1.1 主机A复制文件到主机B &gt; - scp /home/filename root@101.1.1.3:/home 1.2 从主机B复制文件到主机A scp /root/fei/a.txt root@121.42.43.161:/root/fei","text":"1. scp命令 在主机A上操作 ### 1.1 主机A复制文件到主机B &gt; - scp /home/filename root@101.1.1.3:/home 1.2 从主机B复制文件到主机A scp /root/fei/a.txt root@121.42.43.161:/root/fei 1.3 避免每次都需要输入密码 1.3.1 生成密钥 ssh-keygen -t rsa 查看当前用户目录下.ssh文件夹 -rw——- 1 root root 1671 Sep 28 14:34 id_rsa -rw——- 1 root root 400 Sep 28 14:34 id_rsa.pub 1.3.2 上传密钥到服务器B scp /root/.ssh/id_rsa.pub 10.0.0.2:/root/.ssh/authorized_keys 将本地生成的公钥上传到B，并改名authorized_keys。 4. 写成脚本执行，传送批量文件 1. touch upload.sh 2. vi upload.sh #!/bash/sh scp /root/fei/a.txt 10.1.1.3:/root/fei/ 3. chmod u+x upload.sh 4. ./upload.sh 1.4 上传文件夹 scp -r 添加-r参数即可 2. rsync 命令 2.1 安装rsync服务 一般都已经安装rsync服务，只需要自己添加配置文件即可。ubuntu 安装方式： sudo apt-get install rsync ###2.2 配置文件（主机A） - touch /etc/rsyncd.conf 创建服务器配置文件 1234567891011121314151617181920212223242526pid file = /var/run/rsyncd.pidport = 873address = 114.215.128.207 (服务器的IP，就是A主机的IP)uid = rootgid = rootuse chroot = yesread only = yes\\#hosts allow=192.168.1.0/255.255.255.0\\#hosts deny = *max connection = 5motd file = /etc/rsyncd.motdlog file = /var/log/rsyncd.logtransfer logging = yeslog format = %t %a %m %f %bsyslog facility = local3timeout = 300[test]（备份结点）path = /root/fei（需要备份的路径）list=yesignore errorsauth users = rootsecrets file = /etc/rsyncd.secrets（客户端使用rsync命令时，需要使用这里设定的用户名和密码）comment = This is test data（备份的注释）exclude = （忽略的文件夹） touch /etc/rsyncd.secrets 创建密码文件 1root:123456(用户名：密码) touch /etc/rsyncd.motd 创建服务器信息文件 1234++++++++++++++++welcome to use rsync service !(自定义当客户端连接时返回的提示信息)+++++++++++++++++ 修改权限 chown root.root rsyncd.secrets chmod 600 rsyncd.secrets ### 2.3 启动服务 12rsync --daemon --config = /etc/rsyncd.cond(如果配置文件就在etc下，可以省略--config) 2.4 在主机B上访问rsync服务 2.4.1 查看主机A上提供的备份数据源 1rsync --list-only root@123.234.321.1:: 出现配置文件中定义的欢迎信息说明配置成功。 123456+++++++++++++++++++Welcome to use rsync service !++++++++++++++++++++++++test This is test datatest就是主机A或者说rsync服务器上提供的数据源。如果在数据源的配置文件中加上`list=no`则不会显示在这里 2.4.2 查看数据源的内容 -rsync -avzP root@114.215.2.207::test这里会要求输入密码，密码就是在主机A中的rsyncd.secrets文件中保存的密码。 ####2.4.3 把A中的内容同步到B 1234rsync -avzP root@114.215.128.207::test test(同步到本机当前目录的test文件夹下)rsync -avzP --delete root@114.215.128.207::test test(加上delete参数A中删除的文件也会在B中删除) 2.4.4 避免每次同步都需要输入密码 在本地创建密码文件 123touch rsyncd.secrets;chmod 600 rsyncd.secrets;echo &apos;password&apos;&gt;rsyncd.secrets同步时运行rsync -avzP --delete --password-file=rsyncd.secrets root@114.215.128.207::test test 2.4.5 编写脚本实现同步ls 12#!/bin/sh/usr/bin/rsync -avzP --password-file=/root/fei/rsyncd.secrets root@114.215.128.207::test 2.4.6 定时执行同步脚本实现自动同步 1234crontab -e (打开定时任务编辑器)输入一下内容：`* * * * * ／root/fei/rsync.sh`(每分钟自动运行rsync.sh) crontab基本操作 crontab -l 列出当前的定时任务 crontab -r 删除当前的定时任务 crontab -e 编辑当前的定时任务 - 定时的格式： f1 f2 f3 f4 f5 program 其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。program 表示要执行的程序。 当 f1 为 * 时表示每分钟都要执行 program，f2 为 * 时表示每小时都要执行程序，其馀类推 当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b 小时都要执行，其馀类推 当 f1 为 /n 时表示每 n 分钟个时间间隔执行一次，f2 为 /n 表示每 n 小时个时间间隔执行一次，其馀类推 当 f1 为 a, b, c,… 时表示第 a, b, c,… 分钟要执行，f2 为 a, b, c,… 时表示第 a, b, c…个小时要执行，其馀类推 使用者也可以将所有的设定先存放在档案 file 中，用 crontab file 的方式来设定时程表。 当程式在你所指定的时间执行后,系统会寄一封信给你,显示该程式执行的内容,若是你不希望收到这样的信,请在每一行空一格之后加上 &gt; /dev/null 2&gt;&amp;1 即可。 2.4.7 只复制目录结构，不复制内容 1rsync -av --include &apos;*/&apos; --exclude &apos;*&apos; source-dir dest-dir","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"Web开发","slug":"技术/Web开发","permalink":"http://ff120.github.io/hexoblog/categories/技术/Web开发/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://ff120.github.io/hexoblog/tags/linux/"}]},{"title":"Linux常用命令","slug":"技术/Web开发/后台开发_Linux常用命令","date":"2016-06-11T12:08:53.000Z","updated":"2019-03-28T00:54:58.793Z","comments":true,"path":"2016/06/11/技术/Web开发/后台开发_Linux常用命令/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/11/技术/Web开发/后台开发_Linux常用命令/","excerpt":"介绍Linux常用命令的主要用法","text":"介绍Linux常用命令的主要用法 12345678910- 查找某个软件包是否安装：yum list installed|grep mcrypt- 查看某个命令的位置whereis ls- 检查某个端口是否打开lsof -i :port- 查看某个运行的进程ps -ef|grep httpd- 查找某个进程pgrep -l ssh","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"Web开发","slug":"技术/Web开发","permalink":"http://ff120.github.io/hexoblog/categories/技术/Web开发/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://ff120.github.io/hexoblog/tags/linux/"}]},{"title":"Lavarel 后台组件frozenode的使用","slug":"技术/Web开发/后台开发_Lavarel-后台组件frozenode的使用","date":"2016-06-11T12:01:45.000Z","updated":"2019-03-28T00:54:58.717Z","comments":true,"path":"2016/06/11/技术/Web开发/后台开发_Lavarel-后台组件frozenode的使用/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/11/技术/Web开发/后台开发_Lavarel-后台组件frozenode的使用/","excerpt":"安装 使用","text":"安装 使用 导航栏配置 administrator.php: uri 后台管理地址 model_config_path 模型地址 setting_config_path 每个子菜单配置文件的地址 menu 导航栏菜单项目 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173&lt;?phpreturn array( /** * Package URI * * @type string */ 'uri' =&gt; 'eadmin', /** * Page title * * @type string */ 'title' =&gt; 'PomeMartAdminPanel', /** * The path to your model config directory * * @type string */ 'model_config_path' =&gt; app('path') . '/config/administrator', /** * The path to your settings config directory * * @type string */ 'settings_config_path' =&gt; app('path') . '/config/administrator/settings', /** * The menu structure of the site. For models, you should either supply the name of a model config file or an array of names of model config * files. The same applies to settings config files, except you must prepend 'settings.' to the settings config file name. You can also add * custom pages by prepending a view path with 'page.'. By providing an array of names, you can group certain models or settings pages * together. Each name needs to either have a config file in your model config path, settings config path with the same name, or a path to a * fully-qualified Laravel view. So 'users' would require a 'users.php' file in your model config path, 'settings.site' would require a * 'site.php' file in your settings config path, and 'page.foo.test' would require a 'test.php' or 'test.blade.php' file in a 'foo' directory * inside your view directory. * * @type array * * array( * 'E-Commerce' =&gt; array('collections', 'products', 'product_images', 'orders'), * 'homepage_sliders', * 'users', * 'roles', * 'colors', * 'Settings' =&gt; array('settings.site', 'settings.ecommerce', 'settings.social'), * 'Analytics' =&gt; array('E-Commerce' =&gt; 'page.ecommerce.analytics'), * ) */ 'menu' =&gt; array ( '商品' =&gt; array ( 'products' =&gt; 'products', 'product images' =&gt; 'productImages', 'tags' =&gt; 'tags', 'attributes' =&gt; 'attributes', 'categories' =&gt; 'categories', 'productDetailImage' =&gt; 'productDetailImage', 'accounting' =&gt; 'accounting', 'accounting_withdraw' =&gt; 'accounting_withdraw' ), '店铺' =&gt; array( 'stores' =&gt; 'stores', 'cmsItems' =&gt;'cmsItems', 'storePromos' =&gt; 'storePromos', 'storeOuterlinks' =&gt; 'storeOuterlinks', 'shares' =&gt; 'shares', 'themes' =&gt; 'themes' ), '优惠券' =&gt; array( 'coupons' =&gt; 'coupons', 'couponCreationRules' =&gt; 'couponCreationRules', 'fixedDiscountCoupons' =&gt; 'fixedDiscountCoupons', 'percentageDiscountCoupons' =&gt; 'percentageDiscountCoupons', 'amountOffOverCoupons' =&gt; 'amountOffOverCoupons' ), '订单' =&gt; array( 'orders' =&gt; 'orders', 'shipments' =&gt; 'shipments', 'trackings' =&gt; 'trackings' ), '评价' =&gt; array( 'ratings'=&gt;'ratings', 'productRatings' =&gt; 'productRatings' ) ), /** * The permission option is the highest-level authentication check that lets you define a closure that should return true if the current user * is allowed to view the admin section. Any \"falsey\" response will send the user back to the 'login_path' defined below. * * @type closure */ 'permission'=&gt; function() &#123; if (Auth::check() &amp;&amp; Auth::user()-&gt;hasRole('Admin')) &#123; return true; &#125; return false; &#125;, /** * This determines if you will have a dashboard (whose view you provide in the dashboard_view option) or a non-dashboard home * page (whose menu item you provide in the home_page option) * * @type bool */ 'use_dashboard' =&gt; false, /** * If you want to create a dashboard view, provide the view string here. * * @type string */ 'dashboard_view' =&gt; '', /** * The menu item that should be used as the default landing page of the administrative section * * @type string */ 'home_page' =&gt; 'products', /** * The route to which the user will be taken when they click the \"back to site\" button * * @type string */ 'back_to_site_path' =&gt; '/', /** * The login path is the path where Administrator will send the user if they fail a permission check * * @type string */ 'login_path' =&gt; 'accounts/signin', /** * The logout path is the path where Administrator will send the user when they click the logout link * * @type string */ 'logout_path' =&gt; 'accounts/signout', /** * This is the key of the return path that is sent with the redirection to your login_action. Session::get('redirect') will hold the return URL. * * @type string */ 'login_redirect_key' =&gt; 'redirect', /** * Global default rows per page * * @type NULL|int */ 'global_rows_per_page' =&gt; 20, /** * An array of available locale strings. This determines which locales are available in the languages menu at the top right of the Administrator * interface. * * @type array */ 'locales' =&gt; array('zh-CN','en'),); accounting.php : 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?php/** * model config */return array( 'title' =&gt; '财务', 'single' =&gt; '财务', 'model' =&gt; 'PomeMartDomainModel\\Entities\\Accounting', 'columns' =&gt; array( 'id', 'store_id' =&gt; array ( 'title' =&gt; '店铺ID', ), 'alipay_account' =&gt; array( 'title' =&gt; '支付宝账户', ), 'total_income' =&gt; array( 'title' =&gt; '总收入' ), 'balance' =&gt; array( 'title' =&gt; '待提金额' ), 'last_order_received_on' =&gt; array( 'title' =&gt; '上次提取现金的时间', ) ), 'edit_fields' =&gt; array( 'store_id' =&gt; array( 'title' =&gt; '店铺ID' ), 'alipay_account' =&gt; array( 'title' =&gt; '支付宝账户', ), 'total_income' =&gt; array( 'title' =&gt; '总收入', 'type' =&gt; 'number' ), 'balance' =&gt; array( 'title' =&gt; '待提取金额' ), 'last_order_received_on' =&gt; array( 'title' =&gt; '上次提取现金的时间', 'type' =&gt; 'datetime' ) ), 'filters' =&gt; array( 'store_id' =&gt; array( 'title' =&gt; '店铺ID' ), 'alipay_account' =&gt; array( 'title' =&gt; '支付宝账户' ) ),); 里面的model 指定要操作的数据库的表的对应的模型的位置。 参考文档地址：http://administrator.frozennode.com/ 添加按钮执行自定义代码 执行全局操作，没有输入参数 123456789101112131415161718'global_actions' =&gt; array( //Create Excel Download 'clear_cache' =&gt; array( 'title' =&gt; 'Clear Cache', 'messages' =&gt; array( 'active' =&gt; 'clear cache ...', 'success' =&gt; 'success!', 'error' =&gt; 'failed!', ), //the Eloquent query builder is passed to the closure 'action' =&gt; function($query) &#123; $store = Auth::user()-&gt;store; Cache::forget('store_'.$store-&gt;store_alias); return true; &#125; ), ), 针对每条数据，执行自定义操作，传入参数$data就是编辑后的数据 123456789101112131415161718192021'actions' =&gt; array( //Clearing the site cache 'save_color' =&gt; array( 'title' =&gt; 'Save Color', 'messages' =&gt; array( 'active' =&gt; 'Clearing cache...', 'success' =&gt; 'Cache cleared!', 'error' =&gt; 'There was an error while clearing the cache', ), //the settings data is passed to the function and saved if a truthy response is returned 'action' =&gt; function(&amp;$data) &#123; //return true to flash the success message //return false to flash the default error //return a string to show a custom error //return a Response::download() to initiate a file download return \"$data\"; &#125; ), ), ====","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"Web开发","slug":"技术/Web开发","permalink":"http://ff120.github.io/hexoblog/categories/技术/Web开发/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://ff120.github.io/hexoblog/tags/laravel/"},{"name":"frozenode","slug":"frozenode","permalink":"http://ff120.github.io/hexoblog/tags/frozenode/"}]},{"title":"PHP编译less文件-lessphp的使用","slug":"技术/Web开发/后台开发_PHP编译less文件-lessphp的使用","date":"2016-06-11T11:56:51.000Z","updated":"2019-03-28T00:54:58.884Z","comments":true,"path":"2016/06/11/技术/Web开发/后台开发_PHP编译less文件-lessphp的使用/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/11/技术/Web开发/后台开发_PHP编译less文件-lessphp的使用/","excerpt":"用composer安装 12345&#123; \"require\":&#123; \"leafo/lessphp\": \"0.4.0\" &#125;&#125;","text":"用composer安装 12345&#123; \"require\":&#123; \"leafo/lessphp\": \"0.4.0\" &#125;&#125; 手动安装 lessphp源代码 下载源代码，将其中的lessc.inc.php拷贝到任意文件夹中，使用时include即可。 lessphp文档地址 ##2. 使用 根据变量的不同将style.less编译成不同的css文件 1234567891011121314require 'app\\lib\\lessc.inc.php';use lessc; $less = new lessc(); $less-&gt;setVariables(array( \"color-main\" =&gt; \"#555555\", \"color-secondary\" =&gt; \"#222222\", \"color-contract\" =&gt; \"#333333\" )); $inputFile = \"public_html/styles/style.less\"; $outputFile = \"public_html/styles/style.css\"; $inputString = file_get_contents($inputFile); $ouputString = $less-&gt;compile($inputString); echo file_put_contents($outputFile,$ouputString);","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"Web开发","slug":"技术/Web开发","permalink":"http://ff120.github.io/hexoblog/categories/技术/Web开发/"}],"tags":[{"name":"php","slug":"php","permalink":"http://ff120.github.io/hexoblog/tags/php/"},{"name":"less","slug":"less","permalink":"http://ff120.github.io/hexoblog/tags/less/"}]},{"title":"think php note 03","slug":"技术/Web开发/后台开发_think-php-note-03","date":"2016-06-11T08:02:38.000Z","updated":"2019-03-28T00:54:58.997Z","comments":true,"path":"2016/06/11/技术/Web开发/后台开发_think-php-note-03/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/11/技术/Web开发/后台开发_think-php-note-03/","excerpt":"ThinkPHP入门教程-取出数据 配置数据库连接 本地mysql数据库的配置如下： 数据库用户名：root 密码：空 使用的数据库：test 数据库的信息：只有一张表user,user包含id,name,password三个字段 在testThinkPHP/Conf/config.php中键入如下代码：","text":"ThinkPHP入门教程-取出数据 配置数据库连接 本地mysql数据库的配置如下： 数据库用户名：root 密码：空 使用的数据库：test 数据库的信息：只有一张表user,user包含id,name,password三个字段 在testThinkPHP/Conf/config.php中键入如下代码： 12345678910111213&lt;?phpreturn array ( //'配置项'=&gt;'配置值' 'DB_TYPE' =&gt; 'mysql', // 数据库类型 'DB_PORT' =&gt; '3306', // 端口 'DB_CHARSET' =&gt; 'utf8', // 数据库编码默认采用utf8 'DB_HOST' =&gt; \"localhost\", // 服务器地址 'DB_NAME' =&gt; \"test\", // 数据库名 'DB_USER' =&gt; \"root\", // 用户名 'DB_PWD' =&gt; \"123456\", // 密码 'DB_PREFIX' =&gt; \"a_\", // 数据库表前缀 );?&gt; 定义模型 在testThinkPHP/Lib/Model/UserMdel.php 中键入如下内容： 12345678910&lt;?php/*** Created by PhpStorm.* User: Administrator* Date: 2015/7/18* Time: 17:36*/class UserModel extends Model &#123;&#125; 以上表示定义了User模型，该模型会自动和数据库中的user数据表相对应 定义控制器 在ThinkPHP/Lib/Action/UserAction.class.php 中： 12345678910111213141516&lt;?phpclass UserAction extends Action &#123; public function showUser() &#123; $user = M('User'); $user -&gt;find(1 ); $user_name = $user-&gt;user_name ; $password = $user-&gt;password ; $tpl = \"User:showUser\"; $this -&gt;assign('username', $user_name); $this -&gt;assign('password', $password); $this -&gt;display($tpl ); &#125;&#125; 定义视图 ThinkPHP/Tpl/User/showUser.html 中键入： 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title &gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 用户名： &lt;?php echo $username?&gt; &lt; br&gt; 密码： &lt;?php echo $password?&gt; &lt; br&gt;&lt;/body&gt;&lt;/html&gt; 查看结果 在浏览器中输入 localhost/testThinkPHP/?m=User&amp;a=showUser 至此，我们完成了一个简单的从数据库中读取数据，显示在视图中的过程，下面再完成一个从视图中读取数据，存入数据库的过程，框架的基本功能就算是掌握了。","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"Web开发","slug":"技术/Web开发","permalink":"http://ff120.github.io/hexoblog/categories/技术/Web开发/"}],"tags":[{"name":"thinkphp","slug":"thinkphp","permalink":"http://ff120.github.io/hexoblog/tags/thinkphp/"}]},{"title":"think php note 02","slug":"技术/Web开发/后台开发_think-php-note-02","date":"2016-06-11T08:00:12.000Z","updated":"2019-03-28T00:54:58.974Z","comments":true,"path":"2016/06/11/技术/Web开发/后台开发_think-php-note-02/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/11/技术/Web开发/后台开发_think-php-note-02/","excerpt":"ThinkPHP入门教程-存入数据 配置显示输入表单的页面 12345testThinkPHP/Lib/Action/UserAction.class.phppublic function addUserGet ()&#123; $this -&gt;display();&#125;","text":"ThinkPHP入门教程-存入数据 配置显示输入表单的页面 12345testThinkPHP/Lib/Action/UserAction.class.phppublic function addUserGet ()&#123; $this -&gt;display();&#125; 新建模版 testThinkPHP/Tpl/User/addUserGet.html 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title &gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"&lt;?php echo U('User:addUserPost') ?&gt;\" method= \"post\"&gt; &lt;input type= \"text\" name=\"user_name\" /&gt; &lt;input type= \"password\" name=\"password\"/&gt; &lt;input type= \"submit\"/&gt; &lt;/form &gt;&lt;/body&gt;&lt;/html&gt; 在浏览器输入localhost/testThinkPHP/?m=User$a=addUserGet就可以看到表单输入页面了 单击submit按钮后，表单数据会提交到UserModel的addUserPost()方法 12345678910public function addUserPost ()&#123; $user_name = $_POST[ 'user_name']; $password = $_POST[ 'password']; $user = M('User'); $data ['user_name'] = $user_name; $data ['password'] = $password; $user -&gt;create($data ); $user -&gt;add();&#125; 执行完这个方法，数据库的user数据表中就会新增一条记录，但是要记住，id字段一定是自增的，否则可能会出现插入不进去的情况。","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"Web开发","slug":"技术/Web开发","permalink":"http://ff120.github.io/hexoblog/categories/技术/Web开发/"}],"tags":[{"name":"thinkphp","slug":"thinkphp","permalink":"http://ff120.github.io/hexoblog/tags/thinkphp/"}]},{"title":"think php note 01","slug":"技术/Web开发/后台开发_think-php-note-01","date":"2016-06-11T07:57:25.000Z","updated":"2019-03-28T00:54:58.953Z","comments":true,"path":"2016/06/11/技术/Web开发/后台开发_think-php-note-01/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/11/技术/Web开发/后台开发_think-php-note-01/","excerpt":"ThinkPHP入门教程-默认的规则 URL模式 在testThinkPHP/Conf/config.php中加入 ‘URL_MODEL’ =&gt; 0, //URL模式 此时的URL模式是普通模式 http://serverName/appName/?m=module&amp;a=action&amp;id=1 serverName： localhost appName: testThinkPHP 就是项目文件夹的名字 m = 控制器的名字，例如UserAction.class.php的名字为User a = 控制器方法的名字，想执行showUser方法，就写showUser 后面的参数为传入该方法的参数 所以采用此种方式 访问刚才显示用户名密码的页面的 地址就是： http://localhost/testThinkPHP/?m=User&amp;a=showUser","text":"ThinkPHP入门教程-默认的规则 URL模式 在testThinkPHP/Conf/config.php中加入 ‘URL_MODEL’ =&gt; 0, //URL模式 此时的URL模式是普通模式 http://serverName/appName/?m=module&amp;a=action&amp;id=1 serverName： localhost appName: testThinkPHP 就是项目文件夹的名字 m = 控制器的名字，例如UserAction.class.php的名字为User a = 控制器方法的名字，想执行showUser方法，就写showUser 后面的参数为传入该方法的参数 所以采用此种方式 访问刚才显示用户名密码的页面的 地址就是： http://localhost/testThinkPHP/?m=User&amp;a=showUser ‘URL_MODEL’ =&gt; 1, //URL模式 这个时候是PATHINFO模式 http://serverName/appName/module/action/id/1/ 这个时候访问显示用户名密码的页面的地址就是： http://localhost/a/index.php/User/showUser 值得注意的是，设置URL_MODEL只是改变使用系统U函数生成的URL的样式，无论设置成什么模式，几种URL都是可以访问的。 例如，当URL_MODEL = 1 的时候，访问 http://localhost/testThinkPHP/?m=User&amp;a=showUser 依然可以出现显示用户名密码的界面 模型-控制器-视图默认的映射关系 testThinkPHP –Lib –Action –UserAction.class.php –Model –UserModel.class.php –Tpl –User –addUserGet.html –addUserPost.html –showUser.html testThinkPHP是项目的主目录，按照这样的文件夹结构，定义了模型User，控制器User，视图组User 控制器User中的方法名称自动对应视图组User中的同方法名称相同的模版文件。 在这样的默认对应规则下，可以使用User:addUserGet找到模板文件testThinkPHP/Tpl/User/addUserGet.html文件 配置文件的生效位置 testThinkPHP/Conf/config.php 中返回数组，配置参数就会生效。","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"Web开发","slug":"技术/Web开发","permalink":"http://ff120.github.io/hexoblog/categories/技术/Web开发/"}],"tags":[{"name":"thinkphp","slug":"thinkphp","permalink":"http://ff120.github.io/hexoblog/tags/thinkphp/"}]},{"title":"sublime Text tricks","slug":"技术/Web开发/后台开发_sublime-Text-tricks","date":"2016-06-11T07:42:50.000Z","updated":"2019-03-28T00:54:58.930Z","comments":true,"path":"2016/06/11/技术/Web开发/后台开发_sublime-Text-tricks/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/11/技术/Web开发/后台开发_sublime-Text-tricks/","excerpt":"快速注释 Ctrl + / 单行注释/取消注释 选中行 Ctrl + Shift + / 多行注释/取消注释 选中行 快速打开文件 Ctrl + P 输入要打开的文件名前几个字母就可以快速打开文件 Ctrl+G：跳转到第几行","text":"快速注释 Ctrl + / 单行注释/取消注释 选中行 Ctrl + Shift + / 多行注释/取消注释 选中行 快速打开文件 Ctrl + P 输入要打开的文件名前几个字母就可以快速打开文件 Ctrl+G：跳转到第几行 快捷键 Ctrl + L 选择整行（按住-继续选择下行） Ctrl + KK 从光标处删除至行尾 Ctrl + Shift+K 删除整行 Ctrl + Shift+D 复制光标所在整行，插入在该行之前 Ctrl + J 合并行（已选择需要合并的多行时） Ctrl + KU 改为大写 Ctrl + KL 改为小写 Ctrl + D 选词 （按住-继续选择下个相同的字符串） Ctrl + M 光标移动至括号内开始或结束的位置 Ctrl + Shift + M 选择括号内的内容（按住-继续选择父括号） Ctrl + / 注释整行（如已选择内容，同“Ctrl+Shift+/”效果） Ctrl + Shift + / 注释已选择内容 Ctrl + Z 撤销 Ctrl + Y 恢复撤销 Ctrl + M 光标跳至对应的括号 Alt + . 闭合当前标签 Ctrl + Shift+A 选择光标位置父标签对儿 Ctrl + Shift+[ 折叠代码 Ctrl + Shift+] 展开代码 Ctrl + KT 折叠属性 Ctrl + K0 展开所有 Ctrl + U 软撤销 Ctrl + T 词互换 Tab 缩进 自动完成 Shift + Tab 去除缩进 ctrl+tab：切换选项卡： Ctrl + Shift+↑ 与上行互换 Ctrl + Shift+↓ 与下行互换 Ctrl + K Backspace 从光标处删除至行首 Ctrl + Enter 光标后插入行 Ctrl + Shift+Enter 光标前插入行 Ctrl + F2 设置书签 F2 下一个书签 Shift + F2 上一个书签 Alt+Shift+数字：分屏显示 Alt+数字：切换打开第N个文件","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"Web开发","slug":"技术/Web开发","permalink":"http://ff120.github.io/hexoblog/categories/技术/Web开发/"}],"tags":[{"name":"sublimeText","slug":"sublimeText","permalink":"http://ff120.github.io/hexoblog/tags/sublimeText/"}]},{"title":"Make phpStorm friendly to laravel","slug":"技术/Web开发/后台开发_Make-phpStorm-friendly-to-laravel","date":"2016-06-11T07:15:12.000Z","updated":"2019-03-28T00:54:58.815Z","comments":true,"path":"2016/06/11/技术/Web开发/后台开发_Make-phpStorm-friendly-to-laravel/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/11/技术/Web开发/后台开发_Make-phpStorm-friendly-to-laravel/","excerpt":"phpStorm的个性化设置 file--&gt;setting 打开设置界面，有两个appearance,第一个设置软件整体的风格，例如可以改成Windows风格","text":"phpStorm的个性化设置 file--&gt;setting 打开设置界面，有两个appearance,第一个设置软件整体的风格，例如可以改成Windows风格 2. 第二个appearance是修改编辑器风格的，我喜欢修改成sublime Text的风格 - 下载主题包：链接: http://pan.baidu.com/s/1nthy0kT 密码: 2ymp - 将里面的XML结尾的文件复制到C:\\Users\\Seemeloo1\\.WebIde70\\config\\colors 文件夹下，这里的Seemeloo1是用户名，不同的电脑不一样。 - 在主题选择页面找到刚才下载的主题，另存为，然后修改字体大小和其它属性 安装laravel-ide-helper实现代码自动完成、代码提示和跟踪 在composer.json的require下添加一行 1“barryvdh/laravel-ide-helper”:”1.11.*” 执行composer update安装刚才添加的插件 执行php artisan ide-helper:generate,生成代码提示和跟踪需要的文件，现在就可以按住Ctrl单击方法追踪方法来源了。","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"Web开发","slug":"技术/Web开发","permalink":"http://ff120.github.io/hexoblog/categories/技术/Web开发/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://ff120.github.io/hexoblog/tags/laravel/"},{"name":"phpStorm","slug":"phpStorm","permalink":"http://ff120.github.io/hexoblog/tags/phpStorm/"}]},{"title":"laravel 4 note 01","slug":"技术/Web开发/后台开发_laravel-4-note-01","date":"2016-06-11T05:58:44.000Z","updated":"2019-03-28T00:54:58.692Z","comments":true,"path":"2016/06/11/技术/Web开发/后台开发_laravel-4-note-01/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/11/技术/Web开发/后台开发_laravel-4-note-01/","excerpt":"artisan常用命令 php artisan generate:seed page 新建app/database/seeds/PageTableSeeder.php文件，seed文件可以用来随机生成数据填充到数据库。 php artisan generate:view admin._layout.default 新建app/views/admin/_layout/default.blade.php文件，这是模版文件。 php artisan generate:mode article 新建app/models/Article.php文件，这是模型，与数据库操作相关。 php artisan serve 开启Laravel自带的Web服务器，使用地址localhost:8000访问 php artisan migrate 执行数据迁移,该命令会将migration下面改动的文件执行一遍，确保和数据库的一致。","text":"artisan常用命令 php artisan generate:seed page 新建app/database/seeds/PageTableSeeder.php文件，seed文件可以用来随机生成数据填充到数据库。 php artisan generate:view admin._layout.default 新建app/views/admin/_layout/default.blade.php文件，这是模版文件。 php artisan generate:mode article 新建app/models/Article.php文件，这是模型，与数据库操作相关。 php artisan serve 开启Laravel自带的Web服务器，使用地址localhost:8000访问 php artisan migrate 执行数据迁移,该命令会将migration下面改动的文件执行一遍，确保和数据库的一致。 使用Composer安装需要的依赖 在composer.json的require或require-dev添加组件名称和版本号 1&quot;edvinaskrucas/notification&quot;: &quot;3.0.1&quot; 在项目的根目录下执行composer update命令 在app.php中的providers添加一行 1&apos;Krucas\\Notification\\NotificationServiceProvider&apos;, 在aliases中添加一行 1&apos;Notification&apos; =&gt; &apos;Krucas\\Notification\\Facades\\Notification&apos;, 常见错误 新增的类编译的时候提示找不到该类：执行composer auto-dump 新建文件夹后找不到文件：在composer.json中的autoload的classmap新增一行该文件夹的路径。 常用方法 Sentry::check() 检查用户是否登陆 Input::get('email') 获取前台通过get方式提交的email字段 Redirect::route('admin.login') Redirect::to('eadmin/products') HTML::link('account/newaccount','register',array('class'=&gt;'default-btn')) Blade模版语法 Form::open(array('url'=&gt;'accounts/sigin')) Eloqyent操作 12345678910111213//建立一个Page模型，与数据库中的表user关联class Page extends \\Eloquent&#123; protected $table='users'; //指定使用的数据库，不指定的时候默认为类名称的小写复数形式 protected $primaryKey='id'; //指定主键的名称，不指定默认为id protected $timestamps = false; //取消数据库的created_at 和 updated_at两个字段，默认情况下每个数据库都有这两个字段，是框架自动生成和维护的。 protected $appends = array('a1','a2'); //需要使用但是数据库中没有定义的字段 protected $hidden = array('h1','h2'); //需要隐藏的字段，隐藏的字段不会出现在查询结果中。 use SoftDeletingTrait; //开启软删除功能，默认情况下该功能是不打开的。开启软删除之后，删除数据库的命令不会真正执行，而是更新数据库的deleted_at字段。 //如果要自定义返回的时间戳的格式，可以改写此方法实现 protected function getDateFormat()&#123; return 'U'; &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"Web开发","slug":"技术/Web开发","permalink":"http://ff120.github.io/hexoblog/categories/技术/Web开发/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://ff120.github.io/hexoblog/tags/laravel/"}]},{"title":"How to install Laravel framework","slug":"技术/Web开发/后台开发_How-to-install-Laravel-framework","date":"2016-06-11T04:58:02.000Z","updated":"2019-03-28T00:54:58.670Z","comments":true,"path":"2016/06/11/技术/Web开发/后台开发_How-to-install-Laravel-framework/","link":"","permalink":"http://ff120.github.io/hexoblog/2016/06/11/技术/Web开发/后台开发_How-to-install-Laravel-framework/","excerpt":"安装composer 下载composer的Windows安装包，Composer-Setup.exe 运行安装程序，配置php.exe所在的位置 安装程序会自动从官网下载所需的文件，自动完成安装","text":"安装composer 下载composer的Windows安装包，Composer-Setup.exe 运行安装程序，配置php.exe所在的位置 安装程序会自动从官网下载所需的文件，自动完成安装 安装完成后，打开cmd，键入composer，出现如下提示证明安装成功 如果因为没有翻墙安装失败，可以使用国内composer镜像安装 composer中国镜像 composer 离线安装方法 下载需要的文件 百度云：链接: http://pan.baidu.com/s/1qW0VhCC 密码: 2nc1 将文件解压至任意目录，例如c:\\composer\\ 将bin所在的路径添加到系统的path变量中 重新打开一个cmd，键入composer测试 安装Laravel框架 官方文档 官网教程 下载框架安装 百度云： 链接: http://pan.baidu.com/s/1mg84OCo 密码: ev2x 下载完成后，解压文件到Web服务器目录下，文件结构为 在该目录下运行 composer install ，安装lavarel框架所需要的依赖包 安装完成后，会在该文件夹下新增一个vender文件夹，这里面是lavarel框架的依赖包。 vender 的结构 在项目根目录下键入php artisan serve 在浏览器输入localhost:8000出现如下页面，证明安装成功 听听音乐","categories":[{"name":"技术","slug":"技术","permalink":"http://ff120.github.io/hexoblog/categories/技术/"},{"name":"Web开发","slug":"技术/Web开发","permalink":"http://ff120.github.io/hexoblog/categories/技术/Web开发/"}],"tags":[{"name":"php","slug":"php","permalink":"http://ff120.github.io/hexoblog/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"http://ff120.github.io/hexoblog/tags/laravel/"}]}]}