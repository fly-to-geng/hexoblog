<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FEI&#39;s Blog</title>
  
  <subtitle>Talents come from diligence, and knowledge is gained by accumulation.</subtitle>
  <link href="/hexoblog/atom.xml" rel="self"/>
  
  <link href="http://ff120.github.io/hexoblog/"/>
  <updated>2019-04-02T23:22:52.402Z</updated>
  <id>http://ff120.github.io/hexoblog/</id>
  
  <author>
    <name>FF120</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代码记忆法</title>
    <link href="http://ff120.github.io/hexoblog/2019/04/03/%E5%BF%83%E7%90%86%E5%AD%A6/%E8%AE%B0%E5%BF%86%E9%AD%94%E6%B3%95/%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BF%86%E6%B3%95/"/>
    <id>http://ff120.github.io/hexoblog/2019/04/03/心理学/记忆魔法/代码记忆法/</id>
    <published>2019-04-03T14:51:32.000Z</published>
    <updated>2019-04-02T23:22:52.402Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码记忆法">代码记忆法</h1><p>使用英语单词对数字编码，强化记忆数字和编码之间的关系，就可以把数字转换成对应的英语单词，而英语单词是有意义的，可以转化成画面，运用画面辅助记忆，可以达到快速记忆的目的。这就是代码记忆法的思路。</p><h2 id="数字编码方法">数字编码方法</h2><p>来自布拉德·乔伊斯（美）的超级记忆力训练</p><h3 id="section">0</h3><div class="figure"><img src="zero.jpg" alt="Z, S"><p class="caption">Z, S</p></div><h3 id="section-1">1</h3><div class="figure"><img src="tie.jpg" alt="T,D,tie,领带"><p class="caption">T,D,tie,领带</p></div><h3 id="section-2">2</h3><div class="figure"><img src="noah.jpg" alt="N, noah, 诺亚方舟"><p class="caption">N, noah, 诺亚方舟</p></div><h3 id="section-3">3</h3><div class="figure"><img src="ma.jpg" alt="M, ma, 妈妈"><p class="caption">M, ma, 妈妈</p></div><h3 id="section-4">4</h3><div class="figure"><img src="rye.jpg" alt="R, rye, 燕麦"><p class="caption">R, rye, 燕麦</p></div><h3 id="section-5">5</h3><div class="figure"><img src="law.jpg" alt="L, law, 法律"><p class="caption">L, law, 法律</p></div><h3 id="section-6">6</h3><p><img src="shoe.jpg" alt="sh, shoe, 鞋子"> ### 7</p><div class="figure"><img src="cow.jpg" alt="K,C, cow, 奶牛"><p class="caption">K,C, cow, 奶牛</p></div><h3 id="section-7">8</h3><div class="figure"><img src="ivy.jpg" alt="V, ivy, 常春藤"><p class="caption">V, ivy, 常春藤</p></div><h3 id="section-8">9</h3><div class="figure"><img src="bee.jpg" alt="B,P, bee, 蜜蜂"><p class="caption">B,P, bee, 蜜蜂</p></div><p>0 到9都有了代表它们的发音字母和具体的实物，接下来为10 到 99 设置对应的代表实物，方法是分解成单个数字，然后组合。</p><p>例如：</p><p>10 由 1 和 0 组成， 所以代表10的单词应该包含T或者D，且包含Z或者S，找一个满足这个条件的单词，我们使用toes这个单词。</p><h3 id="section-9">10</h3><div class="figure"><img src="toes.jpg" alt="toes, 脚趾"><p class="caption">toes, 脚趾</p></div><h3 id="section-10">11 – 50</h3><table><thead><tr class="header"><th>数字</th><th>单词</th><th>含义</th><th>自己想象画面</th></tr></thead><tbody><tr class="odd"><td>11</td><td>tot</td><td>小孩</td><td></td></tr><tr class="even"><td>12</td><td>tin</td><td>罐头</td><td></td></tr><tr class="odd"><td>13</td><td>tomb</td><td>坟墓</td><td></td></tr><tr class="even"><td>14</td><td>tire</td><td>轮胎</td><td></td></tr><tr class="odd"><td>15</td><td>towel</td><td>毛巾</td><td></td></tr><tr class="even"><td>16</td><td>dish</td><td>盘子</td><td></td></tr><tr class="odd"><td>17</td><td>tack</td><td>大头针</td><td></td></tr><tr class="even"><td>18</td><td>dove</td><td>鸽子</td><td></td></tr><tr class="odd"><td>19</td><td>tub</td><td>浴盆</td><td></td></tr><tr class="even"><td>20</td><td>nose</td><td>鼻子</td><td></td></tr><tr class="odd"><td>21</td><td>net</td><td>网</td><td></td></tr><tr class="even"><td>22</td><td>nun</td><td>修女</td><td></td></tr><tr class="odd"><td>23</td><td>name</td><td>名字</td><td></td></tr><tr class="even"><td>24</td><td>nero</td><td>罗马暴君尼禄</td><td></td></tr><tr class="odd"><td>25</td><td>nail</td><td>指甲</td><td></td></tr><tr class="even"><td>26</td><td>notch</td><td>东非大裂谷</td><td></td></tr><tr class="odd"><td>27</td><td>neck</td><td>脖子</td><td></td></tr><tr class="even"><td>28</td><td>knife</td><td>刀子</td><td></td></tr><tr class="odd"><td>29</td><td>knob</td><td>球形把手</td><td></td></tr><tr class="even"><td>30</td><td>mice</td><td>老鼠</td><td></td></tr><tr class="odd"><td>31</td><td>mat</td><td>席子</td><td></td></tr><tr class="even"><td>32</td><td>moon</td><td>月亮</td><td></td></tr><tr class="odd"><td>33</td><td>mummy</td><td>木乃伊</td><td></td></tr><tr class="even"><td>34</td><td>mower</td><td>割草机</td><td></td></tr><tr class="odd"><td>35</td><td>mule</td><td>骡子</td><td></td></tr><tr class="even"><td>36</td><td>match</td><td>火柴</td><td></td></tr><tr class="odd"><td>37</td><td>mug</td><td>大杯子</td><td></td></tr><tr class="even"><td>38</td><td>movie</td><td>电影</td><td></td></tr><tr class="odd"><td>39</td><td>mob</td><td>拖把</td><td></td></tr><tr class="even"><td>40</td><td>rose</td><td>玫瑰</td><td></td></tr><tr class="odd"><td>41</td><td>rod</td><td>杆子</td><td></td></tr><tr class="even"><td>42</td><td>rain</td><td>雨水</td><td></td></tr><tr class="odd"><td>43</td><td>ram</td><td>公羊</td><td></td></tr><tr class="even"><td>44</td><td>rower</td><td>划船的人</td><td></td></tr><tr class="odd"><td>45</td><td>roll</td><td>面包卷</td><td></td></tr><tr class="even"><td>46</td><td>roach</td><td>螳螂</td><td></td></tr><tr class="odd"><td>47</td><td>rock</td><td>岩石</td><td></td></tr><tr class="even"><td>48</td><td>roof</td><td>房顶</td><td></td></tr><tr class="odd"><td>49</td><td>rope</td><td>绳子</td><td></td></tr><tr class="even"><td>50</td><td>lace</td><td>鞋带</td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;代码记忆法&quot;&gt;代码记忆法&lt;/h1&gt;
&lt;p&gt;使用英语单词对数字编码，强化记忆数字和编码之间的关系，就可以把数字转换成对应的英语单词，而英语单词是有意义的，可以转化成画面，运用画面辅助记忆，可以达到快速记忆的目的。这就是代码记忆法的思路。&lt;/p&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
      <category term="心理学" scheme="http://ff120.github.io/hexoblog/categories/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
      <category term="记忆魔法" scheme="http://ff120.github.io/hexoblog/categories/%E5%BF%83%E7%90%86%E5%AD%A6/%E8%AE%B0%E5%BF%86%E9%AD%94%E6%B3%95/"/>
    
    
      <category term="记忆" scheme="http://ff120.github.io/hexoblog/tags/%E8%AE%B0%E5%BF%86/"/>
    
  </entry>
  
  <entry>
    <title>AutoHotKey非常有用的脚本</title>
    <link href="http://ff120.github.io/hexoblog/2018/12/02/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/AutoHotKey/AutoHotKey%E9%9D%9E%E5%B8%B8%E6%9C%89%E7%94%A8%E7%9A%84%E8%84%9A%E6%9C%AC/"/>
    <id>http://ff120.github.io/hexoblog/2018/12/02/技术/工具/AutoHotKey/AutoHotKey非常有用的脚本/</id>
    <published>2018-12-02T09:42:38.000Z</published>
    <updated>2019-03-29T00:28:33.890Z</updated>
    
    <content type="html"><![CDATA[<p>键盘和鼠标按键修改工具AutoHotKey可以实现修改任意键盘按键和鼠标按键的功能，可以实现快捷短语的输入。</p><p>我的AutoHotKey脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br></pre></td><td class="code"><pre><span class="line">SetCapsLockState, AlwaysOff</span><br><span class="line">;***********************************************************</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;||                 使用键盘模拟鼠标                      ||</span><br><span class="line">;|+-------------------------+-----------------------------+|</span><br><span class="line">;||      CapsLock+d         |    开启                     ||</span><br><span class="line">;||      CapsLock+f         |    关闭                     ||</span><br><span class="line">;|+-------------------------+-----------------------------+|</span><br><span class="line">;||        d                |    左键                     ||</span><br><span class="line">;||        f                |    右键                     ||</span><br><span class="line">;||      ikjl               |    鼠标移动                 ||</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">#SingleInstance</span><br><span class="line">count = 0</span><br><span class="line">JoyMultiplier = 0.20</span><br><span class="line">JoyThreshold = 3</span><br><span class="line">JoyThresholdUpper := 50 + JoyThresholdr</span><br><span class="line">JoyThresholdLower := 50 - JoyThreshold</span><br><span class="line">YAxisMultiplier = -1</span><br><span class="line">SetTimer, WatchKeyboard, 20</span><br><span class="line">Hotkey, d, ButtonRight</span><br><span class="line">Hotkey, f, ButtonLeft</span><br><span class="line">Hotkey, i,empty</span><br><span class="line">Hotkey, k,empty</span><br><span class="line">Hotkey, j,empty</span><br><span class="line">Hotkey, l,empty</span><br><span class="line">Hotkey, u,empty</span><br><span class="line">Hotkey, m,empty</span><br><span class="line">Return</span><br><span class="line"></span><br><span class="line">CapsLock &amp; d::</span><br><span class="line">    SetTimer, WatchKeyboard,On</span><br><span class="line">    Hotkey, d, on</span><br><span class="line">    Hotkey, f, on</span><br><span class="line">    Hotkey, i, on</span><br><span class="line">    Hotkey, k, on</span><br><span class="line">    Hotkey, j, on</span><br><span class="line">    Hotkey, l, on</span><br><span class="line">Hotkey, u, on</span><br><span class="line">Hotkey, m, on</span><br><span class="line">Return</span><br><span class="line"></span><br><span class="line">CapsLock &amp; f::</span><br><span class="line">    SetTimer, WatchKeyboard, Off</span><br><span class="line">    Hotkey, d, Off</span><br><span class="line">    Hotkey, f, Off</span><br><span class="line">    Hotkey, i, Off</span><br><span class="line">    Hotkey, k, Off</span><br><span class="line">    Hotkey, j, Off</span><br><span class="line">    Hotkey, l, Off</span><br><span class="line">Hotkey, u, off</span><br><span class="line">Hotkey, m, off</span><br><span class="line">Return</span><br><span class="line"></span><br><span class="line">empty:</span><br><span class="line">Return</span><br><span class="line">WatchKeyboard:</span><br><span class="line">MouseNeedsToBeMoved := false  ; Set default.</span><br><span class="line">JoyMultiplier+=0.01</span><br><span class="line">SetFormat, float, 03</span><br><span class="line">i:=GetKeyState(&quot;i&quot;,&quot;p&quot;)</span><br><span class="line">k:=GetKeyState(&quot;k&quot;,&quot;p&quot;)</span><br><span class="line">j:=GetKeyState(&quot;j&quot;,&quot;p&quot;)</span><br><span class="line">l:=GetKeyState(&quot;l&quot;,&quot;p&quot;)</span><br><span class="line">u:=GetKeyState(&quot;u&quot;,&quot;p&quot;)</span><br><span class="line">m:=GetKeyState(&quot;m&quot;,&quot;p&quot;)</span><br><span class="line">if(u)</span><br><span class="line">&#123;</span><br><span class="line">send,&#123;WheelUp&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(m)</span><br><span class="line">&#123;</span><br><span class="line">send,&#123;WheelDown&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(l)</span><br><span class="line">&#123;</span><br><span class="line">    MouseNeedsToBeMoved := true</span><br><span class="line">    DeltaX := 10</span><br><span class="line">&#125;</span><br><span class="line">else if(j)</span><br><span class="line">&#123;</span><br><span class="line">    MouseNeedsToBeMoved := true</span><br><span class="line">BeMoved := true</span><br><span class="line">    DeltaX := -10</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">    DeltaX = 0</span><br><span class="line">if (i)</span><br><span class="line">&#123;</span><br><span class="line">    MouseNeedsToBeMoved := true</span><br><span class="line">    DeltaY := 10</span><br><span class="line">&#125;</span><br><span class="line">else if (k)</span><br><span class="line">&#123;</span><br><span class="line">    MouseNeedsToBeMoved := true</span><br><span class="line">    DeltaY := -10</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">    DeltaY = 0</span><br><span class="line">if MouseNeedsToBeMoved</span><br><span class="line">&#123;</span><br><span class="line">    SetMouseDelay, -1  ; Makes movement smoother.</span><br><span class="line">    MouseMove, DeltaX * JoyMultiplier, DeltaY * JoyMultiplier * YAxisMultiplier, 0, R</span><br><span class="line">&#125;</span><br><span class="line">Else</span><br><span class="line">count++</span><br><span class="line">If(count&gt;20)&#123;</span><br><span class="line">JoyMultiplier = 0.30</span><br><span class="line">count=0</span><br><span class="line">&#125;</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">ButtonLeft:</span><br><span class="line">SetMouseDelay, -1  ; Makes movement smoother.</span><br><span class="line">MouseClick, left,,, 1, 0, D  ; Hold down the left mouse button.</span><br><span class="line">SetTimer, WaitForLeftButtonUp, 10</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">ButtonRight:</span><br><span class="line">SetMouseDelay, -1  ; Makes movement smoother.</span><br><span class="line">MouseClick, right,,, 1, 0, D  ; Hold down the right mouse button.</span><br><span class="line">SetTimer, WaitForRightButtonUp, 10</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WaitForLeftButtonUp:</span><br><span class="line">if GetKeyState(&quot;f&quot;)</span><br><span class="line">    return  ; The button is still, down, so keep waiting.</span><br><span class="line">; Otherwise, the button has been released.</span><br><span class="line">SetTimer, WaitForLeftButtonUp, off</span><br><span class="line">SetMouseDelay, -1  ; Makes movement smoother.</span><br><span class="line">MouseClick, left,,, 1, 0, U  ; Release the mouse button.</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">WaitForRightButtonUp:</span><br><span class="line">if GetKeyState(&quot;d&quot;)</span><br><span class="line">    return  ; The button is still, down, so keep waiting.</span><br><span class="line">; Otherwise, the button has been released.</span><br><span class="line">SetTimer, WaitForRightButtonUp, off</span><br><span class="line">MouseClick, right,,, 1, 0, U  ; Release the mouse button.</span><br><span class="line">return</span><br><span class="line">;************************************************************</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;||                 使用键盘模拟鼠标                      ||</span><br><span class="line">;|+-------------------------+-----------------------------+|</span><br><span class="line">;||      a+f                |    左键                     ||</span><br><span class="line">;||      a+d                |    右键                     ||</span><br><span class="line">;||      a+u                |    向上滚轮                 ||</span><br><span class="line">;||      a+m                |    向下滚轮                 ||</span><br><span class="line">;||      a+i,j,k,l          |    鼠标移动                 ||</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;************************************************************</span><br><span class="line">$a::</span><br><span class="line">Send, a</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">a &amp; i::</span><br><span class="line">SetMouseDelay, -1 </span><br><span class="line">MouseMove, 0, -15, 0, R </span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">a &amp; k::</span><br><span class="line">SetMouseDelay, -1 </span><br><span class="line">MouseMove, 0, 15, 0, R</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">a &amp; j::</span><br><span class="line">SetMouseDelay, -1 </span><br><span class="line">MouseMove, -15, 0, 0, R</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">a &amp; l::</span><br><span class="line">SetMouseDelay, -1</span><br><span class="line">MouseMove 15 ,0,0,R</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">a &amp; u::</span><br><span class="line">Send, &#123;WheelUp&#125;</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">a &amp; m::</span><br><span class="line">Send, &#123;WheelDown&#125;</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">a &amp; f::</span><br><span class="line">SetMouseDelay, -1  </span><br><span class="line">MouseClick, left,,, 1, 0, D  ; Hold down the left mouse button.</span><br><span class="line">SetTimer, WaitForLeftButtonUp, 10</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">a &amp; d::</span><br><span class="line">SetMouseDelay, -1 </span><br><span class="line">MouseClick, right,,, 1, 0, D  ; Hold down the right mouse button.</span><br><span class="line">SetTimer, WaitForRightButtonUp, 10</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">;************************************************************</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;||                CapsLock改成Enter键                    ||</span><br><span class="line">;|+-------------------------+-----------------------------+|</span><br><span class="line">;||      CaspLock                |    Enter               ||</span><br><span class="line">;||      alt + CapsLock          |    CaspLock            ||</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;************************************************************</span><br><span class="line">$CapsLock::Enter </span><br><span class="line"></span><br><span class="line">LAlt &amp; CapsLock::</span><br><span class="line">GetKeyState, CapsLockState, CapsLock, T</span><br><span class="line">if CapsLockState = D</span><br><span class="line">SetCapsLockState, AlwaysOff</span><br><span class="line">else</span><br><span class="line">SetCapsLockState, AlwaysOn</span><br><span class="line">KeyWait, CapsLock </span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">RAlt &amp; CapsLock::</span><br><span class="line">GetKeyState, CapsLockState, CapsLock, T</span><br><span class="line">if CapsLockState = D</span><br><span class="line">SetCapsLockState, AlwaysOff</span><br><span class="line">else</span><br><span class="line">SetCapsLockState, AlwaysOn</span><br><span class="line">KeyWait, CapsLock </span><br><span class="line">return</span><br><span class="line">;************************************************************</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;||                主键盘增加方向键                       ||</span><br><span class="line">;|+-------------------------+-----------------------------+|</span><br><span class="line">;||      CaspLock + i       |    Up                       ||</span><br><span class="line">;||      CaspLock + k       |    Down                     ||</span><br><span class="line">;||      CaspLock + j       |    Left                     ||</span><br><span class="line">;||      CaspLock + l       |    Right                    ||</span><br><span class="line">;||      CaspLock + u       |    Home                     ||</span><br><span class="line">;||      CaspLock + m       |    End                      ||</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;************************************************************</span><br><span class="line"></span><br><span class="line">CapsLock &amp; k::</span><br><span class="line">if GetKeyState(&quot;LShift&quot;, &quot;P&quot;)</span><br><span class="line">Send, +&#123;Down&#125;</span><br><span class="line">else if GetKeyState(&quot;LAlt&quot;, &quot;P&quot;)</span><br><span class="line">Send,^&#123;Down&#125;</span><br><span class="line">else if GetKeyState(&quot;LControl&quot;, &quot;P&quot;)</span><br><span class="line">Send,^+&#123;Down&#125;</span><br><span class="line">else</span><br><span class="line">Send, &#123;Down&#125;</span><br><span class="line">Return</span><br><span class="line"></span><br><span class="line">CapsLock &amp; i::</span><br><span class="line">if GetKeyState(&quot;LShift&quot;, &quot;P&quot;)</span><br><span class="line">Send, +&#123;Up&#125;</span><br><span class="line">else if GetKeyState(&quot;LAlt&quot;, &quot;P&quot;)</span><br><span class="line">Send,^&#123;Up&#125;</span><br><span class="line">else if GetKeyState(&quot;LControl&quot;, &quot;P&quot;)</span><br><span class="line">Send,^+&#123;Up&#125;</span><br><span class="line">else</span><br><span class="line">Send, &#123;Up&#125;</span><br><span class="line">Return</span><br><span class="line"></span><br><span class="line">; move left</span><br><span class="line">CapsLock &amp; j::</span><br><span class="line">if GetKeyState(&quot;LShift&quot;, &quot;P&quot;)</span><br><span class="line">Send, +&#123;Left&#125;</span><br><span class="line">else if GetKeyState(&quot;LAlt&quot;, &quot;P&quot;)</span><br><span class="line">Send,^&#123;left&#125;</span><br><span class="line">else if GetKeyState(&quot;LControl&quot;, &quot;P&quot;)</span><br><span class="line">Send,^+&#123;left&#125;</span><br><span class="line">else</span><br><span class="line">Send, &#123;Left&#125;</span><br><span class="line">Return</span><br><span class="line"></span><br><span class="line">CapsLock &amp; l::</span><br><span class="line">if GetKeyState(&quot;LShift&quot;, &quot;P&quot;)</span><br><span class="line">Send, +&#123;Right&#125;</span><br><span class="line">else if GetKeyState(&quot;LAlt&quot;, &quot;P&quot;)</span><br><span class="line">Send,^&#123;Right&#125;</span><br><span class="line">else if GetKeyState(&quot;LControl&quot;, &quot;P&quot;)</span><br><span class="line">Send,^+&#123;Right&#125;</span><br><span class="line">else</span><br><span class="line">Send, &#123;Right&#125;</span><br><span class="line">Return</span><br><span class="line"></span><br><span class="line">CapsLock &amp; u::</span><br><span class="line">if GetKeyState(&quot;LShift&quot;, &quot;P&quot;)</span><br><span class="line">    Send, +&#123;Home&#125;</span><br><span class="line">else if GetKeyState(&quot;LAlt&quot;, &quot;P&quot;)</span><br><span class="line">Send, ^&#123;Home&#125;</span><br><span class="line">else if GetKeyState(&quot;LControl&quot;, &quot;P&quot;)</span><br><span class="line">Send, ^&#123;Home&#125;</span><br><span class="line">else</span><br><span class="line">Send, &#123;Home&#125;</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">CapsLock &amp; m::</span><br><span class="line">if GetKeyState(&quot;LShift&quot;, &quot;P&quot;)</span><br><span class="line">    Send, +&#123;End&#125;</span><br><span class="line">else if GetKeyState(&quot;LAlt&quot;, &quot;P&quot;)</span><br><span class="line">Send, ^&#123;End&#125;</span><br><span class="line">else if GetKeyState(&quot;LControl&quot;, &quot;P&quot;)</span><br><span class="line">Send, ^&#123;End&#125;</span><br><span class="line">else</span><br><span class="line">Send, &#123;End&#125;</span><br><span class="line">return</span><br><span class="line">;************************************************************</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;||                剪贴板设置成3个                        ||</span><br><span class="line">;|+-------------------------+-----------------------------+|</span><br><span class="line">;||      Ctrl + 1           |    复制到剪贴板1            ||</span><br><span class="line">;||      Ctrl + 2           |    复制到剪贴板2            ||</span><br><span class="line">;||      Ctrl + 3           |    复制到剪贴板3            ||</span><br><span class="line">;||      Alt  + l           |    粘贴剪贴板1的内容        ||</span><br><span class="line">;||      Alt  + 2           |    粘贴剪贴板2的内容        ||</span><br><span class="line">;||      Alt  + 3           |    粘贴剪贴板3的内容        ||</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;************************************************************</span><br><span class="line">^1:: </span><br><span class="line">Send ^c</span><br><span class="line">a = %ClipBoard%</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">^2:: </span><br><span class="line">Send ^c</span><br><span class="line">b = %ClipBoard%</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">^3:: </span><br><span class="line">Send ^c</span><br><span class="line">c = %ClipBoard%</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">!1:: </span><br><span class="line">ClipBoard = %a%</span><br><span class="line">Send ^v</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">!2:: </span><br><span class="line">ClipBoard = %b%</span><br><span class="line">Send ^v</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">!3:: </span><br><span class="line">ClipBoard = %c%</span><br><span class="line">Send ^v</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">;************************************************************</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;||                主键盘区域增加小键盘                   ||</span><br><span class="line">;|+-------------------------+-----------------------------+|</span><br><span class="line">;||      CapsLock + p       |    开关                     ||</span><br><span class="line">;||      m                  |    0                        ||</span><br><span class="line">;||      j, k, l            |    1, 2, 3                  ||</span><br><span class="line">;||      u, i, p            |    4, 5, 6                  ||</span><br><span class="line">;||      7, 8, 9            |    7, 8, 9                  ||</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;************************************************************</span><br><span class="line">#if</span><br><span class="line">CapsLock &amp; p::</span><br><span class="line">ONOFF := !ONOFF</span><br><span class="line">Return</span><br><span class="line">#if ONOFF</span><br><span class="line">&#123;</span><br><span class="line">u::4</span><br><span class="line">i::5</span><br><span class="line">o::6</span><br><span class="line">j::1</span><br><span class="line">k::2</span><br><span class="line">l::3</span><br><span class="line">m::0</span><br><span class="line">n::0</span><br><span class="line">&#125;</span><br><span class="line">#if</span><br><span class="line"></span><br><span class="line">;************************************************************</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;||                   快捷搜索                            ||</span><br><span class="line">;|+-------------------------+-----------------------------+|</span><br><span class="line">;||      CapsLock + e       |    翻译所选词汇             ||</span><br><span class="line">;||      CapsLock + s       |    搜索所选词汇             ||</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;************************************************************</span><br><span class="line"></span><br><span class="line">CapsLock &amp; e::</span><br><span class="line">ffSearchWord = %ClipBoard%</span><br><span class="line">run https://fanyi.baidu.com/#en/zh/%ffSearchWord%</span><br><span class="line">run https://cn.bing.com/dict/search?q=%ffSearchWord%</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">CapsLock &amp; s::</span><br><span class="line">Send ^c</span><br><span class="line">content = %ClipBoard%</span><br><span class="line">run https://www.baidu.com/s?wd=%content%</span><br><span class="line">run https://cn.bing.com/search?q=%content%</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">CapsLock &amp; n::</span><br><span class="line">run http://www.baidu.com</span><br><span class="line">return</span><br><span class="line">;************************************************************</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;||                   重新加载本脚本                      ||</span><br><span class="line">;|+-------------------------+-----------------------------+|</span><br><span class="line">;||      CapsLock + r       |    重载                     ||</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;************************************************************</span><br><span class="line">CapsLock &amp; r::</span><br><span class="line">Send ^s</span><br><span class="line">reload</span><br><span class="line">return</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;键盘和鼠标按键修改工具AutoHotKey可以实现修改任意键盘按键和鼠标按键的功能，可以实现快捷短语的输入。&lt;/p&gt;
&lt;p&gt;我的AutoHotKey脚本：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
      <category term="技术" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="工具" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="AutoHotKey" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/AutoHotKey/"/>
    
    
      <category term="AutoHotKey" scheme="http://ff120.github.io/hexoblog/tags/AutoHotKey/"/>
    
  </entry>
  
  <entry>
    <title>Git 手册</title>
    <link href="http://ff120.github.io/hexoblog/2018/07/29/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/Git/Git%E6%9F%A5%E8%AF%A2%E6%89%8B%E5%86%8C/"/>
    <id>http://ff120.github.io/hexoblog/2018/07/29/技术/工具/Git/Git查询手册/</id>
    <published>2018-07-29T09:13:42.000Z</published>
    <updated>2019-03-28T13:37:41.721Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git-的结构">Git 的结构</h2><p>Git 分成三个区域，工作区，暂存区，版本库</p><ul><li><p>工作区：就是和<code>.git</code>文件夹在同一级的工程目录。</p></li><li><p>暂存区：<code>.git</code>中的index中存储暂存区的目录树</p></li><li><p>版本库：<code>.git</code>中的其他地方存储版本库的内容，这个里面包含历史提交和即将要推送到远程版本库的内容。</p></li></ul><p>工作区的文件我们可以从文件管理器直观的看到，暂存区和版本库的文件<code>git</code>只是存储的相应的目录树，具体文件的内容在<code>.git\object</code>对象库中存储，并且使用的是差异化的存储，所以不能之间看到相应的文件，但是可以利用<code>Git</code>提供的工具间接的了解其中的内容。</p><div class="figure"><img src="git_show_01.svg" alt="Git内部结构"><p class="caption">Git内部结构</p></div><h2 id="查看差异">查看差异</h2><ul><li><p><code>git diff</code> ： 比较工作区和暂存区的差异</p></li><li><p><code>git diff --cached</code> ： 比较暂存区和版本库的差异</p></li><li><p><code>git diff HEAD</code> : 比较工作区和版本库的差异</p></li></ul><p>将上面命令中的<code>giff</code>换成<code>difftool</code>, 可以使用自定义的图形工具比较差异文件。</p><h2 id="从工作区到暂存区">1. 从工作区到暂存区</h2><p>如果想把工作区所做的改动(添加文件、修改内容、删除文件)，可以使用<code>git add</code>命令。</p><ul><li><p><code>git add filename</code> : 把工作区文件filename的改动添加到暂存区</p></li><li><p><code>git reset -- filename</code> : 把添加到暂存区的文件filename 撤销，工作区的文件filename不变，其实就是撤销刚才的<code>git add filename</code> 命令。</p></li><li><code>git add .</code> : 把工作区所有改动添加到暂存区</li><li><p><code>git reset</code> : 撤销<code>git add .</code>操作</p></li><li><p><code>git add -i</code> : 用交互的方式选择添加哪些文件到暂存区</p></li></ul><h2 id="从暂存区到工作区">2. 从暂存区到工作区</h2><ul><li><p><code>git checkout filename</code> : 把暂存区的文件filename添加到工作区，工作区的该文件会被覆盖，其实相当于<code>git add filename</code>的逆操作。</p></li><li><p><code>git reset filename</code> : 用暂存区的文件<code>filename</code>覆盖工作区的文件，相当于<code>git add filename</code>的反操作</p></li><li><p><code>git checkout .</code> : 把暂存区的所有文件添加到工作区，相当于<code>git add .</code>的逆操作。</p></li><li><p><code>git reset</code> : 撤销<code>git add .</code>操作，即用暂存区的内容覆盖工作区的内容。</p></li></ul><p><code>git checkout</code>会清除工作区中尚未<code>add</code>到暂存区中的内容，一定不要用错，否则自己做的工作就要白费了。</p><h2 id="从暂存区到版本库">3. 从暂存区到版本库</h2><p>如果想把在暂存区的内容提交到版本库，推送到远程版本库，可以使用<code>git commit</code>命令。</p><ul><li><p><code>git commit</code> : 提交暂存区的内容到版本库，需要写提交说明。</p></li><li><p><code>git commit --allow-empty</code> : 允许提交空的内容</p></li><li><p><code>git commit --amend</code> : 修补提交，不生成新的提交，而是在上一次提交的基础上修改提交内容。</p></li><li><p><code>git reset --soft HEAD^</code> : 撤销最新的提交，相当于<code>git commit</code>的逆操作。 命令解析：<code>--soft</code>选项指定不改变工作区和暂存区, HEAD指向最新的提交，<code>HEAD^</code>指向上一次提交，合起来该命令实现的功能就是撤销最新的提交，而工作区和暂存区的内容不改变。</p></li></ul><h2 id="从版本库到暂存区">4. 从版本库到暂存区</h2><ul><li><code>git reset HEAD^</code> : 工作区不改变，暂存区回退到上一次提交，版本库回退到上一次提交。</li></ul><h2 id="工作区直接到版本库">5. 工作区直接到版本库</h2><h2 id="版本库直接到工作区">6. 版本库直接到工作区</h2><ul><li><code>git reset --hard HEAD^</code> : 工作区、暂存区都会回退到上一次提交，版本库回退到上一次提交</li></ul><h2 id="常用命令解析">常用命令解析</h2><h3 id="git-diff"><code>git diff</code></h3><h3 id="git-log"><code>git log</code></h3><p><code>git log -g -2 HEAD</code> : 查看最近HEAD指向的两次提交</p><h3 id="git-add"><code>git add</code></h3><h3 id="git-checkout"><code>git checkout</code></h3><p>有两种主要的用法，切换分支 和 检出文件</p><p>检出文件：</p><ul><li><code>git checkout -- filename</code> : 从暂存区检出filename到工作区，工作区未提交的内容会丢失</li><li><code>git checkout -- '.'</code> :用暂存区覆盖工作区</li></ul><h3 id="git-reset"><code>git reset</code></h3><p>reset就是重置的意思，该命令的本质是修改HEAD指向的提交ID，可以使用不同的参数指定对暂存区和工作区的影响。</p><ul><li><p><code>git reset</code> : 其对应的完成形式应该是<code>git reset --mixed HEAD</code>, 含义是用HEAD指向的内容覆盖暂存区内容， 它是<code>git add .</code>的逆操作。</p></li><li><p><code>git reset -- filename</code> : 其完整形式是<code>git reset -- filename HEAD</code>, 含义是用HEAD指向的文件filename的内容覆盖暂存区内容，它是<code>git add filename</code>的逆操作。</p></li><li><p><code>git reset --mixed</code> : 工作区内容不变，暂存区和版本库重置；</p></li><li><p><code>git reset --soft</code> : 工作区和暂存区内容都不变，版本库重置；</p></li><li><p><code>git reset --hard</code> : 工作区，暂存区和版本库都改变。</p></li></ul><p>例如，<code>git reset --soft HEAD^</code>, 撤销最近的提交，暂存区和工作区都不变，要想恢复直接<code>git commit</code>; <code>git reset --mixed HEAD^</code>, 撤销最近的提交和暂存区的内容，要想恢复需要<code>git add .</code>, <code>git commit</code>两条命令； <code>git reset --hard HEAD^</code> 工作区，暂存区都会被上一次提交覆盖，工作区保持和上一次提交一致，未提交的内容会丢失。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;git-的结构&quot;&gt;Git 的结构&lt;/h2&gt;
&lt;p&gt;Git 分成三个区域，工作区，暂存区，版本库&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;工作区：就是和&lt;code&gt;.git&lt;/code&gt;文件夹在同一级的工程目录。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;暂存区：&lt;code&gt;
      
    
    </summary>
    
      <category term="技术" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="工具" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Git" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/Git/"/>
    
    
      <category term="Git" scheme="http://ff120.github.io/hexoblog/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://ff120.github.io/hexoblog/2018/07/29/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://ff120.github.io/hexoblog/2018/07/29/技术/工具/正则表达式/正则表达式/</id>
    <published>2018-07-29T09:13:42.000Z</published>
    <updated>2019-03-28T00:54:58.534Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式是使用一个字符串表达一个要匹配的模式。模式的表示通过元字符，正则表达式常用的元字符及含义如下：</p><h2 id="元字符">元字符</h2><table><thead><tr class="header"><th>匹配单个字符</th><th>含义</th></tr></thead><tbody><tr class="odd"><td><code>.</code></td><td>匹配任意一个字符，除了<code>\r</code>和<code>\n</code></td></tr><tr class="even"><td><code>\d</code></td><td>匹配数字0-9，等价于<code>[0-9]</code></td></tr><tr class="odd"><td><code>\D</code></td><td>匹配除了0-9之外的字符,等价于<code>[^0-9]</code></td></tr><tr class="even"><td><code>\w</code></td><td>匹配任何一个字母数字或者下划线，等价于<code>[A-Za-z0-9_]</code></td></tr><tr class="odd"><td><code>\W</code></td><td>匹配任何一个非字母数字下划线，等价于<code>[^A-Za-z0-9_]</code></td></tr><tr class="even"><td><code>\b</code></td><td>匹配单词边界</td></tr><tr class="odd"><td><code>\B</code></td><td>匹配非单词边界</td></tr><tr class="even"><td><code>\s</code></td><td>匹配任意一个空白字符，等价于<code>[\f\n\r\t\v]</code></td></tr><tr class="odd"><td><code>\S</code></td><td>匹配任意一个非空白字符</td></tr><tr class="even"><td><code>^</code></td><td>匹配一行的开头</td></tr><tr class="odd"><td><code>$</code></td><td>匹配一行的结束</td></tr></tbody></table><table><thead><tr class="header"><th>匹配重复次数</th><th>含义</th></tr></thead><tbody><tr class="odd"><td><code>?</code></td><td>匹配0次或者1次，用在一个表达式后面可以表示非贪心的匹配</td></tr><tr class="even"><td><code>+</code></td><td>匹配一次或者多次</td></tr><tr class="odd"><td><code>*</code></td><td>匹配0次或者多次</td></tr><tr class="even"><td><code>{n}</code></td><td>匹配n次</td></tr><tr class="odd"><td><code>{m,}</code></td><td>至少匹配m次</td></tr><tr class="even"><td><code>{m,n}</code></td><td>最少匹配m次，最多匹配n次</td></tr></tbody></table><p>了解了以上的元字符，便可以构造匹配任意字符任意次的一个模式，但是还不能指定多个字符构成的模式的重复次数，下面介绍分组和捕获的相关内容。</p><table style="width:14%;"><colgroup><col width="6%"><col width="6%"></colgroup><thead><tr class="header"><th>逻辑控制</th><th>含义</th></tr></thead><tbody><tr class="odd"><td><code>x|y</code></td><td>逻辑或，匹配x或者匹配y</td></tr><tr class="even"><td><code>{}</code></td><td>里面跟数字，指定前面的模式的重复次数</td></tr><tr class="odd"><td><code>[]</code></td><td>里面放置任意字符，都是或的关系，匹配这个集合里面的任意一个</td></tr><tr class="even"><td><code>(pattern)</code></td><td>指定分组，分组后面紧跟的描述符描述的是这一组模式重复的次数,这个分组会被捕获，可以使用<code>\num</code>来引用捕获的这个分组</td></tr><tr class="odd"><td><code>(?:pattern)</code></td><td>指定这个分组不被捕获</td></tr><tr class="even"><td><code>(?=pattern)</code></td><td>非捕获匹配，正向肯定预先查找，匹配后面符合pattern的前面部分，例如<code>Windows(?=95|98|NT|2000)</code>,在匹配<code>Windows的时候会查找</code>Windows后面的字符，只匹配那些后面紧跟的是<code>95</code>,<code>98</code>,<code>NT</code>,<code>2000</code>的<code>Windows</code>,而不会匹配到<code>Windows3.1</code>中的<code>Windows</code></td></tr><tr class="odd"><td><code>(?!pattern)</code></td><td>非捕获匹配，正向非肯定预先查找</td></tr><tr class="even"><td><code>(?&lt;=pattern)</code></td><td>非捕获匹配，反向肯定预先查找</td></tr><tr class="odd"><td><code>(?&lt;!pattern)</code></td><td>非捕获查找，反向非肯定预先查找</td></tr></tbody></table><h2 id="常用实例解析">常用实例解析</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;正则表达式是使用一个字符串表达一个要匹配的模式。模式的表示通过元字符，正则表达式常用的元字符及含义如下：&lt;/p&gt;
&lt;h2 id=&quot;元字符&quot;&gt;元字符&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th&gt;匹配单个字符&lt;/th&gt;

      
    
    </summary>
    
      <category term="技术" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="工具" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="正则表达式" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习-第七章-感知机</title>
    <link href="http://ff120.github.io/hexoblog/2017/11/04/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
    <id>http://ff120.github.io/hexoblog/2017/11/04/技术/机器学习/机器学习-第七章-感知机/</id>
    <published>2017-11-04T01:06:41.000Z</published>
    <updated>2019-03-28T00:54:57.561Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    <summary type="html">
    
      
      
        

      
    
    </summary>
    
      <category term="技术" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="机器学习" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习-第六章-kmeans</title>
    <link href="http://ff120.github.io/hexoblog/2017/11/04/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E5%85%AD%E7%AB%A0-kmeans/"/>
    <id>http://ff120.github.io/hexoblog/2017/11/04/技术/机器学习/机器学习-第六章-kmeans/</id>
    <published>2017-11-04T01:06:21.000Z</published>
    <updated>2019-03-28T00:54:57.654Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    <summary type="html">
    
      
      
        

      
    
    </summary>
    
      <category term="技术" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="机器学习" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习-第五章-最近邻</title>
    <link href="http://ff120.github.io/hexoblog/2017/11/04/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9C%80%E8%BF%91%E9%82%BB/"/>
    <id>http://ff120.github.io/hexoblog/2017/11/04/技术/机器学习/机器学习-第五章-最近邻/</id>
    <published>2017-11-04T01:05:45.000Z</published>
    <updated>2019-03-28T00:54:57.630Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    <summary type="html">
    
      
      
        

      
    
    </summary>
    
      <category term="技术" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="机器学习" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习-第四章-支持向量机</title>
    <link href="http://ff120.github.io/hexoblog/2017/11/04/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    <id>http://ff120.github.io/hexoblog/2017/11/04/技术/机器学习/机器学习-第四章-支持向量机/</id>
    <published>2017-11-04T01:05:10.000Z</published>
    <updated>2019-03-28T00:54:57.687Z</updated>
    
    <content type="html"><![CDATA[<p>【支持向量机】【函数间隔】【几何间隔】【KTT】</p><a id="more"></a><h2 id="模型">模型</h2><p>令 <span class="math inline">\(\theta = (w_1,w_2,...,w_n,b)\)</span>, <span class="math inline">\(x = (x_1,x_2,...,x_n,1)\)</span>,则有： <span class="math display">\[\theta^T \cdot x = w_1x_1+x_2x_2+...+w_nx_n+b\]</span></p><p>支持向量机要得到的分类决策函数是：</p><p><span class="math display">\[h_\theta(x) = sign(\theta^T \cdot x)\]</span></p><p>其中，<span class="math inline">\(sign(x)\)</span>的定义是：</p><p><span class="math display">\[sign(x) = \begin{cases}          1, &amp; x&gt;=0 \\          0, &amp; x &lt; 0 \\          \end{cases}\]</span></p><p>当<span class="math inline">\(\theta^T &gt;= 0\)</span> 的时候，分类成正类，当<span class="math inline">\(\theta^T &lt; 0\)</span>的时候，分类成负类。支持向量机就是通过给定的训练数据求解出<span class="math inline">\(\theta\)</span>.</p><h2 id="策略">策略</h2><h3 id="函数间隔">函数间隔</h3><p><span class="math inline">\(\theta^T \cdot x = 0\)</span> 可以确定一个超平面(n维空间中，n-1维的叫做超平面)，<span class="math inline">\(\theta^T \cdot x &gt; 0\)</span> 的时候，我们定义类别的标签是<code>1</code>, <span class="math inline">\(\theta^T \cdot x &lt; 0\)</span> 的时候，我们定义类别的标签是<code>-1</code>. 这样，<span class="math inline">\(\theta^T \cdot x\)</span>的符号和标签<code>y</code>的符号是一致的。 $ y(\theta^T x ) &gt; 0 $ 表示分类正确， $y(\theta^T x)&lt;0 $ 表示分类错误. 而<span class="math inline">\(|\theta^T \cdot x|\)</span>表示的是点<code>x</code>到分类超平面的距离，可以认为距离越远，分类的可信度越高。</p><p>点<span class="math inline">\((x_i,y_i)\)</span>函数间隔的定义为：</p><p><span class="math display">\[\hat \gamma_i = y_i(\theta^T \cdot x_i)\]</span></p><p>训练集合中所有样本的函数间隔定义为所有样本的函数间隔最小的那一个。</p><h3 id="几何间隔">几何间隔</h3><p><span class="math inline">\(\theta^T \cdot x = wx+b\)</span>, 其中<span class="math inline">\(w = (w_1,w_2,...,w_n)\)</span>. 函数间隔有一个问题，就是成比例的改变<span class="math inline">\(w\)</span>和<span class="math inline">\(b\)</span>的值，函数间隔的大小就会成比例的变化。所以函数间隔并不适合用来求极值点。 改进的方法是限制<span class="math inline">\(w\)</span>的取值，是<span class="math inline">\(||w|| = 1\)</span>, 这样函数间隔就变成了几何间隔。</p><p>样本<span class="math inline">\((x_i,y_i)\)</span>到分类超平面<span class="math inline">\(wx+b=0\)</span>的几何间隔是：</p><p><span class="math display">\[\gamma_i = y_i(\frac w {||w||} \cdot x_i + \frac b {||w||})\]</span></p><p>训练集的几何间隔取 训练集合中所有的样本点到分类超平面几何间隔的最小值。</p><p><strong>优化目标</strong></p><p>支持向量机的优化目标就是找到使得 几何间隔最大化的参数取值。这是一个约束优化问题，目标是<span class="math inline">\(max(\gamma)\)</span>, 约束条件是<span class="math inline">\(\gamma_i &gt;= \gamma\)</span>, 含义是在保证某个点的几何间隔都大于等于<span class="math inline">\(\gamma\)</span>的情况下，求最大的<span class="math inline">\(\gamma\)</span>.</p><p>在约束条件两边都乘以一个<span class="math inline">\(||w||\)</span>, 等式的性质不变，现在约束变成 <span class="math inline">\(y_i(w \cdot x_i + b) &gt;= \hat \gamma\)</span>, 因为 <span class="math inline">\(\gamma = \frac {\hat \gamma} \gamma\)</span>, 最优化的目标变为： <span class="math inline">\(\frac {\hat \gamma} {||w||}\)</span>, <span class="math inline">\(\hat \gamma\)</span>的取值是不影响最后的结果的，前面介绍过了，函数间隔会根据<span class="math inline">\(w\)</span>和<span class="math inline">\(b\)</span>的取值等比例的缩放，所以这里我们令<span class="math inline">\(\hat \gamma = 1\)</span>, 最优化问题可以写成下面的形式：</p><p><span class="math display">\[min \quad \frac 1 2 {||w||^2} \\s.t. \quad y_i(w \cdot x_i + b)-1 &gt;= 0, \quad \text{i=1,2,...,n}\]</span></p><blockquote><p>最大化 <span class="math inline">\(\frac 1 {||w||}\)</span> 等价于 最小化<span class="math inline">\(\frac 1 2 {||w||^2}\)</span></p></blockquote><p>支持向量机就是求解上面的最优化问题，来求得参数<span class="math inline">\(\theta\)</span>，然后构造分类超平面为未知的数据分类的。</p><h2 id="方法">方法</h2><h3 id="拉格朗日函数">拉格朗日函数</h3><p>凸优化问题的一般形式</p><p><span class="math display">\[min \quad f(x) \\s.t. \quad c_i(x) &lt;= 0, \quad i = 1,2,...,k \\           h_j(x) = 0, \quad j = 1,2,...,l\]</span></p><p>其中，<span class="math inline">\(f(x)\)</span>和<span class="math inline">\(c_i(x)\)</span> 都是 <span class="math inline">\(R^n\)</span>上的连续可微的凸函数，<span class="math inline">\(h_j(x)\)</span> 是 <span class="math inline">\(R^n\)</span>上的仿射函数。</p><blockquote><p><span class="math inline">\(f(x)\)</span>是仿射函数的含义是满足条件：<span class="math inline">\(f(x) = ax+b\)</span>,其中<span class="math inline">\(a \in R^n\)</span>,<span class="math inline">\(b \in R\)</span>,<span class="math inline">\(x \in R^n\)</span>.</p></blockquote><p>拉格朗日函数是在 约束优化问题中 用来把约束条件添加到目标函数中的一种手段，广义的拉格朗日函数的定义是：</p><p><span class="math display">\[L(x,\alpha,\beta) = f(x) + \sum_{i=1}^k \alpha_i c_i(x) + \sum_{j=1}^l \beta_j h_j(x) \quad \alpha_i &gt;= 0\]</span></p><p>其中，<span class="math inline">\(f(x)\)</span>是原来约束优化问题的目标函数，<span class="math inline">\(c_i(x)\)</span>和<span class="math inline">\(h_j(x)\)</span>是约束条件中的函数.</p><p>定义函数：</p><p><span class="math display">\[P(x) = \mathop{max} \limits_{\alpha,\beta} L(x,\alpha,\beta)\]</span></p><p>其中，<span class="math inline">\(P(x)\)</span>表示在把<span class="math inline">\(x\)</span>看作常数，<span class="math inline">\(\alpha,\beta\)</span>看作变量的情况下，求<span class="math inline">\(L(x,\alpha,\beta)\)</span>的最大值；</p><p>现在来分析函数<span class="math inline">\(P(x)\)</span>, 如果<span class="math inline">\(x\)</span>满足原来最优化问题的约束条件，即<span class="math inline">\(c_i(x) &lt;= 0\)</span>, <span class="math inline">\(h_j(x) = 0\)</span>, 那么 <span class="math inline">\(P(x) = \mathop{max} \limits_{\alpha,\beta} ( f(x) + \sum_{i=1}^k \alpha_i c_i(x))\)</span>, 这个时候的最大值的结果就是<span class="math inline">\(P(x) = f(x)\)</span>, <span class="math inline">\(\alpha_i = 0\)</span>. 除此之外，<span class="math inline">\(\alpha_i\)</span>取任何大于0的值最后的结果都会减小。</p><p>如果<span class="math inline">\(x\)</span>不满足约束条件，即 <span class="math inline">\(c_i(x) &gt; 0\)</span> 或者 <span class="math inline">\(h_j(x) \neq 0\)</span>, 这个时候总能找到满足的 <span class="math inline">\(\alpha\)</span> 或 <span class="math inline">\(\beta\)</span> ,使得 <span class="math inline">\(P(x) = +\infty\)</span> . 例如，如果<span class="math inline">\(c_i(x) &gt; 0\)</span>, 只需要让<span class="math inline">\(\alpha_i\)</span>足够大，就能保证结果足够大，如果<span class="math inline">\(h_j(x) \neq 0\)</span>, 只需要让<span class="math inline">\(\beta_j\)</span>足够大就能保证结果趋近 <span class="math inline">\(+\infty\)</span> .</p><p>综上，<span class="math inline">\(P(x)\)</span>是一个满足下述条件的函数：</p><p><span class="math display">\[P(x) = \begin{cases}        f(x) &amp; \text{x 满足约束条件} \\        +\infty &amp; \text{x 不满足约束条件}       \end{cases}\]</span></p><p>那么， <span class="math inline">\(min P(x)\)</span> 表示求<span class="math inline">\(P(x)\)</span>的最小值，其含义就是求在满足约束条件的情况下，<span class="math inline">\(f(x)\)</span>的最小值。所以原来的约束最优化问题，在引入拉格朗日函数之后，可以变成下面的无约束优化问题，它与原来的问题等价：</p><p><span class="math display">\[\mathop{min} \limits_x   \quad \mathop{max} \limits_{\alpha,\beta} ( f(x) + \sum_{i=1}^k \alpha_i c_i(x) + \sum_{j=1}^l \beta_j h_j(x))  \quad \alpha_i &gt;= 0\]</span></p><h3 id="对偶问题">对偶问题</h3><p>如果原始问题是：</p><p><span class="math display">\[p^*  =  \mathop{min} \limits_x   \quad \mathop{max} \limits_{\alpha,\beta} ( f(x) + \sum_{i=1}^k \alpha_i c_i(x) + \sum_{j=1}^l \beta_j h_j(x))  \quad \alpha_i &gt;= 0\]</span></p><p>则它的对偶问题是：</p><p><span class="math display">\[d^* =   \mathop{max} \limits_{\alpha,\beta}  \quad  \mathop{min} \limits_x   ( f(x) + \sum_{i=1}^k \alpha_i c_i(x) + \sum_{j=1}^l \beta_j h_j(x))  \quad \alpha_i &gt;= 0\]</span></p><p>原问题是先固定的把<span class="math inline">\(x\)</span>看作常数，求解<span class="math inline">\(\alpha,\beta\)</span>, 再把<span class="math inline">\(\alpha,\beta\)</span>看作常数，求解<span class="math inline">\(x\)</span>; 而对偶问题正好反了过来，是先把<span class="math inline">\(\alpha,\beta\)</span>看作常数，求解出<span class="math inline">\(x\)</span>,再把<span class="math inline">\(x\)</span>看作常数，求解出<span class="math inline">\(\alpha,\beta\)</span></p><p>如果<span class="math inline">\(p^*\)</span>表示原始问题的最优解，而<span class="math inline">\(d^*\)</span>表示对偶问题的最优解，则有<span class="math inline">\(d^* &lt;= p^*\)</span>. 原问题的解是大于等于对偶问题的最优解的，如果想通过解对偶问题来解原来的问题，需要满足如下的KKT条件，才能保证原问题和对偶问题的解相同：</p><p><span class="math display">\[\triangledown_x L(x,\alpha,\beta) = 0 \\\triangledown_{\alpha} L(x,\alpha,\beta) = 0 \\\triangledown_{\beta} L(x,\alpha,\beta) = 0 \\\alpha_ic_i(x) = 0,i=1,2,...,k \\c_i(x) &lt;=0, i = 1,2,...,k \\\alpha_i &gt;= 0, i=1,2,...,k \\h_j(x) = 0, j=1,2,...,l\]</span></p><p>其中， <span class="math inline">\(x,\alpha,\beta\)</span>,分别代表原始问题和最优问题的解。如果满足上述的约束条件，则原始问题和对偶问题有相同的解。 前三个条件是对<span class="math inline">\(x,\alpha,\beta\)</span>的偏导数为0， 后三个条件是原来问题的约束条件，只有中间的条件是新的约束条件 <span class="math inline">\(\alpha_i c_i(x) = 0\)</span>, 这意味着如果<span class="math inline">\(\alpha_i &gt; 0\)</span>, 那么<span class="math inline">\(c_i(x) = 0\)</span>，否则约束条件就无法得到满足。</p><h3 id="求解原问题">求解原问题</h3><p>支持向量机的优化目标是：</p><p><span class="math display">\[min \quad \frac 1 2 {||w||^2} \\s.t. \quad y_i(w \cdot x_i + b)-1 &gt;= 0, \quad \text{i=1,2,...,n}\]</span></p><p>把约束条件加入优化函数，改写成拉格朗日函数如下：</p><p><span class="math display">\[L(w,\alpha) = \frac 1 2 {||w||^2} - ( \sum_{k=1}^m \alpha_i (y_i(w \cdot x_i + b)-1) )\]</span></p><p>因为没有等式约束条件，所以这里没有<span class="math inline">\(\beta\)</span>, 还有这里是<span class="math inline">\(-\)</span>号，因为凸优化的标准约束是小于等于的形式，而这里却是大于等于的形式。</p><p>所以原来的优化问题可以转化成求解下面的问题：</p><p><span class="math display">\[\mathop{min} \limits_w \quad \mathop{max} \limits_{\alpha} L(w,\alpha)\]</span></p><p>它的对偶问题是:</p><p><span class="math display">\[\mathop{max} \limits_{\alpha} \quad \mathop{min} \limits_w  L(w,\alpha)\]</span></p><p>首先要求解<span class="math inline">\(\mathop{min} \limits_w L(w,\alpha)\)</span>, 这个时候<span class="math inline">\(w,b\)</span>是变量，<span class="math inline">\(\alpha\)</span>看作常量，求解函数 <span class="math inline">\(\frac 1 2 {||w||^2} - ( \sum_{k=1}^m \alpha_i (y_i(w \cdot x_i + b)-1) )\)</span> 的最小值。</p><blockquote><p>多元函数的极值点必在驻点（偏导数为0的点）和偏导数不存在的点中。</p></blockquote><p>要求极值点，首先对每个变量(<span class="math inline">\(w,b\)</span>)求偏导数，令其等于0：</p><p><span class="math display">\[\triangledown_w L(w,b,\alpha) = w - \sum_{i=1}^m \alpha_i y_i x_i = 0 \\\triangledown_b L(w,b,\alpha) = \sum_{i=1}^m \alpha_i y_i = 0\]</span></p><p>把得到的等式带入原来的式子<span class="math inline">\(L(w,b,\alpha)\)</span>中化简,去掉<span class="math inline">\(w,b\)</span>,得到只有<span class="math inline">\(x,y,\alpha\)</span>的表达式：</p><p><span class="math display">\[\mathop{min} \limits_{w,b}  L(w,b,\alpha)  = - \frac 1 2 \sum_{i=1}^m \sum_{j=1}^m \alpha_i \alpha_j y_i y_j(x_i \cdot  x_j) + \sum_{i=1}^m \alpha_i\]</span></p><p>上式中，<span class="math inline">\(w,b\)</span>已经确定了，得到了一个极小值，下一步是求极大值<span class="math inline">\(\mathop{max} \limits_{\alpha} \quad \mathop{min} \limits_{w,b} L(w,b,\alpha)\)</span>, 具体的式子带入，转化成求如下的约束优化问题：</p><p><span class="math display">\[\mathop{max} \limits_{\alpha}  \quad - \frac 1 2 \sum_{i=1}^m \sum_{j=1}^m \alpha_i \alpha_j y_i y_j(x_i \cdot  x_j) + \sum_{i=1}^m \alpha_i \\s.t. \quad \sum_{i=1}^m \alpha_i y_i = 0 \\    \alpha_i &gt;= 0, \quad i=1,2,...,m\]</span></p><p>把求解最大化问题转化成求解最小化问题：</p><p><span class="math display">\[\mathop{min} \limits_{\alpha}  \quad  \frac 1 2 \sum_{i=1}^m \sum_{j=1}^m \alpha_i \alpha_j y_i y_j(x_i \cdot  x_j) - \sum_{i=1}^m \alpha_i \\s.t. \quad \sum_{i=1}^m \alpha_i y_i = 0 \\    \alpha_i &gt;= 0, \quad i=1,2,...,m\]</span></p><p>设该问题的解是<span class="math inline">\(\alpha^*\)</span>, 则原来问题的解是<span class="math inline">\(w^*,b^*\)</span>, KKT条件成立，可以导出三者之间的关系为：</p><p><span class="math display">\[w^* = \sum_{i=1}^m \alpha^* y_i x_i \\b^* = y_i - \sum_{i=1}^m \alpha^* y_i (x_i \cdot x_j)\]</span></p><h3 id="求解支持向量机参数的一般步骤">求解支持向量机参数的一般步骤</h3><p>输入：训练集<span class="math inline">\((x_i,y_i)\)</span>, 训练集合有样本<code>m</code>个，特征数量<code>n</code>个。</p><p>输出：分类决策函数</p><p><strong>最大间隔法</strong></p><ol style="list-style-type: decimal"><li>构造并求解约束最优化问题：</li></ol><p><span class="math display">\[\mathop{min} \limits_{w,b} \quad \frac 1 2 {||w||^2} \\s.t. \quad  y_i(w \cdot x_i + b) - 1 &gt;= 0, \quad i=1,2,...,m\]</span></p><ol start="2" style="list-style-type: decimal"><li><p>求解该问题得到问题的解<span class="math inline">\(w^*,b^*\)</span></p></li><li><p>构造分类平面 <span class="math inline">\(w^* \cdot x + b^* = 0\)</span></p></li></ol><p><strong>对偶学习算法</strong></p><ol style="list-style-type: decimal"><li>构造并求解约束最优化问题：</li></ol><p><span class="math display">\[\mathop{min} \limits_{\alpha} \quad \frac 1 2 \sum_{i=1}^n \sum_{j=1}^n \alpha_i \alpha_j y_i y_j (x_i \cdot x_j) - \sum_{i=1}^n \\s.t. \quad \sum_{i=1}^m \alpha_i y_i = 0 \\    \alpha_i &gt;= 0, \quad i=1,2,...,m\]</span></p><p>求解上面的最优化问题得到 <span class="math inline">\(\alpha^*\)</span>.</p><ol start="2" style="list-style-type: decimal"><li>计算 <span class="math inline">\(w^*\)</span> 和 <span class="math inline">\(b^*\)</span> :</li></ol><p><span class="math display">\[w^* = \sum_{i=1}^n \alpha^* y_i x_i \\b^* = y_i - \sum_{i=1}^n \alpha^*_i y_i (x_i \cdot x_j)\]</span></p><ol start="3" style="list-style-type: decimal"><li>根据第二步求解的参数构造分类决策函数：</li></ol><p><span class="math display">\[w^* \cdot x + b^* = 0\]</span></p><h3 id="一个具体的例子">一个具体的例子</h3><p>有三个训练样本，每个样本有两个特征，<span class="math inline">\(x_1 = (3,3), x_2 = (4,3), x_3 = (1,1)\)</span>, 求支持向量机的分类超平面。其中<span class="math inline">\(x_1,x_2\)</span>是正样本，<span class="math inline">\(x_3\)</span>是负样本。</p><ol style="list-style-type: decimal"><li>用最大间隔法求解</li></ol><p>根据数据构造约束最优化问题：</p><p><span class="math display">\[\mathop{min} \limits_{w,b} \quad \frac 1 2 (w_1^2+w_2^2) \\s.t. \quad 3w_1 + 3w_2 + b &gt;= 1 \\           4w_1 + 4w_2 + b &gt;= 1 \\           -w_1 - w_2 - b &gt;= 1\]</span></p><p>求解此最优化问题得到结果：<span class="math inline">\(w_1 = w_2 = \frac 1 2, b = -2\)</span>, 最后的分类超平面是:</p><p><span class="math display">\[\frac 1 2 x^{(1)} + \frac 1 2 x^{(2)} - 2 = 0\]</span></p><ol start="2" style="list-style-type: decimal"><li>用对偶学习算法求解：</li></ol><p>根据数据构造约束最优化问题：</p><p><span class="math display">\[\mathop{min} \limits_{\alpha} \quad \frac 1 2 (18\alpha_1^2 + 25\alpha_2^2 + 2\alpha_3^2 + 42 \alpha_1 \alpha_2 - 12 \alpha_1 \alpha_3 - 14 \alpha_2 \alpha_3) - (\alpha_1 + \alpha_2 + \alpha_3)  \\s.t. \quad \alpha_1 + \alpha_2 - \alpha_3 = 0 \\           \alpha_i &gt;= 0, \quad i=1,2,3\]</span></p><p>求解最优化问题得到结果：<span class="math inline">\(\alpha_1 = \frac 1 4, \alpha_2 = 0, \alpha_3 = \frac 1 4\)</span>.</p><p>则可以得到 <span class="math inline">\(w_1^* = = w_2^* = \frac 1 2\)</span>, <span class="math inline">\(b^* = -2\)</span>.</p><p>最后的分类超平面为：</p><p><span class="math display">\[\frac 1 2 x^{(1)} + \frac 1 2 x^{(2)} - 2 = 0\]</span></p><p>比较最大间隔算法和对偶学习算法可以看出，对偶学习算法更容易求解，因为其约束条件变得更少，更容易得到不同变量之间的转换关系。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【支持向量机】【函数间隔】【几何间隔】【KTT】&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="机器学习" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ML" scheme="http://ff120.github.io/hexoblog/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>机器学习-第三章-朴素贝叶斯</title>
    <link href="http://ff120.github.io/hexoblog/2017/11/04/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    <id>http://ff120.github.io/hexoblog/2017/11/04/技术/机器学习/机器学习-第三章-朴素贝叶斯/</id>
    <published>2017-11-04T01:04:49.000Z</published>
    <updated>2019-03-28T00:54:57.585Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    <summary type="html">
    
      
      
        

      
    
    </summary>
    
      <category term="技术" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="机器学习" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ML" scheme="http://ff120.github.io/hexoblog/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>机器学习-第二章-决策树</title>
    <link href="http://ff120.github.io/hexoblog/2017/11/04/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <id>http://ff120.github.io/hexoblog/2017/11/04/技术/机器学习/机器学习-第二章-决策树/</id>
    <published>2017-11-04T01:04:25.000Z</published>
    <updated>2019-03-28T00:54:57.607Z</updated>
    
    <content type="html"><![CDATA[<p>【决策树】【ID3】【C4.5】</p><a id="more"></a><h2 id="模型">模型</h2><p>一棵树，每次分支都按照某个属性确定分到哪一个分支，直到所有的数据集都被分到正确的类别上。</p><h2 id="策略">策略</h2><p>主要涉及使用什么指标划分</p><p>如何剪枝避免过拟合</p><h2 id="方法">方法</h2><p>ID3</p><p>C4.5</p><p>CART</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【决策树】【ID3】【C4.5】&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="机器学习" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ML" scheme="http://ff120.github.io/hexoblog/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>机器学习-第一章-逻辑回归</title>
    <link href="http://ff120.github.io/hexoblog/2017/11/04/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    <id>http://ff120.github.io/hexoblog/2017/11/04/技术/机器学习/机器学习-第一章-逻辑回归/</id>
    <published>2017-11-04T01:04:05.000Z</published>
    <updated>2019-03-28T00:54:57.537Z</updated>
    
    <content type="html"><![CDATA[<p>【逻辑回归】</p><a id="more"></a><h2 id="模型">模型</h2><p>令 <span class="math inline">\(\theta = (w_1,w_2,...,w_n,b)\)</span>, <span class="math inline">\(x = (x_1,x_2,...,x_n,1)\)</span>,则有： <span class="math display">\[\theta^T \cdot x = w_1x_1+x_2x_2+...+w_nx_n+b\]</span></p><p>逻辑回归要训练得到的函数模型是：</p><p><span class="math display">\[h_\theta(x) = f(\theta^T \cdot x)\]</span></p><p>其中<code>f</code>是下面的函数：</p><p><span class="math display">\[f(z) = \frac 1 {1+e^{-z}}\]</span></p><p>函数<code>f</code>的图像如下图所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plot[<span class="number">1.0</span> / (<span class="number">1</span> + E^(-x)), &#123;x, <span class="number">-10</span>, <span class="number">10</span>&#125;]</span><br></pre></td></tr></table></figure><div class="figure"><img src="softmax.png" alt="f(z)"><p class="caption">f(z)</p></div><p><span class="math inline">\(h_\theta(x)\)</span> 的结果是<code>(0,1)</code>，含义是类别为正类别的概率; <span class="math inline">\(\theta\)</span>的含义是模型的参数.</p><p>算法的目标是在已知<span class="math inline">\((x_1,x_2,...x_n)\)</span> 和对应的 <span class="math inline">\(y\)</span> 的若干个样本的情况下，求解出<span class="math inline">\((w_1,w_2,...,w_n,b)\)</span>这些参数，使得损失函数最小。</p><blockquote><p>Wolfram Mathematica 是一个专业的科学计算软件，使用它可以非常方便的绘制出函数的图形。<code>Plot[1.0 / (1 + E^(-x)), {x, -10, 10}]</code>就是绘制出上面的函数图形的命令。</p></blockquote><h2 id="策略">策略</h2><p>逻辑回归使用的损失函数是：</p><p><span class="math display">\[cost(h_\theta(x),y) = \begin{cases}                      -log(h_\theta(x)) &amp; \text{if y = 1} \\                      -log(1-h_\theta(x)) &amp;  \text{if y = 0}                      \end{cases}\]</span></p><p>其中，<span class="math inline">\(h_\theta(x)\)</span>就是模型预测的结果，<span class="math inline">\(y\)</span>是实际的标签，取值是<span class="math inline">\(0，1\)</span>.</p><p>当<span class="math inline">\(y=1\)</span>时，<span class="math inline">\(h_\theta(x)\)</span>接近1的时候，损失函数<span class="math inline">\(-log(h_\theta(x))\)</span>接近0，而当<span class="math inline">\(h_\theta(x)\)</span>接近0的时候，损失函数是接近正无穷的。其对应的关系如下图所示：</p><div class="figure"><img src="hox.png"></div><p>当<span class="math inline">\(y = 0\)</span>时，<span class="math inline">\(h_\theta(x)\)</span>接近0的时候，损失函数<span class="math inline">\(-log(1-h_\theta(x))\)</span>接近0，而当<span class="math inline">\(h_\theta(x)\)</span>接近1的时候，损失函数<span class="math inline">\(-log(1-h_\theta(x))\)</span>接近正无穷。其对应的关系如下图所示：</p><div class="figure"><img src="hox2.png"></div><p>分段函数不利于表达，把上面的<code>cost</code>函数写成统一的格式如下：</p><p><span class="math display">\[cost(h_\theta(x),y) = - ( y \times log(h_\theta(x))  +  (1-y) \times log(1-h_\theta(x)) )\]</span></p><p>对于一个有<code>m</code>个样本的训练集，训练集上的损失为：</p><p><span class="math display">\[J(\theta) = - \frac 1 m \sum_{i=1}^{m} (y^{(i)} \times log(h_\theta(x^{(i)})) + (1-y^{(i)}) \times log(1-h_\theta(x^{(i)})))\]</span></p><p>其中，<span class="math inline">\(i\)</span>表示训练集中的第<span class="math inline">\(i\)</span>个样本，<span class="math inline">\(x\)</span>表示特征向量<span class="math inline">\((x_1,x_2,...,x_n,x_{n+1})\)</span>, <span class="math inline">\(y\)</span> 表示实际的标签，取值<span class="math inline">\(0,1\)</span>。</p><h2 id="算法">算法</h2><p>找到一种算法，在已经知道<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>的情况下，求解出能够使得<span class="math inline">\(J(\theta)\)</span>最小的<span class="math inline">\(\theta\)</span>的值，具体的就是<span class="math inline">\((w_1,w_2,...,w_n,b)\)</span>的值。</p><h3 id="梯度下降法">梯度下降法</h3><p><strong>梯度</strong>， 函数对每一个参数求偏导数，偏导数组合成向量，向量的方向就是梯度的方向，函数在梯度的方向上升最快，在梯度的反方向下降最快。</p><p>使用梯度下降法求解参数的步骤：</p><ol style="list-style-type: decimal"><li>初始化参数。</li></ol><p>首先给参数一个初始值<span class="math inline">\(\theta = \theta^0\)</span>, 定义一个步长<span class="math inline">\(\alpha\)</span>,就是每次要在梯度的方向上移动的距离; 定义一个终止条件<span class="math inline">\(\epsilon\)</span>，确定算法在什么条件下终止。（一般是看参数更新前后两者的差值，小于某一个很小的数字，就可以结束算法）</p><ol start="2" style="list-style-type: decimal"><li>计算梯度：</li></ol><p><span class="math display">\[\frac \partial {\partial\theta_j} J(\theta_1,\theta_2,...,\theta_{n+1})) = \frac 1 m   \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})x\]</span></p><p>其中，<span class="math inline">\(j \in (1,n+1)\)</span> 表示第<code>j</code>个参数， <span class="math inline">\(i \in (1,m)\)</span> 表示第<code>m</code>个样本。</p><blockquote><p>这里涉及到函数的求导，先来复习一下函数的链式求导法则： <span class="math display">\[\frac {dx} {dy} = \frac {dx} {dz} \times \frac {dz} {dy}\]</span> 举个例子： sigmoid 函数的导数是： <span class="math display">\[y = f(z) = \frac 1 {1 + e^{-z}}\]</span> 它的导数可以很容易的求出来，还可以把它表示成y的乘积的形式。 <span class="math display">\[\frac {dy} {dz} = \frac {e^{-z}} {1+e^{-z}} = y(1-y)\]</span></p></blockquote><p>现在来求损失函数的对每一个参数<span class="math inline">\(\theta_i\)</span>的导数：</p><p><span class="math display">\[\frac {\partial cos(h_\theta,y)} {\partial \theta} = (h_\theta(x) - y) \cdot x\]</span></p><p>假设一共有<code>m</code>个训练样本,<span class="math inline">\(i \in (1,m)\)</span>, 一共有<code>n+1</code>个参数，<span class="math inline">\(j \in (1,n+1)\)</span>, 则每个参数的导数如下：</p><p><span class="math display">\[\frac {\partial cos(h_\theta(x),y)}  {\theta_j}   =  \frac 1 m   \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)}))  x_j^{(i)}\]</span></p><p>根据上面的公式，初始化<span class="math inline">\(\theta^0\)</span>之后，可以利用整个训练集的数据<span class="math inline">\((x^{(i)},y^{(i)}),i \in (1,m)\)</span>, 计算出一个梯度向量<span class="math inline">\((\Delta \theta_1,\Delta \theta_2,...,\Delta \theta_{n+1})\)</span>.</p><ol start="3" style="list-style-type: decimal"><li>更新参数</li></ol><p><span class="math display">\[\theta^{i+1} = \theta^i + \alpha \Delta \theta^i\]</span></p><p>其中，<span class="math inline">\(\theta^i\)</span>表示第<span class="math inline">\(i\)</span>次迭代的时候的参数取值，<span class="math inline">\(\Delta \theta^i\)</span>表示第二步计算出来的梯度，<span class="math inline">\(\alpha\)</span>表示 <strong>学习率</strong>，是控制梯度下降的每步大小的一个超参数，需要自己设置。</p><ol start="4" style="list-style-type: decimal"><li>比较更新前后的参数的变化</li></ol><p><span class="math display">\[\epsilon = \sum_{i=1}^{n+1} ( \theta^{i+1} - \theta^{i} )\]</span></p><p>如果<span class="math inline">\(\epsilon\)</span>的值小于预先确定的结束条件，算法结束，最后的<span class="math inline">\(\theta\)</span>就是要求解的参数，如果<span class="math inline">\(\epsilon\)</span>大于结束条件，则转到第三步继续迭代，直到满足结束条件为止。</p><blockquote><p>梯度下降的几种策略： 上面的例子中，每一次参数的更新，我们是使用训练集中的所有样本计算的梯度，这样做每次计算出来的梯度比较准确，但是当训练集合非常大的时候，每次的计算开销就很大。 <span class="math display">\[\frac {\partial cos(h_\theta(x),y)}  {\theta_j}   =  \frac 1 m   \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)}))  x_j^{(i)}\]</span> 可以看出，求解的方法是每个样本计算出一个梯度，然后求和取平均值作为最后的梯度。</p><p><strong>随机梯度下降法</strong></p><p>随机梯度下降法就是把上面的式子中的求和符号去掉，每次只使用一个样本计算梯度，计算出来就更新一次参数，然后再在更新之后的参数上，利用下一个样本计算梯度，这样每次更新的速度都很快，但是只是利用一个样本计算出来的梯度可能根本就不是函数上升最快的方向，所以收敛的速度不一定快。</p><p><strong>批量梯度下降法</strong></p><p>这种方法就综合上面两种方法的利弊提出的，每次使用若干个（一般是10个）样本计算梯度，计算完就更新参数，然后在更新的参数的基础上利用另外的10个样本计算下一个梯度方向，直到算法结束。</p></blockquote><h3 id="梯度下降法算法调优">梯度下降法算法调优</h3><p>通过梯度下降法的求解过程，我们知道要设置三个重要的参数，一个是<span class="math inline">\(\theta^0\)</span>, 初始参数的值；一个是<span class="math inline">\(\alpha\)</span>,学习率；一个是算法停止条件，<span class="math inline">\(\epsilon\)</span>.</p><p>如果要优化的函数是凸函数（只有一个极值点），<span class="math inline">\(\theta^0\)</span> 的值不会影响最终的结果，但是会影响算法结束的速度；如果优化的函数有多个极值点，<span class="math inline">\(\theta^0\)</span> 的初始值会影响最后的结果。这个时候，一个解决的办法是随机选择多次初始点，分别计算出极值点，选择极值点最小的那个初始点作为算法的初始点。 理论上如果选择足够多的初始点(并且是随机选择)，一定可以找到真正的极值点。</p><p><span class="math inline">\(\alpha\)</span> 的选择也十分重要，如果过小，算法迭代次数过多，会结束的非常慢；如果过大，很可能会越过极值点，找不到正确的结果。</p><p><span class="math inline">\(\epsilon\)</span> 的选择影响算法的终止条件，如果过大，可能还没有达到极值点就结束了，如果过小，可能导致算法运行时间过长。</p><p>除此之外，使用梯度下降法时候，特征一般要归一化处理，这是因为，如果不同的维度取值范围差异很大的话，算法的迭代效率就很差，归一化的方法是计算数据的均值和方差，然后每个特征减去均值之后除以标准差</p><p>使用随机梯度下降的时候，如果数据集不是线性可分的(存在噪声的情况)，可能会造成梯度来回波动的情况，可以下面的方式优化：</p><blockquote><ul><li>在每次迭代时，调整更新步长<span class="math inline">\(\alpha\)</span>的值。随着迭代的进行，<span class="math inline">\(\alpha\)</span>越来越小，这会缓解系数的高频波动（也就是每次迭代系数改变得太大，跳的跨度太大）。当然了，为了避免<span class="math inline">\(\alpha\)</span>随着迭代不断减小到接近于0（这时候，系数几乎没有调整，那么迭代也没有意义了），我们约束<span class="math inline">\(\alpha\)</span>一定大于一个稍微大点的常数项.</li></ul></blockquote><blockquote><ul><li>每次迭代，改变样本的优化顺序。也就是随机选择样本来更新回归系数。这样做可以减少周期性的波动，因为样本顺序的改变，使得每次迭代不再形成周期性。</li></ul></blockquote><h3 id="牛顿法">牛顿法</h3><h3 id="拟牛顿法">拟牛顿法</h3><h2 id="对模型的理解">对模型的理解</h2><p>理解一个模型的含义有时候会很有帮助，但不是所有的模型都有确切的含义，幸运的是，逻辑回归模型有一些很好的解释便于理解实际含义。</p><p><strong>对数几率</strong></p><p>在逻辑回归模型中，<span class="math inline">\(\theta^T \cdot x\)</span>的值是有含义的。假设一件事发生的概率是<span class="math inline">\(P\)</span>,不发生的概率是<span class="math inline">\(1-P\)</span>,定义一件事发生的<strong>几率</strong> 为发生的概率和不发生的概率的比值：<span class="math inline">\(p / (1-p)\)</span>. 定义一件事发生的对数几率是：<span class="math inline">\(log(p / (1-p))\)</span>.</p><p>逻辑回归的输出<span class="math inline">\(h_\theta(x)\)</span>可以看作分类为1的概率：</p><p><span class="math display">\[P(Y=1|X) = h_\theta(x) = \frac 1 {1 + e^{-\theta^T \cdot x}}\]</span></p><p>记A表示分类结果是1这一时间，则A的对数几率是：</p><p><span class="math display">\[logit(A) = log(\frac {h_\theta(x)} {1-h_\theta(x)}) = \theta^T = w_1 x_1+ x_2 x_2 + ... + w_n x_n + b\]</span></p><p><span class="math inline">\(\theta^T \cdot x\)</span> 的含义其实是事件A发生的对数几率，取对数并不影响函数原来的极值点，可以认为是原来的含义。所以可以认为<span class="math inline">\(\theta^T \cdot x\)</span> 度量了事件A发生的几率。 而原来的<span class="math inline">\(h_\theta(x)\)</span> 表示的事件A发生的概率。</p><p><strong>最大似然</strong></p><p>最大似然的思想是： 选择使得已经发生的事件概率取得最大值的 那些参数。 例如<span class="math inline">\(\theta\)</span>表示箱子的编号，1号箱子里面有1个红球，9个白球，2号箱子里面有1个白球，9个红球；如果任意选择一个箱子，任意取一个球，发现取得的是红球，那么根据最大似然的原理<span class="math inline">\(\theta = 2\)</span>,因为如果是2号箱子，取得红球的概率是0.9， 如果是1号箱子，取得红球的概率是0.1.</p><p>把训练集中的出现的样本作为一次实验，那么出现这种实验结果的概率是：</p><p><span class="math display">\[P(Y=1|X)^{y_i} (1-P(Y=0|X))^{1-y_i}\]</span></p><p>所有的<code>m</code>个样本出现的概率是每一个样本出现的概率的乘积：</p><p><span class="math display">\[L(\theta) = \prod_{i=1}^m (h_\theta(x))^{y_i} (1-h_\theta(x))^{1-y_i}\]</span></p><p>用最大似然的观点，逻辑回归转化成求<span class="math inline">\(L(\theta)\)</span>最大的时候，<span class="math inline">\(\theta\)</span>的值。求解该函数的极大值，就是求解负函数的极小值。对<span class="math inline">\(\theta\)</span>求导之后会发现，最优化函数和上面提到的用损失函数表示的是一样的。所以求解的方法依然是梯度下降法。</p><h2 id="编写算法python">编写算法（Python）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Sat Nov 04 20:47:47 2017</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: FF120</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math <span class="keyword">as</span> mm</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogisticRegression</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    theta : 初始的参数选择(n+1_features),最后一个参数是截距b</span></span><br><span class="line"><span class="string">    alpha : 学习率</span></span><br><span class="line"><span class="string">    epsilon : 终止条件</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,theta,alpha,epsilon)</span>:</span></span><br><span class="line">        self.theta = theta</span><br><span class="line">        self.alpha = alpha</span><br><span class="line">        self.epsilon = epsilon</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(z)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span> / (<span class="number">1</span> + mm.exp(-z))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_theta</span><span class="params">(self,X,y)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        使用所有训练数据完成一次参数的更新过程</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        返回值</span></span><br><span class="line"><span class="string">        epsilon: 本次更新的梯度和上次的差异</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m,n = X.shape</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n+<span class="number">1</span>): <span class="comment"># 第j个参数的偏移</span></span><br><span class="line">            delta_theta = np.zeros((<span class="number">1</span>,n+<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span> i,line_x,line_y <span class="keyword">in</span> enumerate(zip(X,y)):</span><br><span class="line">                line_x = np.array(list(line_x) + [<span class="number">1</span>]) <span class="comment"># 添加x_n+1</span></span><br><span class="line">                theta = np.array(self.theta)</span><br><span class="line">                delta_theta[i] += self.sigmoid(np.dot(theta.T,line_x) - line_y) * (line_x[j])</span><br><span class="line">                </span><br><span class="line">            delta_theta = delta_theta*(<span class="number">1.0</span> / m)</span><br><span class="line">            epsilon = np.sum(np.absolute(self.alpha *delta_theta))</span><br><span class="line">            self.theta = self.theta + self.alpha * delta_theta</span><br><span class="line">            <span class="keyword">return</span> epsilon</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fix</span><span class="params">(self,X,y)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        X : (n_samples,n_featues) 训练集合</span></span><br><span class="line"><span class="string">        y : (n_samples,) 训练集对应的标签</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            epsilon = self.update_theta(X,y)</span><br><span class="line">            <span class="keyword">if</span> epsilon &lt; self.epsilon:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self,X)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        X : (n_samples.n_features) 训练集合</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> X.shape[<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            y = self.sigmoid( np.dot(self.theta.T,X) )</span><br><span class="line">            <span class="keyword">if</span> y &gt;= <span class="number">0.5</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> y &lt; <span class="number">0.5</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【逻辑回归】&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="机器学习" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ML" scheme="http://ff120.github.io/hexoblog/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>机器学习-绪论-基本概念</title>
    <link href="http://ff120.github.io/hexoblog/2017/11/04/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%BB%AA%E8%AE%BA-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://ff120.github.io/hexoblog/2017/11/04/技术/机器学习/机器学习-绪论-基本概念/</id>
    <published>2017-11-04T01:03:50.000Z</published>
    <updated>2019-03-28T00:54:57.740Z</updated>
    
    <content type="html"><![CDATA[<h2 id="统计学习方法的三要素">统计学习方法的三要素</h2><blockquote><p>方法 = 模型 + 策略 + 算法</p></blockquote><p><strong>模型</strong> 是方法依据的数学原理 <strong>策略</strong> 是使用哪种损失函数或者代价函数 <strong>算法</strong> 是如何如何求解问题</p><p>一个模型可以有多种策略(例如使用不同的损失函数度量损失的程度)， 一种策略可以有多种不同的方法(例如可以用梯度下降法，最小二乘法求解)。</p><h2 id="常用的模型">常用的模型</h2><h2 id="常用的损失函数">常用的损失函数</h2><h3 id="损失函数">0-1 损失函数</h3><p><span class="math display">\[L(Y,f(X)) = \begin{cases}              1, &amp; { Y \neq f(X)} \\              0, &amp; { Y = f(X) }              \end{cases}\]</span></p><p><code>Y</code>表示实际的值，<code>f(X)</code>表示通过模型预测出来的值，0-1损失就是当预测正确的时候损失是0，预测错误的时候损失是1.</p><h3 id="绝对值损失函数">绝对值损失函数</h3><p><span class="math display">\[L(Y,f(X) = |Y - f(X)|\]</span></p><h3 id="平方损失函数">平方损失函数</h3><p><span class="math display">\[L(Y,f(X)) = (Y - f(X))^2\]</span></p><h3 id="对数损失函数">对数损失函数</h3><p><span class="math display">\[L(Y,P(Y|X)) = -logP(Y|X)\]</span></p><h2 id="常用的算法">常用的算法</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;统计学习方法的三要素&quot;&gt;统计学习方法的三要素&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;方法 = 模型 + 策略 + 算法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;模型&lt;/strong&gt; 是方法依据的数学原理 &lt;strong&gt;策略&lt;/st
      
    
    </summary>
    
      <category term="技术" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="机器学习" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ML" scheme="http://ff120.github.io/hexoblog/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>SQL</title>
    <link href="http://ff120.github.io/hexoblog/2017/11/02/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/"/>
    <id>http://ff120.github.io/hexoblog/2017/11/02/技术/数据库/SQL/</id>
    <published>2017-11-02T06:15:52.000Z</published>
    <updated>2019-03-28T00:54:55.839Z</updated>
    
    <content type="html"><![CDATA[<p>基于MySQL的语法说明数据库查询的一些操作。</p><p>在<code>test</code>数据库中创建一个<code>user</code>表，执行一些查询操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">6Li Xiao102017-11-01</span><br><span class="line">7Li Xiao202017-11-02</span><br><span class="line">8Li Xiao102017-11-03</span><br><span class="line">9Zhao Hi202016-10-11</span><br><span class="line">10Zhao Hi202016-10-12</span><br><span class="line">11Zhao Hi202016-10-13</span><br><span class="line">12Kao Ha102016-03-01</span><br><span class="line">13Kao Ha202016-03-02</span><br><span class="line">14Cao Pi502016-09-11</span><br><span class="line">15Cao Pi102016-09-12</span><br></pre></td></tr></table></figure><a id="more"></a><ol style="list-style-type: decimal"><li>切换数据库</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure><ol start="2" style="list-style-type: decimal"><li>显示数据库中的表</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure><ol start="3" style="list-style-type: decimal"><li>如果已经存在<code>user</code>表，删除它</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><ol start="4" style="list-style-type: decimal"><li>创建表</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    price <span class="built_in">numeric</span>(<span class="number">20</span>,<span class="number">2</span>) <span class="keyword">default</span> <span class="number">0.0</span>,</span><br><span class="line">    update_time <span class="built_in">date</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>创建表的时候基本语法是： 列名 类型 [约束]，</p><p>约束是可选的，可用的约束有：</p><ul><li>unique 唯一值</li><li>not null 不能为空</li><li>default 默认值 添加默认值</li><li>check 满足某一个条件</li><li>primary key 指定为主键</li><li>foreign key 指定外键</li></ul><p>只约束某一列的时候，可以直接写在某个列上，如果涉及多个列，要写在最后。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    price <span class="built_in">numeric</span>(<span class="number">20</span>,<span class="number">2</span>) <span class="keyword">default</span> <span class="number">0.0</span>,</span><br><span class="line">    update_time <span class="built_in">date</span>,</span><br><span class="line">    <span class="keyword">check</span> (<span class="keyword">id</span> &gt; <span class="number">0</span> <span class="keyword">and</span> price &gt; <span class="number">0</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="5" style="list-style-type: decimal"><li>插入值</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">name</span>, price , update_time) <span class="keyword">values</span> (<span class="string">'Li Xiao'</span>,<span class="number">10.0</span>,<span class="string">'2017-11-01'</span>);</span><br></pre></td></tr></table></figure><p>指定自动增长的列和没有设置非空约束的列可以没有对应的值，会自动添加对应的数据。指定非空的列在插入的时候必须有值。</p><ol start="6" style="list-style-type: decimal"><li>更新值</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> update_time = <span class="keyword">curdate</span>() <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'Li Xiao'</span>;</span><br></pre></td></tr></table></figure><ol start="7" style="list-style-type: decimal"><li>删除值</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'Li Xiao'</span>;</span><br></pre></td></tr></table></figure><p>完整的创建数据库和插入需要的数据的语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  price <span class="built_in">numeric</span> <span class="keyword">default</span> <span class="number">0.0</span>,</span><br><span class="line">  <span class="built_in">date</span> <span class="built_in">date</span> </span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">name</span>,price,<span class="built_in">date</span>) <span class="keyword">values</span> (<span class="string">'Li Xiao'</span>,<span class="number">10.2</span>,<span class="keyword">curdate</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">name</span>,price,<span class="built_in">date</span>) <span class="keyword">values</span> (<span class="string">'Li Xiao'</span>,<span class="number">80.0</span>,<span class="keyword">curdate</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">name</span>,price,<span class="built_in">date</span>) <span class="keyword">values</span> (<span class="string">'Li Xiao'</span>,<span class="number">10.0</span>,<span class="keyword">curdate</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">name</span>,price,<span class="built_in">date</span>) <span class="keyword">values</span> (<span class="string">'Zhao Hi'</span>,<span class="number">20.0</span>,<span class="string">'2016-10-10'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">name</span>,price,<span class="built_in">date</span>) <span class="keyword">values</span> (<span class="string">'Zhao Hi'</span>,<span class="number">20.0</span>,<span class="string">'2016-6-10'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">name</span>,price,<span class="built_in">date</span>) <span class="keyword">values</span> (<span class="string">'Zhao Hi'</span>,<span class="number">20.0</span>,<span class="string">'2016-3-6'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">name</span>,price,<span class="built_in">date</span>) <span class="keyword">values</span> (<span class="string">'Kao Ha'</span>,<span class="number">10.0</span>,<span class="string">'2016-3-5'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">name</span>,price,<span class="built_in">date</span>) <span class="keyword">values</span> (<span class="string">'Kao Ha'</span>,<span class="number">20.0</span>,<span class="string">'2016-3-7'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">name</span>,price,<span class="built_in">date</span>) <span class="keyword">values</span> (<span class="string">'Cao Pi'</span>,<span class="number">50.0</span>,<span class="string">'2016-9-10'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">name</span>,price,<span class="built_in">date</span>) <span class="keyword">values</span> (<span class="string">'Cao Pi'</span>,<span class="number">10.0</span>,<span class="string">'2016-2-10'</span>);</span><br></pre></td></tr></table></figure><ol start="8" style="list-style-type: decimal"><li>查询</li></ol><p>每个人的总额</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">sum</span>(price) <span class="keyword">as</span> total <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure><p>每个人的记录数量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">count</span>(*) <span class="keyword">as</span> nums <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure><p>每个人的平均值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">sum</span>(price) / <span class="keyword">count</span>(*) <span class="keyword">as</span> <span class="keyword">avg</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure><p>总的金额</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(price) <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p>每个人每次得到的钱占总共金额的百分比</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, price / (<span class="keyword">select</span> <span class="keyword">sum</span>(price) <span class="keyword">from</span> <span class="keyword">user</span>) <span class="keyword">as</span> <span class="keyword">percent</span> <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p>每个人得到的钱的和占总金额的百分比：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">sum</span>(price) / (<span class="keyword">select</span> <span class="keyword">sum</span>(price) <span class="keyword">from</span> <span class="keyword">user</span>) <span class="keyword">as</span> <span class="keyword">percent</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure><p>输出记录数量大于2且总金额大于90的人的姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">having</span> <span class="keyword">count</span>(*) &gt; <span class="number">2</span> <span class="keyword">and</span> <span class="keyword">sum</span>(price) &gt; <span class="number">90</span>;</span><br></pre></td></tr></table></figure><p>输出2016年每个人得到的金额 占 2016 年总金额的百分比</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">sum</span>(price) / (<span class="keyword">select</span> <span class="keyword">sum</span>(price) <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="built_in">date</span>) = <span class="number">2016</span>) <span class="keyword">as</span> <span class="keyword">percent</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="built_in">date</span>) = <span class="number">2016</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure><p>输出每一年 每个人得到的总金额 占当年总金额的百分比</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 获得每个人在一年总的收入金额</span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">sum</span>(price) <span class="keyword">as</span> price ,<span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="built_in">date</span>) <span class="keyword">as</span> <span class="keyword">year</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>)；</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 获得每一年总的金额</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="built_in">date</span>) <span class="keyword">as</span> <span class="keyword">year</span> , <span class="keyword">sum</span>(price) <span class="keyword">as</span> <span class="keyword">sum</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="built_in">date</span>);</span><br><span class="line">3. 两个表连接</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> a.name, a.price, b.sum, a.year <span class="keyword">from</span> ((<span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">sum</span>(price) <span class="keyword">as</span> price ,<span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="built_in">date</span>) <span class="keyword">as</span> <span class="keyword">year</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>)) <span class="keyword">as</span> a, (<span class="keyword">select</span> <span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="built_in">date</span>) <span class="keyword">as</span> <span class="keyword">year</span> , <span class="keyword">sum</span>(price) <span class="keyword">as</span> <span class="keyword">sum</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="built_in">date</span>)) <span class="keyword">as</span> b <span class="keyword">where</span> a.year = b.year;</span><br><span class="line"></span><br><span class="line">4. 查询连接之后的表得到结果</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, price / <span class="keyword">sum</span> <span class="keyword">as</span> <span class="keyword">percent</span> <span class="keyword">from</span> (<span class="keyword">select</span> a.name, a.price, b.sum, a.year <span class="keyword">from</span> ((<span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">sum</span>(price) <span class="keyword">as</span> price ,<span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="built_in">date</span>) <span class="keyword">as</span> <span class="keyword">year</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>)) <span class="keyword">as</span> a, (<span class="keyword">select</span> <span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="built_in">date</span>) <span class="keyword">as</span> <span class="keyword">year</span> , <span class="keyword">sum</span>(price) <span class="keyword">as</span> <span class="keyword">sum</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="built_in">date</span>)) <span class="keyword">as</span> b <span class="keyword">where</span> a.year = b.year) <span class="keyword">as</span> tmp</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于MySQL的语法说明数据库查询的一些操作。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;test&lt;/code&gt;数据库中创建一个&lt;code&gt;user&lt;/code&gt;表，执行一些查询操作。&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;6	Li Xiao	10	2017-11-01&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7	Li Xiao	20	2017-11-02&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8	Li Xiao	10	2017-11-03&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9	Zhao Hi	20	2016-10-11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10	Zhao Hi	20	2016-10-12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11	Zhao Hi	20	2016-10-13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12	Kao Ha	10	2016-03-01&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13	Kao Ha	20	2016-03-02&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14	Cao Pi	50	2016-09-11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15	Cao Pi	10	2016-09-12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数据库" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="SQL" scheme="http://ff120.github.io/hexoblog/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>KNN with C++</title>
    <link href="http://ff120.github.io/hexoblog/2017/10/15/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/KNN-with-C/"/>
    <id>http://ff120.github.io/hexoblog/2017/10/15/技术/机器学习/KNN-with-C/</id>
    <published>2017-10-15T14:27:57.000Z</published>
    <updated>2019-03-28T00:54:57.473Z</updated>
    
    <content type="html"><![CDATA[<p>KNN 算法步骤：</p><ul><li>存储训练集的特征和标签，确定K</li><li>预测一个未知的样本的时候，计算该样本到每一个训练集中的样本的距离，取前K个距离的最小值</li><li>在前K个最小值中选择标签出现次数最大的那个，作为预测结果</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KNN</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> feature_num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; trainSet;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; trainLabel;</span><br><span class="line">    <span class="comment">// 特征向量之间的距离，修改这里使用不同的距离度量</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">distance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;a, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="comment">//  返回两个点的距离</span></span><br><span class="line">        <span class="keyword">if</span>(a.size() != b.size()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.size();i++)&#123;</span><br><span class="line">            sum += (a[i] - b[i]) * (a[i] - b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> dis = <span class="built_in">sqrt</span>(sum);</span><br><span class="line">        <span class="keyword">return</span> dis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    KNN() : k(<span class="number">3</span>) &#123;&#125;</span><br><span class="line">    <span class="comment">// 创建类的时候保存训练集的特征和标签数据</span></span><br><span class="line">    KNN(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; features,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; labels)&#123;</span><br><span class="line">        <span class="keyword">int</span> samples = features.size();</span><br><span class="line">        <span class="keyword">if</span>(samples != labels.size())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;trainSet = features;</span><br><span class="line">        <span class="keyword">this</span>-&gt;trainLabel = labels;</span><br><span class="line">        <span class="keyword">if</span>(!features.empty()) feature_num = features[<span class="number">0</span>].size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预测一个测试样例的标签</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">predict</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; test)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(test.size() != <span class="keyword">this</span>-&gt;feature_num) <span class="keyword">throw</span> <span class="keyword">new</span> exception();</span><br><span class="line">        <span class="comment">// 求test到训练集合中所有点的距离，找出距离最小的K个值</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">double</span>,<span class="keyword">int</span>&gt;,<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">double</span>,<span class="keyword">int</span>&gt;&gt;,lessThan&gt; maxHeap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;trainSet.size();i++)&#123;</span><br><span class="line">            <span class="keyword">double</span> dis = <span class="keyword">this</span>-&gt;distance(trainSet[i],test);</span><br><span class="line">            <span class="keyword">if</span>(maxHeap.size() &lt; <span class="keyword">this</span>-&gt;k)&#123;</span><br><span class="line">                maxHeap.push(make_pair(dis,trainLabel[i]));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(dis &lt; maxHeap.top().first)&#123;</span><br><span class="line">                    maxHeap.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 统计K个点的类别标签，找到出现次数最多的那个标签</span></span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cc; <span class="comment">// 统计每个类别从出现的次数 kye</span></span><br><span class="line">        <span class="keyword">while</span>(!maxHeap.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(cc.count(maxHeap.top().second) == <span class="number">0</span>)&#123;</span><br><span class="line">                cc[maxHeap.top().second] = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cc[maxHeap.top().second]++;</span><br><span class="line">            &#125;</span><br><span class="line">            maxHeap.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxV = INT32_MIN;</span><br><span class="line">        <span class="keyword">int</span> label = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter= cc.begin();iter != cc.end(); iter++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(iter-&gt;second &gt; maxV)&#123;</span><br><span class="line">                maxV = iter-&gt;second;</span><br><span class="line">                label = iter-&gt;first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> label;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 预测一个测试样例的标签</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">predict</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; test, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;predict(test);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Kmeans 算法步骤</p><ul><li>在数据集中随机选择K个点</li><li>计算所有的点到K个中心点的距离，距离哪个中心点近，就标记成哪个中心点所属的列别</li><li>计算每个团的新的中心，</li><li>计算新的中心和上次的中心的差距</li><li>如果差距大，就继续循环，否则退出</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> MINVALUE = <span class="number">0.01</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">feature</span>&#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; v;</span><br><span class="line">    <span class="keyword">int</span> label; <span class="comment">// 属于哪一个聚类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kmeans</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 从[start,end] 产生 count 个随机数</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; random(<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> count)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">distance</span><span class="params">(feature &amp;a, feature &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> cycle = <span class="number">1000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cluster</span><span class="params">(<span class="built_in">vector</span>&lt;feature&gt; dataset)</span></span>&#123;</span><br><span class="line">         <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; random3 = random(<span class="number">0</span>,dataset.size()<span class="number">-1</span>,<span class="number">3</span>);</span><br><span class="line">         <span class="built_in">vector</span>&lt;feature&gt; centers;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;random3.size();i++)&#123;</span><br><span class="line">             dataset[i].label = i;</span><br><span class="line">             centers.push_back(dataset[i]);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">while</span>(cycle--) &#123;</span><br><span class="line">             <span class="comment">// 标记所有点的所属聚簇</span></span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dataset.size(); i++) &#123;</span><br><span class="line">                 <span class="keyword">double</span> minDistance = INT32_MAX;</span><br><span class="line">                 <span class="keyword">int</span> label = <span class="number">-1</span>;</span><br><span class="line">                 <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; random3.size(); j++) &#123;</span><br><span class="line">                     <span class="keyword">double</span> dis = distance(dataset[i], dataset[random3[j]]);</span><br><span class="line">                     <span class="keyword">if</span> (dis &lt; minDistance) &#123;</span><br><span class="line">                         minDistance = dis;</span><br><span class="line">                         label = j;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 dataset[i].label = label;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 更新每个聚簇的中心</span></span><br><span class="line">             <span class="built_in">vector</span>&lt;feature&gt; newCenters(centers);</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dataset[<span class="number">0</span>].v.size(); j++) &#123;</span><br><span class="line">                 <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; sum(k, <span class="number">0.0</span>);</span><br><span class="line">                 <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cc(k, <span class="number">0</span>);</span><br><span class="line">                 <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dataset.size(); i++) &#123;</span><br><span class="line">                     <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; k; p++) &#123;</span><br><span class="line">                         <span class="keyword">if</span> (dataset[i].label == p) &#123;</span><br><span class="line">                             sum[p] += dataset[i].v[j];</span><br><span class="line">                             cc[p]++;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">                     sum[i] = sum[i] / cc[i];</span><br><span class="line">                     newCenters[i].v.push_back(sum[i]);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 计算和上次中心的差距，差距在一定范围内就退出,centers, newcenters 之间的差距</span></span><br><span class="line">             <span class="keyword">double</span> dis = <span class="number">0.0</span>;</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">                 dis += distance(newCenters[i], centers[i]);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (dis &lt; MINVALUE) &#123;</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cluster</span><span class="params">(<span class="built_in">vector</span>&lt;feature&gt; dataset,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cluster(dataset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;KNN 算法步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储训练集的特征和标签，确定K&lt;/li&gt;
&lt;li&gt;预测一个未知的样本的时候，计算该样本到每一个训练集中的样本的距离，取前K个距离的最小值&lt;/li&gt;
&lt;li&gt;在前K个最小值中选择标签出现次数最大的那个，作为预测结果&lt;/li
      
    
    </summary>
    
      <category term="技术" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="机器学习" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="KNN" scheme="http://ff120.github.io/hexoblog/tags/KNN/"/>
    
  </entry>
  
  <entry>
    <title>大数据基础框架</title>
    <link href="http://ff120.github.io/hexoblog/2017/10/06/%E6%8A%80%E6%9C%AF/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6/"/>
    <id>http://ff120.github.io/hexoblog/2017/10/06/技术/大数据/大数据基础框架/</id>
    <published>2017-10-06T12:21:59.000Z</published>
    <updated>2019-03-28T00:54:55.378Z</updated>
    
    <content type="html"><![CDATA[<p>大数据系统最初由google公布的一篇论文引起，后来发展出hadoop和一系列工具，后来又有spark，本文介绍在大数据处理领域一些常用工具的基本原理。</p><a id="more"></a><h2 id="hdfs">HDFS</h2><p><code>hadoop distributed file system (HDFS)</code> 是脱胎于<code>google file system</code>的一个分布式文件系统,据说，其性能并没有达到GFS的水平，只是根据谷歌论文的原理的一个开源实现版本。 HDFS的特定有以下几点：</p><ol style="list-style-type: decimal"><li>同时保存多个副本(默认三个)，提供容错机制，副本丢失能够自动恢复。</li><li>运行在不可靠机器上(廉价机器上)</li><li>适合大数据的处理，HDFS默认将文件分成64M大小的block, 将block按照键值对的方式存储在HDFS上。将映射关系保存在内存中。</li></ol><h3 id="hdfs的构成">HDFS的构成</h3><p><code>HDFS</code>是主从结构(<code>master/slave</code>结构)，主要由<code>NameNode</code>和<code>DataNode</code>组成。<code>NameNode</code> 是Master节点，负责整个系统的结构信息和调度控制，<code>DataNode</code>是slave节点，负责存储数据。除此之外，一般还有一个<code>SecondaryNameNode</code>节点，是<code>NameNode</code>节点的备份，负责承担一部分<code>NameNode</code>的工作，定时备份<code>NameNode</code>的数据，当<code>NameNode</code>出现故障的时候，可以从<code>SecondaryNameNode</code>恢复数据。</p><ul><li>NameNode</li><li>DataNode</li></ul><h3 id="写文件操作">写文件操作</h3><div class="figure"><img src="26162921-2de9d28df9b54fe6a97a6fd88f1cb03f.jpg" alt="HDFS写文件示意图"><p class="caption">HDFS写文件示意图</p></div><p>如上图，该图表示一个win7系统的电脑要把一个100M的文件写入一个HDFS文件系统。该HDFS文件系统运行在一个Hadoop集群之上，集群拥有一个NameNode(NN)节点，8个DataNode(DN)节点，有三个机架(rack1,rack2,rack3), 全部在一个机房内。</p><ol style="list-style-type: decimal"><li><p>client把文件分割程64M大小(HDFS文件系统的默认大小)，生成两个文件块，一个64M， 一个36M。</p></li><li><p>client向NameNode发送写文件的请求。</p></li><li><p>NameNode收到请求之后，查询自己数据中记录的整个HDFS文件系统的信息，确定这些数据写入哪些DataNode节点中，并且记录下该信息，返回该信息给请求的主机。</p></li></ol><blockquote><p>假设分配的情况如下：</p></blockquote><blockquote><ul><li>block1: host2,host1,host3</li><li>block2: host7,host8,host4</li></ul></blockquote><blockquote><p>分配DataNode节点的规则为： 如果client为DataNode节点，那么副本1存储在与client相同的节点上，副本2存储在不同机架的节点上，副本三存储在同副本2相同机架上的不同节点； 如果client不是DataNode节点，则副本1随机选择一个节点，副本2选择不同的机架，副本3同副本2的机架的不同节点。</p></blockquote><ol start="4" style="list-style-type: decimal"><li><p>client根据收到的写入信息,把block1写入第一个主机host2, 整个写入过程是流式写入的，数据被分割策划那个64K的小数据包写入，每次写完64K，host2将自己刚刚得到的64K数据写入host1, host1得到64K之后写入host3, 实际上客户端只需要向host2写入一次数据，数据就可以有三个备份。当第一个block写完之后，host2,host1,host3向NameNode, host2向client发送信息说明数据已经写完。</p></li><li><p>client收到信息之后发送第二个block，过程和第一个block一样。</p></li><li><p>第二个block写完之后，数据彻底写完，写文件的过程就结束了。</p></li></ol><p>通过写文件的过程和不同副本的分配策略可以看出，挂掉一个节点设置整个机架都是没有关系的，总能从其他的地方找回这些丢失的数据。</p><h3 id="读文件操作">读文件操作</h3><div class="figure"><img src="26163017-fc613879835c402886b75e0593ca52ed.jpg" alt="HDFS读取文件示意图"><p class="caption">HDFS读取文件示意图</p></div><p>如图，win7客户端要从HDFS文件系统上读取一个100M大小的的文件，该文件在HDFS中有两个数据块组成:block1,block2.</p><ol style="list-style-type: decimal"><li><p>client 向NameNode 发送读取文件的请求。</p></li><li><p>NameNode收到读取文件的请求，查询自己存储的元信息，返回block1和block2的存储位置： <code>block1: host2,host1,host3; block2: host7,host8,host4</code>;</p></li><li><p>客户端收到NameNode的消息，去机器host2读取block1,去机器host7读取block2,读取完成之后合并成一个完整的文件，整个读文件的过程就结束了。如果client位于DataNode内，则优先读取本机架上的数据。</p></li></ol><p>参考文献：<a href="http://www.cnblogs.com/laov/p/3434917.html" target="_blank" rel="noopener">HDFS读写原理</a></p><h2 id="mapreduce">MapReduce</h2><p>MapReduce 是一个计算框架，就是在特定的输入上产生特定的输出。输入和输出都是<code>&lt;key,val&gt;</code>这种键值对的形式。 Mapper就是对每个个体进行操作，不涉及个体之间的相互作用，例如转换格式，分割字符串等，这样Mapper这个阶段做的工作可以在许多机器上并行的执行， Reducer执行一些需要不同条目之间协同才能完成的操作，例如计数，求和，需要遍历所有的条目才能得到结果。Reducer任务会在不同的机器上传递结果，得到最终的结果之后再返回。</p><div class="figure"><img src="x.png" alt="MapReduce运行机制"><p class="caption">MapReduce运行机制</p></div><ol style="list-style-type: decimal"><li><p>在执行Map计算之前，先要根据文件的大小和HDFS的配置情况进行分片(input split), 假设HDFS默认的block大小是64M，而本次任务的输入有3个文件，一个10M，一个70M，一个128M，则10M的文件会被分成一片，70M的文件会被分成两片，128M的文件也会被分成两片。 分片操作仅仅计算出一个分片的长度和每个分片对应的数据的索引位置，并不改变原来的数据。</p></li><li><p>执行程序中定义好的Map操作，Map在各个数据节点上独立的执行，相互之间没有影响。</p></li><li><p>combiner阶段：目的是在本地机器上执行reduce操作，把可以在本地机器上合并的结果先执行了，避免以后需要大量传输数据(机器之间传输数据 的开销往往是分布式系统最大的瓶颈). 例如求最大值，最小值和求和等操作，可以Map之后可以现在各个数据节点求出整个数据节点的最大值，作为一个结果输出，之后的reduce操作会大大减少结果的传输负担。</p></li><li><p>shuffle阶段： 将Mapper阶段的输出作为Reducer阶段的输入数据。</p></li><li><p>Reduce阶段： 执行用户编写的reduce函数，得出结果之后存储在HDFS文件系统之上。</p></li></ol><div class="figure"><img src="1.png" alt="Map-Shuffle-Reduce过程解析"><p class="caption">Map-Shuffle-Reduce过程解析</p></div><p>参考文献:<a href="http://www.cnblogs.com/sharpxiajun/p/3151395.html" target="_blank" rel="noopener">cnblogs</a></p><h2 id="spark">Spark</h2><h3 id="弹性分布式数据集rdd">弹性分布式数据集(RDD)</h3><p>Spark 底层存储数据的时候使用的是Hadoop的HDFS分布是文件系统，所以可以存储任何兼容Hadoop的数据源，例如Hbase. Spark 在逻辑上把数据存储在一个一个的RDD中，一个RDD可以看作一张表格，可以保存任何类型的数据。RDD是不可改变的，任何改变RDD的操作都会返回一个全新的RDD，spark的所有操作，在逻辑上都是针对RDD的操作。 RDD支持两种操作：transformation 和 action . transformation 是对RDD执行一个变换操作，不会立即计算，只是记录了应该在该RDD上执行这样的操作。 action 一般会是一个reduce操作， 会立刻执行，就是之前定义的所有transformation操作和当前定义的action操作。</p><ul><li><p><strong>transformation</strong>: 对RDD执行一个变换，返回一个新的RDD。可用的操作有map,filter,flatMap, groupByKey, reduceByKey 等。</p></li><li><p><strong>action</strong>: 在该RDD对象上执行之前定义的所有操作(包括所有的transformation操作)， 返回计算的结果。 可用的操作有reduce, collect, count, first, countByKey 等。</p></li></ul><h3 id="wordcount-程序">WordCount 程序</h3><p>使用spark运行一个统计单词个数的程序十分简单，这个过程可以帮助我们了解spark是如何工作的。</p><p>读取文本文件并生成RDD，将RDD缓存在内存中，缓存的RDD不需要从头开始计算，如果RDD没有缓存，就算过后的RDD会被立刻丢弃，每次想要得到结果都需要从头开始计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SimpleApp.scala */</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.SparkContext</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.SparkContext._</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.SparkConf</span><br><span class="line"></span><br><span class="line">object SimpleApp &#123;</span><br><span class="line">  <span class="function">def <span class="title">main</span><span class="params">(args: Array[String])</span> </span>&#123;</span><br><span class="line">    val logFile = <span class="string">"YOUR_SPARK_HOME/README.md"</span> <span class="comment">// 应该是你系统上的某些文件</span></span><br><span class="line">    val conf = <span class="keyword">new</span> SparkConf().setAppName(<span class="string">"Simple Application"</span>)</span><br><span class="line">    val sc = <span class="keyword">new</span> SparkContext(conf)</span><br><span class="line">    val logData = sc.textFile(logFile, <span class="number">2</span>).cache()</span><br><span class="line">    val numAs = logData.filter(line =&gt; line.contains(<span class="string">"a"</span>)).count()</span><br><span class="line">    val numBs = logData.filter(line =&gt; line.contains(<span class="string">"b"</span>)).count()</span><br><span class="line">    println(<span class="string">"Lines with a: %s, Lines with b: %s"</span>.format(numAs, numBs))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序仅仅是在 Spark README 中计算行里面包含 ‘a’ 和包含 ‘b’ 的次数.</p><h3 id="spark-框架的主要内容">Spark 框架的主要内容</h3><div class="figure"><img src="spark-stack-new.png" alt="Spark生态系统"><p class="caption">Spark生态系统</p></div><ul><li><p><code>spark streaming</code> : 基于微批量方式的计算和处理，可以用于处理实时的流数据。它使用DStream，简单来说就是一个弹性分布式数据集（RDD）系列，处理实时数据。</p></li><li><p><code>spark SQL</code> : 可以通过JDBC API将Spark数据集暴露出去，而且还可以用传统的BI和可视化工具在Spark数据上执行类似SQL的查询。用户还可以用Spark SQL对不同格式的数据（如JSON，Parquet以及数据库等）执行ETL，将其转化，然后暴露给特定的查询。</p></li><li><p><code>spark mlib</code> : 是一个可扩展的Spark机器学习库，由通用的学习算法和工具组成，包括二元分类、线性回归、聚类、协同过滤、梯度下降以及底层优化原语。</p></li><li><p><code>spark graphx</code> : 是用于图计算和并行图计算的新的（alpha）Spark API。通过引入弹性分布式属性图（Resilient Distributed Property Graph），一种顶点和边都带有属性的有向多重图，扩展了Spark RDD。为了支持图计算，GraphX暴露了一个基础操作符集合（如subgraph，joinVertices和aggregateMessages）和一个经过优化的Pregel API变体。此外，GraphX还包括一个持续增长的用于简化图分析任务的图算法和构建器集合。</p></li><li><p><code>blinkDB</code> : 一个近似查询引擎，用于在海量数据上执行交互式SQL查询。BlinkDB可以通过牺牲数据精度来提升查询响应时间。通过在数据样本上执行查询并展示包含有意义的错误线注解的结果，操作大数据集合。</p></li><li><p><code>sparkR</code> : R语言的spark接口</p></li></ul><h2 id="hbase">HBASE</h2><p>HBase, Hadoop Database, 是Google Bigtable的开源实现，是一个面向列的，可伸缩的分布式存储系统，它的底层文件存储使用的是HDFS。</p><p><strong><code>HBase</code>的存储逻辑</strong></p><p>表由行和列组成，列被分组，若干个列组成一个列簇（row family）,表在定义的时候，就必须声明所有的列簇，但是列簇内包含几个列可以动态增加(这也体现了面向列的存储这一方面). 同一个列簇使用相同的前缀为其命名，例如<code>temperature:air</code> 和 <code>temperature:dew</code> 都是<code>temperature</code>列簇的成员, <code>HBase</code>的每个列簇称作一个<code>store</code>，同一个列簇的数据会存储在同一个目录下，可能会分割成多个文件存储。</p><p>每个行由一个键表示，行键是一个字节数组，行按照行键进行排序。</p><p>行列交叉的位置称作<code>Cell</code>，每个cell都有版本，以时间戳标识，这个标识可以自己定义。也就是说，Hbase中的每个数据都是有版本的，数据按照时间倒序排列，最新的数据排列在最前面。cell中的内容是字节数组，不带格式,HBase存储的数据都是无格式的。唯一的确定一个cell需要下面这些数据：row key(行键), column:label(列簇的前缀的列的名称)， version(版本号)， 行键用来确定是哪一行，column:label确定是哪一列，版本号确定是哪个版本的数据，这样可以唯一的确定一个单元格里的数据。</p><p>HBase自动把表格水平划分程若干region, 每个region都是连续的若干行数据(类似数据库的水平分割).</p><p><strong>HBase的物理存储结构</strong></p><p>一个Table最初只有一个Region,随这行的数量的增加，当超过一个既定的阈值的时候，Region就会等分为2个。 相同的Region保证存储在相同的机器上，不同的Region可以存储在不同的机器上，叫做region server。</p><p>每个Region存储的若干行和这些行的所有列。每个Region的内部存储是这样的：Region 由一个或者多个store组成，每个store存储一个列簇， 每个store包括一个memStore和0个或者多个storefile,storefile是存储的最小单位，以HFile的格式保存在HDFS文件系统上。</p><div class="figure"><img src="QQ截图20171007212611.png" alt="HBase架构示意图"><p class="caption">HBase架构示意图</p></div><p><strong>HBase的运行</strong></p><p>HBase 由一个主节点master和若干个RegionServer组成，主节点的负载较轻，主要负责引导初始安装，分配区域给已经注册的区域服务器，恢复区域服务器的故障等。 区域服务器负责自己存储的若干个区域的读写工作。</p><h2 id="hive">Hive</h2><p>hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供完整的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析</p><p>Hive是建立在 Hadoop 上的数据仓库基础构架。它提供了一系列的工具，可以用来进行数据提取转化加载（ETL），这是一种可以存储、查询和分析存储在 Hadoop 中的大规模数据的机制。Hive 定义了简单的类 SQL 查询语言，称为 HQL，它允许熟悉 SQL 的用户查询数据。同时，这个语言也允许熟悉 MapReduce 开发者的开发自定义的 mapper 和 reducer 来处理内建的 mapper 和 reducer 无法完成的复杂的分析工作</p><p>简单来讲，Hive提供了一种高级的类似SQL的语言，来执行一些以前必须要自己写Map,Reduce程序才能实现的功能，大大简化了数据处理的难度(MapReduce程序很难写)， 但是，Hive的实时性很差，适合离线处理，数据分析和数据挖掘等对实时性要求不高的任务。</p><h2 id="pig">Pig</h2><p>提供类似SQL的语言叫做<code>Pig Latin</code>, 可以把类SQL的语言转化程优化处理过的MapReduce运算。</p><p>Pig是一种大规模数据集的脚本语言，它实际上提供了一整套脚本语言的特性，用来处理海量的数据。</p><h2 id="zookeeper">Zookeeper</h2><p>Zookeeper的目的是提供一些工具集，用来建立安全处理局部故障的分布式应用。 使用Zookeeper, 我们可以更容易的自己实现一个分布式的应用。</p><p>参考文献:<a href="http://www.cnblogs.com/wuxl360/p/5817471.html" target="_blank" rel="noopener">1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大数据系统最初由google公布的一篇论文引起，后来发展出hadoop和一系列工具，后来又有spark，本文介绍在大数据处理领域一些常用工具的基本原理。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="大数据" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="HDFS" scheme="http://ff120.github.io/hexoblog/tags/HDFS/"/>
    
  </entry>
  
  <entry>
    <title>算法专题_常见题目</title>
    <link href="http://ff120.github.io/hexoblog/2017/10/03/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98-%E5%B8%B8%E8%A7%81%E9%A2%98%E7%9B%AE/"/>
    <id>http://ff120.github.io/hexoblog/2017/10/03/技术/数据结构和算法/算法专题-常见题目/</id>
    <published>2017-10-03T03:06:18.000Z</published>
    <updated>2019-03-28T00:54:56.233Z</updated>
    
    <content type="html"><![CDATA[<p>【栈】【队列】【链表】【二叉树】【堆】【快速排序】【归并排序】【数组】【指针】</p><a id="more"></a><h2 id="栈">栈</h2><h3 id="栈的压入弹出序列"><a href="https://www.nowcoder.com/questionTerminal/d77d11405cc7470d82554cb392585106" target="_blank" rel="noopener">栈的压入弹出序列</a></h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsPopOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pushV,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popV)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列"><a href="http://lintcode.com/zh-cn/problem/132-pattern/#" target="_blank" rel="noopener">132序列</a></h3><p>Given a sequence of n integers a1, a2, …, an, a 132 pattern is a subsequence ai, aj, ak such that i &lt; j &lt; k and ai &lt; ak &lt; aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.</p><p>n will be less than 20,000.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> third = INT32_MIN; <span class="comment">// 中间大的数</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">// 如果找到小于第二大的数字，则小于第二大的数字，第二大的数字和最大的数字三个数字都找到，返回true;</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; third) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 如果当前数字大于栈顶元素，则找到了第二大的数字(栈顶元素)，最大的数字变成了当前数字</span></span><br><span class="line">            <span class="keyword">while</span> (!s.empty() &amp;&amp; nums[i] &gt; s.top()) &#123;</span><br><span class="line">                third = s.top(); s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        s.push(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表">链表</h2><h3 id="翻转链表"><a href="http://lintcode.com/zh-cn/problem/reverse-linked-list/" target="_blank" rel="noopener">翻转链表</a></h3><p>翻转一个链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode * <span class="title">reverse</span><span class="params">(ListNode * head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并k个链表"><a href="http://lintcode.com/zh-cn/problem/merge-k-sorted-lists/" target="_blank" rel="noopener">合并K个链表</a></h3><p>合并k个排序链表，并且返回合并后的排序链表。尝试分析和描述其复杂度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode *&gt; &amp;lists)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// write your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂链表的复制"><a href="http://lintcode.com/zh-cn/problem/copy-list-with-random-pointer/" target="_blank" rel="noopener">复杂链表的复制</a></h3><p>给出一个链表，每个节点包含一个额外增加的随机指针可以指向链表中的任何节点或空的节点。</p><p>返回一个深拷贝的链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表求和"><a href="http://lintcode.com/zh-cn/problem/add-two-numbers-ii/#" target="_blank" rel="noopener">链表求和</a></h3><p>假定用一个链表表示两个数，其中每个节点仅包含一个数字。假设这两个数的数字顺序排列，请设计一种方法将两个数相加，并将其结果表现为链表的形式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode * <span class="title">addLists2</span><span class="params">(ListNode * l1, ListNode * l2)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// write your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表的中间节点">链表的中间节点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 找到链表的中间节点并返回</span></span><br><span class="line"><span class="comment"> * @param head</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ListNode* <span class="title">findMiddle</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *first = head, *second = head;</span><br><span class="line">    <span class="keyword">while</span>(second-&gt;next &amp;&amp; second-&gt;next-&gt;next)&#123;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        second = second-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树">二叉树</h2><h3 id="前序遍历的非递归实现"><a href="http://lintcode.com/zh-cn/problem/binary-tree-preorder-traversal/" target="_blank" rel="noopener">前序遍历的非递归实现</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode * root) &#123;</span><br><span class="line">      <span class="comment">// write your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历的非递归实现"><a href="http://lintcode.com/zh-cn/problem/binary-tree-inorder-traversal/" target="_blank" rel="noopener">中序遍历的非递归实现</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode * root) &#123;</span><br><span class="line">       <span class="comment">// write your code here</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历的非递归实现"><a href="http://lintcode.com/zh-cn/problem/binary-tree-postorder-traversal/" target="_blank" rel="noopener">后序遍历的非递归实现</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode * root) &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的最大深度"><a href="http://lintcode.com/zh-cn/problem/maximum-depth-of-binary-tree/#" target="_blank" rel="noopener">二叉树的最大深度</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的最小深度"><a href="http://lintcode.com/zh-cn/problem/minimum-depth-of-binary-tree/#" target="_blank" rel="noopener">二叉树的最小深度</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode * root)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// write your code here</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="叶子之间的最长距离">叶子之间的最长距离</h3><h3 id="堆排序">堆排序</h3><h3 id="top-k">TOP K</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="数据流的中位数"><a href="http://lintcode.com/zh-cn/problem/data-stream-median/" target="_blank" rel="noopener">数据流的中位数</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; medianII(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums) &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序">快速排序</h2><h3 id="第k大的数"><a href="http://lintcode.com/zh-cn/problem/kth-largest-element/" target="_blank" rel="noopener">第K大的数</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthLargestElement</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中位数"><a href="http://lintcode.com/zh-cn/problem/median/#" target="_blank" rel="noopener">中位数</a></h3><p>给定一个未排序的整数数组，找到其中位数。</p><p>中位数是排序后数组的中间值，如果数组的个数是偶数个，则返回排序后数组的第N/2个数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">median</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序">归并排序</h2><h3 id="数组的逆序对的个数"><a href="http://lintcode.com/zh-cn/problem/reverse-pairs/" target="_blank" rel="noopener">数组的逆序对的个数</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="字符串">字符串</h2><h3 id="kmp算法"><a href="http://lintcode.com/zh-cn/problem/strstr/" target="_blank" rel="noopener">KMP算法</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *source, <span class="keyword">const</span> <span class="keyword">char</span> *target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="字典树">字典树</h3><p>给定整数m以及n个数字A1, A2, …, An，将数列A中所有元素两两异或，共能得到n(n-1)/2个结果。请求出这些结果中大于m的有多少个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="哈夫曼编码">哈夫曼编码</h3><h2 id="一维数组">一维数组</h2><h3 id="出现一半以上的数">出现一半以上的数</h3><p>一个数组中有一个数字的出现次数超过一半(超过50%),求出这个数字。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMajority</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="数组跳跃能否达到终点">数组跳跃能否达到终点</h3><p>一个整形数组，每个元素代表可以在当前位置的基础上向后跳跃几步，问要跳跃到最后最少需要跳跃几步，如果不能到达最后返回-1;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大数据">大数据</h2><h3 id="布隆过滤器">布隆过滤器</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【栈】【队列】【链表】【二叉树】【堆】【快速排序】【归并排序】【数组】【指针】&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数据结构和算法" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://ff120.github.io/hexoblog/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>手写代码-其他</title>
    <link href="http://ff120.github.io/hexoblog/2017/09/27/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81-%E5%85%B6%E4%BB%96/"/>
    <id>http://ff120.github.io/hexoblog/2017/09/27/技术/数据结构和算法/手写代码-其他/</id>
    <published>2017-09-27T15:12:30.000Z</published>
    <updated>2019-03-28T00:54:56.087Z</updated>
    
    <content type="html"><![CDATA[<p>【快速排序】【第K大的数】【归并排序】【逆序对】【二分查找】【冒泡排序】【单例模式】</p><a id="more"></a><h3 id="二分查找">二分查找</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不考虑重复元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = v.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">       <span class="keyword">if</span>(v[mid] == val) <span class="keyword">return</span> mid;</span><br><span class="line">       <span class="keyword">if</span>(v[mid] &gt; val)&#123;</span><br><span class="line">           j = mid - <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(v[mid] &lt; val)&#123;</span><br><span class="line">         i = mid + <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有重复的val,返回val的起始位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binaryResearch</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = v.size() <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mind;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j))&#123;</span><br><span class="line">      <span class="keyword">if</span>(v[mid] == val)&#123;</span><br><span class="line">        <span class="keyword">while</span>(v[mid] == val &amp;&amp; mid &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">          mid--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p+<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(v[mid] &gt; val)&#123;</span><br><span class="line">        j = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(v[mid] &lt; val)&#123;</span><br><span class="line">        i = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序">冒泡排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = v.size()<span class="number">-1</span>;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;j;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i] &gt; v[i+<span class="number">1</span>]) swap(v[i],v[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单例模式">单例模式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">static</span> Single* instance = null; <span class="comment">// 静态私有变量，属于类</span></span><br><span class="line">      Singleton()&#123;&#125;</span><br><span class="line">      Singleton(<span class="keyword">const</span> Singleton&amp;)&#123;&#125;</span><br><span class="line">      Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;)&#123;&#125; <span class="comment">// 防止赋值的时候拷贝</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">static</span> Singleton* getInstance() <span class="comment">// 静态方法，确保使用类可以调用</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (instance == <span class="literal">NULL</span>)&#123;</span><br><span class="line">             lock(); <span class="comment">// 线程安全的写法，如果不用确保线程安全，不需要</span></span><br><span class="line">             <span class="keyword">if</span>(instance == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                 instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">             &#125;</span><br><span class="line">             unlock();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> instance;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>// 使用方法 <code>auto instance = Singleton::getInstance();</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【快速排序】【第K大的数】【归并排序】【逆序对】【二分查找】【冒泡排序】【单例模式】&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数据结构和算法" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://ff120.github.io/hexoblog/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>算法专题_二叉树2</title>
    <link href="http://ff120.github.io/hexoblog/2017/09/23/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E4%BA%8C%E5%8F%89%E6%A0%912/"/>
    <id>http://ff120.github.io/hexoblog/2017/09/23/技术/数据结构和算法/算法专题_二叉树2/</id>
    <published>2017-09-23T10:26:58.000Z</published>
    <updated>2019-03-28T00:54:56.362Z</updated>
    
    <content type="html"><![CDATA[<p>【前序遍历】【中序遍历】【后序遍历】【路径搜索】【公共祖先】【堆】【top K】【线段树】【树状数组】【并查集】</p><a id="more"></a><h3 id="前序遍历"><a href="http://lintcode.com/zh-cn/problem/binary-tree-preorder-traversal/" target="_blank" rel="noopener">前序遍历</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left, *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val = val;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left = <span class="keyword">this</span>-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 递归前序遍历</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode * root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> re;</span><br><span class="line"></span><br><span class="line">    re.push_back(root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp = preorderTraversal(root-&gt;left);</span><br><span class="line">        re.insert(re.end(),tmp.begin(),tmp.end());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp = preorderTraversal(root-&gt;right);</span><br><span class="line">        re.insert(re.end(),tmp.begin(),tmp.end());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归前序遍历</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorder(TreeNode* root)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> re;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode* iter = root;</span><br><span class="line">    <span class="keyword">while</span>(iter || !s.empty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(iter)&#123;</span><br><span class="line">            <span class="comment">// 首先输出根</span></span><br><span class="line">            re.push_back(iter-&gt;val);</span><br><span class="line">            s.push(iter);</span><br><span class="line">            iter = iter-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        iter = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        iter = iter-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="http://lintcode.com/zh-cn/problem/binary-tree-inorder-traversal/" target="_blank" rel="noopener">中序遍历</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归中序遍历</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode *root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> re;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp = inorderTraversal(root-&gt;left);</span><br><span class="line">        re.insert(re.end(),tmp.begin(),tmp.end());</span><br><span class="line">    &#125;</span><br><span class="line">    re.push_back(root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp = inorderTraversal(root-&gt;right);</span><br><span class="line">        re.insert(re.end(),tmp.begin(),tmp.end());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归中序遍历</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder(TreeNode* root)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> re;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode* iter = root;</span><br><span class="line">    <span class="keyword">while</span>(iter || !s.empty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(iter)&#123;</span><br><span class="line">            s.push(iter);</span><br><span class="line">            iter = iter-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        iter = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        re.push_back(iter-&gt;val);</span><br><span class="line">        iter = iter-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="http://lintcode.com/zh-cn/problem/binary-tree-postorder-traversal/" target="_blank" rel="noopener">后序遍历</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归后序遍历</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode *root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> re;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp = postorderTraversal(root-&gt;left);</span><br><span class="line">        re.insert(re.end(),tmp.begin(),tmp.end());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp = postorderTraversal(root-&gt;right);</span><br><span class="line">        re.insert(re.end(),tmp.begin(),tmp.end());</span><br><span class="line">    &#125;</span><br><span class="line">    re.push_back(root-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后序遍历的非递归实现</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postOrder(TreeNode *root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> re;</span><br><span class="line"></span><br><span class="line">    TreeNode *iter = root;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode *&gt; s;</span><br><span class="line">    TreeNode *last = root;</span><br><span class="line">    s.push(iter);</span><br><span class="line">    <span class="keyword">while</span> (!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        iter = s.top();</span><br><span class="line">        <span class="comment">// 1. 当前节点是叶节点(没有左右孩子)，输出</span></span><br><span class="line">        <span class="comment">// 2. 上次访问了当前节点的左孩子，而且当前节点没有右孩子，输出</span></span><br><span class="line">        <span class="comment">// 3. 上次访问了当前节点的右孩子，输出</span></span><br><span class="line">        <span class="keyword">if</span>( (iter-&gt;left == <span class="literal">nullptr</span> &amp;&amp; iter-&gt;right == <span class="literal">nullptr</span>) ||</span><br><span class="line">                (iter-&gt;right == <span class="literal">nullptr</span> &amp;&amp; last == iter-&gt;left) ||</span><br><span class="line">                    (last == iter-&gt;right) )</span><br><span class="line">        &#123;</span><br><span class="line">            re.push_back(iter-&gt;val);</span><br><span class="line">            last = iter;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 栈是后进先出的，要先处理左孩子，所以要先放入右耗资</span></span><br><span class="line">            <span class="keyword">if</span>(iter-&gt;right)</span><br><span class="line">                s.push(iter-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(iter-&gt;left)</span><br><span class="line">                s.push(iter-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的路径搜索">二叉树的路径搜索</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 搜索根节点到叶子节点的所有路径 [http://lintcode.com/zh-cn/problem/binary-tree-paths/#]</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vv;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binaryTreePaths</span><span class="params">(TreeNode *root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;tmp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;</span><br><span class="line">        tmp.push_back(root-&gt;val);</span><br><span class="line">        vv.push_back(tmp);</span><br><span class="line">        tmp.clear();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        tmp.push_back(root-&gt;val);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp1(tmp);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp2(tmp);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) binaryTreePaths(root-&gt;left,tmp1);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) binaryTreePaths(root-&gt;right,tmp2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树最大深度"><a href="http://lintcode.com/zh-cn/problem/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">二叉树最大深度</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用方式： maxDepth2(root,0)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth2</span><span class="params">(TreeNode *root, <span class="keyword">const</span> <span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> dep;</span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> dep+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> maxDepth2(root-&gt;left,dep+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right &amp;&amp; !root-&gt;left) <span class="keyword">return</span> maxDepth2(root-&gt;right,dep+<span class="number">1</span>);     </span><br><span class="line">    <span class="keyword">return</span> max(maxDepth2(root-&gt;left,dep+<span class="number">1</span>),maxDepth2(root-&gt;right,dep+<span class="number">1</span>));   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树最小深度"><a href="http://lintcode.com/zh-cn/problem/minimum-depth-of-binary-tree/#" target="_blank" rel="noopener">二叉树最小深度</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最小深度 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDepth2</span><span class="params">(TreeNode* root,<span class="keyword">const</span> <span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> dep;</span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> dep+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left &amp;&amp; !root-&gt;right)  <span class="keyword">return</span> minDepth2(root-&gt;left,dep+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; root-&gt;right)  <span class="keyword">return</span> minDepth2(root-&gt;right,dep+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> min(minDepth2(root-&gt;left,dep+<span class="number">1</span>),minDepth2(root-&gt;right,dep+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="叶子节点到叶子节点路径的搜索">叶子节点到叶子节点路径的搜索</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;TreeNode*,<span class="built_in">vector</span>&lt;TreeNode*&gt;&gt; nodes; <span class="comment">// 存储树的结构</span></span><br><span class="line"><span class="built_in">map</span>&lt;TreeNode*,<span class="keyword">bool</span>&gt; visited;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vv;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* leaf,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span>&#123;</span><br><span class="line">    visited[leaf] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; tmp = nodes[leaf];</span><br><span class="line">    <span class="keyword">bool</span> is = <span class="literal">true</span>;</span><br><span class="line">    v.push_back(leaf-&gt;val);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tmp.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[tmp[i]] == <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1(v);</span><br><span class="line">            dfs(tmp[i],v1);</span><br><span class="line">            is = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(is)&#123; <span class="comment">// 叶节点</span></span><br><span class="line">        vv.push_back(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="top-k-问题">top K 问题</h3><p>如果是最大的K个数，那么首先使用前K个数建立一个最小堆，然后从第K+1个数开始和堆顶的元素比较，如果大于堆顶的元素，就把堆顶的元素弹出，把该元素push进堆。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; topk(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v, <span class="keyword">int</span> k)&#123;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; heap; <span class="comment">// 最小堆（堆顶元素最小）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        heap.push(v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;v.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i] &gt; heap.top())&#123;</span><br><span class="line">            heap.pop();</span><br><span class="line">            heap.push(v[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">    <span class="keyword">while</span>(!heap.empty())&#123;</span><br><span class="line">        re.push_back(heap.top());</span><br><span class="line">        heap.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据流的中位数"><a href="http://lintcode.com/zh-cn/problem/data-stream-median/" target="_blank" rel="noopener">数据流的中位数</a></h3><p>使用大顶堆(<code>priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt;</code>) 保存前半部分的数据，使用小顶堆(<code>priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;</code>) 保存后半部分的数据, 保证大顶堆的顶 小于等于 小顶堆的顶， 那么在每次需要求当前的数据的中位数的时候，只需要两个堆顶元素就可以求出来了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt;&gt; maxHeap;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; minHeap;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line">    <span class="keyword">bool</span> is_left;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MedianFinder() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;is_left = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 轮流加入左右两个堆</span></span><br><span class="line">        <span class="keyword">if</span>(is_left)&#123;</span><br><span class="line">            <span class="comment">// 如果right的堆为空，可以确保左边最大的小于等于右边最小的，直接加入</span></span><br><span class="line">            <span class="comment">// 如果要加入的元素小于等于right的堆顶，也可以保证上述条件</span></span><br><span class="line">            <span class="keyword">if</span>(minHeap.empty() || num &lt;= minHeap.top())&#123;</span><br><span class="line">                maxHeap.push(num);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果num &gt; minHeap.top(); 不能直接加入maxHeap,因为如果这样做，就不能保证maxHeap中的所有的数字都小于等于minHeap中的数字。</span></span><br><span class="line">            <span class="comment">// 这个时候的做法是， 先把num加入minHeap, 在把minHeap.top()弹出，加入maxHeap;</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                minHeap.push(num);</span><br><span class="line">                maxHeap.push(minHeap.top());</span><br><span class="line">                minHeap.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            is_left = !is_left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!is_left)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maxHeap.empty() || num &gt;= maxHeap.top())&#123;</span><br><span class="line">                minHeap.push(num);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                maxHeap.push(num);</span><br><span class="line">                minHeap.push(maxHeap.top());</span><br><span class="line">                maxHeap.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            is_left = !is_left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &gt;&gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (maxHeap.top() + minHeap.top()) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> maxHeap.top();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="合并k个排序链表"><a href="http://lintcode.com/zh-cn/problem/merge-k-sorted-lists" target="_blank" rel="noopener">合并K个排序链表</a></h3><p>这里使用小顶堆这种结构保存K个链表，每次取得堆顶的元素就可以得到K个链表中最小的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode *&gt; &amp;lists)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;ListNode*,<span class="built_in">vector</span>&lt;ListNode*&gt;,bigger&gt; minHeap;</span><br><span class="line">    <span class="keyword">if</span>(lists.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lists.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists[i]) minHeap.push(lists[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *head = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *iter = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(!minHeap.empty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            head = minHeap.top();</span><br><span class="line">            iter = head;</span><br><span class="line">            <span class="keyword">if</span>(minHeap.top()-&gt;next)&#123;</span><br><span class="line">                minHeap.push(minHeap.top()-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">            minHeap.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            iter-&gt;next = minHeap.top();</span><br><span class="line">            iter = iter-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(minHeap.top()-&gt;next)&#123;</span><br><span class="line">                minHeap.push(minHeap.top()-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">            minHeap.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序">堆排序</h3><p>使用堆这种结构维护数据的有序性，从而进行排序的算法是堆排序。堆排序的具体步骤是： 使用要排序的整个数组建立堆。然后把最后一个元素和堆顶元素交换，堆的大小减1，调整堆，然后再把新的堆的最后一个元素和堆顶元素交换，调整堆，直到全部数据有序为止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 建立最大堆</span></span><br><span class="line">    make_heap(v.begin(),v.end(),less&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="keyword">int</span> index = v.size();</span><br><span class="line">    <span class="keyword">while</span>(index &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 交换堆顶和堆尾的元素，重新调整堆</span></span><br><span class="line">        pop_heap(v.begin(),v.begin()+index,less&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        index--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的序列化和反序列化">二叉树的序列化和反序列化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    T val;</span><br><span class="line">    Node  *left,*right;</span><br><span class="line">    Node()&#123;&#125;</span><br><span class="line">    Node(T init) : val(init), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的先根遍历，非递归实现，使用栈</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preOrder(Node&lt;<span class="keyword">int</span>&gt;* root)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Node&lt;<span class="keyword">int</span>&gt;*&gt; s;</span><br><span class="line">    Node&lt;<span class="keyword">int</span>&gt;* iter = root;</span><br><span class="line">    <span class="keyword">while</span>(iter || !s.empty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(iter)&#123;</span><br><span class="line">            ans.push_back(iter-&gt;val);</span><br><span class="line">            s.push(iter);</span><br><span class="line">            iter = iter-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        iter = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        iter = iter-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的层次遍历，非递归，使用队列</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; levelOrder(Node&lt;<span class="keyword">int</span>&gt;* root)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node&lt;<span class="keyword">int</span>&gt;*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    Node&lt;<span class="keyword">int</span>&gt;* iter;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        iter = q.front();</span><br><span class="line">        <span class="keyword">if</span>(iter)&#123;</span><br><span class="line">            ans.push_back(iter-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(iter-&gt;left) q.push(iter-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(iter-&gt;right) q.push(iter-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用层次遍历的方法序列化二叉树</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; levelOrderSeries(Node&lt;<span class="keyword">int</span>&gt;* root)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node&lt;<span class="keyword">int</span>&gt;*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    Node&lt;<span class="keyword">int</span>&gt;* iter;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        iter = q.front();</span><br><span class="line">        <span class="keyword">if</span>(iter)&#123;</span><br><span class="line">            <span class="keyword">if</span>(iter-&gt;val != <span class="number">-1</span>)&#123;</span><br><span class="line">                ans.push_back(to_string(iter-&gt;val));</span><br><span class="line">                <span class="keyword">if</span>(iter-&gt;left)&#123;</span><br><span class="line">                    q.push(iter-&gt;left);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    q.push(<span class="keyword">new</span> Node&lt;<span class="keyword">int</span>&gt;(<span class="number">-1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(iter-&gt;right)&#123;</span><br><span class="line">                    q.push(iter-&gt;right);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    q.push(<span class="keyword">new</span> Node&lt;<span class="keyword">int</span>&gt;(<span class="number">-1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.push_back(<span class="string">"#"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*(--ans.end()) == <span class="string">"#"</span>) ans.erase(--ans.end());</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据二叉树的层次遍历的结果重建二叉树</span></span><br><span class="line"><span class="comment"> * @param c</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node&lt;<span class="keyword">int</span>&gt;* reConstructTree(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;c)&#123;</span><br><span class="line">    <span class="keyword">if</span>(c.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;Node&lt;<span class="keyword">int</span>&gt;*&gt; q;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(c[index] == <span class="string">"#"</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">auto</span> root = <span class="keyword">new</span> Node&lt;<span class="keyword">int</span>&gt;( stoi(c[index]) );  index++;</span><br><span class="line">    q.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        Node&lt;<span class="keyword">int</span>&gt;* parent = q.front(); q.pop();</span><br><span class="line">        Node&lt;<span class="keyword">int</span>&gt;* left = <span class="literal">nullptr</span>;</span><br><span class="line">        Node&lt;<span class="keyword">int</span>&gt;* right = <span class="literal">nullptr</span> ;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; c.size() &amp;&amp; c[index] != <span class="string">"#"</span>) &#123; left = <span class="keyword">new</span> Node&lt;<span class="keyword">int</span>&gt;(stoi(c[index]));  &#125;  index++;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; c.size() &amp;&amp; c[index] != <span class="string">"#"</span>) &#123; right = <span class="keyword">new</span> Node&lt;<span class="keyword">int</span>&gt;(stoi(c[index])); &#125;  index++;</span><br><span class="line">        <span class="keyword">if</span>(left) &#123; parent-&gt;left = left; q.push(left); &#125;</span><br><span class="line">        <span class="keyword">if</span>(right) &#123; parent-&gt;right = right; q.push(right); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v = &#123;<span class="string">"3"</span>,<span class="string">"9"</span>,<span class="string">"20"</span>,<span class="string">"#"</span>,<span class="string">"#"</span>,<span class="string">"15"</span>,<span class="string">"7"</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> re = reConstructTree(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> hh = levelOrderSeries(re);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用非递归非栈的方式遍历二叉树">使用非递归、非栈的方式遍历二叉树</h3><p>核心的思想是使用二叉树的左子树的最右边的空指针指向 在遍历完左子树之后 需要遍历的下一个节点。 具体的步骤是：</p><ol style="list-style-type: decimal"><li>令<code>iter = root</code>,<code>root</code>表示二叉树的根节点。首先让<code>iter</code>的左子树的最右节点的<code>right</code>指针指向<code>iter</code>. 完成这一步的代码类似下面这样：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Node* tp = iter-&gt;left; <span class="comment">// tp 指向iter的左子树</span></span><br><span class="line"><span class="keyword">if</span>(tp)&#123;</span><br><span class="line">    <span class="comment">// 通过循环找到最右边的节点</span></span><br><span class="line">    <span class="keyword">while</span>(tp-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">         tp = tp-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最右节点的right指针指向iter</span></span><br><span class="line">    <span class="keyword">if</span>(tp-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        tp-&gt;right = iter; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" style="list-style-type: decimal"><li>处理完<code>root</code>节点之后，循环处理<code>iter=iter-&gt;left</code>直到<code>iter</code>的<code>left</code>指针为空为止，也就是上文中的<code>tp==nullptr</code>的情况。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">    Node()&#123;&#125;</span><br><span class="line">    Node(<span class="keyword">int</span> v) : val(v),left(<span class="literal">nullptr</span>),right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的前序遍历，非递归，不用栈</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preOrder(Node* root)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    Node* iter = root;</span><br><span class="line">    Node* tp = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(iter != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="comment">// 处理iter的左子树</span></span><br><span class="line">        tp = iter-&gt;left;</span><br><span class="line">        <span class="keyword">if</span>(tp != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="comment">// 找到 iter 左子树的最右节点</span></span><br><span class="line">            <span class="keyword">while</span>(tp-&gt;right != <span class="literal">nullptr</span> &amp;&amp; tp-&gt;right != iter)&#123;</span><br><span class="line">                tp = tp-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是不满足tp-&gt;right != nullptr 而退出了上面的循环，</span></span><br><span class="line">            <span class="comment">// 说明找到的节点iter的左子树的最右面的空节点，</span></span><br><span class="line">            <span class="comment">// 把该节点指向iter</span></span><br><span class="line">            <span class="comment">// 继续处理 iter 的左孩子</span></span><br><span class="line">            <span class="keyword">if</span>(tp-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                tp-&gt;right = iter; <span class="comment">// 左子树的最右节点指向之前的节点</span></span><br><span class="line">                ans.push_back(iter-&gt;val); <span class="comment">// 一旦找到左子树最右边的节点就输出iter，因为前序遍历根节点要最先输出</span></span><br><span class="line">                iter = iter-&gt;left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是因为不满足tp-&gt;right != iter 退出了循环，</span></span><br><span class="line">            <span class="comment">// 就是说tp-&gt;right == iter</span></span><br><span class="line">            <span class="comment">// 说明已经遍历过一遍(否则不可能有指向iter的指针)</span></span><br><span class="line">            <span class="comment">// 把tp-&gt;right 置空，恢复二叉树原来的样子</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                tp-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 没有左子树，也要输出根</span></span><br><span class="line">            ans.push_back(iter-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        iter = iter-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的中序遍历，非递归，不用栈</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inOrder(Node* root)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    Node* iter = root;</span><br><span class="line">    Node* tp = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(iter != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="comment">// 处理iter的左子树</span></span><br><span class="line">        tp = iter-&gt;left;</span><br><span class="line">        <span class="keyword">if</span>(tp != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="comment">// 找到 iter 左子树的最右节点</span></span><br><span class="line">            <span class="keyword">while</span>(tp-&gt;right != <span class="literal">nullptr</span> &amp;&amp; tp-&gt;right != iter)&#123;</span><br><span class="line">                tp = tp-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是不满足tp-&gt;right != nullptr 而退出了上面的循环，</span></span><br><span class="line">            <span class="comment">// 说明找到的节点iter的左子树的最右面的空节点，</span></span><br><span class="line">            <span class="comment">// 把该节点指向iter</span></span><br><span class="line">            <span class="comment">// 继续处理 iter 的左孩子</span></span><br><span class="line">            <span class="keyword">if</span>(tp-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                tp-&gt;right = iter; <span class="comment">// 左子树的最右节点指向之前的节点</span></span><br><span class="line">                iter = iter-&gt;left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是因为不满足tp-&gt;right != iter 退出了循环，</span></span><br><span class="line">            <span class="comment">// 就是说tp-&gt;right == iter</span></span><br><span class="line">            <span class="comment">// 说明已经遍历过一遍(否则不可能有指向iter的指针)</span></span><br><span class="line">            <span class="comment">// 把tp-&gt;right 置空，恢复二叉树原来的样子</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                tp-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push_back(iter-&gt;val);</span><br><span class="line">        iter = iter-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【前序遍历】【中序遍历】【后序遍历】【路径搜索】【公共祖先】【堆】【top K】【线段树】【树状数组】【并查集】&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数据结构和算法" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://ff120.github.io/hexoblog/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>算法专题_字典树(Trie树)</title>
    <link href="http://ff120.github.io/hexoblog/2017/08/23/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98-%E5%AD%97%E5%85%B8%E6%A0%91-Trie%E6%A0%91/"/>
    <id>http://ff120.github.io/hexoblog/2017/08/23/技术/数据结构和算法/算法专题-字典树-Trie树/</id>
    <published>2017-08-23T01:58:56.000Z</published>
    <updated>2019-03-28T00:54:56.209Z</updated>
    
    <content type="html"><![CDATA[<p>一种字符串前缀的匹配技术。</p><a id="more"></a><h2 id="字典树">字典树</h2><h2 id="字典树的应用">字典树的应用</h2><h3 id="异或今日头条2017秋招真题">异或（今日头条2017秋招真题）</h3><p><a href="http://exercise.acmcoder.com/online/online_judge_ques?ques_id=3338&amp;konwledgeId=158" target="_blank" rel="noopener">异或（今日头条2017秋招真题）</a></p><p>题目描述</p><p>给定整数m以及n个数字A1, A2, …, An，将数列A中所有元素两两异或，共能得到n(n-1)/2个结果。请求出这些结果中大于m的有多少个。</p><p>输入 第一行包含两个整数n, m。 第二行给出n个整数A1, A2, …, An。 样例输入 3 10 6 5 10 输出 输出仅包括一行，即所求的答案。 样例输出 2 时间限制 C/C++语言：1000MS其它语言：3000MS<br>内存限制 C/C++语言：65536KB其它语言：589824K</p><p>思路：</p><ol style="list-style-type: decimal"><li>从最高位开始建立字典树，左子树表示二进制0，右子树表示二进制位1. 每个节点统计在n个数字中对应的二进制位上有多少个对应的0或者1.</li><li><p>查询每个数字a和m，比较a和m对应的位，有如下情况 2.1 a = 0, m = 0, 这个时候 b=0 , a^b = 0 不能确定谁大，继续查找下一位 2.2 a = 0, m = 1, 这个时候 b=0 , 肯定有a^b &lt; m, 不满足条件，跳过； b = 1, 继续查找下一位 2.3 a = 1, m = 0, 这个时候 b=0 , 肯定有a^b &gt; m, 满足条件，直接将对应的count加在结果上， b=1,继续查找下一位 2.4 a = 1, m = 1, 这个时候 b=0 , 继续查找下一位，b = 1,肯定不满足条件，</p></li><li><p>最后的结果除以2返回， 因为我们既统计了a与b的异或，也统计了b与a的异或。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrieTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieTree</span>* <span class="title">next</span>[2]&#123;</span><span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">    TrieTree():count(<span class="number">1</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TrieTree* <span class="title">buildTrieTree</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TrieTree* trieTree = <span class="keyword">new</span> TrieTree();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="keyword">int</span>)<span class="built_in">array</span>.size();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        TrieTree* cur = trieTree;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">16</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> digit = (<span class="built_in">array</span>[i] &gt;&gt; j) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">NULL</span> == cur-&gt;next[digit])</span><br><span class="line">                cur-&gt;next[digit] = <span class="keyword">new</span> TrieTree();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ++(cur-&gt;next[digit]-&gt;count);</span><br><span class="line">            cur = cur-&gt;next[digit];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> trieTree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">queryTrieTree</span><span class="params">(TrieTree*&amp; trieTree, <span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> m, <span class="keyword">const</span> <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == trieTree)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    TrieTree* cur = trieTree;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> aDigit = (a &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mDigit = (m &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span>==aDigit &amp;&amp; <span class="number">1</span>==mDigit)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">NULL</span> == cur-&gt;next[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            cur = cur-&gt;next[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == aDigit &amp;&amp; <span class="number">1</span>==mDigit)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">NULL</span> == cur-&gt;next[<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            cur = cur-&gt;next[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">1</span> == aDigit &amp;&amp; <span class="number">0</span> == mDigit)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> val0 =  (<span class="literal">NULL</span> == cur-&gt;next[<span class="number">0</span>]) ? <span class="number">0</span> : cur-&gt;next[<span class="number">0</span>]-&gt;count;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> val1 =  queryTrieTree(cur-&gt;next[<span class="number">1</span>],a,m,i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span> val0+val1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == aDigit &amp;&amp; <span class="number">0</span> == mDigit)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> val0 =  queryTrieTree(cur-&gt;next[<span class="number">0</span>],a,m,i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> val1 =  (<span class="literal">NULL</span> == cur-&gt;next[<span class="number">1</span>]) ? <span class="number">0</span> : cur-&gt;next[<span class="number">1</span>]-&gt;count;</span><br><span class="line">            <span class="keyword">return</span> val0+val1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">solve</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span>&amp; m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TrieTree* trieTree = buildTrieTree(<span class="built_in">array</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="keyword">int</span>)<span class="built_in">array</span>.size();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        result += queryTrieTree(trieTree,<span class="built_in">array</span>[i],m,<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result /<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"d:/A.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;<span class="built_in">array</span>[i];</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; solve(<span class="built_in">array</span>,m) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXBIT = <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trieTree</span>&#123;</span></span><br><span class="line">    ll count = <span class="number">0</span>;</span><br><span class="line">    trieTree* next[<span class="number">2</span>] = &#123;<span class="literal">nullptr</span>, <span class="literal">nullptr</span>&#125;;</span><br><span class="line">    trieTree() : count(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    trieTree(<span class="keyword">int</span> c) : count(c)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">trieTree* <span class="title">createTree</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span>&#123;</span><br><span class="line">    trieTree* root = <span class="keyword">new</span> trieTree(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = MAXBIT; <span class="comment">// int 整形最多32位</span></span><br><span class="line">        trieTree* cur = root;</span><br><span class="line">        <span class="keyword">while</span>(index &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> digit = (arr[i] &gt;&gt; index) &amp; <span class="number">1</span>; <span class="comment">// 从低位到高位第index+1位的值</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next[digit] == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                cur-&gt;next[digit] = <span class="keyword">new</span> trieTree(<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next[digit]-&gt;count ++;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next[digit];</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询trie树中有多少个数字满足a^b&gt;m</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> * @param a</span></span><br><span class="line"><span class="comment"> * @param m</span></span><br><span class="line"><span class="comment"> * @param index</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ll <span class="title">queryTree</span><span class="params">(trieTree* root,<span class="keyword">int</span> a, <span class="keyword">int</span> m, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> aDigit = (a &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mDigit = (m &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(aDigit == <span class="number">0</span> &amp;&amp; mDigit == <span class="number">0</span>)&#123;</span><br><span class="line">            ll v0 = <span class="number">0</span> , v1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;next[<span class="number">1</span>] != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                v0 = root-&gt;next[<span class="number">1</span>]-&gt;count;</span><br><span class="line">            &#125;</span><br><span class="line">            v1 = queryTree(root-&gt;next[<span class="number">0</span>],a,m,i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span> v0 + v1;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(aDigit == <span class="number">0</span> &amp;&amp; mDigit == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;next[<span class="number">1</span>] == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> queryTree(root-&gt;next[<span class="number">1</span>],a,m,i<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(aDigit == <span class="number">1</span> &amp;&amp; mDigit == <span class="number">0</span>)&#123;</span><br><span class="line">            ll v0 = <span class="number">0</span> , v1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;next[<span class="number">0</span>] != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                v0 = root-&gt;next[<span class="number">0</span>]-&gt;count;</span><br><span class="line">            &#125;</span><br><span class="line">            v1 = queryTree(root-&gt;next[<span class="number">1</span>],a,m,i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span> v0 + v1;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(aDigit == <span class="number">1</span> &amp;&amp; mDigit == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;next[<span class="number">0</span>] == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> queryTree(root-&gt;next[<span class="number">0</span>],a,m,i<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"error"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    trieTree* root = createTree(v);</span><br><span class="line">    ll result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); ++i) &#123;</span><br><span class="line">        result += queryTree(root,v[i],m,MAXBIT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"d:/A.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(n,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;solve(v,m)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="统计子目录">统计子目录</h3><p><a href="http://hihocoder.com/problemset/problem/1551" target="_blank" rel="noopener">统计子目录</a></p><p>描述 小Hi的电脑的文件系统中一共有N个文件，例如：</p><p>/hihocoder/offer22/solutions/p1</p><p>/hihocoder/challenge30/p1/test</p><p>/game/moba/dota2/uninstall</p><p>小Hi想统计其中一共有多少个不同的子目录。上例中一共有8个不同的子目录：</p><p>/hihocoder</p><p>/hihocoder/offer22</p><p>/hihocoder/offer22/solutions</p><p>/hihocoder/challenge30</p><p>/hihocoder/challenge30/p1</p><p>/game</p><p>/game/moba</p><p>/game/moba/dota2/</p><p>输入 第一行包含一个整数N (1 ≤ N ≤ 10000)</p><p>以下N行每行包含一个字符串，代表一个文件的绝对路径。保证路径从根目录“/”开始，并且文件名和目录名只包含小写字母和数字。</p><p>对于80%的数据，N个文件的绝对路径长度之和不超过10000</p><p>对于100%的数据，N个文件的绝对路径长度之和不超过500000</p><p>输出 一个整数代表不同子目录的数目。</p><p>样例输入 3<br>/hihocoder/offer22/solutions/p1<br>/hihocoder/challenge30/p1/test<br>/game/moba/dota2/uninstall 样例输出 8</p><p>思路： 用每个目录的名字建立字典树，根是空字符，然后统计整棵树节点的数目，最后返回节点的数目-1.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * [统计子目录](http://hihocoder.com/problemset/solution/1157194)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trieTree</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> description;</span><br><span class="line">    <span class="built_in">vector</span>&lt;trieTree*&gt; sons;</span><br><span class="line">    trieTree() : description(<span class="string">""</span>)&#123;&#125;</span><br><span class="line">    trieTree(<span class="built_in">string</span> &amp;s) : description(s)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 层次遍历统计节点数目</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(trieTree* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;sons.empty()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;trieTree*&gt; nodes, next;</span><br><span class="line">    nodes.push_back(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> re = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.size(); ++i) &#123;</span><br><span class="line">            next.insert(next.end(),nodes[i]-&gt;sons.begin(),nodes[i]-&gt;sons.end());</span><br><span class="line">        &#125;</span><br><span class="line">        re += nodes.size();</span><br><span class="line">        nodes = next;</span><br><span class="line">        next.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归遍历节点数目</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countNode2</span><span class="params">(trieTree *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;sons.empty()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> re = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; root-&gt;sons.size(); ++i) &#123;</span><br><span class="line">        re += countNode2(root-&gt;sons[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; splitString(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; re;</span><br><span class="line">    <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> re;</span><br><span class="line">    <span class="keyword">size_t</span> index1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> index2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(s.find(<span class="string">'/'</span>,index2) != <span class="number">-1</span>)&#123;</span><br><span class="line">        index2 = s.find(<span class="string">'/'</span>,index1+<span class="number">1</span>);</span><br><span class="line">        re.push_back(s.substr(index1+<span class="number">1</span>,index2-index1<span class="number">-1</span>));</span><br><span class="line">        index1 = index2;</span><br><span class="line">        index2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;pathes, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pathes.empty() || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    trieTree *root = <span class="keyword">new</span> trieTree();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path = splitString(pathes[i]);</span><br><span class="line">        trieTree *cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; path.size(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;sons.empty())&#123;</span><br><span class="line">                cur-&gt;sons.push_back(<span class="keyword">new</span> trieTree(path[j]));</span><br><span class="line">                result++;</span><br><span class="line">                cur = cur-&gt;sons[<span class="number">0</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> index = cur-&gt;sons.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cur-&gt;sons.size(); ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cur-&gt;sons[k]-&gt;description == path[j])&#123;</span><br><span class="line">                        index = k;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(index == cur-&gt;sons.size())&#123;</span><br><span class="line">                    cur-&gt;sons.push_back(<span class="keyword">new</span> trieTree(path[j]));</span><br><span class="line">                    result++;</span><br><span class="line">                    cur = cur-&gt;sons[cur-&gt;sons.size()<span class="number">-1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cur = cur-&gt;sons[index];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> re = countNode2(root) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"d:/A.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; pathes(n,<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; pathes[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;solve(pathes,n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并子目录">合并子目录</h3><p><a href="http://hihocoder.com/problemset/solution/1157744" target="_blank" rel="noopener">合并子目录</a></p><p>描述 小Hi的电脑的文件系统中一共有N个文件，例如：</p><p>/hihocoder/offer23/solutions/p1</p><p>/hihocoder/challenge30/p1/test</p><p>/game/moba/dota2/uninstall</p><p>经过统计，小Hi认为他的电脑中子目录实在太多了，于是他决定减少子目录的数量。小Hi发现其中一些子目录只包含另一个子目录，例如/hihocoder/offer22只包含一个子目录solution，/game只包含一个子目录moba，而moba也只包含一个子目录dota2。小Hi决定把这样的子目录合并成一个子目录，并且将被合并的子目录的名字用’-’连起来作为新子目录的名字。合并之后上例的3个文件的路径会变为：</p><p>/hihocoder/offer23-solutions/p1</p><p>/hihocoder/challenge30-p1/test</p><p>/game-moba-dota2/uninstall</p><p>输入 第一行包含一个整数N (1 ≤ N ≤ 10000)</p><p>以下N行每行包含一个字符串，代表一个文件的绝对路径。保证路径从根目录“/”开始，并且文件名和目录名只包含小写字母和数字。</p><p>对于80%的数据，N个文件的绝对路径长度之和不超过10000</p><p>对于100%的数据，N个文件的绝对路径长度之和不超过500000</p><p>输出 对于输入中的每个文件，输出合并子目录之后该文件的绝对路径。</p><p>样例输入 3 /hihocoder/offer23/solutions/p1 /hihocoder/challenge30/p1/test /game/moba/dota2/uninstall 样例输出 /hihocoder/offer23-solutions/p1 /hihocoder/challenge30-p1/test /game-moba-dota2/uninstall</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * [统计子目录](http://hihocoder.com/problemset/solution/1157194)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trieTree</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> description;</span><br><span class="line">    <span class="built_in">vector</span>&lt;trieTree*&gt; sons;</span><br><span class="line">    trieTree() : description(<span class="string">""</span>)&#123;&#125;</span><br><span class="line">    trieTree(<span class="built_in">string</span> &amp;s) : description(s)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; splitString(<span class="built_in">string</span> &amp;s)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; re;</span><br><span class="line">    <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> re;</span><br><span class="line">    s.push_back(<span class="string">'/'</span>);</span><br><span class="line">    <span class="keyword">size_t</span> index1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> index2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(s.find(<span class="string">'/'</span>,index2) != <span class="number">-1</span>)&#123;</span><br><span class="line">        index2 = s.find(<span class="string">'/'</span>,index1+<span class="number">1</span>);</span><br><span class="line">        re.push_back(s.substr(index1+<span class="number">1</span>,index2-index1<span class="number">-1</span>));</span><br><span class="line">        index1 = index2;</span><br><span class="line">        index2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">trieTree* <span class="title">createTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;pathes)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pathes.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    trieTree *root = <span class="keyword">new</span> trieTree();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pathes.size(); ++i) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path = splitString(pathes[i]);</span><br><span class="line">        trieTree *cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; path.size(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;sons.empty())&#123;</span><br><span class="line">                cur-&gt;sons.push_back(<span class="keyword">new</span> trieTree(path[j]));</span><br><span class="line">                result++;</span><br><span class="line">                cur = cur-&gt;sons[<span class="number">0</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> index = cur-&gt;sons.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cur-&gt;sons.size(); ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cur-&gt;sons[k]-&gt;description == path[j])&#123;</span><br><span class="line">                        index = k;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(index == cur-&gt;sons.size())&#123;</span><br><span class="line">                    cur-&gt;sons.push_back(<span class="keyword">new</span> trieTree(path[j]));</span><br><span class="line">                    result++;</span><br><span class="line">                    cur = cur-&gt;sons[cur-&gt;sons.size()<span class="number">-1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cur = cur-&gt;sons[index];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">trieTree* <span class="title">reduceTree</span><span class="params">(trieTree* root)</span></span>&#123;</span><br><span class="line">    trieTree* re = root;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;sons.empty()) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;sons.size() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; root-&gt;sons.size(); ++i) &#123;</span><br><span class="line">            reduceTree(root-&gt;sons[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;sons.size() == <span class="number">1</span>)&#123;</span><br><span class="line">        trieTree* next = root-&gt;sons[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(next-&gt;sons.empty())&#123;</span><br><span class="line"><span class="comment">//            root-&gt;description = root-&gt;description + "-";</span></span><br><span class="line"><span class="comment">//            root-&gt;description = root-&gt;description + next-&gt;description;</span></span><br><span class="line"><span class="comment">//            root-&gt;sons.clear();</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;sons.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; next-&gt;sons.size(); ++i) &#123;</span><br><span class="line">            root-&gt;sons.push_back(next-&gt;sons[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;description = root-&gt;description + <span class="string">"-"</span>;</span><br><span class="line">        root-&gt;description = root-&gt;description + next-&gt;description;</span><br><span class="line">        reduceTree(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTree</span><span class="params">(trieTree* root,<span class="built_in">string</span> out)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">nullptr</span> == root) <span class="keyword">return</span>;</span><br><span class="line">    out += root-&gt;description + <span class="string">"/"</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;sons.empty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(out.find_last_of(<span class="string">'/'</span>) == out.size() - <span class="number">1</span>)&#123;</span><br><span class="line">            out.erase(out.size()<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;out&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; root-&gt;sons.size(); ++i) &#123;</span><br><span class="line">            printTree(root-&gt;sons[i],out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;pathes, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    trieTree* root = createTree(pathes);</span><br><span class="line">    trieTree* reduced = reduceTree(root);</span><br><span class="line">    <span class="built_in">string</span> out = <span class="string">""</span>;</span><br><span class="line">    printTree(reduced,out);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"d:/A.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; pathes(n,<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; pathes[i];</span><br><span class="line">    &#125;</span><br><span class="line">    solve(pathes,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一种字符串前缀的匹配技术。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数据结构和算法" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://ff120.github.io/hexoblog/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>今日头条_在线编程题</title>
    <link href="http://ff120.github.io/hexoblog/2017/08/22/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1-%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    <id>http://ff120.github.io/hexoblog/2017/08/22/技术/数据结构和算法/今日头条-在线编程题/</id>
    <published>2017-08-22T08:10:10.000Z</published>
    <updated>2019-03-28T00:54:55.996Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="头条校招">头条校招</h2><p><a href="https://www.nowcoder.com/questionTerminal/57cf0b1050834901933e9b48daafbb9a" target="_blank" rel="noopener">头条校招</a></p><p>头条的2017校招开始了！为了这次校招，我们组织了一个规模宏大的出题团队，每个出题人都出了一些有趣的题目，而我们现在想把这些题目组合成若干场考试出来，在选题之前，我们对题目进行了盲审，并定出了每道题的难度系统。一场考试包含3道开放性题目，假设他们的难度从小到大分别为a,b,c，我们希望这3道题能满足下列条件：</p><p>a&lt;=b&lt;=c b-a&lt;=10 c-b&lt;=10</p><p>所有出题人一共出了n道开放性题目。现在我们想把这n道题分布到若干场考试中（1场或多场，每道题都必须使用且只能用一次），然而由于上述条件的限制，可能有一些考试没法凑够3道题，因此出题人就需要多出一些适当难度的题目来让每场考试都达到要求，然而我们出题已经出得很累了，你能计算出我们最少还需要再出几道题吗？ 输入描述:</p><p>输入的第一行包含一个整数n，表示目前已经出好的题目数量。</p><p>第二行给出每道题目的难度系数d1,d2,…,dn。</p><p>数据范围</p><p>对于30%的数据，1 ≤ n,di ≤ 5;</p><p>对于100%的数据，1 ≤ n ≤ 10^5,1 ≤ di ≤ 100。</p><p>在样例中，一种可行的方案是添加2个难度分别为20和50的题目，这样可以组合成两场考试：（20 20 23）和（35,40,50）。</p><p>输出描述:</p><p>输出只包括一行，即所求的答案。 示例1 输入</p><p>4<br>20 35 23 40 输出</p><p>2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.empty()) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    sort(v.begin(),v.end());</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> re = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n)&#123;</span><br><span class="line">           <span class="keyword">if</span>(v[i+<span class="number">1</span>] - v[i] &gt; <span class="number">20</span>)&#123;</span><br><span class="line">               re = re + <span class="number">2</span>;</span><br><span class="line">               i = i + <span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(v[i+<span class="number">1</span>] - v[i] &gt; <span class="number">10</span>)&#123;</span><br><span class="line">               re = re + <span class="number">1</span>;</span><br><span class="line">               i = i + <span class="number">2</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">if</span>(i+<span class="number">2</span> &lt; n)&#123;</span><br><span class="line">                   <span class="keyword">if</span>(v[i+<span class="number">2</span>] - v[i+<span class="number">1</span>] &gt; <span class="number">10</span>)&#123;</span><br><span class="line">                       re = re + <span class="number">1</span>;</span><br><span class="line">                       i = i + <span class="number">2</span>;</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       i = i + <span class="number">3</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   re = re + <span class="number">1</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            re = re + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"d:/A.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(n,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> re = solve(v,n);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;re&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;头条校招&quot;&gt;头条校招&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/questionTerminal/57cf0b1050834901933e9b48daafbb9a&quot; target=&quot;
      
    
    </summary>
    
      <category term="技术" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数据结构和算法" scheme="http://ff120.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://ff120.github.io/hexoblog/tags/ACM/"/>
    
  </entry>
  
</feed>
